
c:/Users/dawil/Documents/TinasPresentV4/HeartPresent/target/1.0.0/photon/HeartPresent.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .module_info  00000018  080a0000  080a0000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000097c8  080a0018  080a0018  00010018  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .backup       00000004  40024000  080a97e0  00024000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .data         000000bc  20000300  080a97e4  00030300  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          00001284  200003bc  200003bc  000403bc  2**2
                  ALLOC
  5 .module_info_suffix 00000028  080a98a0  080a98a0  000398a0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .module_info_crc 00000004  080a98c8  080a98c8  000398c8  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .debug_info   001a8bf2  00000000  00000000  000398cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00027934  00000000  00000000  001e24be  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    0002217e  00000000  00000000  00209df2  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 000031f0  00000000  00000000  0022bf70  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00004ba8  00000000  00000000  0022f160  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  00049c7e  00000000  00000000  00233d08  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00065d3b  00000000  00000000  0027d986  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    000a2e0c  00000000  00000000  002e36c1  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  0000ed90  00000000  00000000  003864d0  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080a0018 <user_part_module>:
 80a0018:	3c 81 0a 08                                         <...

080a001c <module_user_pre_init>:
/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a001c:	4809      	ldr	r0, [pc, #36]	; (80a0044 <module_user_pre_init+0x28>)
 80a001e:	490a      	ldr	r1, [pc, #40]	; (80a0048 <module_user_pre_init+0x2c>)
extern constructor_ptr_t link_constructors_end;

/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {
 80a0020:	b508      	push	{r3, lr}

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a0022:	4288      	cmp	r0, r1
 80a0024:	d005      	beq.n	80a0032 <module_user_pre_init+0x16>
 80a0026:	4a09      	ldr	r2, [pc, #36]	; (80a004c <module_user_pre_init+0x30>)
 80a0028:	4282      	cmp	r2, r0
 80a002a:	d002      	beq.n	80a0032 <module_user_pre_init+0x16>
    {
        memcpy(&link_global_data_start, &link_global_data_initial_values, link_global_data_size);
 80a002c:	1a12      	subs	r2, r2, r0
 80a002e:	f007 fc09 	bl	80a7844 <memcpy>
    }

    memset(&link_bss_location, 0, link_bss_size );
 80a0032:	4807      	ldr	r0, [pc, #28]	; (80a0050 <module_user_pre_init+0x34>)
 80a0034:	4a07      	ldr	r2, [pc, #28]	; (80a0054 <module_user_pre_init+0x38>)
 80a0036:	2100      	movs	r1, #0
 80a0038:	1a12      	subs	r2, r2, r0
 80a003a:	f007 fc0e 	bl	80a785a <memset>
    return &link_heap_start;
}
 80a003e:	4806      	ldr	r0, [pc, #24]	; (80a0058 <module_user_pre_init+0x3c>)
 80a0040:	bd08      	pop	{r3, pc}
 80a0042:	bf00      	nop
 80a0044:	20000300 	.word	0x20000300
 80a0048:	080a97e4 	.word	0x080a97e4
 80a004c:	200003bc 	.word	0x200003bc
 80a0050:	200003bc 	.word	0x200003bc
 80a0054:	20001640 	.word	0x20001640
 80a0058:	20001640 	.word	0x20001640

080a005c <module_user_init>:
extern constructor_ptr_t link_constructors_location[];
extern constructor_ptr_t link_constructors_end;
#define link_constructors_size   ((unsigned long)&link_constructors_end  -  (unsigned long)&link_constructors_location )

void module_user_init()
{
 80a005c:	b570      	push	{r4, r5, r6, lr}
    module_user_init_hook();
 80a005e:	f006 f91b 	bl	80a6298 <module_user_init_hook>
 80a0062:	4b07      	ldr	r3, [pc, #28]	; (80a0080 <module_user_init+0x24>)
 80a0064:	4c07      	ldr	r4, [pc, #28]	; (80a0084 <module_user_init+0x28>)
 80a0066:	461e      	mov	r6, r3
 80a0068:	1ae4      	subs	r4, r4, r3
 80a006a:	08a4      	lsrs	r4, r4, #2

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a006c:	2500      	movs	r5, #0
 80a006e:	42a5      	cmp	r5, r4
 80a0070:	d004      	beq.n	80a007c <module_user_init+0x20>
    {
        link_constructors_location[ctor_num]();
 80a0072:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80a0076:	4798      	blx	r3
{
    module_user_init_hook();

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a0078:	3501      	adds	r5, #1
 80a007a:	e7f8      	b.n	80a006e <module_user_init+0x12>
    {
        link_constructors_location[ctor_num]();
    }
}
 80a007c:	bd70      	pop	{r4, r5, r6, pc}
 80a007e:	bf00      	nop
 80a0080:	080a971c 	.word	0x080a971c
 80a0084:	080a97d8 	.word	0x080a97d8

080a0088 <module_user_setup>:

/**
 * Export these functions with a fuller name so they don't clash with the setup/loop wrappers in the system module.
 */
void module_user_setup() {
    setup();
 80a0088:	f001 bb3a 	b.w	80a1700 <setup>

080a008c <module_user_loop>:
}

void module_user_loop() {
 80a008c:	b508      	push	{r3, lr}
    loop();
 80a008e:	f001 f9bf 	bl	80a1410 <loop>
    _post_loop();
}
 80a0092:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    setup();
}

void module_user_loop() {
    loop();
    _post_loop();
 80a0096:	f006 b8c1 	b.w	80a621c <_post_loop>

080a009a <_Znwj>:
 80a009a:	f005 ba33 	b.w	80a5504 <malloc>

080a009e <_Znaj>:
	return malloc(size);
}

void *operator new[](size_t size)
{
	return malloc(size);
 80a009e:	f005 ba31 	b.w	80a5504 <malloc>

080a00a2 <_ZdlPv>:
 80a00a2:	f005 ba37 	b.w	80a5514 <free>
	...

080a00a8 <__cxa_pure_virtual>:
        ;
    }
}

/* Default implementation for call made to pure virtual function. */
void __cxa_pure_virtual() {
 80a00a8:	b508      	push	{r3, lr}
  PANIC(PureVirtualCall,"Call on pure virtual");
 80a00aa:	4a03      	ldr	r2, [pc, #12]	; (80a00b8 <__cxa_pure_virtual+0x10>)
 80a00ac:	2100      	movs	r1, #0
 80a00ae:	200c      	movs	r0, #12
 80a00b0:	f005 f97c 	bl	80a53ac <panic_>
 80a00b4:	e7fe      	b.n	80a00b4 <__cxa_pure_virtual+0xc>
 80a00b6:	bf00      	nop
 80a00b8:	080a5039 	.word	0x080a5039

080a00bc <__cxa_guard_acquire>:

/* Provide default implemenation for __cxa_guard_acquire() and
 * __cxa_guard_release(). Note: these must be revisited if a multitasking
 * OS is ported to this platform. */
__extension__ typedef int __guard __attribute__((mode (__DI__)));
int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
 80a00bc:	7800      	ldrb	r0, [r0, #0]
 80a00be:	fab0 f080 	clz	r0, r0
 80a00c2:	0940      	lsrs	r0, r0, #5
 80a00c4:	4770      	bx	lr

080a00c6 <__cxa_guard_release>:
void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
 80a00c6:	2301      	movs	r3, #1
 80a00c8:	7003      	strb	r3, [r0, #0]
 80a00ca:	4770      	bx	lr

080a00cc <_ZN9IMUSensor10setupAccelEv>:
function: setupAccel()
description: initializes accelerometer sensor on the i2c bus. 
parameters: none
returns: none
*/
void IMUSensor::setupAccel(void){
 80a00cc:	b510      	push	{r4, lr}
    if (! this->lis.begin(0x18))
 80a00ce:	2118      	movs	r1, #24
function: setupAccel()
description: initializes accelerometer sensor on the i2c bus. 
parameters: none
returns: none
*/
void IMUSensor::setupAccel(void){
 80a00d0:	4604      	mov	r4, r0
    if (! this->lis.begin(0x18))
 80a00d2:	f004 fae5 	bl	80a46a0 <_ZN15Adafruit_LIS3DH5beginEh>
 80a00d6:	b908      	cbnz	r0, 80a00dc <_ZN9IMUSensor10setupAccelEv+0x10>
        System.reset();
 80a00d8:	f005 fb54 	bl	80a5784 <_ZN11SystemClass5resetEv>
        // If the accelerometer doesn't sync, then the system resets!
    
    // Sets default listening modes.     
    this->lis.setRange(LIS3DH_RANGE_4_G);   // 2, 4, 8 or 16 G!
 80a00dc:	4620      	mov	r0, r4
 80a00de:	2101      	movs	r1, #1
 80a00e0:	f004 fab5 	bl	80a464e <_ZN15Adafruit_LIS3DH8setRangeE14lis3dh_range_t>
    delay(20);
}
 80a00e4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        System.reset();
        // If the accelerometer doesn't sync, then the system resets!
    
    // Sets default listening modes.     
    this->lis.setRange(LIS3DH_RANGE_4_G);   // 2, 4, 8 or 16 G!
    delay(20);
 80a00e8:	2014      	movs	r0, #20
 80a00ea:	f005 be07 	b.w	80a5cfc <delay>
	...

080a00f0 <_GLOBAL__sub_I__ZN9IMUSensor10setupAccelEv>:
} // namespace particle

// particle::Flag<TagT, ValueT>
template<typename TagT, typename ValueT>
inline particle::Flag<TagT, ValueT>::Flag(ValueT val) :
        val_(val) {
 80a00f0:	4b02      	ldr	r3, [pc, #8]	; (80a00fc <_GLOBAL__sub_I__ZN9IMUSensor10setupAccelEv+0xc>)
 80a00f2:	2200      	movs	r2, #0
 80a00f4:	701a      	strb	r2, [r3, #0]
inline int32_t pinReadFast(pin_t _pin)
{
	return ((PIN_MAP[_pin].gpio_peripheral->IDR & PIN_MAP[_pin].gpio_pin) == 0 ? LOW : HIGH);
}
#elif defined(STM32F2XX)
static STM32_Pin_Info* PIN_MAP = HAL_Pin_Map();
 80a00f6:	f004 bf27 	b.w	80a4f48 <HAL_Pin_Map>
 80a00fa:	bf00      	nop
 80a00fc:	200003c0 	.word	0x200003c0

080a0100 <_ZN17notificationLight9setupLEDsEv>:
function: setupLEDs()
description: startup sequence for setting up the RGB LED strip on the front of the heart. 
parameters: none
returns: none
*/
void notificationLight::setupLEDs(void){
 80a0100:	b510      	push	{r4, lr}
 80a0102:	4604      	mov	r4, r0
    this->rgb.setBrightness(BRIGHTNESS);
 80a0104:	2128      	movs	r1, #40	; 0x28
 80a0106:	f003 ff58 	bl	80a3fba <_ZN17Adafruit_NeoPixel13setBrightnessEh>
    this->rgb.begin();
 80a010a:	4620      	mov	r0, r4
 80a010c:	f002 fe35 	bl	80a2d7a <_ZN17Adafruit_NeoPixel5beginEv>
    this->rgb.show(); // Initialize all pixels to 'off'
 80a0110:	4620      	mov	r0, r4
}
 80a0112:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
returns: none
*/
void notificationLight::setupLEDs(void){
    this->rgb.setBrightness(BRIGHTNESS);
    this->rgb.begin();
    this->rgb.show(); // Initialize all pixels to 'off'
 80a0116:	f002 be67 	b.w	80a2de8 <_ZN17Adafruit_NeoPixel4showEv>

080a011a <_ZN17notificationLight8setStripEhhh>:
function: setStrip(int red, int green, int blue)
description: sets the entire strip to a single RGB value
parameters: int red, int green, int blue 
returns: none
*/
void notificationLight::setStrip(uint8_t red, uint8_t green, uint8_t blue){
 80a011a:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 80a011e:	4605      	mov	r5, r0
 80a0120:	460e      	mov	r6, r1
 80a0122:	4617      	mov	r7, r2
 80a0124:	4698      	mov	r8, r3
    for(int i = 0; i < PIXEL_COUNT; i++)
 80a0126:	2400      	movs	r4, #0
    {
        this->rgb.setPixelColor(i, red, green, blue);
 80a0128:	b2a1      	uxth	r1, r4
 80a012a:	f8cd 8000 	str.w	r8, [sp]
 80a012e:	463b      	mov	r3, r7
 80a0130:	4632      	mov	r2, r6
 80a0132:	4628      	mov	r0, r5
description: sets the entire strip to a single RGB value
parameters: int red, int green, int blue 
returns: none
*/
void notificationLight::setStrip(uint8_t red, uint8_t green, uint8_t blue){
    for(int i = 0; i < PIXEL_COUNT; i++)
 80a0134:	3401      	adds	r4, #1
    {
        this->rgb.setPixelColor(i, red, green, blue);
 80a0136:	f003 ff11 	bl	80a3f5c <_ZN17Adafruit_NeoPixel13setPixelColorEthhh>
description: sets the entire strip to a single RGB value
parameters: int red, int green, int blue 
returns: none
*/
void notificationLight::setStrip(uint8_t red, uint8_t green, uint8_t blue){
    for(int i = 0; i < PIXEL_COUNT; i++)
 80a013a:	2c18      	cmp	r4, #24
 80a013c:	d1f4      	bne.n	80a0128 <_ZN17notificationLight8setStripEhhh+0xe>
    {
        this->rgb.setPixelColor(i, red, green, blue);
    }
    this->rgb.show();
 80a013e:	4628      	mov	r0, r5
}
 80a0140:	b002      	add	sp, #8
 80a0142:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
void notificationLight::setStrip(uint8_t red, uint8_t green, uint8_t blue){
    for(int i = 0; i < PIXEL_COUNT; i++)
    {
        this->rgb.setPixelColor(i, red, green, blue);
    }
    this->rgb.show();
 80a0146:	f002 be4f 	b.w	80a2de8 <_ZN17Adafruit_NeoPixel4showEv>

080a014a <_ZN17notificationLight6setLEDEthhh>:
function: setLED(int l, int)
description: set's a specific LED to a specific color
parameters: uint16_t l(position), uint8_t r, uint8_t g, uint8_t b
returns: none
*/
void notificationLight::setLED(uint16_t l, uint8_t r, uint8_t g, uint8_t b){
 80a014a:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a014c:	4604      	mov	r4, r0
 80a014e:	f89d 5018 	ldrb.w	r5, [sp, #24]
    this->rgb.setPixelColor(l, r, g, b);
 80a0152:	9500      	str	r5, [sp, #0]
 80a0154:	f003 ff02 	bl	80a3f5c <_ZN17Adafruit_NeoPixel13setPixelColorEthhh>
    this->rgb.show();
 80a0158:	4620      	mov	r0, r4
    
}
 80a015a:	b003      	add	sp, #12
 80a015c:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
parameters: uint16_t l(position), uint8_t r, uint8_t g, uint8_t b
returns: none
*/
void notificationLight::setLED(uint16_t l, uint8_t r, uint8_t g, uint8_t b){
    this->rgb.setPixelColor(l, r, g, b);
    this->rgb.show();
 80a0160:	f002 be42 	b.w	80a2de8 <_ZN17Adafruit_NeoPixel4showEv>

080a0164 <_ZN17notificationLight8wakeLEDSEv>:
function: wakeLEDs()
description: set's the brightness and re-displays whatever content that was on the screen
parameters: none
returns: none
*/
void notificationLight::wakeLEDS(void){
 80a0164:	b510      	push	{r4, lr}
 80a0166:	4604      	mov	r4, r0
    this->rgb.setBrightness(BRIGHTNESS);
 80a0168:	2128      	movs	r1, #40	; 0x28
 80a016a:	f003 ff26 	bl	80a3fba <_ZN17Adafruit_NeoPixel13setBrightnessEh>
    this->rgb.show();
 80a016e:	4620      	mov	r0, r4
}
 80a0170:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
parameters: none
returns: none
*/
void notificationLight::wakeLEDS(void){
    this->rgb.setBrightness(BRIGHTNESS);
    this->rgb.show();
 80a0174:	f002 be38 	b.w	80a2de8 <_ZN17Adafruit_NeoPixel4showEv>

080a0178 <_ZN17notificationLight12playWithLEDSEv>:
description: fills in the LED's to random differnet colors 
parameters: none
returns: none
*/
void notificationLight::playWithLEDS(void)
{
 80a0178:	b513      	push	{r0, r1, r4, lr}
    if (this->playPixelCursor % 4 == 0)
 80a017a:	8a83      	ldrh	r3, [r0, #20]
description: fills in the LED's to random differnet colors 
parameters: none
returns: none
*/
void notificationLight::playWithLEDS(void)
{
 80a017c:	4604      	mov	r4, r0
    if (this->playPixelCursor % 4 == 0)
 80a017e:	079b      	lsls	r3, r3, #30
 80a0180:	d108      	bne.n	80a0194 <_ZN17notificationLight12playWithLEDSEv+0x1c>
        this->playColorCursor = rand() % 3;
 80a0182:	f007 fb9b 	bl	80a78bc <rand>
 80a0186:	2303      	movs	r3, #3
 80a0188:	fb90 f3f3 	sdiv	r3, r0, r3
 80a018c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80a0190:	1ac3      	subs	r3, r0, r3
 80a0192:	82e3      	strh	r3, [r4, #22]
   
    switch(playColorCursor){
 80a0194:	8ae3      	ldrh	r3, [r4, #22]
 80a0196:	2b01      	cmp	r3, #1
 80a0198:	d013      	beq.n	80a01c2 <_ZN17notificationLight12playWithLEDSEv+0x4a>
 80a019a:	d309      	bcc.n	80a01b0 <_ZN17notificationLight12playWithLEDSEv+0x38>
 80a019c:	2b02      	cmp	r3, #2
 80a019e:	d117      	bne.n	80a01d0 <_ZN17notificationLight12playWithLEDSEv+0x58>
            break;
        case 1:
            this->setLED(playPixelCursor, 100, 10, 10);
            break;
        case 2: 
            this->setLED(playPixelCursor, 100, 80, 100);
 80a01a0:	2264      	movs	r2, #100	; 0x64
 80a01a2:	8aa1      	ldrh	r1, [r4, #20]
 80a01a4:	9200      	str	r2, [sp, #0]
 80a01a6:	2350      	movs	r3, #80	; 0x50
 80a01a8:	4620      	mov	r0, r4
 80a01aa:	f7ff ffce 	bl	80a014a <_ZN17notificationLight6setLEDEthhh>
            break;
 80a01ae:	e00f      	b.n	80a01d0 <_ZN17notificationLight12playWithLEDSEv+0x58>
    if (this->playPixelCursor % 4 == 0)
        this->playColorCursor = rand() % 3;
   
    switch(playColorCursor){
        case 0:
            this->setLED(playPixelCursor, 138, 43, 226);
 80a01b0:	23e2      	movs	r3, #226	; 0xe2
 80a01b2:	9300      	str	r3, [sp, #0]
 80a01b4:	8aa1      	ldrh	r1, [r4, #20]
 80a01b6:	232b      	movs	r3, #43	; 0x2b
 80a01b8:	228a      	movs	r2, #138	; 0x8a
 80a01ba:	4620      	mov	r0, r4
 80a01bc:	f7ff ffc5 	bl	80a014a <_ZN17notificationLight6setLEDEthhh>
            break;
 80a01c0:	e006      	b.n	80a01d0 <_ZN17notificationLight12playWithLEDSEv+0x58>
        case 1:
            this->setLED(playPixelCursor, 100, 10, 10);
 80a01c2:	230a      	movs	r3, #10
 80a01c4:	8aa1      	ldrh	r1, [r4, #20]
 80a01c6:	9300      	str	r3, [sp, #0]
 80a01c8:	2264      	movs	r2, #100	; 0x64
 80a01ca:	4620      	mov	r0, r4
 80a01cc:	f7ff ffbd 	bl	80a014a <_ZN17notificationLight6setLEDEthhh>
            break;
        default:
            break;
    }
    
    this->playPixelCursor++;
 80a01d0:	8aa3      	ldrh	r3, [r4, #20]
 80a01d2:	3301      	adds	r3, #1
 80a01d4:	b29b      	uxth	r3, r3
    
    if(this->playPixelCursor > 24)
 80a01d6:	2b18      	cmp	r3, #24
        this->playPixelCursor = 0;
 80a01d8:	bf88      	it	hi
 80a01da:	2300      	movhi	r3, #0
 80a01dc:	82a3      	strh	r3, [r4, #20]
 80a01de:	b002      	add	sp, #8
 80a01e0:	bd10      	pop	{r4, pc}

080a01e2 <_GLOBAL__sub_I__ZN17notificationLight9setupLEDsEv>:
 80a01e2:	f004 beb1 	b.w	80a4f48 <HAL_Pin_Map>

080a01e6 <_ZN8LEDRelay13setupLEDStripEv>:
function: setupLEDStrip()
description: sets the pin definitions and tests the LED strip relay
parameters: none
returns: none
*/
void LEDRelay::setupLEDStrip(void){
 80a01e6:	b538      	push	{r3, r4, r5, lr}
 80a01e8:	4605      	mov	r5, r0
    pinMode(WKP, OUTPUT);//setups WKP pin as an output, rather than a wakeup pin
    this->ledStripStatus = false; //ledStripStatus is disabled. 
 80a01ea:	2400      	movs	r4, #0
description: sets the pin definitions and tests the LED strip relay
parameters: none
returns: none
*/
void LEDRelay::setupLEDStrip(void){
    pinMode(WKP, OUTPUT);//setups WKP pin as an output, rather than a wakeup pin
 80a01ec:	2101      	movs	r1, #1
 80a01ee:	2011      	movs	r0, #17
 80a01f0:	f006 fd40 	bl	80a6c74 <pinMode>
    this->ledStripStatus = false; //ledStripStatus is disabled. 
    digitalWrite(WKP, HIGH);
 80a01f4:	2101      	movs	r1, #1
parameters: none
returns: none
*/
void LEDRelay::setupLEDStrip(void){
    pinMode(WKP, OUTPUT);//setups WKP pin as an output, rather than a wakeup pin
    this->ledStripStatus = false; //ledStripStatus is disabled. 
 80a01f6:	702c      	strb	r4, [r5, #0]
    digitalWrite(WKP, HIGH);
 80a01f8:	2011      	movs	r0, #17
 80a01fa:	f006 fd4c 	bl	80a6c96 <digitalWrite>
    delay(500);
 80a01fe:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80a0202:	f005 fd7b 	bl	80a5cfc <delay>
    digitalWrite(WKP, LOW);
 80a0206:	4621      	mov	r1, r4
}
 80a0208:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
void LEDRelay::setupLEDStrip(void){
    pinMode(WKP, OUTPUT);//setups WKP pin as an output, rather than a wakeup pin
    this->ledStripStatus = false; //ledStripStatus is disabled. 
    digitalWrite(WKP, HIGH);
    delay(500);
    digitalWrite(WKP, LOW);
 80a020c:	2011      	movs	r0, #17
 80a020e:	f006 bd42 	b.w	80a6c96 <digitalWrite>

080a0212 <_ZN8LEDRelay6toggleEv>:
description: toggles the LED. 
parameters: none
returns: none
*/
void LEDRelay::toggle(void){
    this->ledStripStatus =! this->ledStripStatus; 
 80a0212:	7801      	ldrb	r1, [r0, #0]
 80a0214:	f081 0101 	eor.w	r1, r1, #1
 80a0218:	7001      	strb	r1, [r0, #0]
    digitalWrite(WKP, this->ledStripStatus);
 80a021a:	2011      	movs	r0, #17
 80a021c:	f006 bd3b 	b.w	80a6c96 <digitalWrite>

080a0220 <_ZN8LEDRelay6setLEDEb>:
description: turns on or off LED
parameters: none
returns: none
*/
void LEDRelay::setLED(bool LED){
    this->ledStripStatus = LED;
 80a0220:	7001      	strb	r1, [r0, #0]
    digitalWrite(WKP, LED);
 80a0222:	2011      	movs	r0, #17
 80a0224:	f006 bd37 	b.w	80a6c96 <digitalWrite>

080a0228 <_GLOBAL__sub_I__ZN8LEDRelay20ledStripStatusStringEv>:
 80a0228:	f004 be8e 	b.w	80a4f48 <HAL_Pin_Map>

080a022c <_ZN12ClockControl5setupEP3UDP>:
description:  Sets up the udp interface. 
parameters: none
returns:  none
*/
void ClockControl::setup(UDP *Udp){
    this->Udp = Udp; 
 80a022c:	6001      	str	r1, [r0, #0]
 80a022e:	4770      	bx	lr

080a0230 <_ZN12ClockControl4wakeEv>:
function: wake(void)
description:  sends the wake command to the clock
parameters: none
returns:  none
*/
void ClockControl::wake(void){
 80a0230:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    Udp->sendPacket(this->wake_buff, sizeof(this->wake_buff), this->remoteIP, this->port);
 80a0234:	4604      	mov	r4, r0
function: wake(void)
description:  sends the wake command to the clock
parameters: none
returns:  none
*/
void ClockControl::wake(void){
 80a0236:	4606      	mov	r6, r0
    Udp->sendPacket(this->wake_buff, sizeof(this->wake_buff), this->remoteIP, this->port);
 80a0238:	f854 7b08 	ldr.w	r7, [r4], #8
function: wake(void)
description:  sends the wake command to the clock
parameters: none
returns:  none
*/
void ClockControl::wake(void){
 80a023c:	b088      	sub	sp, #32
    Udp->sendPacket(this->wake_buff, sizeof(this->wake_buff), this->remoteIP, this->port);
 80a023e:	683b      	ldr	r3, [r7, #0]

/**
 * The IP address stored in host order.
 *
 */
class IPAddress : public Printable {
 80a0240:	ad03      	add	r5, sp, #12
 80a0242:	f8d3 8028 	ldr.w	r8, [r3, #40]	; 0x28
 80a0246:	4b08      	ldr	r3, [pc, #32]	; (80a0268 <_ZN12ClockControl4wakeEv+0x38>)
 80a0248:	9302      	str	r3, [sp, #8]
 80a024a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80a024c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80a024e:	6823      	ldr	r3, [r4, #0]
 80a0250:	2205      	movs	r2, #5
 80a0252:	702b      	strb	r3, [r5, #0]
 80a0254:	8bb3      	ldrh	r3, [r6, #28]
 80a0256:	f106 0125 	add.w	r1, r6, #37	; 0x25
 80a025a:	9300      	str	r3, [sp, #0]
 80a025c:	4638      	mov	r0, r7
 80a025e:	ab02      	add	r3, sp, #8
 80a0260:	47c0      	blx	r8
}
 80a0262:	b008      	add	sp, #32
 80a0264:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a0268:	080a9474 	.word	0x080a9474

080a026c <_ZN12ClockControl5sleepEv>:
function: sleep(void)
description:  sends the sleep command to clock
parameters: none
returns:  none
*/
void ClockControl::sleep(void){
 80a026c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    Udp->sendPacket(this->sleep_buff, sizeof(this->wake_buff), this->remoteIP, this->port);
 80a0270:	4604      	mov	r4, r0
function: sleep(void)
description:  sends the sleep command to clock
parameters: none
returns:  none
*/
void ClockControl::sleep(void){
 80a0272:	4606      	mov	r6, r0
    Udp->sendPacket(this->sleep_buff, sizeof(this->wake_buff), this->remoteIP, this->port);
 80a0274:	f854 7b08 	ldr.w	r7, [r4], #8
function: sleep(void)
description:  sends the sleep command to clock
parameters: none
returns:  none
*/
void ClockControl::sleep(void){
 80a0278:	b088      	sub	sp, #32
    Udp->sendPacket(this->sleep_buff, sizeof(this->wake_buff), this->remoteIP, this->port);
 80a027a:	683b      	ldr	r3, [r7, #0]
 80a027c:	ad03      	add	r5, sp, #12
 80a027e:	f8d3 8028 	ldr.w	r8, [r3, #40]	; 0x28
 80a0282:	4b08      	ldr	r3, [pc, #32]	; (80a02a4 <_ZN12ClockControl5sleepEv+0x38>)
 80a0284:	9302      	str	r3, [sp, #8]
 80a0286:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80a0288:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80a028a:	6823      	ldr	r3, [r4, #0]
 80a028c:	2205      	movs	r2, #5
 80a028e:	702b      	strb	r3, [r5, #0]
 80a0290:	8bb3      	ldrh	r3, [r6, #28]
 80a0292:	f106 0120 	add.w	r1, r6, #32
 80a0296:	9300      	str	r3, [sp, #0]
 80a0298:	4638      	mov	r0, r7
 80a029a:	ab02      	add	r3, sp, #8
 80a029c:	47c0      	blx	r8
}
 80a029e:	b008      	add	sp, #32
 80a02a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a02a4:	080a9474 	.word	0x080a9474

080a02a8 <_ZN12ClockControl8send_msgE6String>:
description:  sends a message to be displayed on the heart. 
parameters: String str(message to be sent)
returns:  none
*/

void ClockControl::send_msg(String str){
 80a02a8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80a02ac:	b088      	sub	sp, #32
 80a02ae:	4606      	mov	r6, r0
 80a02b0:	460d      	mov	r5, r1
    
    uint8_t msg[4 + str.length()];
 80a02b2:	688b      	ldr	r3, [r1, #8]
description:  sends a message to be displayed on the heart. 
parameters: String str(message to be sent)
returns:  none
*/

void ClockControl::send_msg(String str){
 80a02b4:	af02      	add	r7, sp, #8
    
    uint8_t msg[4 + str.length()];
 80a02b6:	f103 0804 	add.w	r8, r3, #4
 80a02ba:	330b      	adds	r3, #11
 80a02bc:	f023 0307 	bic.w	r3, r3, #7
 80a02c0:	ebad 0d03 	sub.w	sp, sp, r3
 80a02c4:	f10d 0908 	add.w	r9, sp, #8
    msg[0] = 40; 
 80a02c8:	2328      	movs	r3, #40	; 0x28
 80a02ca:	f88d 3008 	strb.w	r3, [sp, #8]
    msg[1] = 40; 
 80a02ce:	f889 3001 	strb.w	r3, [r9, #1]
    msg[2] = 50; 
 80a02d2:	2332      	movs	r3, #50	; 0x32
 80a02d4:	f889 3002 	strb.w	r3, [r9, #2]
    msg[3] = 60; 
 80a02d8:	233c      	movs	r3, #60	; 0x3c
 80a02da:	f889 3003 	strb.w	r3, [r9, #3]
 80a02de:	2300      	movs	r3, #0
 80a02e0:	fa1f fa83 	uxth.w	sl, r3
 80a02e4:	1c5c      	adds	r4, r3, #1
    
    for(uint16_t i = 0; i < str.length(); i++){
 80a02e6:	68ab      	ldr	r3, [r5, #8]
 80a02e8:	4553      	cmp	r3, sl
 80a02ea:	d909      	bls.n	80a0300 <_ZN12ClockControl8send_msgE6String+0x58>
        msg[4 + i] = str[i];
 80a02ec:	4651      	mov	r1, sl
 80a02ee:	4628      	mov	r0, r5
 80a02f0:	f005 fb30 	bl	80a5954 <_ZN6StringixEj>
 80a02f4:	7803      	ldrb	r3, [r0, #0]
 80a02f6:	44ca      	add	sl, r9
 80a02f8:	f88a 3004 	strb.w	r3, [sl, #4]
    msg[0] = 40; 
    msg[1] = 40; 
    msg[2] = 50; 
    msg[3] = 60; 
    
    for(uint16_t i = 0; i < str.length(); i++){
 80a02fc:	4623      	mov	r3, r4
 80a02fe:	e7ef      	b.n	80a02e0 <_ZN12ClockControl8send_msgE6String+0x38>
        msg[4 + i] = str[i];
    }
    
    Udp->sendPacket(msg, sizeof(msg), this->remoteIP, this->port);
 80a0300:	4634      	mov	r4, r6
 80a0302:	f854 eb08 	ldr.w	lr, [r4], #8
 80a0306:	1d3d      	adds	r5, r7, #4
 80a0308:	f8de 3000 	ldr.w	r3, [lr]
 80a030c:	f8d3 a028 	ldr.w	sl, [r3, #40]	; 0x28
 80a0310:	4b08      	ldr	r3, [pc, #32]	; (80a0334 <_ZN12ClockControl8send_msgE6String+0x8c>)
 80a0312:	603b      	str	r3, [r7, #0]
 80a0314:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80a0316:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80a0318:	6823      	ldr	r3, [r4, #0]
 80a031a:	4642      	mov	r2, r8
 80a031c:	702b      	strb	r3, [r5, #0]
 80a031e:	8bb3      	ldrh	r3, [r6, #28]
 80a0320:	4649      	mov	r1, r9
 80a0322:	9300      	str	r3, [sp, #0]
 80a0324:	4670      	mov	r0, lr
 80a0326:	463b      	mov	r3, r7
 80a0328:	47d0      	blx	sl
 80a032a:	3718      	adds	r7, #24
 80a032c:	46bd      	mov	sp, r7
 80a032e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a0332:	bf00      	nop
 80a0334:	080a9474 	.word	0x080a9474

080a0338 <_GLOBAL__sub_I__ZN12ClockControl5setupEP3UDP>:
 80a0338:	f004 be06 	b.w	80a4f48 <HAL_Pin_Map>

080a033c <_ZN10rfidReader15setupCardReaderEv>:
function: setupCardReader()
description:initializes the card reader, and card reader spi settings
parameters: none
returns: none
*/
void rfidReader::setupCardReader(void){
 80a033c:	b510      	push	{r4, lr}
 80a033e:	4604      	mov	r4, r0
    //sets the card ID to zero. 
    cardID[0] = 0;
 80a0340:	2300      	movs	r3, #0
 80a0342:	7383      	strb	r3, [r0, #14]
    cardID[1] = 0;
 80a0344:	73c3      	strb	r3, [r0, #15]
    cardID[2] = 0;
 80a0346:	7403      	strb	r3, [r0, #16]
    cardID[3] = 0;
 80a0348:	7443      	strb	r3, [r0, #17]
    mfrc522.setSPIConfig();//configures SPI settings. 
 80a034a:	f002 f8f1 	bl	80a2530 <_ZN7MFRC52212setSPIConfigEv>
    mfrc522.PCD_Init();        // Init MFRC522 card
 80a034e:	4620      	mov	r0, r4
 80a0350:	f002 fa2c 	bl	80a27ac <_ZN7MFRC5228PCD_InitEv>
    delay(500);//delays the whole program. 
}
 80a0354:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    cardID[1] = 0;
    cardID[2] = 0;
    cardID[3] = 0;
    mfrc522.setSPIConfig();//configures SPI settings. 
    mfrc522.PCD_Init();        // Init MFRC522 card
    delay(500);//delays the whole program. 
 80a0358:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80a035c:	f005 bcce 	b.w	80a5cfc <delay>

080a0360 <_ZN10rfidReader10readCardIDEv>:
function: readCardID()
description: Reads for a card, and changes the current buffer with that caerd. 
parameters: none
returns: none
*/
bool rfidReader::readCardID(void){
 80a0360:	b538      	push	{r3, r4, r5, lr}
 80a0362:	4604      	mov	r4, r0
    MFRC522::MIFARE_Key key;
    for (byte i = 0; i < 6; i++) {
            key.keyByte[i] = 0xFF;
    }
    // Look for new cards
    if ( ! mfrc522.PICC_IsNewCardPresent()) {
 80a0364:	f002 fcc2 	bl	80a2cec <_ZN7MFRC52221PICC_IsNewCardPresentEv>
 80a0368:	b908      	cbnz	r0, 80a036e <_ZN10rfidReader10readCardIDEv+0xe>
            return false ;
 80a036a:	2000      	movs	r0, #0
 80a036c:	bd38      	pop	{r3, r4, r5, pc}
    }

    // Select one of the cards
    if ( ! mfrc522.PICC_ReadCardSerial()) {
 80a036e:	4620      	mov	r0, r4
 80a0370:	f002 fccc 	bl	80a2d0c <_ZN7MFRC52219PICC_ReadCardSerialEv>
 80a0374:	2800      	cmp	r0, #0
 80a0376:	d0f8      	beq.n	80a036a <_ZN10rfidReader10readCardIDEv+0xa>
            return false;
    }
    //puts the byte array data in the card
    cardID[0] = mfrc522.uid.uidByte[0];
 80a0378:	7861      	ldrb	r1, [r4, #1]
    cardID[1] = mfrc522.uid.uidByte[1];
 80a037a:	78a2      	ldrb	r2, [r4, #2]
    cardID[2] = mfrc522.uid.uidByte[2];
 80a037c:	78e3      	ldrb	r3, [r4, #3]
    cardID[3] = mfrc522.uid.uidByte[3];
 80a037e:	7925      	ldrb	r5, [r4, #4]
    
    // Halt PICC
    bool cardMatch = false; 
    if(cardID[0] == 228 && cardID[1] == 60 && cardID[2] == 38 && cardID[3] == 235){
 80a0380:	29e4      	cmp	r1, #228	; 0xe4
    // Select one of the cards
    if ( ! mfrc522.PICC_ReadCardSerial()) {
            return false;
    }
    //puts the byte array data in the card
    cardID[0] = mfrc522.uid.uidByte[0];
 80a0382:	73a1      	strb	r1, [r4, #14]
    cardID[1] = mfrc522.uid.uidByte[1];
 80a0384:	73e2      	strb	r2, [r4, #15]
    cardID[2] = mfrc522.uid.uidByte[2];
 80a0386:	7423      	strb	r3, [r4, #16]
    cardID[3] = mfrc522.uid.uidByte[3];
 80a0388:	7465      	strb	r5, [r4, #17]
    
    // Halt PICC
    bool cardMatch = false; 
    if(cardID[0] == 228 && cardID[1] == 60 && cardID[2] == 38 && cardID[3] == 235){
 80a038a:	d108      	bne.n	80a039e <_ZN10rfidReader10readCardIDEv+0x3e>
 80a038c:	2a3c      	cmp	r2, #60	; 0x3c
 80a038e:	d106      	bne.n	80a039e <_ZN10rfidReader10readCardIDEv+0x3e>
 80a0390:	2b26      	cmp	r3, #38	; 0x26
 80a0392:	d104      	bne.n	80a039e <_ZN10rfidReader10readCardIDEv+0x3e>
 80a0394:	f1a5 03eb 	sub.w	r3, r5, #235	; 0xeb
 80a0398:	425d      	negs	r5, r3
 80a039a:	415d      	adcs	r5, r3
 80a039c:	e000      	b.n	80a03a0 <_ZN10rfidReader10readCardIDEv+0x40>
    cardID[1] = mfrc522.uid.uidByte[1];
    cardID[2] = mfrc522.uid.uidByte[2];
    cardID[3] = mfrc522.uid.uidByte[3];
    
    // Halt PICC
    bool cardMatch = false; 
 80a039e:	2500      	movs	r5, #0
    if(cardID[0] == 228 && cardID[1] == 60 && cardID[2] == 38 && cardID[3] == 235){
        cardMatch = true; 
    }
    mfrc522.PICC_HaltA();
 80a03a0:	4620      	mov	r0, r4
 80a03a2:	f002 fc7a 	bl	80a2c9a <_ZN7MFRC52210PICC_HaltAEv>
    // Stop encryption on PCD
    mfrc522.PCD_StopCrypto1();
 80a03a6:	4620      	mov	r0, r4
 80a03a8:	f002 fc9c 	bl	80a2ce4 <_ZN7MFRC52215PCD_StopCrypto1Ev>
    
    // Return boolean status that tells us if our card matched. 
    return cardMatch;
 80a03ac:	4628      	mov	r0, r5
}
 80a03ae:	bd38      	pop	{r3, r4, r5, pc}

080a03b0 <_GLOBAL__sub_I__ZN10rfidReader15setupCardReaderEv>:
 80a03b0:	f004 bdca 	b.w	80a4f48 <HAL_Pin_Map>

080a03b4 <_ZN9HMIScreen5setupEv>:
function: setup()
description: set's up whatever possible with the HMI
parameters: none
returns: none
*/
void HMIScreen::setup(void){
 80a03b4:	b510      	push	{r4, lr}
    nexInit();//sets up the HMI initialization sequence
 80a03b6:	f44f 5016 	mov.w	r0, #9600	; 0x2580
 80a03ba:	f004 fba9 	bl	80a4b10 <_Z7nexInitm>
    setBaudrate(115200);//sets to the fastest baud rate supported by the HMI
 80a03be:	f44f 30e1 	mov.w	r0, #115200	; 0x1c200
 80a03c2:	f004 fc6b 	bl	80a4c9c <_Z11setBaudratem>
    
    sendCommand("sleep=0");
 80a03c6:	480c      	ldr	r0, [pc, #48]	; (80a03f8 <_ZN9HMIScreen5setupEv+0x44>)
 80a03c8:	f004 fb60 	bl	80a4a8c <_Z11sendCommandPKc>
    delay(100);
 80a03cc:	2064      	movs	r0, #100	; 0x64
 80a03ce:	f005 fc95 	bl	80a5cfc <delay>
    sendCommand("dim=60");
    delay(100);
    sendCommand("page 4");
 80a03d2:	4c0a      	ldr	r4, [pc, #40]	; (80a03fc <_ZN9HMIScreen5setupEv+0x48>)
    nexInit();//sets up the HMI initialization sequence
    setBaudrate(115200);//sets to the fastest baud rate supported by the HMI
    
    sendCommand("sleep=0");
    delay(100);
    sendCommand("dim=60");
 80a03d4:	480a      	ldr	r0, [pc, #40]	; (80a0400 <_ZN9HMIScreen5setupEv+0x4c>)
 80a03d6:	f004 fb59 	bl	80a4a8c <_Z11sendCommandPKc>
    delay(100);
 80a03da:	2064      	movs	r0, #100	; 0x64
 80a03dc:	f005 fc8e 	bl	80a5cfc <delay>
    sendCommand("page 4");
 80a03e0:	4620      	mov	r0, r4
 80a03e2:	f004 fb53 	bl	80a4a8c <_Z11sendCommandPKc>
    delay(100);
 80a03e6:	2064      	movs	r0, #100	; 0x64
 80a03e8:	f005 fc88 	bl	80a5cfc <delay>
    sendCommand("page 4");
 80a03ec:	4620      	mov	r0, r4
        
}
 80a03ee:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    delay(100);
    sendCommand("dim=60");
    delay(100);
    sendCommand("page 4");
    delay(100);
    sendCommand("page 4");
 80a03f2:	f004 bb4b 	b.w	80a4a8c <_Z11sendCommandPKc>
 80a03f6:	bf00      	nop
 80a03f8:	080a8150 	.word	0x080a8150
 80a03fc:	080a815f 	.word	0x080a815f
 80a0400:	080a8158 	.word	0x080a8158

080a0404 <_ZN9HMIScreen4homeEv>:
description: brings the HMI home!
parameters: none
returns: none
*/
void HMIScreen::home(void){
    sendCommand("page 0");
 80a0404:	4801      	ldr	r0, [pc, #4]	; (80a040c <_ZN9HMIScreen4homeEv+0x8>)
 80a0406:	f004 bb41 	b.w	80a4a8c <_Z11sendCommandPKc>
 80a040a:	bf00      	nop
 80a040c:	080a8166 	.word	0x080a8166

080a0410 <_ZN9HMIScreen4wakeEv>:
function: wake()
description: wakes up the HMI!
parameters: none
returns: none
*/
void HMIScreen::wake(void){
 80a0410:	b508      	push	{r3, lr}
    sendCommand("sleep = 0");
 80a0412:	4804      	ldr	r0, [pc, #16]	; (80a0424 <_ZN9HMIScreen4wakeEv+0x14>)
 80a0414:	f004 fb3a 	bl	80a4a8c <_Z11sendCommandPKc>
    sendCommand("dim = 50");
}
 80a0418:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
parameters: none
returns: none
*/
void HMIScreen::wake(void){
    sendCommand("sleep = 0");
    sendCommand("dim = 50");
 80a041c:	4802      	ldr	r0, [pc, #8]	; (80a0428 <_ZN9HMIScreen4wakeEv+0x18>)
 80a041e:	f004 bb35 	b.w	80a4a8c <_Z11sendCommandPKc>
 80a0422:	bf00      	nop
 80a0424:	080a816d 	.word	0x080a816d
 80a0428:	080a8177 	.word	0x080a8177

080a042c <_ZN9HMIScreen5sleepEv>:
function: sleep()
description: sleeps the HMI!
parameters: none
returns: none
*/
void HMIScreen::sleep(void){
 80a042c:	b508      	push	{r3, lr}
    sendCommand("sleep = 1");
 80a042e:	4804      	ldr	r0, [pc, #16]	; (80a0440 <_ZN9HMIScreen5sleepEv+0x14>)
 80a0430:	f004 fb2c 	bl	80a4a8c <_Z11sendCommandPKc>
    sendCommand("dim = 0");
}
 80a0434:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
parameters: none
returns: none
*/
void HMIScreen::sleep(void){
    sendCommand("sleep = 1");
    sendCommand("dim = 0");
 80a0438:	4802      	ldr	r0, [pc, #8]	; (80a0444 <_ZN9HMIScreen5sleepEv+0x18>)
 80a043a:	f004 bb27 	b.w	80a4a8c <_Z11sendCommandPKc>
 80a043e:	bf00      	nop
 80a0440:	080a8180 	.word	0x080a8180
 80a0444:	080a818a 	.word	0x080a818a

080a0448 <_ZN9HMIScreen14setProgressBarEi>:
description: allows us to have a progress bar mode. 
parameters: int x(percentage of the progress bar complete)
returns: none
*/
void HMIScreen::setProgressBar(int x){
    loadingBar.setValue(x);
 80a0448:	3094      	adds	r0, #148	; 0x94
 80a044a:	f004 ba67 	b.w	80a491c <_ZN14NexProgressBar8setValueEm>
	...

080a0450 <_ZN9HMIScreen4lockEv>:
function: lock()
description: set's hmi to lock screen
parameters: none
returns: none
*/
void HMIScreen::lock(void){
 80a0450:	b508      	push	{r3, lr}
    sendCommand("page 13");
 80a0452:	4804      	ldr	r0, [pc, #16]	; (80a0464 <_ZN9HMIScreen4lockEv+0x14>)
 80a0454:	f004 fb1a 	bl	80a4a8c <_Z11sendCommandPKc>
    sendCommand("dim=20");
}
 80a0458:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
parameters: none
returns: none
*/
void HMIScreen::lock(void){
    sendCommand("page 13");
    sendCommand("dim=20");
 80a045c:	4802      	ldr	r0, [pc, #8]	; (80a0468 <_ZN9HMIScreen4lockEv+0x18>)
 80a045e:	f004 bb15 	b.w	80a4a8c <_Z11sendCommandPKc>
 80a0462:	bf00      	nop
 80a0464:	080a81a3 	.word	0x080a81a3
 80a0468:	080a81ab 	.word	0x080a81ab

080a046c <_ZN9HMIScreen3runEv>:
description: used to search and wait for callbacks from the HMI
parameters: none
returns: none
*/
void HMIScreen::run(void){
    nexLoop(this->nex_listen_list);//listens out for events attached to the HMI interface. 
 80a046c:	f500 6026 	add.w	r0, r0, #2656	; 0xa60
 80a0470:	f004 bb70 	b.w	80a4b54 <_Z7nexLoopPP8NexTouch>

080a0474 <_GLOBAL__sub_I__ZN9HMIScreen5setupEv>:
 80a0474:	f004 bd68 	b.w	80a4f48 <HAL_Pin_Map>

080a0478 <_ZN10alarmRelay10setupRelayEi>:
function: setupRelay()
description: initializes a relay object with a specific pin value
parameters: none
returns: none
*/
void alarmRelay::setupRelay(int p){
 80a0478:	460b      	mov	r3, r1
    this->pin = p; 
 80a047a:	6001      	str	r1, [r0, #0]
    this->armed = true; 
 80a047c:	2101      	movs	r1, #1
 80a047e:	7101      	strb	r1, [r0, #4]
    pinMode(pin, OUTPUT);
 80a0480:	b298      	uxth	r0, r3
 80a0482:	f006 bbf7 	b.w	80a6c74 <pinMode>

080a0486 <_ZN10alarmRelay8beepOnceEi>:
function: beepOnce()
description: beeps once within a given delay interval, with a 50 percent duty cycle
parameters: none
returns: none
*/
void alarmRelay::beepOnce(int d){
 80a0486:	b538      	push	{r3, r4, r5, lr}
    if(this->armed){
 80a0488:	7903      	ldrb	r3, [r0, #4]
function: beepOnce()
description: beeps once within a given delay interval, with a 50 percent duty cycle
parameters: none
returns: none
*/
void alarmRelay::beepOnce(int d){
 80a048a:	4604      	mov	r4, r0
 80a048c:	460d      	mov	r5, r1
    if(this->armed){
 80a048e:	b163      	cbz	r3, 80a04aa <_ZN10alarmRelay8beepOnceEi+0x24>
        digitalWrite(pin, HIGH);
 80a0490:	2101      	movs	r1, #1
 80a0492:	8800      	ldrh	r0, [r0, #0]
 80a0494:	f006 fbff 	bl	80a6c96 <digitalWrite>
        delay(d);
 80a0498:	4628      	mov	r0, r5
 80a049a:	f005 fc2f 	bl	80a5cfc <delay>
        digitalWrite(pin, LOW);
 80a049e:	8820      	ldrh	r0, [r4, #0]
 80a04a0:	2100      	movs	r1, #0
    }
}
 80a04a2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
*/
void alarmRelay::beepOnce(int d){
    if(this->armed){
        digitalWrite(pin, HIGH);
        delay(d);
        digitalWrite(pin, LOW);
 80a04a6:	f006 bbf6 	b.w	80a6c96 <digitalWrite>
 80a04aa:	bd38      	pop	{r3, r4, r5, pc}

080a04ac <_GLOBAL__sub_I__ZN10alarmRelay10setupRelayEi>:
 80a04ac:	f004 bd4c 	b.w	80a4f48 <HAL_Pin_Map>

080a04b0 <_ZN10TFTDisplay8printTFTEiii6String>:
description: takes in a string, and some paramaters, and prints that text onto the TFT according to said paramters. 
parameters: x axis(x, integer), y axis(y, integer), font size (fontSize, integer), String (str)
returns: none
*/
void TFTDisplay::printTFT(int x, int y, int fontSize, String Str)
{
 80a04b0:	b570      	push	{r4, r5, r6, lr}
 80a04b2:	4604      	mov	r4, r0
 80a04b4:	461e      	mov	r6, r3
 80a04b6:	9d04      	ldr	r5, [sp, #16]
    this->tft.setCursor(x,y);// set the cursor. 
 80a04b8:	b212      	sxth	r2, r2
 80a04ba:	b209      	sxth	r1, r1
 80a04bc:	f003 ffb6 	bl	80a442c <_ZN12Adafruit_GFX9setCursorEss>
    this->tft.setTextSize(fontSize);//set the fontsie
 80a04c0:	b2f1      	uxtb	r1, r6
 80a04c2:	4620      	mov	r0, r4
 80a04c4:	f003 ffb5 	bl	80a4432 <_ZN12Adafruit_GFX11setTextSizeEh>
    this->tft.print(Str);//print text!
 80a04c8:	6829      	ldr	r1, [r5, #0]
 80a04ca:	4620      	mov	r0, r4
}
 80a04cc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
*/
void TFTDisplay::printTFT(int x, int y, int fontSize, String Str)
{
    this->tft.setCursor(x,y);// set the cursor. 
    this->tft.setTextSize(fontSize);//set the fontsie
    this->tft.print(Str);//print text!
 80a04d0:	f005 ba74 	b.w	80a59bc <_ZN5Print5printEPKc>

080a04d4 <_GLOBAL__sub_I__ZN10TFTDisplay15setupTFTDisplayEv>:
 80a04d4:	f004 bd38 	b.w	80a4f48 <HAL_Pin_Map>

080a04d8 <_ZN10TFTDisplay15setupTFTDisplayEv>:
function: setupTFTDisplay()
description: initializes and tests the tft display so we can verify it it's working properly.  
parameters: none
returns: none
*/
void TFTDisplay::setupTFTDisplay(void){
 80a04d8:	b510      	push	{r4, lr}
 80a04da:	4604      	mov	r4, r0
    // Sets up TFT display.
    this->tft.begin();
 80a04dc:	f001 fbc4 	bl	80a1c68 <_ZN16Adafruit_ILI93415beginEv>
    // Clears the display. 
    this->tft.fillScreen(ILI9341_BLACK);
 80a04e0:	4620      	mov	r0, r4
 80a04e2:	2100      	movs	r1, #0
 80a04e4:	f001 faa2 	bl	80a1a2c <_ZN16Adafruit_ILI934110fillScreenEt>
    
    // Filling the display with a bunch of different characters.
    this->tft.setRotation(1);
 80a04e8:	2101      	movs	r1, #1
 80a04ea:	4620      	mov	r0, r4
 80a04ec:	f001 ffb8 	bl	80a2460 <_ZN16Adafruit_ILI934111setRotationEh>
#define digitalPinToInterrupt(P)      (P)
#endif

inline void yield() {
#if PLATFORM_THREADING
  os_thread_yield();
 80a04f0:	f004 fdda 	bl	80a50a8 <os_thread_yield>
    
    yield();
    this->tft.fillScreen(ILI9341_RED);
 80a04f4:	f44f 4178 	mov.w	r1, #63488	; 0xf800
 80a04f8:	4620      	mov	r0, r4
 80a04fa:	f001 fa97 	bl	80a1a2c <_ZN16Adafruit_ILI934110fillScreenEt>
 80a04fe:	f004 fdd3 	bl	80a50a8 <os_thread_yield>
    yield();
    this->tft.fillScreen(ILI9341_GREEN);
 80a0502:	f44f 61fc 	mov.w	r1, #2016	; 0x7e0
 80a0506:	4620      	mov	r0, r4
 80a0508:	f001 fa90 	bl	80a1a2c <_ZN16Adafruit_ILI934110fillScreenEt>
 80a050c:	f004 fdcc 	bl	80a50a8 <os_thread_yield>
    yield();
    this->tft.fillScreen(ILI9341_BLUE);
 80a0510:	211f      	movs	r1, #31
 80a0512:	4620      	mov	r0, r4
 80a0514:	f001 fa8a 	bl	80a1a2c <_ZN16Adafruit_ILI934110fillScreenEt>
 80a0518:	f004 fdc6 	bl	80a50a8 <os_thread_yield>
    yield();
    this->tft.fillScreen(ILI9341_BLACK);
 80a051c:	4620      	mov	r0, r4
 80a051e:	2100      	movs	r1, #0
 80a0520:	f001 fa84 	bl	80a1a2c <_ZN16Adafruit_ILI934110fillScreenEt>
    yield();
}
 80a0524:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a0528:	f004 bdbe 	b.w	80a50a8 <os_thread_yield>

080a052c <_ZN10TFTDisplay17updateTimeDisplayEv>:
function: updateTimeDisplay()
description: takes time data for the arduino, and prints it into the TFT display. 
parameters: none
returns: none
*/
void TFTDisplay::updateTimeDisplay(void){
 80a052c:	b510      	push	{r4, lr}
 80a052e:	4604      	mov	r4, r0
    //fill in screen, then update the Time display. 
    this->tft.fillScreen(ILI9341_BLACK);
 80a0530:	2100      	movs	r1, #0
 80a0532:	f001 fa7b 	bl	80a1a2c <_ZN16Adafruit_ILI934110fillScreenEt>
    this->tft.setCursor(105,40);
 80a0536:	2228      	movs	r2, #40	; 0x28
 80a0538:	2169      	movs	r1, #105	; 0x69
 80a053a:	4620      	mov	r0, r4
 80a053c:	f003 ff76 	bl	80a442c <_ZN12Adafruit_GFX9setCursorEss>
    this->tft.setTextSize(4);//sets to normal text size
 80a0540:	2104      	movs	r1, #4
 80a0542:	4620      	mov	r0, r4
 80a0544:	f003 ff75 	bl	80a4432 <_ZN12Adafruit_GFX11setTextSizeEh>
    this->tft.print(Time.hour());
 80a0548:	f005 fb9e 	bl	80a5c88 <_ZN9TimeClass4hourEv>
 80a054c:	220a      	movs	r2, #10
 80a054e:	4601      	mov	r1, r0
 80a0550:	4620      	mov	r0, r4
 80a0552:	f005 fa94 	bl	80a5a7e <_ZN5Print5printEii>
    this->tft.print(":");
 80a0556:	4936      	ldr	r1, [pc, #216]	; (80a0630 <_ZN10TFTDisplay17updateTimeDisplayEv+0x104>)
 80a0558:	4620      	mov	r0, r4
 80a055a:	f005 fa2f 	bl	80a59bc <_ZN5Print5printEPKc>
    
    if(Time.minute() < 10){
 80a055e:	f005 fb9d 	bl	80a5c9c <_ZN9TimeClass6minuteEv>
 80a0562:	2809      	cmp	r0, #9
 80a0564:	dc03      	bgt.n	80a056e <_ZN10TFTDisplay17updateTimeDisplayEv+0x42>
        this->tft.print("0");
 80a0566:	4933      	ldr	r1, [pc, #204]	; (80a0634 <_ZN10TFTDisplay17updateTimeDisplayEv+0x108>)
 80a0568:	4620      	mov	r0, r4
 80a056a:	f005 fa27 	bl	80a59bc <_ZN5Print5printEPKc>
        this->tft.print(Time.minute());
        this->tft.setTextSize(3);//sets to normal text size
    }
    else{
        this->tft.print(Time.minute());
 80a056e:	f005 fb95 	bl	80a5c9c <_ZN9TimeClass6minuteEv>
 80a0572:	220a      	movs	r2, #10
 80a0574:	4601      	mov	r1, r0
 80a0576:	4620      	mov	r0, r4
 80a0578:	f005 fa81 	bl	80a5a7e <_ZN5Print5printEii>
        this->tft.setTextSize(3);//sets to normal text size
 80a057c:	2103      	movs	r1, #3
 80a057e:	4620      	mov	r0, r4
 80a0580:	f003 ff57 	bl	80a4432 <_ZN12Adafruit_GFX11setTextSizeEh>
    }
    
    this->tft.setCursor(85,100);
 80a0584:	2264      	movs	r2, #100	; 0x64
 80a0586:	2155      	movs	r1, #85	; 0x55
 80a0588:	4620      	mov	r0, r4
 80a058a:	f003 ff4f 	bl	80a442c <_ZN12Adafruit_GFX9setCursorEss>
    this->tft.print(Time.month());//prints month 
 80a058e:	f005 fb99 	bl	80a5cc4 <_ZN9TimeClass5monthEv>
 80a0592:	220a      	movs	r2, #10
 80a0594:	4601      	mov	r1, r0
 80a0596:	4620      	mov	r0, r4
 80a0598:	f005 fa71 	bl	80a5a7e <_ZN5Print5printEii>
    this->tft.print("/");
 80a059c:	4926      	ldr	r1, [pc, #152]	; (80a0638 <_ZN10TFTDisplay17updateTimeDisplayEv+0x10c>)
 80a059e:	4620      	mov	r0, r4
 80a05a0:	f005 fa0c 	bl	80a59bc <_ZN5Print5printEPKc>
    this->tft.print(Time.day());
 80a05a4:	f005 fb84 	bl	80a5cb0 <_ZN9TimeClass3dayEv>
 80a05a8:	220a      	movs	r2, #10
 80a05aa:	4601      	mov	r1, r0
 80a05ac:	4620      	mov	r0, r4
 80a05ae:	f005 fa66 	bl	80a5a7e <_ZN5Print5printEii>
    this->tft.print(":");
 80a05b2:	491f      	ldr	r1, [pc, #124]	; (80a0630 <_ZN10TFTDisplay17updateTimeDisplayEv+0x104>)
 80a05b4:	4620      	mov	r0, r4
 80a05b6:	f005 fa01 	bl	80a59bc <_ZN5Print5printEPKc>
    this->tft.print(Time.year());
 80a05ba:	f005 fb8b 	bl	80a5cd4 <_ZN9TimeClass4yearEv>
 80a05be:	220a      	movs	r2, #10
 80a05c0:	4601      	mov	r1, r0
 80a05c2:	4620      	mov	r0, r4
 80a05c4:	f005 fa5b 	bl	80a5a7e <_ZN5Print5printEii>
    
    if (Time.month() > 10){
 80a05c8:	f005 fb7c 	bl	80a5cc4 <_ZN9TimeClass5monthEv>
 80a05cc:	280a      	cmp	r0, #10
 80a05ce:	dd11      	ble.n	80a05f4 <_ZN10TFTDisplay17updateTimeDisplayEv+0xc8>
        this->tft.setCursor(25, 140);
 80a05d0:	228c      	movs	r2, #140	; 0x8c
 80a05d2:	2119      	movs	r1, #25
 80a05d4:	4620      	mov	r0, r4
 80a05d6:	f003 ff29 	bl	80a442c <_ZN12Adafruit_GFX9setCursorEss>
        this->tft.print("Merry Christmas");
 80a05da:	4918      	ldr	r1, [pc, #96]	; (80a063c <_ZN10TFTDisplay17updateTimeDisplayEv+0x110>)
 80a05dc:	4620      	mov	r0, r4
 80a05de:	f005 f9ed 	bl	80a59bc <_ZN5Print5printEPKc>
        this->tft.setCursor(40, 170);
 80a05e2:	2128      	movs	r1, #40	; 0x28
 80a05e4:	4620      	mov	r0, r4
 80a05e6:	22aa      	movs	r2, #170	; 0xaa
 80a05e8:	f003 ff20 	bl	80a442c <_ZN12Adafruit_GFX9setCursorEss>
        this->tft.print("Thanksgivings");
 80a05ec:	4914      	ldr	r1, [pc, #80]	; (80a0640 <_ZN10TFTDisplay17updateTimeDisplayEv+0x114>)
 80a05ee:	4620      	mov	r0, r4
 80a05f0:	f005 f9e4 	bl	80a59bc <_ZN5Print5printEPKc>
    }
    
    if (Time.month() == 2 && Time.day() == 14){
 80a05f4:	f005 fb66 	bl	80a5cc4 <_ZN9TimeClass5monthEv>
 80a05f8:	2802      	cmp	r0, #2
 80a05fa:	d117      	bne.n	80a062c <_ZN10TFTDisplay17updateTimeDisplayEv+0x100>
 80a05fc:	f005 fb58 	bl	80a5cb0 <_ZN9TimeClass3dayEv>
 80a0600:	280e      	cmp	r0, #14
 80a0602:	d113      	bne.n	80a062c <_ZN10TFTDisplay17updateTimeDisplayEv+0x100>
        this->tft.setCursor(25, 140);
 80a0604:	228c      	movs	r2, #140	; 0x8c
 80a0606:	4620      	mov	r0, r4
 80a0608:	2119      	movs	r1, #25
 80a060a:	f003 ff0f 	bl	80a442c <_ZN12Adafruit_GFX9setCursorEss>
        this->tft.print("Happy Valentines");
 80a060e:	490d      	ldr	r1, [pc, #52]	; (80a0644 <_ZN10TFTDisplay17updateTimeDisplayEv+0x118>)
 80a0610:	4620      	mov	r0, r4
 80a0612:	f005 f9d3 	bl	80a59bc <_ZN5Print5printEPKc>
        this->tft.setCursor(40, 170);
 80a0616:	4620      	mov	r0, r4
 80a0618:	2128      	movs	r1, #40	; 0x28
 80a061a:	22aa      	movs	r2, #170	; 0xaa
 80a061c:	f003 ff06 	bl	80a442c <_ZN12Adafruit_GFX9setCursorEss>
        this->tft.print("I love you :)");
 80a0620:	4620      	mov	r0, r4
    }
} 
 80a0622:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    
    if (Time.month() == 2 && Time.day() == 14){
        this->tft.setCursor(25, 140);
        this->tft.print("Happy Valentines");
        this->tft.setCursor(40, 170);
        this->tft.print("I love you :)");
 80a0626:	4908      	ldr	r1, [pc, #32]	; (80a0648 <_ZN10TFTDisplay17updateTimeDisplayEv+0x11c>)
 80a0628:	f005 b9c8 	b.w	80a59bc <_ZN5Print5printEPKc>
 80a062c:	bd10      	pop	{r4, pc}
 80a062e:	bf00      	nop
 80a0630:	080a81b2 	.word	0x080a81b2
 80a0634:	080a8190 	.word	0x080a8190
 80a0638:	080a81b4 	.word	0x080a81b4
 80a063c:	080a81b6 	.word	0x080a81b6
 80a0640:	080a81c6 	.word	0x080a81c6
 80a0644:	080a81d4 	.word	0x080a81d4
 80a0648:	080a81e5 	.word	0x080a81e5

080a064c <_ZN10TFTDisplay8printTFTE6String>:
function: printTFT()
description: clears out a string. takes in a string, sets font to size 3, and prints out the texts. 
parameters: String str. 
returns: none
*/
void TFTDisplay::printTFT(String str){
 80a064c:	b538      	push	{r3, r4, r5, lr}
 80a064e:	4604      	mov	r4, r0
 80a0650:	460d      	mov	r5, r1
    tft.fillScreen(ILI9341_BLACK);//blacks out the whole display
 80a0652:	2100      	movs	r1, #0
 80a0654:	f001 f9ea 	bl	80a1a2c <_ZN16Adafruit_ILI934110fillScreenEt>
    tft.setCursor(0, 0);//resets cursor
 80a0658:	2200      	movs	r2, #0
 80a065a:	4611      	mov	r1, r2
 80a065c:	4620      	mov	r0, r4
 80a065e:	f003 fee5 	bl	80a442c <_ZN12Adafruit_GFX9setCursorEss>
    tft.setTextSize(3);//sets to normal text size
 80a0662:	4620      	mov	r0, r4
 80a0664:	2103      	movs	r1, #3
 80a0666:	f003 fee4 	bl	80a4432 <_ZN12Adafruit_GFX11setTextSizeEh>
    tft.print(str);
 80a066a:	6829      	ldr	r1, [r5, #0]
 80a066c:	4620      	mov	r0, r4
}
 80a066e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
*/
void TFTDisplay::printTFT(String str){
    tft.fillScreen(ILI9341_BLACK);//blacks out the whole display
    tft.setCursor(0, 0);//resets cursor
    tft.setTextSize(3);//sets to normal text size
    tft.print(str);
 80a0672:	f005 b9a3 	b.w	80a59bc <_ZN5Print5printEPKc>

080a0676 <_Z18toggleWifiParticlev>:
function: toggleWifiParticle()
description: toggles the Wifi on or off on the particle device. 
parameters: none
returns: none
*/
void toggleWifiParticle(void){
 80a0676:	b510      	push	{r4, lr}
    static void sleep(Spark_Sleep_TypeDef sleepMode, long seconds=0) __attribute__ ((deprecated("Please use System.sleep() instead.")))
    { SystemClass::sleep(sleepMode, seconds); }
    static void sleep(uint16_t wakeUpPin, InterruptMode edgeTriggerMode, long seconds=0) __attribute__ ((deprecated("Please use System.sleep() instead.")))
    { SystemClass::sleep(wakeUpPin, edgeTriggerMode, seconds); }

    static bool connected(void) { return spark_cloud_flag_connected(); }
 80a0678:	f004 ff1c 	bl	80a54b4 <spark_cloud_flag_connected>
    if(Particle.connected())
 80a067c:	4603      	mov	r3, r0
 80a067e:	b138      	cbz	r0, 80a0690 <_Z18toggleWifiParticlev+0x1a>
        WiFi.off();
    else{
        WiFi.on();
        Particle.connect();
    }
}
 80a0680:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    void on(void) {
        network_on(*this, 0, 0, NULL);
    }

    void off(void) {
        network_off(*this, 0, 0, NULL);
 80a0684:	2300      	movs	r3, #0
 80a0686:	461a      	mov	r2, r3
 80a0688:	4619      	mov	r1, r3
 80a068a:	4618      	mov	r0, r3
 80a068c:	f004 bef2 	b.w	80a5474 <network_off>
    bool ready(void) {
        return network_ready(*this, 0, NULL);
    }

    void on(void) {
        network_on(*this, 0, 0, NULL);
 80a0690:	4602      	mov	r2, r0
 80a0692:	4601      	mov	r1, r0
 80a0694:	f004 fee6 	bl	80a5464 <network_on>
 80a0698:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    static bool disconnected(void) { return !connected(); }
    static void connect(void) {
        spark_cloud_flag_connect();
 80a069c:	f004 bf02 	b.w	80a54a4 <spark_cloud_flag_connect>

080a06a0 <_Z19enableListeningModev>:
function: enableListeningMode()
description: enables listening mode on the particle photon
parameters: none
returns: none
*/
void enableListeningMode(void){
 80a06a0:	b508      	push	{r3, lr}
    void connect(unsigned flags=0) {
        network_connect(*this, flags, 0, NULL);
    }

    void disconnect(void) {
        network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, NULL);
 80a06a2:	2200      	movs	r2, #0
 80a06a4:	4610      	mov	r0, r2
 80a06a6:	2102      	movs	r1, #2
 80a06a8:	f004 fecc 	bl	80a5444 <network_disconnect>
    WiFi.disconnect();
    WiFi.listen();
 80a06ac:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    void off(void) {
        network_off(*this, 0, 0, NULL);
    }

    void listen(bool begin=true) {
        network_listen(*this, begin ? 0 : 1, NULL);
 80a06b0:	2200      	movs	r2, #0
 80a06b2:	4611      	mov	r1, r2
 80a06b4:	4610      	mov	r0, r2
 80a06b6:	f004 bee5 	b.w	80a5484 <network_listen>

080a06ba <_GLOBAL__sub_I__Z13isWifiWorkingv>:
 80a06ba:	f004 bc45 	b.w	80a4f48 <HAL_Pin_Map>

080a06be <_ZN15Adafruit_Sensor15enableAutoRangeEb>:
  // Constructor(s)
  Adafruit_Sensor() {}
  virtual ~Adafruit_Sensor() {}

  // These must be defined by the subclass
  virtual void enableAutoRange(bool enabled) {};
 80a06be:	4770      	bx	lr

080a06c0 <_Z16quickMessageJumpPv>:
function: quickMessageJump(void *ptr)
description: jumps to the quick message page! and sets the message names(designed to be customizable!) 
parameters: none 
returns: none
*/
void quickMessageJump(void *ptr){
 80a06c0:	4770      	bx	lr

080a06c2 <_ZNSt17_Function_handlerIFvvEPS0_E9_M_invokeERKSt9_Any_data>:

     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
	(*_Base::_M_get_pointer(__functor))(
 80a06c2:	6803      	ldr	r3, [r0, #0]
 80a06c4:	4718      	bx	r3

080a06c6 <_ZNSt14_Function_base13_Base_managerIPFvvEE10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation>:
      public:
	static bool
	_M_manager(_Any_data& __dest, const _Any_data& __source,
		   _Manager_operation __op)
	{
	  switch (__op)
 80a06c6:	2a01      	cmp	r2, #1
 80a06c8:	d002      	beq.n	80a06d0 <_ZNSt14_Function_base13_Base_managerIPFvvEE10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation+0xa>
 80a06ca:	2a02      	cmp	r2, #2
 80a06cc:	d002      	beq.n	80a06d4 <_ZNSt14_Function_base13_Base_managerIPFvvEE10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation+0xe>
 80a06ce:	e004      	b.n	80a06da <_ZNSt14_Function_base13_Base_managerIPFvvEE10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation+0x14>
	    case __get_type_info:
	      __dest._M_access<const type_info*>() = &typeid(_Functor);
	      break;
#endif
	    case __get_functor_ptr:
	      __dest._M_access<_Functor*>() = _M_get_pointer(__source);
 80a06d0:	6001      	str	r1, [r0, #0]
	      break;
 80a06d2:	e002      	b.n	80a06da <_ZNSt14_Function_base13_Base_managerIPFvvEE10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation+0x14>
	// Clone a location-invariant function object that fits within
	// an _Any_data structure.
	static void
	_M_clone(_Any_data& __dest, const _Any_data& __source, true_type)
	{
	  new (__dest._M_access()) _Functor(__source._M_access<_Functor>());
 80a06d4:	680b      	ldr	r3, [r1, #0]
 80a06d6:	b100      	cbz	r0, 80a06da <_ZNSt14_Function_base13_Base_managerIPFvvEE10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation+0x14>
 80a06d8:	6003      	str	r3, [r0, #0]
	    case __destroy_functor:
	      _M_destroy(__dest, _Local_storage());
	      break;
	    }
	  return false;
	}
 80a06da:	2000      	movs	r0, #0
 80a06dc:	4770      	bx	lr

080a06de <_ZN10TFTDisplayD1Ev>:
#define TFT_MOSI D2
#define TFT_MISO D3
#define TFT_CLK D4
#define TFT_RST D7

class TFTDisplay{
 80a06de:	4770      	bx	lr

080a06e0 <_ZN9IMUSensorD1Ev>:

#include "Particle.h"
#include <Adafruit_LIS3DH.h>


class IMUSensor{
 80a06e0:	4770      	bx	lr

080a06e2 <_ZN12ClockControlD1Ev>:
#ifndef _CLOCKCONTROL_H
#define _CLOCKCONTROL_H

#include "Particle.h"

class ClockControl{
 80a06e2:	4770      	bx	lr

080a06e4 <_Z17toggleLEDCallbackPv>:
description: toggles LED when the LED is set to toggle. 
parameters: none
returns: none
*/
void toggleLEDCallback(void *ptr){
    lampLight.toggle();
 80a06e4:	4801      	ldr	r0, [pc, #4]	; (80a06ec <_Z17toggleLEDCallbackPv+0x8>)
 80a06e6:	f7ff bd94 	b.w	80a0212 <_ZN8LEDRelay6toggleEv>
 80a06ea:	bf00      	nop
 80a06ec:	20000feb 	.word	0x20000feb

080a06f0 <_Z21quickMessage6FunctionPv>:
description: jumps back to the home page
parameters: none 
returns: none
*/
void quickMessage6Function(void *ptr){
    hmiScreen.home();
 80a06f0:	4801      	ldr	r0, [pc, #4]	; (80a06f8 <_Z21quickMessage6FunctionPv+0x8>)
 80a06f2:	f7ff be87 	b.w	80a0404 <_ZN9HMIScreen4homeEv>
 80a06f6:	bf00      	nop
 80a06f8:	20000540 	.word	0x20000540

080a06fc <_Z9s_10_taskv>:
void ms_1000_task(void){
    
}

void s_10_task(void){
    tftDisplay.updateTimeDisplay();
 80a06fc:	4801      	ldr	r0, [pc, #4]	; (80a0704 <_Z9s_10_taskv+0x8>)
 80a06fe:	f7ff bf15 	b.w	80a052c <_ZN10TFTDisplay17updateTimeDisplayEv>
 80a0702:	bf00      	nop
 80a0704:	20000fec 	.word	0x20000fec

080a0708 <_Z9s_30_taskv>:
}

void s_30_task(void){
    if(lockStatus.system_locked){
 80a0708:	4b03      	ldr	r3, [pc, #12]	; (80a0718 <_Z9s_30_taskv+0x10>)
 80a070a:	781b      	ldrb	r3, [r3, #0]
 80a070c:	b113      	cbz	r3, 80a0714 <_Z9s_30_taskv+0xc>
        tftDisplay.updateTimeDisplay();
 80a070e:	4803      	ldr	r0, [pc, #12]	; (80a071c <_Z9s_30_taskv+0x14>)
 80a0710:	f7ff bf0c 	b.w	80a052c <_ZN10TFTDisplay17updateTimeDisplayEv>
 80a0714:	4770      	bx	lr
 80a0716:	bf00      	nop
 80a0718:	20000fea 	.word	0x20000fea
 80a071c:	20000fec 	.word	0x20000fec

080a0720 <_Z17sleepModeCallbackPv>:
function: sleepModeCallBack()
description: runs when the HMI detects a press on the sleep mode button. 
parameters: none
returns: none
*/
void sleepModeCallback(void *ptr){
 80a0720:	b508      	push	{r3, lr}
    sleepMode.sleep_mode_enabled = true; 
 80a0722:	4b0a      	ldr	r3, [pc, #40]	; (80a074c <_Z17sleepModeCallbackPv+0x2c>)
 80a0724:	2201      	movs	r2, #1
    hmiScreen.sleep();
 80a0726:	480a      	ldr	r0, [pc, #40]	; (80a0750 <_Z17sleepModeCallbackPv+0x30>)
description: runs when the HMI detects a press on the sleep mode button. 
parameters: none
returns: none
*/
void sleepModeCallback(void *ptr){
    sleepMode.sleep_mode_enabled = true; 
 80a0728:	701a      	strb	r2, [r3, #0]
    hmiScreen.sleep();
 80a072a:	f7ff fe7f 	bl	80a042c <_ZN9HMIScreen5sleepEv>
    notifLight.setStrip(0, 0, 0);
 80a072e:	2300      	movs	r3, #0
 80a0730:	4619      	mov	r1, r3
 80a0732:	461a      	mov	r2, r3
 80a0734:	4807      	ldr	r0, [pc, #28]	; (80a0754 <_Z17sleepModeCallbackPv+0x34>)
 80a0736:	f7ff fcf0 	bl	80a011a <_ZN17notificationLight8setStripEhhh>
    lampLight.setLED(false);
 80a073a:	4807      	ldr	r0, [pc, #28]	; (80a0758 <_Z17sleepModeCallbackPv+0x38>)
 80a073c:	2100      	movs	r1, #0
 80a073e:	f7ff fd6f 	bl	80a0220 <_ZN8LEDRelay6setLEDEb>
    clock_control.sleep();
}
 80a0742:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
void sleepModeCallback(void *ptr){
    sleepMode.sleep_mode_enabled = true; 
    hmiScreen.sleep();
    notifLight.setStrip(0, 0, 0);
    lampLight.setLED(false);
    clock_control.sleep();
 80a0746:	4805      	ldr	r0, [pc, #20]	; (80a075c <_Z17sleepModeCallbackPv+0x3c>)
 80a0748:	f7ff bd90 	b.w	80a026c <_ZN12ClockControl5sleepEv>
 80a074c:	20001020 	.word	0x20001020
 80a0750:	20000540 	.word	0x20000540
 80a0754:	20000474 	.word	0x20000474
 80a0758:	20000feb 	.word	0x20000feb
 80a075c:	2000048c 	.word	0x2000048c

080a0760 <_Z18toggleWifiCallbackPv>:
description: toggles Wifi on or off!
parameters: none 
returns: none
*/
void toggleWifiCallback(void *ptr){
   toggleWifiParticle();
 80a0760:	f7ff bf89 	b.w	80a0676 <_Z18toggleWifiParticlev>

080a0764 <_Z14wakeUpCallbackPv>:
function: wakeUpCallback(void *ptr)
description: wakes up particle! 
parameters: none 
returns: none
*/
void wakeUpCallback(void *ptr){
 80a0764:	b510      	push	{r4, lr}
    sleepMode.sleep_mode_enabled = false; 
    hmiScreen.home();
 80a0766:	4c07      	ldr	r4, [pc, #28]	; (80a0784 <_Z14wakeUpCallbackPv+0x20>)
description: wakes up particle! 
parameters: none 
returns: none
*/
void wakeUpCallback(void *ptr){
    sleepMode.sleep_mode_enabled = false; 
 80a0768:	4b07      	ldr	r3, [pc, #28]	; (80a0788 <_Z14wakeUpCallbackPv+0x24>)
 80a076a:	2200      	movs	r2, #0
    hmiScreen.home();
 80a076c:	4620      	mov	r0, r4
description: wakes up particle! 
parameters: none 
returns: none
*/
void wakeUpCallback(void *ptr){
    sleepMode.sleep_mode_enabled = false; 
 80a076e:	701a      	strb	r2, [r3, #0]
    hmiScreen.home();
 80a0770:	f7ff fe48 	bl	80a0404 <_ZN9HMIScreen4homeEv>
    hmiScreen.wake();
 80a0774:	4620      	mov	r0, r4
 80a0776:	f7ff fe4b 	bl	80a0410 <_ZN9HMIScreen4wakeEv>
    clock_control.wake();
}
 80a077a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
*/
void wakeUpCallback(void *ptr){
    sleepMode.sleep_mode_enabled = false; 
    hmiScreen.home();
    hmiScreen.wake();
    clock_control.wake();
 80a077e:	4803      	ldr	r0, [pc, #12]	; (80a078c <_Z14wakeUpCallbackPv+0x28>)
 80a0780:	f7ff bd56 	b.w	80a0230 <_ZN12ClockControl4wakeEv>
 80a0784:	20000540 	.word	0x20000540
 80a0788:	20001020 	.word	0x20001020
 80a078c:	2000048c 	.word	0x2000048c

080a0790 <_Z16keyBoardCallbackPv>:
function: wakeUpCallback(void *ptr)
description: wakes up particle! 
parameters: none 
returns: none
*/
void keyBoardCallback(void *ptr){
 80a0790:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    hmiScreen.keyboardText.getText(hmiScreen.keyBuffer, sizeof(hmiScreen.keyBuffer));
 80a0792:	4948      	ldr	r1, [pc, #288]	; (80a08b4 <_Z16keyBoardCallbackPv+0x124>)
 80a0794:	22c0      	movs	r2, #192	; 0xc0
 80a0796:	f1a1 0048 	sub.w	r0, r1, #72	; 0x48
 80a079a:	f004 fb5d 	bl	80a4e58 <_ZN7NexText7getTextEPct>
    String buffer = hmiScreen.keyBuffer;
 80a079e:	4945      	ldr	r1, [pc, #276]	; (80a08b4 <_Z16keyBoardCallbackPv+0x124>)
 80a07a0:	4668      	mov	r0, sp
 80a07a2:	f005 f898 	bl	80a58d6 <_ZN6StringC1EPK19__FlashStringHelper>
    if(buffer.equals("exit")){
 80a07a6:	4944      	ldr	r1, [pc, #272]	; (80a08b8 <_Z16keyBoardCallbackPv+0x128>)
 80a07a8:	4668      	mov	r0, sp
 80a07aa:	f005 f8c1 	bl	80a5930 <_ZNK6String6equalsEPKc>
 80a07ae:	b328      	cbz	r0, 80a07fc <_Z16keyBoardCallbackPv+0x6c>
        hmiScreen.terminalText.setText("Exiting");
 80a07b0:	4942      	ldr	r1, [pc, #264]	; (80a08bc <_Z16keyBoardCallbackPv+0x12c>)
 80a07b2:	4843      	ldr	r0, [pc, #268]	; (80a08c0 <_Z16keyBoardCallbackPv+0x130>)
 80a07b4:	f004 fb58 	bl	80a4e68 <_ZN7NexText7setTextEPKc>
        delay(100);
 80a07b8:	2064      	movs	r0, #100	; 0x64
 80a07ba:	f005 fa9f 	bl	80a5cfc <delay>
        hmiScreen.terminalText.setText("Exiting.");
 80a07be:	4941      	ldr	r1, [pc, #260]	; (80a08c4 <_Z16keyBoardCallbackPv+0x134>)
 80a07c0:	483f      	ldr	r0, [pc, #252]	; (80a08c0 <_Z16keyBoardCallbackPv+0x130>)
 80a07c2:	f004 fb51 	bl	80a4e68 <_ZN7NexText7setTextEPKc>
        delay(100);
 80a07c6:	2064      	movs	r0, #100	; 0x64
 80a07c8:	f005 fa98 	bl	80a5cfc <delay>
        hmiScreen.terminalText.setText("Exiting..");
 80a07cc:	493e      	ldr	r1, [pc, #248]	; (80a08c8 <_Z16keyBoardCallbackPv+0x138>)
 80a07ce:	483c      	ldr	r0, [pc, #240]	; (80a08c0 <_Z16keyBoardCallbackPv+0x130>)
 80a07d0:	f004 fb4a 	bl	80a4e68 <_ZN7NexText7setTextEPKc>
        delay(100);
 80a07d4:	2064      	movs	r0, #100	; 0x64
 80a07d6:	f005 fa91 	bl	80a5cfc <delay>
        hmiScreen.terminalText.setText("Exiting...");
 80a07da:	493c      	ldr	r1, [pc, #240]	; (80a08cc <_Z16keyBoardCallbackPv+0x13c>)
 80a07dc:	4838      	ldr	r0, [pc, #224]	; (80a08c0 <_Z16keyBoardCallbackPv+0x130>)
 80a07de:	f004 fb43 	bl	80a4e68 <_ZN7NexText7setTextEPKc>
        delay(100);
 80a07e2:	2064      	movs	r0, #100	; 0x64
 80a07e4:	f005 fa8a 	bl	80a5cfc <delay>
        hmiScreen.terminalText.setText("Exiting....");
 80a07e8:	4939      	ldr	r1, [pc, #228]	; (80a08d0 <_Z16keyBoardCallbackPv+0x140>)
 80a07ea:	4835      	ldr	r0, [pc, #212]	; (80a08c0 <_Z16keyBoardCallbackPv+0x130>)
 80a07ec:	f004 fb3c 	bl	80a4e68 <_ZN7NexText7setTextEPKc>
        delay(100);
 80a07f0:	2064      	movs	r0, #100	; 0x64
 80a07f2:	f005 fa83 	bl	80a5cfc <delay>
        hmiScreen.home();
 80a07f6:	4837      	ldr	r0, [pc, #220]	; (80a08d4 <_Z16keyBoardCallbackPv+0x144>)
 80a07f8:	f7ff fe04 	bl	80a0404 <_ZN9HMIScreen4homeEv>
    }
    
    if(buffer.equals("reset")){
 80a07fc:	4936      	ldr	r1, [pc, #216]	; (80a08d8 <_Z16keyBoardCallbackPv+0x148>)
 80a07fe:	4668      	mov	r0, sp
 80a0800:	f005 f896 	bl	80a5930 <_ZNK6String6equalsEPKc>
 80a0804:	b358      	cbz	r0, 80a085e <_Z16keyBoardCallbackPv+0xce>
        hmiScreen.terminalText.setText("Resetting Device");
 80a0806:	4935      	ldr	r1, [pc, #212]	; (80a08dc <_Z16keyBoardCallbackPv+0x14c>)
 80a0808:	482d      	ldr	r0, [pc, #180]	; (80a08c0 <_Z16keyBoardCallbackPv+0x130>)
 80a080a:	f004 fb2d 	bl	80a4e68 <_ZN7NexText7setTextEPKc>
        delay(100);
 80a080e:	2064      	movs	r0, #100	; 0x64
 80a0810:	f005 fa74 	bl	80a5cfc <delay>
        hmiScreen.terminalText.setText("Resetting Device.");
 80a0814:	4932      	ldr	r1, [pc, #200]	; (80a08e0 <_Z16keyBoardCallbackPv+0x150>)
 80a0816:	482a      	ldr	r0, [pc, #168]	; (80a08c0 <_Z16keyBoardCallbackPv+0x130>)
 80a0818:	f004 fb26 	bl	80a4e68 <_ZN7NexText7setTextEPKc>
        delay(100);
 80a081c:	2064      	movs	r0, #100	; 0x64
 80a081e:	f005 fa6d 	bl	80a5cfc <delay>
        hmiScreen.terminalText.setText("Resetting Device..");
 80a0822:	4930      	ldr	r1, [pc, #192]	; (80a08e4 <_Z16keyBoardCallbackPv+0x154>)
 80a0824:	4826      	ldr	r0, [pc, #152]	; (80a08c0 <_Z16keyBoardCallbackPv+0x130>)
 80a0826:	f004 fb1f 	bl	80a4e68 <_ZN7NexText7setTextEPKc>
        delay(100);
 80a082a:	2064      	movs	r0, #100	; 0x64
 80a082c:	f005 fa66 	bl	80a5cfc <delay>
        hmiScreen.terminalText.setText("Resetting Device...");
 80a0830:	492d      	ldr	r1, [pc, #180]	; (80a08e8 <_Z16keyBoardCallbackPv+0x158>)
 80a0832:	4823      	ldr	r0, [pc, #140]	; (80a08c0 <_Z16keyBoardCallbackPv+0x130>)
 80a0834:	f004 fb18 	bl	80a4e68 <_ZN7NexText7setTextEPKc>
        delay(100);
 80a0838:	2064      	movs	r0, #100	; 0x64
 80a083a:	f005 fa5f 	bl	80a5cfc <delay>
        hmiScreen.terminalText.setText("Resetting Device....");
 80a083e:	492b      	ldr	r1, [pc, #172]	; (80a08ec <_Z16keyBoardCallbackPv+0x15c>)
 80a0840:	481f      	ldr	r0, [pc, #124]	; (80a08c0 <_Z16keyBoardCallbackPv+0x130>)
 80a0842:	f004 fb11 	bl	80a4e68 <_ZN7NexText7setTextEPKc>
        delay(100);
 80a0846:	2064      	movs	r0, #100	; 0x64
 80a0848:	f005 fa58 	bl	80a5cfc <delay>
        hmiScreen.terminalText.setText("Resetting Device.....");
 80a084c:	4928      	ldr	r1, [pc, #160]	; (80a08f0 <_Z16keyBoardCallbackPv+0x160>)
 80a084e:	481c      	ldr	r0, [pc, #112]	; (80a08c0 <_Z16keyBoardCallbackPv+0x130>)
 80a0850:	f004 fb0a 	bl	80a4e68 <_ZN7NexText7setTextEPKc>
        delay(100);
 80a0854:	2064      	movs	r0, #100	; 0x64
 80a0856:	f005 fa51 	bl	80a5cfc <delay>
        System.reset();
 80a085a:	f004 ff93 	bl	80a5784 <_ZN11SystemClass5resetEv>
    }
    
    if(buffer.equals("wifilisten")){
 80a085e:	4925      	ldr	r1, [pc, #148]	; (80a08f4 <_Z16keyBoardCallbackPv+0x164>)
 80a0860:	4668      	mov	r0, sp
 80a0862:	f005 f865 	bl	80a5930 <_ZNK6String6equalsEPKc>
 80a0866:	b168      	cbz	r0, 80a0884 <_Z16keyBoardCallbackPv+0xf4>
        hmiScreen.terminalText.setText("Setting Wifi to listening mode...");
 80a0868:	4923      	ldr	r1, [pc, #140]	; (80a08f8 <_Z16keyBoardCallbackPv+0x168>)
 80a086a:	4815      	ldr	r0, [pc, #84]	; (80a08c0 <_Z16keyBoardCallbackPv+0x130>)
 80a086c:	f004 fafc 	bl	80a4e68 <_ZN7NexText7setTextEPKc>
        enableListeningMode();
 80a0870:	f7ff ff16 	bl	80a06a0 <_Z19enableListeningModev>
        delay(700);
 80a0874:	f44f 702f 	mov.w	r0, #700	; 0x2bc
 80a0878:	f005 fa40 	bl	80a5cfc <delay>
        hmiScreen.terminalText.setText("WiFi has been set to listening mode!!");
 80a087c:	491f      	ldr	r1, [pc, #124]	; (80a08fc <_Z16keyBoardCallbackPv+0x16c>)
 80a087e:	4810      	ldr	r0, [pc, #64]	; (80a08c0 <_Z16keyBoardCallbackPv+0x130>)
 80a0880:	f004 faf2 	bl	80a4e68 <_ZN7NexText7setTextEPKc>
    }
    
     if(buffer.equals("beep")){
 80a0884:	491e      	ldr	r1, [pc, #120]	; (80a0900 <_Z16keyBoardCallbackPv+0x170>)
 80a0886:	4668      	mov	r0, sp
 80a0888:	f005 f852 	bl	80a5930 <_ZNK6String6equalsEPKc>
 80a088c:	b138      	cbz	r0, 80a089e <_Z16keyBoardCallbackPv+0x10e>
        hmiScreen.terminalText.setText("beeping...");
 80a088e:	491d      	ldr	r1, [pc, #116]	; (80a0904 <_Z16keyBoardCallbackPv+0x174>)
 80a0890:	480b      	ldr	r0, [pc, #44]	; (80a08c0 <_Z16keyBoardCallbackPv+0x130>)
 80a0892:	f004 fae9 	bl	80a4e68 <_ZN7NexText7setTextEPKc>
        // 
        hmiScreen.terminalText.setText("Completed Beeping");
 80a0896:	491c      	ldr	r1, [pc, #112]	; (80a0908 <_Z16keyBoardCallbackPv+0x178>)
 80a0898:	4809      	ldr	r0, [pc, #36]	; (80a08c0 <_Z16keyBoardCallbackPv+0x130>)
 80a089a:	f004 fae5 	bl	80a4e68 <_ZN7NexText7setTextEPKc>
     }
     
    hmiScreen.keyboardText.setText("");
 80a089e:	491b      	ldr	r1, [pc, #108]	; (80a090c <_Z16keyBoardCallbackPv+0x17c>)
 80a08a0:	481b      	ldr	r0, [pc, #108]	; (80a0910 <_Z16keyBoardCallbackPv+0x180>)
 80a08a2:	f004 fae1 	bl	80a4e68 <_ZN7NexText7setTextEPKc>
parameters: none 
returns: none
*/
void keyBoardCallback(void *ptr){
    hmiScreen.keyboardText.getText(hmiScreen.keyBuffer, sizeof(hmiScreen.keyBuffer));
    String buffer = hmiScreen.keyBuffer;
 80a08a6:	4668      	mov	r0, sp
 80a08a8:	f004 ffce 	bl	80a5848 <_ZN6StringD1Ev>
        // 
        hmiScreen.terminalText.setText("Completed Beeping");
     }
     
    hmiScreen.keyboardText.setText("");
}
 80a08ac:	b005      	add	sp, #20
 80a08ae:	f85d fb04 	ldr.w	pc, [sp], #4
 80a08b2:	bf00      	nop
 80a08b4:	200007d8 	.word	0x200007d8
 80a08b8:	080a8212 	.word	0x080a8212
 80a08bc:	080a8217 	.word	0x080a8217
 80a08c0:	200007b4 	.word	0x200007b4
 80a08c4:	080a821f 	.word	0x080a821f
 80a08c8:	080a8228 	.word	0x080a8228
 80a08cc:	080a8232 	.word	0x080a8232
 80a08d0:	080a823d 	.word	0x080a823d
 80a08d4:	20000540 	.word	0x20000540
 80a08d8:	080a8249 	.word	0x080a8249
 80a08dc:	080a824f 	.word	0x080a824f
 80a08e0:	080a8260 	.word	0x080a8260
 80a08e4:	080a8272 	.word	0x080a8272
 80a08e8:	080a8285 	.word	0x080a8285
 80a08ec:	080a8299 	.word	0x080a8299
 80a08f0:	080a82ae 	.word	0x080a82ae
 80a08f4:	080a82c4 	.word	0x080a82c4
 80a08f8:	080a82cf 	.word	0x080a82cf
 80a08fc:	080a82f1 	.word	0x080a82f1
 80a0900:	080a8317 	.word	0x080a8317
 80a0904:	080a831c 	.word	0x080a831c
 80a0908:	080a8327 	.word	0x080a8327
 80a090c:	080a92e8 	.word	0x080a92e8
 80a0910:	20000790 	.word	0x20000790

080a0914 <_ZN5Timer7timeoutEv>:

    /*
     * Subclasses can either provide a callback function, or override
     * this timeout method.
     */
    virtual void timeout()
 80a0914:	b510      	push	{r4, lr}
    {
		running = true;
 80a0916:	2301      	movs	r3, #1
 80a0918:	7103      	strb	r3, [r0, #4]
        if (callback)
 80a091a:	6943      	ldr	r3, [r0, #20]

    /*
     * Subclasses can either provide a callback function, or override
     * this timeout method.
     */
    virtual void timeout()
 80a091c:	4604      	mov	r4, r0
    {
		running = true;
        if (callback)
 80a091e:	b113      	cbz	r3, 80a0926 <_ZN5Timer7timeoutEv+0x12>
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
	__throw_bad_function_call();
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a0920:	6983      	ldr	r3, [r0, #24]
 80a0922:	300c      	adds	r0, #12
 80a0924:	4798      	blx	r3
        {
            callback();
        }
        running = false;
 80a0926:	2300      	movs	r3, #0
 80a0928:	7123      	strb	r3, [r4, #4]
 80a092a:	bd10      	pop	{r4, pc}

080a092c <_ZN3UDPD1Ev>:



public:
	UDP();
        virtual ~UDP() { stop(); releaseBuffer(); }
 80a092c:	b510      	push	{r4, lr}
 80a092e:	4604      	mov	r4, r0
 80a0930:	4b05      	ldr	r3, [pc, #20]	; (80a0948 <_ZN3UDPD1Ev+0x1c>)
 80a0932:	6003      	str	r3, [r0, #0]
 80a0934:	3364      	adds	r3, #100	; 0x64
 80a0936:	6103      	str	r3, [r0, #16]
 80a0938:	f005 fa4e 	bl	80a5dd8 <_ZN3UDP4stopEv>
 80a093c:	4620      	mov	r0, r4
 80a093e:	f005 fb87 	bl	80a6050 <_ZN3UDP13releaseBufferEv>
 80a0942:	4620      	mov	r0, r4
 80a0944:	bd10      	pop	{r4, pc}
 80a0946:	bf00      	nop
 80a0948:	080a93e8 	.word	0x080a93e8

080a094c <_ZN17notificationLightD1Ev>:

/*
class: notificationLight
description: class that handles controlling the rgb notifcation circle. 
*/
class notificationLight{
 80a094c:	b510      	push	{r4, lr}
 80a094e:	4604      	mov	r4, r0
 80a0950:	f002 f9e9 	bl	80a2d26 <_ZN17Adafruit_NeoPixelD1Ev>
 80a0954:	4620      	mov	r0, r4
 80a0956:	bd10      	pop	{r4, pc}

080a0958 <_ZN5Timer12invoke_timerEPv>:
private:
	volatile bool running;
    os_timer_t handle;
    timer_callback_fn callback;

    static void invoke_timer(os_timer_t timer)
 80a0958:	b507      	push	{r0, r1, r2, lr}
    {
        void* timer_id = NULL;
 80a095a:	2300      	movs	r3, #0
 80a095c:	a902      	add	r1, sp, #8
 80a095e:	f841 3d04 	str.w	r3, [r1, #-4]!
        if (!os_timer_get_id(timer, &timer_id)) {
 80a0962:	f004 fbb9 	bl	80a50d8 <os_timer_get_id>
 80a0966:	b920      	cbnz	r0, 80a0972 <_ZN5Timer12invoke_timerEPv+0x1a>
            if (timer_id)
 80a0968:	9801      	ldr	r0, [sp, #4]
 80a096a:	b110      	cbz	r0, 80a0972 <_ZN5Timer12invoke_timerEPv+0x1a>
                ((Timer*)timer_id)->timeout();
 80a096c:	6803      	ldr	r3, [r0, #0]
 80a096e:	689b      	ldr	r3, [r3, #8]
 80a0970:	4798      	blx	r3
        }
    }
 80a0972:	b003      	add	sp, #12
 80a0974:	f85d fb04 	ldr.w	pc, [sp], #4

080a0978 <_Z4pushPKcS0_>:
function: pushNotification()
description: pushes a notification by printing to the tft led, and blinking the rgb leds :)
parameters:  *event, *data const char 
returns: none
*/
void push(const char *event, const char *data){
 80a0978:	b500      	push	{lr}
    if(!lockStatus.system_locked && !sleepMode.sleep_mode_enabled){
 80a097a:	4b24      	ldr	r3, [pc, #144]	; (80a0a0c <_Z4pushPKcS0_+0x94>)
function: pushNotification()
description: pushes a notification by printing to the tft led, and blinking the rgb leds :)
parameters:  *event, *data const char 
returns: none
*/
void push(const char *event, const char *data){
 80a097c:	b089      	sub	sp, #36	; 0x24
    if(!lockStatus.system_locked && !sleepMode.sleep_mode_enabled){
 80a097e:	7818      	ldrb	r0, [r3, #0]
 80a0980:	4a23      	ldr	r2, [pc, #140]	; (80a0a10 <_Z4pushPKcS0_+0x98>)
 80a0982:	b908      	cbnz	r0, 80a0988 <_Z4pushPKcS0_+0x10>
 80a0984:	7810      	ldrb	r0, [r2, #0]
 80a0986:	b190      	cbz	r0, 80a09ae <_Z4pushPKcS0_+0x36>
        counter.stagger_push = true; 
        alarm.beepOnce(300);
        clock_control.send_msg(buffer);
        
    }
    else if(lockStatus.system_locked & sleepMode.sleep_mode_enabled){
 80a0988:	7819      	ldrb	r1, [r3, #0]
 80a098a:	7813      	ldrb	r3, [r2, #0]
 80a098c:	b2db      	uxtb	r3, r3
 80a098e:	2900      	cmp	r1, #0
 80a0990:	d038      	beq.n	80a0a04 <_Z4pushPKcS0_+0x8c>
 80a0992:	2b00      	cmp	r3, #0
 80a0994:	d036      	beq.n	80a0a04 <_Z4pushPKcS0_+0x8c>
        tftDisplay.printTFT("Message Receieved");
 80a0996:	491f      	ldr	r1, [pc, #124]	; (80a0a14 <_Z4pushPKcS0_+0x9c>)
 80a0998:	a804      	add	r0, sp, #16
 80a099a:	f004 ff9c 	bl	80a58d6 <_ZN6StringC1EPK19__FlashStringHelper>
 80a099e:	a904      	add	r1, sp, #16
 80a09a0:	481d      	ldr	r0, [pc, #116]	; (80a0a18 <_Z4pushPKcS0_+0xa0>)
 80a09a2:	f7ff fe53 	bl	80a064c <_ZN10TFTDisplay8printTFTE6String>
 80a09a6:	a804      	add	r0, sp, #16
 80a09a8:	f004 ff4e 	bl	80a5848 <_ZN6StringD1Ev>
    }
    
}
 80a09ac:	e02a      	b.n	80a0a04 <_Z4pushPKcS0_+0x8c>
parameters:  *event, *data const char 
returns: none
*/
void push(const char *event, const char *data){
    if(!lockStatus.system_locked && !sleepMode.sleep_mode_enabled){
        String buffer = data; 
 80a09ae:	4668      	mov	r0, sp
 80a09b0:	f004 ff91 	bl	80a58d6 <_ZN6StringC1EPK19__FlashStringHelper>
        tftDisplay.printTFT(buffer);
 80a09b4:	4669      	mov	r1, sp
 80a09b6:	a804      	add	r0, sp, #16
 80a09b8:	f004 ffaf 	bl	80a591a <_ZN6StringC1ERKS_>
 80a09bc:	a904      	add	r1, sp, #16
 80a09be:	4816      	ldr	r0, [pc, #88]	; (80a0a18 <_Z4pushPKcS0_+0xa0>)
 80a09c0:	f7ff fe44 	bl	80a064c <_ZN10TFTDisplay8printTFTE6String>
 80a09c4:	a804      	add	r0, sp, #16
 80a09c6:	f004 ff3f 	bl	80a5848 <_ZN6StringD1Ev>
        hmiScreen.home();
 80a09ca:	4814      	ldr	r0, [pc, #80]	; (80a0a1c <_Z4pushPKcS0_+0xa4>)
 80a09cc:	f7ff fd1a 	bl	80a0404 <_ZN9HMIScreen4homeEv>
        hmiScreen.homeText.setText(buffer);
 80a09d0:	9900      	ldr	r1, [sp, #0]
 80a09d2:	4813      	ldr	r0, [pc, #76]	; (80a0a20 <_Z4pushPKcS0_+0xa8>)
 80a09d4:	f004 fa48 	bl	80a4e68 <_ZN7NexText7setTextEPKc>
        counter.stagger_push = true; 
 80a09d8:	4b12      	ldr	r3, [pc, #72]	; (80a0a24 <_Z4pushPKcS0_+0xac>)
 80a09da:	2201      	movs	r2, #1
        alarm.beepOnce(300);
 80a09dc:	f44f 7196 	mov.w	r1, #300	; 0x12c
 80a09e0:	4811      	ldr	r0, [pc, #68]	; (80a0a28 <_Z4pushPKcS0_+0xb0>)
    if(!lockStatus.system_locked && !sleepMode.sleep_mode_enabled){
        String buffer = data; 
        tftDisplay.printTFT(buffer);
        hmiScreen.home();
        hmiScreen.homeText.setText(buffer);
        counter.stagger_push = true; 
 80a09e2:	731a      	strb	r2, [r3, #12]
        alarm.beepOnce(300);
 80a09e4:	f7ff fd4f 	bl	80a0486 <_ZN10alarmRelay8beepOnceEi>
        clock_control.send_msg(buffer);
 80a09e8:	4669      	mov	r1, sp
 80a09ea:	a804      	add	r0, sp, #16
 80a09ec:	f004 ff95 	bl	80a591a <_ZN6StringC1ERKS_>
 80a09f0:	a904      	add	r1, sp, #16
 80a09f2:	480e      	ldr	r0, [pc, #56]	; (80a0a2c <_Z4pushPKcS0_+0xb4>)
 80a09f4:	f7ff fc58 	bl	80a02a8 <_ZN12ClockControl8send_msgE6String>
 80a09f8:	a804      	add	r0, sp, #16
 80a09fa:	f004 ff25 	bl	80a5848 <_ZN6StringD1Ev>
parameters:  *event, *data const char 
returns: none
*/
void push(const char *event, const char *data){
    if(!lockStatus.system_locked && !sleepMode.sleep_mode_enabled){
        String buffer = data; 
 80a09fe:	4668      	mov	r0, sp
 80a0a00:	f004 ff22 	bl	80a5848 <_ZN6StringD1Ev>
    }
    else if(lockStatus.system_locked & sleepMode.sleep_mode_enabled){
        tftDisplay.printTFT("Message Receieved");
    }
    
}
 80a0a04:	b009      	add	sp, #36	; 0x24
 80a0a06:	f85d fb04 	ldr.w	pc, [sp], #4
 80a0a0a:	bf00      	nop
 80a0a0c:	20000fea 	.word	0x20000fea
 80a0a10:	20001020 	.word	0x20001020
 80a0a14:	080a8339 	.word	0x080a8339
 80a0a18:	20000fec 	.word	0x20000fec
 80a0a1c:	20000540 	.word	0x20000540
 80a0a20:	20000604 	.word	0x20000604
 80a0a24:	20001040 	.word	0x20001040
 80a0a28:	200003c4 	.word	0x200003c4
 80a0a2c:	2000048c 	.word	0x2000048c

080a0a30 <_ZN10CloudClass7publishEPKcS1_.isra.11.constprop.17>:
// Deprecated methods
inline particle::Future<bool> CloudClass::publish(const char* name) {
    return publish(name, PUBLIC);
}

inline particle::Future<bool> CloudClass::publish(const char* name, const char* data) {
 80a0a30:	b513      	push	{r0, r1, r4, lr}
 80a0a32:	4604      	mov	r4, r0
 80a0a34:	4b05      	ldr	r3, [pc, #20]	; (80a0a4c <_ZN10CloudClass7publishEPKcS1_.isra.11.constprop.17+0x1c>)
        return publish(eventName, eventData, 60, flags1, flags2);
    }

    inline particle::Future<bool> publish(const char *eventName, const char *eventData, int ttl, PublishFlags flags1, PublishFlags flags2 = PublishFlags())
    {
        return publish_event(eventName, eventData, ttl, flags1 | flags2);
 80a0a36:	460a      	mov	r2, r1
 80a0a38:	781b      	ldrb	r3, [r3, #0]
 80a0a3a:	4905      	ldr	r1, [pc, #20]	; (80a0a50 <_ZN10CloudClass7publishEPKcS1_.isra.11.constprop.17+0x20>)
 80a0a3c:	f88d 3000 	strb.w	r3, [sp]
 80a0a40:	233c      	movs	r3, #60	; 0x3c
 80a0a42:	f005 fd73 	bl	80a652c <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE>
    return publish(name, PUBLIC);
}

inline particle::Future<bool> CloudClass::publish(const char* name, const char* data) {
    return publish(name, data, PUBLIC);
}
 80a0a46:	4620      	mov	r0, r4
 80a0a48:	b002      	add	sp, #8
 80a0a4a:	bd10      	pop	{r4, pc}
 80a0a4c:	20000404 	.word	0x20000404
 80a0a50:	080a834b 	.word	0x080a834b

080a0a54 <_ZN10CloudClass9subscribeEPKcPFvS1_S1_E32Spark_Subscription_Scope_TypeDef.isra.5.constprop.20>:
    // Deprecated methods
    particle::Future<bool> publish(const char* name) PARTICLE_DEPRECATED_API_DEFAULT_PUBLISH_SCOPE;
    particle::Future<bool> publish(const char* name, const char* data) PARTICLE_DEPRECATED_API_DEFAULT_PUBLISH_SCOPE;
    particle::Future<bool> publish(const char* name, const char* data, int ttl) PARTICLE_DEPRECATED_API_DEFAULT_PUBLISH_SCOPE;

    inline bool subscribe(const char *eventName, EventHandler handler, Spark_Subscription_Scope_TypeDef scope)
 80a0a54:	b507      	push	{r0, r1, r2, lr}
    {
        return CLOUD_FN(spark_subscribe(eventName, handler, NULL, scope, NULL, NULL), false);
 80a0a56:	2300      	movs	r3, #0
 80a0a58:	9301      	str	r3, [sp, #4]
 80a0a5a:	9300      	str	r3, [sp, #0]
 80a0a5c:	461a      	mov	r2, r3
 80a0a5e:	f004 fd39 	bl	80a54d4 <spark_subscribe>
    }
 80a0a62:	b003      	add	sp, #12
 80a0a64:	f85d fb04 	ldr.w	pc, [sp], #4

080a0a68 <_Z8pushLoudPKcS0_>:
 80a0a68:	4770      	bx	lr

080a0a6a <_Z12ms_1000_taskv>:
 80a0a6a:	4770      	bx	lr

080a0a6c <_ZNSt14_Function_baseD1Ev>:
	}
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
 80a0a6c:	b510      	push	{r4, lr}
    {
      if (_M_manager)
 80a0a6e:	6883      	ldr	r3, [r0, #8]
	}
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
 80a0a70:	4604      	mov	r4, r0
    {
      if (_M_manager)
 80a0a72:	b113      	cbz	r3, 80a0a7a <_ZNSt14_Function_baseD1Ev+0xe>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
 80a0a74:	2203      	movs	r2, #3
 80a0a76:	4601      	mov	r1, r0
 80a0a78:	4798      	blx	r3
    }
 80a0a7a:	4620      	mov	r0, r4
 80a0a7c:	bd10      	pop	{r4, pc}
	...

080a0a80 <_ZN5TimerC1EjSt8functionIFvvEEb>:
{
public:

    typedef std::function<void(void)> timer_callback_fn;

    Timer(unsigned period, timer_callback_fn callback_, bool one_shot=false) : running(false), handle(nullptr), callback(std::move(callback_)) {
 80a0a80:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a0a82:	4604      	mov	r4, r0
 80a0a84:	468e      	mov	lr, r1
 80a0a86:	4915      	ldr	r1, [pc, #84]	; (80a0adc <_ZN5TimerC1EjSt8functionIFvvEEb+0x5c>)
 80a0a88:	2500      	movs	r5, #0
 80a0a8a:	b085      	sub	sp, #20
 80a0a8c:	7105      	strb	r5, [r0, #4]
 80a0a8e:	6085      	str	r5, [r0, #8]
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a0a90:	6145      	str	r5, [r0, #20]
 80a0a92:	6001      	str	r1, [r0, #0]
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a0a94:	af02      	add	r7, sp, #8
 80a0a96:	e892 0003 	ldmia.w	r2, {r0, r1}
 80a0a9a:	e887 0003 	stmia.w	r7, {r0, r1}
      __a = _GLIBCXX_MOVE(__b);
 80a0a9e:	f104 060c 	add.w	r6, r4, #12
 80a0aa2:	e896 0003 	ldmia.w	r6, {r0, r1}
 80a0aa6:	e882 0003 	stmia.w	r2, {r0, r1}
      __b = _GLIBCXX_MOVE(__tmp);
 80a0aaa:	e897 0003 	ldmia.w	r7, {r0, r1}
 80a0aae:	e886 0003 	stmia.w	r6, {r0, r1}
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a0ab2:	6891      	ldr	r1, [r2, #8]
      __a = _GLIBCXX_MOVE(__b);
 80a0ab4:	6960      	ldr	r0, [r4, #20]
 80a0ab6:	6090      	str	r0, [r2, #8]
      __b = _GLIBCXX_MOVE(__tmp);
 80a0ab8:	6161      	str	r1, [r4, #20]
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a0aba:	68d1      	ldr	r1, [r2, #12]
      __a = _GLIBCXX_MOVE(__b);
 80a0abc:	69a0      	ldr	r0, [r4, #24]
 80a0abe:	60d0      	str	r0, [r2, #12]
      __b = _GLIBCXX_MOVE(__tmp);
 80a0ac0:	61a1      	str	r1, [r4, #24]
        os_timer_create(&handle, period, invoke_timer, this, one_shot, nullptr);
 80a0ac2:	e88d 0028 	stmia.w	sp, {r3, r5}
 80a0ac6:	4a06      	ldr	r2, [pc, #24]	; (80a0ae0 <_ZN5TimerC1EjSt8functionIFvvEEb+0x60>)
 80a0ac8:	4623      	mov	r3, r4
 80a0aca:	4671      	mov	r1, lr
 80a0acc:	f104 0008 	add.w	r0, r4, #8
 80a0ad0:	f004 faf2 	bl	80a50b8 <os_timer_create>
    }
 80a0ad4:	4620      	mov	r0, r4
 80a0ad6:	b005      	add	sp, #20
 80a0ad8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a0ada:	bf00      	nop
 80a0adc:	080a81fc 	.word	0x080a81fc
 80a0ae0:	080a0959 	.word	0x080a0959

080a0ae4 <_ZN5Timer5_stopEjb>:
    {
        stop(fromISR);
        return handle ? !os_timer_change(handle, OS_TIMER_CHANGE_START, fromISR, 0, block, nullptr) : false;
    }

    bool _stop(unsigned block, bool fromISR=false)
 80a0ae4:	b507      	push	{r0, r1, r2, lr}
    {
        return handle ? !os_timer_change(handle, OS_TIMER_CHANGE_STOP, fromISR, 0, block, nullptr) : false;
 80a0ae6:	6880      	ldr	r0, [r0, #8]
 80a0ae8:	2300      	movs	r3, #0
 80a0aea:	b138      	cbz	r0, 80a0afc <_ZN5Timer5_stopEjb+0x18>
 80a0aec:	e88d 000a 	stmia.w	sp, {r1, r3}
 80a0af0:	2102      	movs	r1, #2
 80a0af2:	f004 faf9 	bl	80a50e8 <os_timer_change>
 80a0af6:	fab0 f080 	clz	r0, r0
 80a0afa:	0940      	lsrs	r0, r0, #5
    }
 80a0afc:	b003      	add	sp, #12
 80a0afe:	f85d fb04 	ldr.w	pc, [sp], #4

080a0b02 <_ZN5Timer6_startEjb>:
    bool changePeriod(unsigned period, unsigned block=default_wait) { return _changePeriod(period, block, false); }

    bool isValid() const { return handle!=nullptr; }
    bool isActive() const { return isValid() && os_timer_is_active(handle, nullptr); }

    bool _start(unsigned block, bool fromISR=false)
 80a0b02:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80a0b04:	4614      	mov	r4, r2
 80a0b06:	4606      	mov	r6, r0
 80a0b08:	460d      	mov	r5, r1
    bool changePeriodFromISR(unsigned period) { return _changePeriod(period, 0, true); }

    static const unsigned default_wait = 0x7FFFFFFF;

    bool start(unsigned block=default_wait) { return _start(block, false); }
    bool stop(unsigned block=default_wait) { return _stop(block, false); }
 80a0b0a:	2200      	movs	r2, #0
 80a0b0c:	4621      	mov	r1, r4
 80a0b0e:	f7ff ffe9 	bl	80a0ae4 <_ZN5Timer5_stopEjb>
    bool isActive() const { return isValid() && os_timer_is_active(handle, nullptr); }

    bool _start(unsigned block, bool fromISR=false)
    {
        stop(fromISR);
        return handle ? !os_timer_change(handle, OS_TIMER_CHANGE_START, fromISR, 0, block, nullptr) : false;
 80a0b12:	68b0      	ldr	r0, [r6, #8]
 80a0b14:	2300      	movs	r3, #0
 80a0b16:	b140      	cbz	r0, 80a0b2a <_ZN5Timer6_startEjb+0x28>
 80a0b18:	9301      	str	r3, [sp, #4]
 80a0b1a:	9500      	str	r5, [sp, #0]
 80a0b1c:	4622      	mov	r2, r4
 80a0b1e:	4619      	mov	r1, r3
 80a0b20:	f004 fae2 	bl	80a50e8 <os_timer_change>
 80a0b24:	fab0 f080 	clz	r0, r0
 80a0b28:	0940      	lsrs	r0, r0, #5
    }
 80a0b2a:	b002      	add	sp, #8
 80a0b2c:	bd70      	pop	{r4, r5, r6, pc}
	...

080a0b30 <_ZN5TimerD1Ev>:
    template <typename T>
    Timer(unsigned period, void (T::*handler)(), T& instance, bool one_shot=false) : Timer(period, std::bind(handler, &instance), one_shot)
    {
    }

    virtual ~Timer() {
 80a0b30:	b538      	push	{r3, r4, r5, lr}
 80a0b32:	4b0e      	ldr	r3, [pc, #56]	; (80a0b6c <_ZN5TimerD1Ev+0x3c>)
 80a0b34:	4604      	mov	r4, r0
 80a0b36:	6003      	str	r3, [r0, #0]
         return handle ? !os_timer_change(handle, OS_TIMER_CHANGE_PERIOD, fromISR, period, block, nullptr) : false;
    }

    void dispose()
    {
        if (handle)
 80a0b38:	6883      	ldr	r3, [r0, #8]
 80a0b3a:	b18b      	cbz	r3, 80a0b60 <_ZN5TimerD1Ev+0x30>
    bool changePeriodFromISR(unsigned period) { return _changePeriod(period, 0, true); }

    static const unsigned default_wait = 0x7FFFFFFF;

    bool start(unsigned block=default_wait) { return _start(block, false); }
    bool stop(unsigned block=default_wait) { return _stop(block, false); }
 80a0b3c:	2200      	movs	r2, #0
 80a0b3e:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 80a0b42:	f7ff ffcf 	bl	80a0ae4 <_ZN5Timer5_stopEjb>
    void dispose()
    {
        if (handle)
        	{
        		stop();
        		while (running) {
 80a0b46:	7923      	ldrb	r3, [r4, #4]
 80a0b48:	f003 05ff 	and.w	r5, r3, #255	; 0xff
 80a0b4c:	b11b      	cbz	r3, 80a0b56 <_ZN5TimerD1Ev+0x26>
				delay(1);
 80a0b4e:	2001      	movs	r0, #1
 80a0b50:	f005 f8d4 	bl	80a5cfc <delay>
 80a0b54:	e7f7      	b.n	80a0b46 <_ZN5TimerD1Ev+0x16>
			}
        		os_timer_destroy(handle, nullptr);
 80a0b56:	4629      	mov	r1, r5
 80a0b58:	68a0      	ldr	r0, [r4, #8]
 80a0b5a:	f004 fab5 	bl	80a50c8 <os_timer_destroy>
            handle = nullptr;
 80a0b5e:	60a5      	str	r5, [r4, #8]
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a0b60:	f104 000c 	add.w	r0, r4, #12
 80a0b64:	f7ff ff82 	bl	80a0a6c <_ZNSt14_Function_baseD1Ev>

    virtual ~Timer() {
    		// when the timer is calling the std::function, we cannot dispose of it until the function completes.
		// the call has exited.
		dispose();
    }
 80a0b68:	4620      	mov	r0, r4
 80a0b6a:	bd38      	pop	{r3, r4, r5, pc}
 80a0b6c:	080a81fc 	.word	0x080a81fc

080a0b70 <_ZN5TimerD0Ev>:
    template <typename T>
    Timer(unsigned period, void (T::*handler)(), T& instance, bool one_shot=false) : Timer(period, std::bind(handler, &instance), one_shot)
    {
    }

    virtual ~Timer() {
 80a0b70:	b510      	push	{r4, lr}
 80a0b72:	4604      	mov	r4, r0
    		// when the timer is calling the std::function, we cannot dispose of it until the function completes.
		// the call has exited.
		dispose();
    }
 80a0b74:	f7ff ffdc 	bl	80a0b30 <_ZN5TimerD1Ev>
 80a0b78:	4620      	mov	r0, r4
 80a0b7a:	f7ff fa92 	bl	80a00a2 <_ZdlPv>
 80a0b7e:	4620      	mov	r0, r4
 80a0b80:	bd10      	pop	{r4, pc}

080a0b82 <_ZN3UDPD0Ev>:
 80a0b82:	b510      	push	{r4, lr}
 80a0b84:	4604      	mov	r4, r0
 80a0b86:	f7ff fed1 	bl	80a092c <_ZN3UDPD1Ev>
 80a0b8a:	4620      	mov	r0, r4
 80a0b8c:	f7ff fa89 	bl	80a00a2 <_ZdlPv>
 80a0b90:	4620      	mov	r0, r4
 80a0b92:	bd10      	pop	{r4, pc}

080a0b94 <_ZN9HMIScreenC1Ev>:
/*
class: HMIScreen
description: Allows me to deal with interactions with the Human machine interace.

*/
struct HMIScreen{
 80a0b94:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a0b98:	4604      	mov	r4, r0
 80a0b9a:	b08b      	sub	sp, #44	; 0x2c
 80a0b9c:	2500      	movs	r5, #0
 80a0b9e:	7005      	strb	r5, [r0, #0]
 80a0ba0:	7045      	strb	r5, [r0, #1]
 80a0ba2:	4629      	mov	r1, r5
 80a0ba4:	9500      	str	r5, [sp, #0]
 80a0ba6:	4bcb      	ldr	r3, [pc, #812]	; (80a0ed4 <_ZN9HMIScreenC1Ev+0x340>)
 80a0ba8:	2203      	movs	r2, #3
 80a0baa:	3004      	adds	r0, #4
 80a0bac:	f003 fec0 	bl	80a4930 <_ZN9NexButtonC1EhhPKcPv>
 80a0bb0:	f104 0328 	add.w	r3, r4, #40	; 0x28
 80a0bb4:	9302      	str	r3, [sp, #8]
 80a0bb6:	4629      	mov	r1, r5
 80a0bb8:	9500      	str	r5, [sp, #0]
 80a0bba:	4bc7      	ldr	r3, [pc, #796]	; (80a0ed8 <_ZN9HMIScreenC1Ev+0x344>)
 80a0bbc:	2205      	movs	r2, #5
 80a0bbe:	9802      	ldr	r0, [sp, #8]
 80a0bc0:	f003 feb6 	bl	80a4930 <_ZN9NexButtonC1EhhPKcPv>
 80a0bc4:	f104 034c 	add.w	r3, r4, #76	; 0x4c
 80a0bc8:	9303      	str	r3, [sp, #12]
 80a0bca:	2201      	movs	r2, #1
 80a0bcc:	4611      	mov	r1, r2
 80a0bce:	9500      	str	r5, [sp, #0]
 80a0bd0:	4bc2      	ldr	r3, [pc, #776]	; (80a0edc <_ZN9HMIScreenC1Ev+0x348>)
 80a0bd2:	9803      	ldr	r0, [sp, #12]
 80a0bd4:	f003 feac 	bl	80a4930 <_ZN9NexButtonC1EhhPKcPv>
 80a0bd8:	f104 0370 	add.w	r3, r4, #112	; 0x70
 80a0bdc:	9304      	str	r3, [sp, #16]
 80a0bde:	9500      	str	r5, [sp, #0]
 80a0be0:	4bbf      	ldr	r3, [pc, #764]	; (80a0ee0 <_ZN9HMIScreenC1Ev+0x34c>)
 80a0be2:	2201      	movs	r2, #1
 80a0be4:	2103      	movs	r1, #3
 80a0be6:	9804      	ldr	r0, [sp, #16]
 80a0be8:	f003 fea2 	bl	80a4930 <_ZN9NexButtonC1EhhPKcPv>
 80a0bec:	9500      	str	r5, [sp, #0]
 80a0bee:	4bbd      	ldr	r3, [pc, #756]	; (80a0ee4 <_ZN9HMIScreenC1Ev+0x350>)
 80a0bf0:	2202      	movs	r2, #2
 80a0bf2:	2104      	movs	r1, #4
 80a0bf4:	f104 0094 	add.w	r0, r4, #148	; 0x94
 80a0bf8:	f003 fe87 	bl	80a490a <_ZN14NexProgressBarC1EhhPKcPv>
 80a0bfc:	9500      	str	r5, [sp, #0]
 80a0bfe:	4bba      	ldr	r3, [pc, #744]	; (80a0ee8 <_ZN9HMIScreenC1Ev+0x354>)
 80a0c00:	2203      	movs	r2, #3
 80a0c02:	2104      	movs	r1, #4
 80a0c04:	f104 00a0 	add.w	r0, r4, #160	; 0xa0
 80a0c08:	f004 f91c 	bl	80a4e44 <_ZN7NexTextC1EhhPKcPv>
 80a0c0c:	4629      	mov	r1, r5
 80a0c0e:	9500      	str	r5, [sp, #0]
 80a0c10:	4bb6      	ldr	r3, [pc, #728]	; (80a0eec <_ZN9HMIScreenC1Ev+0x358>)
 80a0c12:	2206      	movs	r2, #6
 80a0c14:	f104 00c4 	add.w	r0, r4, #196	; 0xc4
 80a0c18:	f004 f914 	bl	80a4e44 <_ZN7NexTextC1EhhPKcPv>
 80a0c1c:	f104 03e8 	add.w	r3, r4, #232	; 0xe8
 80a0c20:	9305      	str	r3, [sp, #20]
 80a0c22:	f8df 9350 	ldr.w	r9, [pc, #848]	; 80a0f74 <_ZN9HMIScreenC1Ev+0x3e0>
 80a0c26:	4629      	mov	r1, r5
 80a0c28:	9500      	str	r5, [sp, #0]
 80a0c2a:	4bb1      	ldr	r3, [pc, #708]	; (80a0ef0 <_ZN9HMIScreenC1Ev+0x35c>)
 80a0c2c:	2202      	movs	r2, #2
 80a0c2e:	9805      	ldr	r0, [sp, #20]
 80a0c30:	f003 fe7e 	bl	80a4930 <_ZN9NexButtonC1EhhPKcPv>
 80a0c34:	464b      	mov	r3, r9
 80a0c36:	9500      	str	r5, [sp, #0]
 80a0c38:	2201      	movs	r2, #1
 80a0c3a:	2111      	movs	r1, #17
 80a0c3c:	f504 7086 	add.w	r0, r4, #268	; 0x10c
 80a0c40:	f004 f900 	bl	80a4e44 <_ZN7NexTextC1EhhPKcPv>
 80a0c44:	9500      	str	r5, [sp, #0]
 80a0c46:	4bab      	ldr	r3, [pc, #684]	; (80a0ef4 <_ZN9HMIScreenC1Ev+0x360>)
 80a0c48:	2201      	movs	r2, #1
 80a0c4a:	210e      	movs	r1, #14
 80a0c4c:	f504 7098 	add.w	r0, r4, #304	; 0x130
 80a0c50:	f004 f8f8 	bl	80a4e44 <_ZN7NexTextC1EhhPKcPv>
 80a0c54:	f504 73aa 	add.w	r3, r4, #340	; 0x154
 80a0c58:	9306      	str	r3, [sp, #24]
 80a0c5a:	9500      	str	r5, [sp, #0]
 80a0c5c:	4ba6      	ldr	r3, [pc, #664]	; (80a0ef8 <_ZN9HMIScreenC1Ev+0x364>)
 80a0c5e:	2201      	movs	r2, #1
 80a0c60:	2117      	movs	r1, #23
 80a0c62:	9806      	ldr	r0, [sp, #24]
 80a0c64:	f003 fe64 	bl	80a4930 <_ZN9NexButtonC1EhhPKcPv>
 80a0c68:	f504 73bc 	add.w	r3, r4, #376	; 0x178
 80a0c6c:	9307      	str	r3, [sp, #28]
 80a0c6e:	9500      	str	r5, [sp, #0]
 80a0c70:	4ba2      	ldr	r3, [pc, #648]	; (80a0efc <_ZN9HMIScreenC1Ev+0x368>)
 80a0c72:	2203      	movs	r2, #3
 80a0c74:	2117      	movs	r1, #23
 80a0c76:	9807      	ldr	r0, [sp, #28]
 80a0c78:	f003 fe5a 	bl	80a4930 <_ZN9NexButtonC1EhhPKcPv>
 80a0c7c:	4fa0      	ldr	r7, [pc, #640]	; (80a0f00 <_ZN9HMIScreenC1Ev+0x36c>)
 80a0c7e:	f504 73ce 	add.w	r3, r4, #412	; 0x19c
 80a0c82:	9308      	str	r3, [sp, #32]
 80a0c84:	9500      	str	r5, [sp, #0]
 80a0c86:	463b      	mov	r3, r7
 80a0c88:	2204      	movs	r2, #4
 80a0c8a:	2117      	movs	r1, #23
 80a0c8c:	9808      	ldr	r0, [sp, #32]
 80a0c8e:	f003 fe4f 	bl	80a4930 <_ZN9NexButtonC1EhhPKcPv>
 80a0c92:	4e9c      	ldr	r6, [pc, #624]	; (80a0f04 <_ZN9HMIScreenC1Ev+0x370>)
 80a0c94:	f504 73e0 	add.w	r3, r4, #448	; 0x1c0
 80a0c98:	9309      	str	r3, [sp, #36]	; 0x24
 80a0c9a:	f504 7bf2 	add.w	fp, r4, #484	; 0x1e4
 80a0c9e:	4633      	mov	r3, r6
 80a0ca0:	9500      	str	r5, [sp, #0]
 80a0ca2:	2205      	movs	r2, #5
 80a0ca4:	2117      	movs	r1, #23
 80a0ca6:	9809      	ldr	r0, [sp, #36]	; 0x24
 80a0ca8:	f003 fe42 	bl	80a4930 <_ZN9NexButtonC1EhhPKcPv>
 80a0cac:	f504 7a02 	add.w	sl, r4, #520	; 0x208
 80a0cb0:	9500      	str	r5, [sp, #0]
 80a0cb2:	4b95      	ldr	r3, [pc, #596]	; (80a0f08 <_ZN9HMIScreenC1Ev+0x374>)
 80a0cb4:	2206      	movs	r2, #6
 80a0cb6:	2117      	movs	r1, #23
 80a0cb8:	4658      	mov	r0, fp
 80a0cba:	f003 fe39 	bl	80a4930 <_ZN9NexButtonC1EhhPKcPv>
 80a0cbe:	f504 780b 	add.w	r8, r4, #556	; 0x22c
 80a0cc2:	9500      	str	r5, [sp, #0]
 80a0cc4:	4b91      	ldr	r3, [pc, #580]	; (80a0f0c <_ZN9HMIScreenC1Ev+0x378>)
 80a0cc6:	2207      	movs	r2, #7
 80a0cc8:	2117      	movs	r1, #23
 80a0cca:	4650      	mov	r0, sl
 80a0ccc:	f003 fe30 	bl	80a4930 <_ZN9NexButtonC1EhhPKcPv>
 80a0cd0:	9500      	str	r5, [sp, #0]
 80a0cd2:	4b8f      	ldr	r3, [pc, #572]	; (80a0f10 <_ZN9HMIScreenC1Ev+0x37c>)
 80a0cd4:	2226      	movs	r2, #38	; 0x26
 80a0cd6:	2116      	movs	r1, #22
 80a0cd8:	4640      	mov	r0, r8
 80a0cda:	f003 fe29 	bl	80a4930 <_ZN9NexButtonC1EhhPKcPv>
 80a0cde:	9500      	str	r5, [sp, #0]
 80a0ce0:	4b8c      	ldr	r3, [pc, #560]	; (80a0f14 <_ZN9HMIScreenC1Ev+0x380>)
 80a0ce2:	2202      	movs	r2, #2
 80a0ce4:	2116      	movs	r1, #22
 80a0ce6:	f504 7014 	add.w	r0, r4, #592	; 0x250
 80a0cea:	f004 f8ab 	bl	80a4e44 <_ZN7NexTextC1EhhPKcPv>
 80a0cee:	464b      	mov	r3, r9
 80a0cf0:	9500      	str	r5, [sp, #0]
 80a0cf2:	2228      	movs	r2, #40	; 0x28
 80a0cf4:	2116      	movs	r1, #22
 80a0cf6:	f504 701d 	add.w	r0, r4, #628	; 0x274
 80a0cfa:	f004 f8a3 	bl	80a4e44 <_ZN7NexTextC1EhhPKcPv>
 80a0cfe:	4629      	mov	r1, r5
 80a0d00:	22c0      	movs	r2, #192	; 0xc0
 80a0d02:	f504 7026 	add.w	r0, r4, #664	; 0x298
 80a0d06:	f006 fda8 	bl	80a785a <memset>
 80a0d0a:	463b      	mov	r3, r7
 80a0d0c:	9500      	str	r5, [sp, #0]
 80a0d0e:	2205      	movs	r2, #5
 80a0d10:	2101      	movs	r1, #1
 80a0d12:	f504 7056 	add.w	r0, r4, #856	; 0x358
 80a0d16:	f003 fe0b 	bl	80a4930 <_ZN9NexButtonC1EhhPKcPv>
 80a0d1a:	4633      	mov	r3, r6
 80a0d1c:	9500      	str	r5, [sp, #0]
 80a0d1e:	2206      	movs	r2, #6
 80a0d20:	2101      	movs	r1, #1
 80a0d22:	f504 705f 	add.w	r0, r4, #892	; 0x37c
 80a0d26:	f003 fe03 	bl	80a4930 <_ZN9NexButtonC1EhhPKcPv>
 80a0d2a:	9500      	str	r5, [sp, #0]
 80a0d2c:	4b7a      	ldr	r3, [pc, #488]	; (80a0f18 <_ZN9HMIScreenC1Ev+0x384>)
 80a0d2e:	220c      	movs	r2, #12
 80a0d30:	2101      	movs	r1, #1
 80a0d32:	f504 7068 	add.w	r0, r4, #928	; 0x3a0
 80a0d36:	f003 fdfb 	bl	80a4930 <_ZN9NexButtonC1EhhPKcPv>
 80a0d3a:	f504 797a 	add.w	r9, r4, #1000	; 0x3e8
 80a0d3e:	9500      	str	r5, [sp, #0]
 80a0d40:	4b76      	ldr	r3, [pc, #472]	; (80a0f1c <_ZN9HMIScreenC1Ev+0x388>)
 80a0d42:	220d      	movs	r2, #13
 80a0d44:	2101      	movs	r1, #1
 80a0d46:	f504 7071 	add.w	r0, r4, #964	; 0x3c4
 80a0d4a:	f003 fdf1 	bl	80a4930 <_ZN9NexButtonC1EhhPKcPv>
 80a0d4e:	9500      	str	r5, [sp, #0]
 80a0d50:	4b73      	ldr	r3, [pc, #460]	; (80a0f20 <_ZN9HMIScreenC1Ev+0x38c>)
 80a0d52:	220b      	movs	r2, #11
 80a0d54:	2101      	movs	r1, #1
 80a0d56:	4648      	mov	r0, r9
 80a0d58:	f003 fdea 	bl	80a4930 <_ZN9NexButtonC1EhhPKcPv>
 80a0d5c:	9500      	str	r5, [sp, #0]
 80a0d5e:	4b71      	ldr	r3, [pc, #452]	; (80a0f24 <_ZN9HMIScreenC1Ev+0x390>)
 80a0d60:	2201      	movs	r2, #1
 80a0d62:	210b      	movs	r1, #11
 80a0d64:	f204 400c 	addw	r0, r4, #1036	; 0x40c
 80a0d68:	f003 fde2 	bl	80a4930 <_ZN9NexButtonC1EhhPKcPv>
 80a0d6c:	9500      	str	r5, [sp, #0]
 80a0d6e:	4b6e      	ldr	r3, [pc, #440]	; (80a0f28 <_ZN9HMIScreenC1Ev+0x394>)
 80a0d70:	2202      	movs	r2, #2
 80a0d72:	210b      	movs	r1, #11
 80a0d74:	f504 6086 	add.w	r0, r4, #1072	; 0x430
 80a0d78:	f003 fdda 	bl	80a4930 <_ZN9NexButtonC1EhhPKcPv>
 80a0d7c:	9500      	str	r5, [sp, #0]
 80a0d7e:	4b6b      	ldr	r3, [pc, #428]	; (80a0f2c <_ZN9HMIScreenC1Ev+0x398>)
 80a0d80:	2203      	movs	r2, #3
 80a0d82:	210b      	movs	r1, #11
 80a0d84:	f204 4054 	addw	r0, r4, #1108	; 0x454
 80a0d88:	f003 fdd2 	bl	80a4930 <_ZN9NexButtonC1EhhPKcPv>
 80a0d8c:	9500      	str	r5, [sp, #0]
 80a0d8e:	4b68      	ldr	r3, [pc, #416]	; (80a0f30 <_ZN9HMIScreenC1Ev+0x39c>)
 80a0d90:	2204      	movs	r2, #4
 80a0d92:	210b      	movs	r1, #11
 80a0d94:	f504 608f 	add.w	r0, r4, #1144	; 0x478
 80a0d98:	f003 fdca 	bl	80a4930 <_ZN9NexButtonC1EhhPKcPv>
 80a0d9c:	9500      	str	r5, [sp, #0]
 80a0d9e:	4b65      	ldr	r3, [pc, #404]	; (80a0f34 <_ZN9HMIScreenC1Ev+0x3a0>)
 80a0da0:	2205      	movs	r2, #5
 80a0da2:	210b      	movs	r1, #11
 80a0da4:	f204 409c 	addw	r0, r4, #1180	; 0x49c
 80a0da8:	f003 fdc2 	bl	80a4930 <_ZN9NexButtonC1EhhPKcPv>
 80a0dac:	9500      	str	r5, [sp, #0]
 80a0dae:	4b62      	ldr	r3, [pc, #392]	; (80a0f38 <_ZN9HMIScreenC1Ev+0x3a4>)
 80a0db0:	2206      	movs	r2, #6
 80a0db2:	210b      	movs	r1, #11
 80a0db4:	f504 6098 	add.w	r0, r4, #1216	; 0x4c0
 80a0db8:	f003 fdba 	bl	80a4930 <_ZN9NexButtonC1EhhPKcPv>
 80a0dbc:	9500      	str	r5, [sp, #0]
 80a0dbe:	4b5f      	ldr	r3, [pc, #380]	; (80a0f3c <_ZN9HMIScreenC1Ev+0x3a8>)
 80a0dc0:	2207      	movs	r2, #7
 80a0dc2:	210b      	movs	r1, #11
 80a0dc4:	f204 40e4 	addw	r0, r4, #1252	; 0x4e4
 80a0dc8:	f003 fdb2 	bl	80a4930 <_ZN9NexButtonC1EhhPKcPv>
 80a0dcc:	9500      	str	r5, [sp, #0]
 80a0dce:	4b5c      	ldr	r3, [pc, #368]	; (80a0f40 <_ZN9HMIScreenC1Ev+0x3ac>)
 80a0dd0:	2208      	movs	r2, #8
 80a0dd2:	210b      	movs	r1, #11
 80a0dd4:	f504 60a1 	add.w	r0, r4, #1288	; 0x508
 80a0dd8:	f003 fdaa 	bl	80a4930 <_ZN9NexButtonC1EhhPKcPv>
 80a0ddc:	9500      	str	r5, [sp, #0]
 80a0dde:	4b59      	ldr	r3, [pc, #356]	; (80a0f44 <_ZN9HMIScreenC1Ev+0x3b0>)
 80a0de0:	2201      	movs	r2, #1
 80a0de2:	210c      	movs	r1, #12
 80a0de4:	f204 502c 	addw	r0, r4, #1324	; 0x52c
 80a0de8:	f003 fda2 	bl	80a4930 <_ZN9NexButtonC1EhhPKcPv>
 80a0dec:	9500      	str	r5, [sp, #0]
 80a0dee:	4b56      	ldr	r3, [pc, #344]	; (80a0f48 <_ZN9HMIScreenC1Ev+0x3b4>)
 80a0df0:	2202      	movs	r2, #2
 80a0df2:	210c      	movs	r1, #12
 80a0df4:	f504 60aa 	add.w	r0, r4, #1360	; 0x550
 80a0df8:	f003 fd9a 	bl	80a4930 <_ZN9NexButtonC1EhhPKcPv>
 80a0dfc:	9500      	str	r5, [sp, #0]
 80a0dfe:	4b53      	ldr	r3, [pc, #332]	; (80a0f4c <_ZN9HMIScreenC1Ev+0x3b8>)
 80a0e00:	2203      	movs	r2, #3
 80a0e02:	210c      	movs	r1, #12
 80a0e04:	f204 5074 	addw	r0, r4, #1396	; 0x574
 80a0e08:	f003 fd92 	bl	80a4930 <_ZN9NexButtonC1EhhPKcPv>
 80a0e0c:	9500      	str	r5, [sp, #0]
 80a0e0e:	4b50      	ldr	r3, [pc, #320]	; (80a0f50 <_ZN9HMIScreenC1Ev+0x3bc>)
 80a0e10:	2204      	movs	r2, #4
 80a0e12:	210c      	movs	r1, #12
 80a0e14:	f504 60b3 	add.w	r0, r4, #1432	; 0x598
 80a0e18:	f003 fd8a 	bl	80a4930 <_ZN9NexButtonC1EhhPKcPv>
 80a0e1c:	4e4d      	ldr	r6, [pc, #308]	; (80a0f54 <_ZN9HMIScreenC1Ev+0x3c0>)
 80a0e1e:	9500      	str	r5, [sp, #0]
 80a0e20:	4b4d      	ldr	r3, [pc, #308]	; (80a0f58 <_ZN9HMIScreenC1Ev+0x3c4>)
 80a0e22:	2205      	movs	r2, #5
 80a0e24:	210c      	movs	r1, #12
 80a0e26:	f204 50bc 	addw	r0, r4, #1468	; 0x5bc
 80a0e2a:	f003 fd81 	bl	80a4930 <_ZN9NexButtonC1EhhPKcPv>
 80a0e2e:	9500      	str	r5, [sp, #0]
 80a0e30:	4b4a      	ldr	r3, [pc, #296]	; (80a0f5c <_ZN9HMIScreenC1Ev+0x3c8>)
 80a0e32:	2206      	movs	r2, #6
 80a0e34:	210c      	movs	r1, #12
 80a0e36:	f504 60bc 	add.w	r0, r4, #1504	; 0x5e0
 80a0e3a:	f003 fd79 	bl	80a4930 <_ZN9NexButtonC1EhhPKcPv>
 80a0e3e:	4633      	mov	r3, r6
 80a0e40:	9500      	str	r5, [sp, #0]
 80a0e42:	2207      	movs	r2, #7
 80a0e44:	210c      	movs	r1, #12
 80a0e46:	f204 6004 	addw	r0, r4, #1540	; 0x604
 80a0e4a:	f003 fdb1 	bl	80a49b0 <_ZN9NexSliderC1EhhPKcPv>
 80a0e4e:	4633      	mov	r3, r6
 80a0e50:	9500      	str	r5, [sp, #0]
 80a0e52:	2208      	movs	r2, #8
 80a0e54:	210c      	movs	r1, #12
 80a0e56:	f504 60c5 	add.w	r0, r4, #1576	; 0x628
 80a0e5a:	f003 fda9 	bl	80a49b0 <_ZN9NexSliderC1EhhPKcPv>
 80a0e5e:	4633      	mov	r3, r6
 80a0e60:	9500      	str	r5, [sp, #0]
 80a0e62:	4e3f      	ldr	r6, [pc, #252]	; (80a0f60 <_ZN9HMIScreenC1Ev+0x3cc>)
 80a0e64:	2209      	movs	r2, #9
 80a0e66:	210c      	movs	r1, #12
 80a0e68:	f204 604c 	addw	r0, r4, #1612	; 0x64c
 80a0e6c:	f003 fda0 	bl	80a49b0 <_ZN9NexSliderC1EhhPKcPv>
 80a0e70:	9500      	str	r5, [sp, #0]
 80a0e72:	4b3c      	ldr	r3, [pc, #240]	; (80a0f64 <_ZN9HMIScreenC1Ev+0x3d0>)
 80a0e74:	2201      	movs	r2, #1
 80a0e76:	210f      	movs	r1, #15
 80a0e78:	f504 60ce 	add.w	r0, r4, #1648	; 0x670
 80a0e7c:	f003 fd38 	bl	80a48f0 <_ZN8NexGaugeC1EhhPKcPv>
 80a0e80:	4633      	mov	r3, r6
 80a0e82:	9500      	str	r5, [sp, #0]
 80a0e84:	2204      	movs	r2, #4
 80a0e86:	210f      	movs	r1, #15
 80a0e88:	f204 607c 	addw	r0, r4, #1660	; 0x67c
 80a0e8c:	f003 ffda 	bl	80a4e44 <_ZN7NexTextC1EhhPKcPv>
 80a0e90:	9500      	str	r5, [sp, #0]
 80a0e92:	4b35      	ldr	r3, [pc, #212]	; (80a0f68 <_ZN9HMIScreenC1Ev+0x3d4>)
 80a0e94:	2203      	movs	r2, #3
 80a0e96:	210f      	movs	r1, #15
 80a0e98:	f504 60d4 	add.w	r0, r4, #1696	; 0x6a0
 80a0e9c:	f003 fd28 	bl	80a48f0 <_ZN8NexGaugeC1EhhPKcPv>
 80a0ea0:	4633      	mov	r3, r6
 80a0ea2:	9500      	str	r5, [sp, #0]
 80a0ea4:	2205      	movs	r2, #5
 80a0ea6:	210f      	movs	r1, #15
 80a0ea8:	f204 60ac 	addw	r0, r4, #1708	; 0x6ac
 80a0eac:	4f2f      	ldr	r7, [pc, #188]	; (80a0f6c <_ZN9HMIScreenC1Ev+0x3d8>)
 80a0eae:	f003 ffc9 	bl	80a4e44 <_ZN7NexTextC1EhhPKcPv>
 80a0eb2:	9500      	str	r5, [sp, #0]
 80a0eb4:	4b2e      	ldr	r3, [pc, #184]	; (80a0f70 <_ZN9HMIScreenC1Ev+0x3dc>)
 80a0eb6:	2202      	movs	r2, #2
 80a0eb8:	210f      	movs	r1, #15
 80a0eba:	f504 60da 	add.w	r0, r4, #1744	; 0x6d0
 80a0ebe:	f003 fd17 	bl	80a48f0 <_ZN8NexGaugeC1EhhPKcPv>
 80a0ec2:	4633      	mov	r3, r6
 80a0ec4:	9500      	str	r5, [sp, #0]
 80a0ec6:	2206      	movs	r2, #6
 80a0ec8:	210f      	movs	r1, #15
 80a0eca:	f204 60dc 	addw	r0, r4, #1756	; 0x6dc
 80a0ece:	f003 ffb9 	bl	80a4e44 <_ZN7NexTextC1EhhPKcPv>
 80a0ed2:	e051      	b.n	80a0f78 <_ZN9HMIScreenC1Ev+0x3e4>
 80a0ed4:	080a8358 	.word	0x080a8358
 80a0ed8:	080a835b 	.word	0x080a835b
 80a0edc:	080a835e 	.word	0x080a835e
 80a0ee0:	080a8369 	.word	0x080a8369
 80a0ee4:	080a8376 	.word	0x080a8376
 80a0ee8:	080a8379 	.word	0x080a8379
 80a0eec:	080a8381 	.word	0x080a8381
 80a0ef0:	080a8384 	.word	0x080a8384
 80a0ef4:	080a838a 	.word	0x080a838a
 80a0ef8:	080a83a4 	.word	0x080a83a4
 80a0efc:	080a8390 	.word	0x080a8390
 80a0f00:	080a8393 	.word	0x080a8393
 80a0f04:	080a8396 	.word	0x080a8396
 80a0f08:	080a8399 	.word	0x080a8399
 80a0f0c:	080a839c 	.word	0x080a839c
 80a0f10:	080a839f 	.word	0x080a839f
 80a0f14:	080a83a3 	.word	0x080a83a3
 80a0f18:	080a83a7 	.word	0x080a83a7
 80a0f1c:	080a83aa 	.word	0x080a83aa
 80a0f20:	080a83ae 	.word	0x080a83ae
 80a0f24:	080a83b1 	.word	0x080a83b1
 80a0f28:	080a83bc 	.word	0x080a83bc
 80a0f2c:	080a83c7 	.word	0x080a83c7
 80a0f30:	080a83d2 	.word	0x080a83d2
 80a0f34:	080a83dd 	.word	0x080a83dd
 80a0f38:	080a83e8 	.word	0x080a83e8
 80a0f3c:	080a83f3 	.word	0x080a83f3
 80a0f40:	080a83fe 	.word	0x080a83fe
 80a0f44:	080a8409 	.word	0x080a8409
 80a0f48:	080a8414 	.word	0x080a8414
 80a0f4c:	080a841f 	.word	0x080a841f
 80a0f50:	080a842a 	.word	0x080a842a
 80a0f54:	080a844b 	.word	0x080a844b
 80a0f58:	080a8435 	.word	0x080a8435
 80a0f5c:	080a8440 	.word	0x080a8440
 80a0f60:	080a845a 	.word	0x080a845a
 80a0f64:	080a8457 	.word	0x080a8457
 80a0f68:	080a845d 	.word	0x080a845d
 80a0f6c:	080a8463 	.word	0x080a8463
 80a0f70:	080a8460 	.word	0x080a8460
 80a0f74:	080a8387 	.word	0x080a8387
 80a0f78:	463b      	mov	r3, r7
 80a0f7a:	2207      	movs	r2, #7
 80a0f7c:	210f      	movs	r1, #15
 80a0f7e:	f504 60e0 	add.w	r0, r4, #1792	; 0x700
 80a0f82:	f003 fce4 	bl	80a494e <_ZN9NexNumberC1EhhPKc>
 80a0f86:	4633      	mov	r3, r6
 80a0f88:	9500      	str	r5, [sp, #0]
 80a0f8a:	2208      	movs	r2, #8
 80a0f8c:	210f      	movs	r1, #15
 80a0f8e:	f204 7024 	addw	r0, r4, #1828	; 0x724
 80a0f92:	f003 ff57 	bl	80a4e44 <_ZN7NexTextC1EhhPKcPv>
 80a0f96:	4b67      	ldr	r3, [pc, #412]	; (80a1134 <_ZN9HMIScreenC1Ev+0x5a0>)
 80a0f98:	2209      	movs	r2, #9
 80a0f9a:	210f      	movs	r1, #15
 80a0f9c:	f504 60e9 	add.w	r0, r4, #1864	; 0x748
 80a0fa0:	f003 fcd5 	bl	80a494e <_ZN9NexNumberC1EhhPKc>
 80a0fa4:	4633      	mov	r3, r6
 80a0fa6:	9500      	str	r5, [sp, #0]
 80a0fa8:	220a      	movs	r2, #10
 80a0faa:	210f      	movs	r1, #15
 80a0fac:	f204 706c 	addw	r0, r4, #1900	; 0x76c
 80a0fb0:	f003 ff48 	bl	80a4e44 <_ZN7NexTextC1EhhPKcPv>
 80a0fb4:	4b60      	ldr	r3, [pc, #384]	; (80a1138 <_ZN9HMIScreenC1Ev+0x5a4>)
 80a0fb6:	220b      	movs	r2, #11
 80a0fb8:	210f      	movs	r1, #15
 80a0fba:	f504 60f2 	add.w	r0, r4, #1936	; 0x790
 80a0fbe:	f003 fcc6 	bl	80a494e <_ZN9NexNumberC1EhhPKc>
 80a0fc2:	4633      	mov	r3, r6
 80a0fc4:	9500      	str	r5, [sp, #0]
 80a0fc6:	220c      	movs	r2, #12
 80a0fc8:	210f      	movs	r1, #15
 80a0fca:	f204 70b4 	addw	r0, r4, #1972	; 0x7b4
 80a0fce:	f003 ff39 	bl	80a4e44 <_ZN7NexTextC1EhhPKcPv>
 80a0fd2:	463b      	mov	r3, r7
 80a0fd4:	220b      	movs	r2, #11
 80a0fd6:	2110      	movs	r1, #16
 80a0fd8:	f504 60fb 	add.w	r0, r4, #2008	; 0x7d8
 80a0fdc:	f003 fcb7 	bl	80a494e <_ZN9NexNumberC1EhhPKc>
 80a0fe0:	4633      	mov	r3, r6
 80a0fe2:	9500      	str	r5, [sp, #0]
 80a0fe4:	220c      	movs	r2, #12
 80a0fe6:	2110      	movs	r1, #16
 80a0fe8:	f204 70fc 	addw	r0, r4, #2044	; 0x7fc
 80a0fec:	f003 ff2a 	bl	80a4e44 <_ZN7NexTextC1EhhPKcPv>
 80a0ff0:	463b      	mov	r3, r7
 80a0ff2:	220d      	movs	r2, #13
 80a0ff4:	2110      	movs	r1, #16
 80a0ff6:	f504 6002 	add.w	r0, r4, #2080	; 0x820
 80a0ffa:	f003 fca8 	bl	80a494e <_ZN9NexNumberC1EhhPKc>
 80a0ffe:	4633      	mov	r3, r6
 80a1000:	9500      	str	r5, [sp, #0]
 80a1002:	220e      	movs	r2, #14
 80a1004:	2110      	movs	r1, #16
 80a1006:	f604 0044 	addw	r0, r4, #2116	; 0x844
 80a100a:	f003 ff1b 	bl	80a4e44 <_ZN7NexTextC1EhhPKcPv>
 80a100e:	463b      	mov	r3, r7
 80a1010:	220f      	movs	r2, #15
 80a1012:	2110      	movs	r1, #16
 80a1014:	f604 0068 	addw	r0, r4, #2152	; 0x868
 80a1018:	f003 fc99 	bl	80a494e <_ZN9NexNumberC1EhhPKc>
 80a101c:	2210      	movs	r2, #16
 80a101e:	4633      	mov	r3, r6
 80a1020:	4611      	mov	r1, r2
 80a1022:	9500      	str	r5, [sp, #0]
 80a1024:	f604 008c 	addw	r0, r4, #2188	; 0x88c
 80a1028:	f003 ff0c 	bl	80a4e44 <_ZN7NexTextC1EhhPKcPv>
 80a102c:	463b      	mov	r3, r7
 80a102e:	2211      	movs	r2, #17
 80a1030:	2110      	movs	r1, #16
 80a1032:	f504 600b 	add.w	r0, r4, #2224	; 0x8b0
 80a1036:	f003 fc8a 	bl	80a494e <_ZN9NexNumberC1EhhPKc>
 80a103a:	4633      	mov	r3, r6
 80a103c:	9500      	str	r5, [sp, #0]
 80a103e:	2212      	movs	r2, #18
 80a1040:	2110      	movs	r1, #16
 80a1042:	f604 00d4 	addw	r0, r4, #2260	; 0x8d4
 80a1046:	f003 fefd 	bl	80a4e44 <_ZN7NexTextC1EhhPKcPv>
 80a104a:	463b      	mov	r3, r7
 80a104c:	2213      	movs	r2, #19
 80a104e:	2110      	movs	r1, #16
 80a1050:	f604 00f8 	addw	r0, r4, #2296	; 0x8f8
 80a1054:	f003 fc7b 	bl	80a494e <_ZN9NexNumberC1EhhPKc>
 80a1058:	4633      	mov	r3, r6
 80a105a:	9500      	str	r5, [sp, #0]
 80a105c:	2214      	movs	r2, #20
 80a105e:	2110      	movs	r1, #16
 80a1060:	f604 101c 	addw	r0, r4, #2332	; 0x91c
 80a1064:	f003 feee 	bl	80a4e44 <_ZN7NexTextC1EhhPKcPv>
 80a1068:	463b      	mov	r3, r7
 80a106a:	2215      	movs	r2, #21
 80a106c:	2110      	movs	r1, #16
 80a106e:	f504 6014 	add.w	r0, r4, #2368	; 0x940
 80a1072:	f003 fc6c 	bl	80a494e <_ZN9NexNumberC1EhhPKc>
 80a1076:	4633      	mov	r3, r6
 80a1078:	9500      	str	r5, [sp, #0]
 80a107a:	2216      	movs	r2, #22
 80a107c:	2110      	movs	r1, #16
 80a107e:	f604 1064 	addw	r0, r4, #2404	; 0x964
 80a1082:	f003 fedf 	bl	80a4e44 <_ZN7NexTextC1EhhPKcPv>
 80a1086:	463b      	mov	r3, r7
 80a1088:	2201      	movs	r2, #1
 80a108a:	2110      	movs	r1, #16
 80a108c:	f604 1088 	addw	r0, r4, #2440	; 0x988
 80a1090:	f003 fc5d 	bl	80a494e <_ZN9NexNumberC1EhhPKc>
 80a1094:	4633      	mov	r3, r6
 80a1096:	9500      	str	r5, [sp, #0]
 80a1098:	2202      	movs	r2, #2
 80a109a:	2110      	movs	r1, #16
 80a109c:	f604 10ac 	addw	r0, r4, #2476	; 0x9ac
 80a10a0:	f003 fed0 	bl	80a4e44 <_ZN7NexTextC1EhhPKcPv>
 80a10a4:	463b      	mov	r3, r7
 80a10a6:	2203      	movs	r2, #3
 80a10a8:	2110      	movs	r1, #16
 80a10aa:	f504 601d 	add.w	r0, r4, #2512	; 0x9d0
 80a10ae:	f003 fc4e 	bl	80a494e <_ZN9NexNumberC1EhhPKc>
 80a10b2:	4633      	mov	r3, r6
 80a10b4:	9500      	str	r5, [sp, #0]
 80a10b6:	2204      	movs	r2, #4
 80a10b8:	2110      	movs	r1, #16
 80a10ba:	f604 10f4 	addw	r0, r4, #2548	; 0x9f4
 80a10be:	f003 fec1 	bl	80a4e44 <_ZN7NexTextC1EhhPKcPv>
 80a10c2:	463b      	mov	r3, r7
 80a10c4:	2205      	movs	r2, #5
 80a10c6:	2110      	movs	r1, #16
 80a10c8:	f604 2018 	addw	r0, r4, #2584	; 0xa18
 80a10cc:	f003 fc3f 	bl	80a494e <_ZN9NexNumberC1EhhPKc>
 80a10d0:	4633      	mov	r3, r6
 80a10d2:	9500      	str	r5, [sp, #0]
 80a10d4:	2206      	movs	r2, #6
 80a10d6:	2110      	movs	r1, #16
 80a10d8:	f604 203c 	addw	r0, r4, #2620	; 0xa3c
 80a10dc:	f003 feb2 	bl	80a4e44 <_ZN7NexTextC1EhhPKcPv>
 80a10e0:	4620      	mov	r0, r4
 80a10e2:	9b06      	ldr	r3, [sp, #24]
 80a10e4:	f8c4 ba70 	str.w	fp, [r4, #2672]	; 0xa70
 80a10e8:	f8c4 3a60 	str.w	r3, [r4, #2656]	; 0xa60
 80a10ec:	9b07      	ldr	r3, [sp, #28]
 80a10ee:	f8c4 aa74 	str.w	sl, [r4, #2676]	; 0xa74
 80a10f2:	f8c4 3a64 	str.w	r3, [r4, #2660]	; 0xa64
 80a10f6:	9b08      	ldr	r3, [sp, #32]
 80a10f8:	f8c4 9a78 	str.w	r9, [r4, #2680]	; 0xa78
 80a10fc:	f8c4 3a68 	str.w	r3, [r4, #2664]	; 0xa68
 80a1100:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80a1102:	f8c4 8a90 	str.w	r8, [r4, #2704]	; 0xa90
 80a1106:	f8c4 3a6c 	str.w	r3, [r4, #2668]	; 0xa6c
 80a110a:	9b05      	ldr	r3, [sp, #20]
 80a110c:	f8c4 5a94 	str.w	r5, [r4, #2708]	; 0xa94
 80a1110:	f8c4 3a7c 	str.w	r3, [r4, #2684]	; 0xa7c
 80a1114:	1d23      	adds	r3, r4, #4
 80a1116:	f8c4 3a80 	str.w	r3, [r4, #2688]	; 0xa80
 80a111a:	9b02      	ldr	r3, [sp, #8]
 80a111c:	f8c4 3a84 	str.w	r3, [r4, #2692]	; 0xa84
 80a1120:	9b03      	ldr	r3, [sp, #12]
 80a1122:	f8c4 3a88 	str.w	r3, [r4, #2696]	; 0xa88
 80a1126:	9b04      	ldr	r3, [sp, #16]
 80a1128:	f8c4 3a8c 	str.w	r3, [r4, #2700]	; 0xa8c
 80a112c:	b00b      	add	sp, #44	; 0x2c
 80a112e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a1132:	bf00      	nop
 80a1134:	080a8466 	.word	0x080a8466
 80a1138:	080a8469 	.word	0x080a8469

080a113c <_Z4lockv>:
        else
            unlock();
    }
}

void lock(void){
 80a113c:	b508      	push	{r3, lr}
    // Disable the lights and turn off un needed peripherals 
    lampLight.setLED(false);
 80a113e:	2100      	movs	r1, #0
 80a1140:	4807      	ldr	r0, [pc, #28]	; (80a1160 <_Z4lockv+0x24>)
 80a1142:	f7ff f86d 	bl	80a0220 <_ZN8LEDRelay6setLEDEb>
    notifLight.setStrip(240, 0, 0);
 80a1146:	2300      	movs	r3, #0
 80a1148:	461a      	mov	r2, r3
 80a114a:	21f0      	movs	r1, #240	; 0xf0
 80a114c:	4805      	ldr	r0, [pc, #20]	; (80a1164 <_Z4lockv+0x28>)
 80a114e:	f7fe ffe4 	bl	80a011a <_ZN17notificationLight8setStripEhhh>
    hmiScreen.lock();
 80a1152:	4805      	ldr	r0, [pc, #20]	; (80a1168 <_Z4lockv+0x2c>)
 80a1154:	f7ff f97c 	bl	80a0450 <_ZN9HMIScreen4lockEv>
    lockStatus.system_locked = true; 
 80a1158:	4b04      	ldr	r3, [pc, #16]	; (80a116c <_Z4lockv+0x30>)
 80a115a:	2201      	movs	r2, #1
 80a115c:	701a      	strb	r2, [r3, #0]
 80a115e:	bd08      	pop	{r3, pc}
 80a1160:	20000feb 	.word	0x20000feb
 80a1164:	20000474 	.word	0x20000474
 80a1168:	20000540 	.word	0x20000540
 80a116c:	20000fea 	.word	0x20000fea

080a1170 <_Z6unlockv>:
}

void unlock(void){
 80a1170:	b510      	push	{r4, lr}
    // Turn back on the notification lights!
    notifLight.wakeLEDS();
    hmiScreen.wake();
 80a1172:	4c07      	ldr	r4, [pc, #28]	; (80a1190 <_Z6unlockv+0x20>)
    lockStatus.system_locked = true; 
}

void unlock(void){
    // Turn back on the notification lights!
    notifLight.wakeLEDS();
 80a1174:	4807      	ldr	r0, [pc, #28]	; (80a1194 <_Z6unlockv+0x24>)
 80a1176:	f7fe fff5 	bl	80a0164 <_ZN17notificationLight8wakeLEDSEv>
    hmiScreen.wake();
 80a117a:	4620      	mov	r0, r4
 80a117c:	f7ff f948 	bl	80a0410 <_ZN9HMIScreen4wakeEv>
    hmiScreen.home();
 80a1180:	4620      	mov	r0, r4
 80a1182:	f7ff f93f 	bl	80a0404 <_ZN9HMIScreen4homeEv>
    lockStatus.system_locked = false;
 80a1186:	4b04      	ldr	r3, [pc, #16]	; (80a1198 <_Z6unlockv+0x28>)
 80a1188:	2200      	movs	r2, #0
 80a118a:	701a      	strb	r2, [r3, #0]
 80a118c:	bd10      	pop	{r4, pc}
 80a118e:	bf00      	nop
 80a1190:	20000540 	.word	0x20000540
 80a1194:	20000474 	.word	0x20000474
 80a1198:	20000fea 	.word	0x20000fea

080a119c <_Z11ms_100_taskv>:

// GLOBAL VARIABLES END // 

// TIMERS FUNCTIONS BEGIN // 

void ms_100_task(void){
 80a119c:	b513      	push	{r0, r1, r4, lr}
    if(sleepMode.sleep_mode_enabled == false && lockStatus.system_locked == false)
 80a119e:	4b3e      	ldr	r3, [pc, #248]	; (80a1298 <_Z11ms_100_taskv+0xfc>)
 80a11a0:	781b      	ldrb	r3, [r3, #0]
 80a11a2:	b913      	cbnz	r3, 80a11aa <_Z11ms_100_taskv+0xe>
 80a11a4:	4b3d      	ldr	r3, [pc, #244]	; (80a129c <_Z11ms_100_taskv+0x100>)
 80a11a6:	781b      	ldrb	r3, [r3, #0]
 80a11a8:	b393      	cbz	r3, 80a1210 <_Z11ms_100_taskv+0x74>
        notifLight.playWithLEDS();
        
    // Checking if UDP messages arrived, parse out and chk commands. 
    if (Udp.parsePacket() > 0) {
 80a11aa:	483d      	ldr	r0, [pc, #244]	; (80a12a0 <_Z11ms_100_taskv+0x104>)
 80a11ac:	f004 ff92 	bl	80a60d4 <_ZN3UDP11parsePacketEv>
 80a11b0:	2800      	cmp	r0, #0
 80a11b2:	dd6f      	ble.n	80a1294 <_Z11ms_100_taskv+0xf8>
 80a11b4:	2400      	movs	r4, #0
        uint8_t msg[4]; 
        for(uint8_t i = 0; i < 4; i++)
            msg[i] = Udp.read();
 80a11b6:	483a      	ldr	r0, [pc, #232]	; (80a12a0 <_Z11ms_100_taskv+0x104>)
 80a11b8:	f004 fdba 	bl	80a5d30 <_ZN3UDP4readEv>
 80a11bc:	ab01      	add	r3, sp, #4
 80a11be:	5518      	strb	r0, [r3, r4]
 80a11c0:	3401      	adds	r4, #1
        notifLight.playWithLEDS();
        
    // Checking if UDP messages arrived, parse out and chk commands. 
    if (Udp.parsePacket() > 0) {
        uint8_t msg[4]; 
        for(uint8_t i = 0; i < 4; i++)
 80a11c2:	2c04      	cmp	r4, #4
 80a11c4:	d1f7      	bne.n	80a11b6 <_Z11ms_100_taskv+0x1a>
            msg[i] = Udp.read();
        
        if(msg[0] == 20 && msg[1] == 20 && msg[2] == 30 && msg[3] == 90){
 80a11c6:	f89d 3004 	ldrb.w	r3, [sp, #4]
 80a11ca:	2b14      	cmp	r3, #20
 80a11cc:	d10e      	bne.n	80a11ec <_Z11ms_100_taskv+0x50>
 80a11ce:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a11d2:	2b14      	cmp	r3, #20
 80a11d4:	d15e      	bne.n	80a1294 <_Z11ms_100_taskv+0xf8>
 80a11d6:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a11da:	2b1e      	cmp	r3, #30
 80a11dc:	d132      	bne.n	80a1244 <_Z11ms_100_taskv+0xa8>
 80a11de:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80a11e2:	2b5a      	cmp	r3, #90	; 0x5a
 80a11e4:	d12e      	bne.n	80a1244 <_Z11ms_100_taskv+0xa8>
            lock();
 80a11e6:	f7ff ffa9 	bl	80a113c <_Z4lockv>
 80a11ea:	e02b      	b.n	80a1244 <_Z11ms_100_taskv+0xa8>
        }
        if(msg[0] == 20 && msg[1] == 20 && msg[2] == 30 && msg[3] == 91){
            unlock();
        }
        if(msg[0] == 50 && msg[1] == 50 && msg[2] == 30 && msg[3] == 92){
 80a11ec:	2b32      	cmp	r3, #50	; 0x32
 80a11ee:	d113      	bne.n	80a1218 <_Z11ms_100_taskv+0x7c>
 80a11f0:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a11f4:	2b32      	cmp	r3, #50	; 0x32
 80a11f6:	d14d      	bne.n	80a1294 <_Z11ms_100_taskv+0xf8>
 80a11f8:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a11fc:	2b1e      	cmp	r3, #30
 80a11fe:	d12e      	bne.n	80a125e <_Z11ms_100_taskv+0xc2>
 80a1200:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80a1204:	2b5c      	cmp	r3, #92	; 0x5c
 80a1206:	d12a      	bne.n	80a125e <_Z11ms_100_taskv+0xc2>
            lampLight.toggle();
 80a1208:	4826      	ldr	r0, [pc, #152]	; (80a12a4 <_Z11ms_100_taskv+0x108>)
 80a120a:	f7ff f802 	bl	80a0212 <_ZN8LEDRelay6toggleEv>
 80a120e:	e026      	b.n	80a125e <_Z11ms_100_taskv+0xc2>

// TIMERS FUNCTIONS BEGIN // 

void ms_100_task(void){
    if(sleepMode.sleep_mode_enabled == false && lockStatus.system_locked == false)
        notifLight.playWithLEDS();
 80a1210:	4825      	ldr	r0, [pc, #148]	; (80a12a8 <_Z11ms_100_taskv+0x10c>)
 80a1212:	f7fe ffb1 	bl	80a0178 <_ZN17notificationLight12playWithLEDSEv>
 80a1216:	e7c8      	b.n	80a11aa <_Z11ms_100_taskv+0xe>
            lampLight.setLED(true);
        }
        if(msg[0] == 50 && msg[1] == 50 && msg[2] == 30 && msg[3] == 90){
            lampLight.setLED(false);
        }
        if(msg[0] == 12 && msg[1] == 12 && msg[2] == 12 && msg[3] == 12){
 80a1218:	2b0c      	cmp	r3, #12
 80a121a:	d13b      	bne.n	80a1294 <_Z11ms_100_taskv+0xf8>
 80a121c:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a1220:	2b0c      	cmp	r3, #12
 80a1222:	d137      	bne.n	80a1294 <_Z11ms_100_taskv+0xf8>
 80a1224:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a1228:	2b0c      	cmp	r3, #12
 80a122a:	d133      	bne.n	80a1294 <_Z11ms_100_taskv+0xf8>
 80a122c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80a1230:	2b0c      	cmp	r3, #12
 80a1232:	d12f      	bne.n	80a1294 <_Z11ms_100_taskv+0xf8>
            alarm.beepOnce(300);
 80a1234:	481d      	ldr	r0, [pc, #116]	; (80a12ac <_Z11ms_100_taskv+0x110>)
 80a1236:	f44f 7196 	mov.w	r1, #300	; 0x12c
        }
    }
}
 80a123a:	b002      	add	sp, #8
 80a123c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        }
        if(msg[0] == 50 && msg[1] == 50 && msg[2] == 30 && msg[3] == 90){
            lampLight.setLED(false);
        }
        if(msg[0] == 12 && msg[1] == 12 && msg[2] == 12 && msg[3] == 12){
            alarm.beepOnce(300);
 80a1240:	f7ff b921 	b.w	80a0486 <_ZN10alarmRelay8beepOnceEi>
            msg[i] = Udp.read();
        
        if(msg[0] == 20 && msg[1] == 20 && msg[2] == 30 && msg[3] == 90){
            lock();
        }
        if(msg[0] == 20 && msg[1] == 20 && msg[2] == 30 && msg[3] == 91){
 80a1244:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a1248:	2b1e      	cmp	r3, #30
 80a124a:	d123      	bne.n	80a1294 <_Z11ms_100_taskv+0xf8>
 80a124c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80a1250:	2b5b      	cmp	r3, #91	; 0x5b
 80a1252:	d11f      	bne.n	80a1294 <_Z11ms_100_taskv+0xf8>
        }
        if(msg[0] == 12 && msg[1] == 12 && msg[2] == 12 && msg[3] == 12){
            alarm.beepOnce(300);
        }
    }
}
 80a1254:	b002      	add	sp, #8
 80a1256:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        
        if(msg[0] == 20 && msg[1] == 20 && msg[2] == 30 && msg[3] == 90){
            lock();
        }
        if(msg[0] == 20 && msg[1] == 20 && msg[2] == 30 && msg[3] == 91){
            unlock();
 80a125a:	f7ff bf89 	b.w	80a1170 <_Z6unlockv>
        }
        if(msg[0] == 50 && msg[1] == 50 && msg[2] == 30 && msg[3] == 92){
            lampLight.toggle();
        }
        if(msg[0] == 50 && msg[1] == 50 && msg[2] == 30 && msg[3] == 91){
 80a125e:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a1262:	2b1e      	cmp	r3, #30
 80a1264:	d107      	bne.n	80a1276 <_Z11ms_100_taskv+0xda>
 80a1266:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80a126a:	2b5b      	cmp	r3, #91	; 0x5b
 80a126c:	d103      	bne.n	80a1276 <_Z11ms_100_taskv+0xda>
            lampLight.setLED(true);
 80a126e:	2101      	movs	r1, #1
 80a1270:	480c      	ldr	r0, [pc, #48]	; (80a12a4 <_Z11ms_100_taskv+0x108>)
 80a1272:	f7fe ffd5 	bl	80a0220 <_ZN8LEDRelay6setLEDEb>
        }
        if(msg[0] == 50 && msg[1] == 50 && msg[2] == 30 && msg[3] == 90){
 80a1276:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a127a:	2b1e      	cmp	r3, #30
 80a127c:	d10a      	bne.n	80a1294 <_Z11ms_100_taskv+0xf8>
 80a127e:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80a1282:	2b5a      	cmp	r3, #90	; 0x5a
 80a1284:	d106      	bne.n	80a1294 <_Z11ms_100_taskv+0xf8>
            lampLight.setLED(false);
 80a1286:	4807      	ldr	r0, [pc, #28]	; (80a12a4 <_Z11ms_100_taskv+0x108>)
 80a1288:	2100      	movs	r1, #0
        }
        if(msg[0] == 12 && msg[1] == 12 && msg[2] == 12 && msg[3] == 12){
            alarm.beepOnce(300);
        }
    }
}
 80a128a:	b002      	add	sp, #8
 80a128c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        }
        if(msg[0] == 50 && msg[1] == 50 && msg[2] == 30 && msg[3] == 91){
            lampLight.setLED(true);
        }
        if(msg[0] == 50 && msg[1] == 50 && msg[2] == 30 && msg[3] == 90){
            lampLight.setLED(false);
 80a1290:	f7fe bfc6 	b.w	80a0220 <_ZN8LEDRelay6setLEDEb>
        }
        if(msg[0] == 12 && msg[1] == 12 && msg[2] == 12 && msg[3] == 12){
            alarm.beepOnce(300);
        }
    }
}
 80a1294:	b002      	add	sp, #8
 80a1296:	bd10      	pop	{r4, pc}
 80a1298:	20001020 	.word	0x20001020
 80a129c:	20000fea 	.word	0x20000fea
 80a12a0:	200004bc 	.word	0x200004bc
 80a12a4:	20000feb 	.word	0x20000feb
 80a12a8:	20000474 	.word	0x20000474
 80a12ac:	200003c4 	.word	0x200003c4

080a12b0 <_Z11ms_300_taskv>:

void ms_300_task(void){
 80a12b0:	b508      	push	{r3, lr}
    // Allows us to change the lock status. if we get a match, we can lock and unlock the system. 
    if(cardReader.readCardID()){
 80a12b2:	480a      	ldr	r0, [pc, #40]	; (80a12dc <_Z11ms_300_taskv+0x2c>)
 80a12b4:	f7ff f854 	bl	80a0360 <_ZN10rfidReader10readCardIDEv>
 80a12b8:	b170      	cbz	r0, 80a12d8 <_Z11ms_300_taskv+0x28>
        lockStatus.system_locked = !lockStatus.system_locked; 
 80a12ba:	4b09      	ldr	r3, [pc, #36]	; (80a12e0 <_Z11ms_300_taskv+0x30>)
 80a12bc:	781a      	ldrb	r2, [r3, #0]
 80a12be:	f082 0201 	eor.w	r2, r2, #1
 80a12c2:	701a      	strb	r2, [r3, #0]
        
        // Once the system lock, we need to update the status' and disable the sensors and peripherals
        if(lockStatus.system_locked)
 80a12c4:	781b      	ldrb	r3, [r3, #0]
 80a12c6:	b11b      	cbz	r3, 80a12d0 <_Z11ms_300_taskv+0x20>
            lock();
        // Vice versa for the unlocking the system. 
        else
            unlock();
    }
}
 80a12c8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    if(cardReader.readCardID()){
        lockStatus.system_locked = !lockStatus.system_locked; 
        
        // Once the system lock, we need to update the status' and disable the sensors and peripherals
        if(lockStatus.system_locked)
            lock();
 80a12cc:	f7ff bf36 	b.w	80a113c <_Z4lockv>
        // Vice versa for the unlocking the system. 
        else
            unlock();
    }
}
 80a12d0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        // Once the system lock, we need to update the status' and disable the sensors and peripherals
        if(lockStatus.system_locked)
            lock();
        // Vice versa for the unlocking the system. 
        else
            unlock();
 80a12d4:	f7ff bf4c 	b.w	80a1170 <_Z6unlockv>
 80a12d8:	bd08      	pop	{r3, pc}
 80a12da:	bf00      	nop
 80a12dc:	20000fd8 	.word	0x20000fd8
 80a12e0:	20000fea 	.word	0x20000fea

080a12e4 <_Z16particleCommandsPKcS0_>:
description: allows you to send some commands to the particle cloud!!!!
parameters: none
returns: none
*/
    
void particleCommands(const char *event, const char *data){
 80a12e4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    String buffer = data; 
 80a12e6:	4668      	mov	r0, sp
 80a12e8:	f004 faf5 	bl	80a58d6 <_ZN6StringC1EPK19__FlashStringHelper>
    if(buffer.equals("notifoff")){
 80a12ec:	4936      	ldr	r1, [pc, #216]	; (80a13c8 <_Z16particleCommandsPKcS0_+0xe4>)
 80a12ee:	4668      	mov	r0, sp
 80a12f0:	f004 fb1e 	bl	80a5930 <_ZNK6String6equalsEPKc>
 80a12f4:	b110      	cbz	r0, 80a12fc <_Z16particleCommandsPKcS0_+0x18>
        notifications.enabled = false; 
 80a12f6:	4b35      	ldr	r3, [pc, #212]	; (80a13cc <_Z16particleCommandsPKcS0_+0xe8>)
 80a12f8:	2200      	movs	r2, #0
 80a12fa:	701a      	strb	r2, [r3, #0]
    }
    if(buffer.equals("notifon")){
 80a12fc:	4934      	ldr	r1, [pc, #208]	; (80a13d0 <_Z16particleCommandsPKcS0_+0xec>)
 80a12fe:	4668      	mov	r0, sp
 80a1300:	f004 fb16 	bl	80a5930 <_ZNK6String6equalsEPKc>
 80a1304:	b110      	cbz	r0, 80a130c <_Z16particleCommandsPKcS0_+0x28>
        notifications.enabled = true;
 80a1306:	4b31      	ldr	r3, [pc, #196]	; (80a13cc <_Z16particleCommandsPKcS0_+0xe8>)
 80a1308:	2201      	movs	r2, #1
 80a130a:	701a      	strb	r2, [r3, #0]
    }
    if(buffer.equals("picoff")){
 80a130c:	4931      	ldr	r1, [pc, #196]	; (80a13d4 <_Z16particleCommandsPKcS0_+0xf0>)
 80a130e:	4668      	mov	r0, sp
 80a1310:	f004 fb0e 	bl	80a5930 <_ZNK6String6equalsEPKc>
        
    }
    if(buffer.equals("picon")){
 80a1314:	4930      	ldr	r1, [pc, #192]	; (80a13d8 <_Z16particleCommandsPKcS0_+0xf4>)
 80a1316:	4668      	mov	r0, sp
 80a1318:	f004 fb0a 	bl	80a5930 <_ZNK6String6equalsEPKc>
       
    }
    if(buffer.equals("beep")){
 80a131c:	492f      	ldr	r1, [pc, #188]	; (80a13dc <_Z16particleCommandsPKcS0_+0xf8>)
 80a131e:	4668      	mov	r0, sp
 80a1320:	f004 fb06 	bl	80a5930 <_ZNK6String6equalsEPKc>
 80a1324:	b118      	cbz	r0, 80a132e <_Z16particleCommandsPKcS0_+0x4a>
        alarm.beepOnce(200);
 80a1326:	21c8      	movs	r1, #200	; 0xc8
 80a1328:	482d      	ldr	r0, [pc, #180]	; (80a13e0 <_Z16particleCommandsPKcS0_+0xfc>)
 80a132a:	f7ff f8ac 	bl	80a0486 <_ZN10alarmRelay8beepOnceEi>
    }
    if(buffer.equals("toggleLED")){
 80a132e:	492d      	ldr	r1, [pc, #180]	; (80a13e4 <_Z16particleCommandsPKcS0_+0x100>)
 80a1330:	4668      	mov	r0, sp
 80a1332:	f004 fafd 	bl	80a5930 <_ZNK6String6equalsEPKc>
 80a1336:	b110      	cbz	r0, 80a133e <_Z16particleCommandsPKcS0_+0x5a>
        lampLight.toggle();
 80a1338:	482b      	ldr	r0, [pc, #172]	; (80a13e8 <_Z16particleCommandsPKcS0_+0x104>)
 80a133a:	f7fe ff6a 	bl	80a0212 <_ZN8LEDRelay6toggleEv>
    }
    if(buffer.equals("reboot")){
 80a133e:	492b      	ldr	r1, [pc, #172]	; (80a13ec <_Z16particleCommandsPKcS0_+0x108>)
 80a1340:	4668      	mov	r0, sp
 80a1342:	f004 faf5 	bl	80a5930 <_ZNK6String6equalsEPKc>
 80a1346:	b108      	cbz	r0, 80a134c <_Z16particleCommandsPKcS0_+0x68>
       System.reset();
 80a1348:	f004 fa1c 	bl	80a5784 <_ZN11SystemClass5resetEv>
    }
    if(buffer.equals("sleep")){
 80a134c:	4928      	ldr	r1, [pc, #160]	; (80a13f0 <_Z16particleCommandsPKcS0_+0x10c>)
 80a134e:	4668      	mov	r0, sp
 80a1350:	f004 faee 	bl	80a5930 <_ZNK6String6equalsEPKc>
 80a1354:	b190      	cbz	r0, 80a137c <_Z16particleCommandsPKcS0_+0x98>
        sleepMode.sleep_mode_enabled = true; 
 80a1356:	4b27      	ldr	r3, [pc, #156]	; (80a13f4 <_Z16particleCommandsPKcS0_+0x110>)
 80a1358:	2201      	movs	r2, #1
        hmiScreen.sleep();
 80a135a:	4827      	ldr	r0, [pc, #156]	; (80a13f8 <_Z16particleCommandsPKcS0_+0x114>)
    }
    if(buffer.equals("reboot")){
       System.reset();
    }
    if(buffer.equals("sleep")){
        sleepMode.sleep_mode_enabled = true; 
 80a135c:	701a      	strb	r2, [r3, #0]
        hmiScreen.sleep();
 80a135e:	f7ff f865 	bl	80a042c <_ZN9HMIScreen5sleepEv>
        notifLight.setStrip(0, 0, 0);
 80a1362:	2300      	movs	r3, #0
 80a1364:	4619      	mov	r1, r3
 80a1366:	461a      	mov	r2, r3
 80a1368:	4824      	ldr	r0, [pc, #144]	; (80a13fc <_Z16particleCommandsPKcS0_+0x118>)
 80a136a:	f7fe fed6 	bl	80a011a <_ZN17notificationLight8setStripEhhh>
        lampLight.setLED(false);
 80a136e:	481e      	ldr	r0, [pc, #120]	; (80a13e8 <_Z16particleCommandsPKcS0_+0x104>)
 80a1370:	2100      	movs	r1, #0
 80a1372:	f7fe ff55 	bl	80a0220 <_ZN8LEDRelay6setLEDEb>
        clock_control.sleep();
 80a1376:	4822      	ldr	r0, [pc, #136]	; (80a1400 <_Z16particleCommandsPKcS0_+0x11c>)
 80a1378:	f7fe ff78 	bl	80a026c <_ZN12ClockControl5sleepEv>
    }
    if(buffer.equals("wake")){
 80a137c:	4921      	ldr	r1, [pc, #132]	; (80a1404 <_Z16particleCommandsPKcS0_+0x120>)
 80a137e:	4668      	mov	r0, sp
 80a1380:	f004 fad6 	bl	80a5930 <_ZNK6String6equalsEPKc>
 80a1384:	b158      	cbz	r0, 80a139e <_Z16particleCommandsPKcS0_+0xba>
        sleepMode.sleep_mode_enabled = false; 
 80a1386:	4b1b      	ldr	r3, [pc, #108]	; (80a13f4 <_Z16particleCommandsPKcS0_+0x110>)
 80a1388:	2200      	movs	r2, #0
        hmiScreen.home();
 80a138a:	481b      	ldr	r0, [pc, #108]	; (80a13f8 <_Z16particleCommandsPKcS0_+0x114>)
        notifLight.setStrip(0, 0, 0);
        lampLight.setLED(false);
        clock_control.sleep();
    }
    if(buffer.equals("wake")){
        sleepMode.sleep_mode_enabled = false; 
 80a138c:	701a      	strb	r2, [r3, #0]
        hmiScreen.home();
 80a138e:	f7ff f839 	bl	80a0404 <_ZN9HMIScreen4homeEv>
        hmiScreen.wake();
 80a1392:	4819      	ldr	r0, [pc, #100]	; (80a13f8 <_Z16particleCommandsPKcS0_+0x114>)
 80a1394:	f7ff f83c 	bl	80a0410 <_ZN9HMIScreen4wakeEv>
        clock_control.wake();
 80a1398:	4819      	ldr	r0, [pc, #100]	; (80a1400 <_Z16particleCommandsPKcS0_+0x11c>)
 80a139a:	f7fe ff49 	bl	80a0230 <_ZN12ClockControl4wakeEv>
    }
    if(buffer.equals("lock")){
 80a139e:	491a      	ldr	r1, [pc, #104]	; (80a1408 <_Z16particleCommandsPKcS0_+0x124>)
 80a13a0:	4668      	mov	r0, sp
 80a13a2:	f004 fac5 	bl	80a5930 <_ZNK6String6equalsEPKc>
 80a13a6:	b108      	cbz	r0, 80a13ac <_Z16particleCommandsPKcS0_+0xc8>
        lock();
 80a13a8:	f7ff fec8 	bl	80a113c <_Z4lockv>
    }
    if(buffer.equals("unlock")){
 80a13ac:	4917      	ldr	r1, [pc, #92]	; (80a140c <_Z16particleCommandsPKcS0_+0x128>)
 80a13ae:	4668      	mov	r0, sp
 80a13b0:	f004 fabe 	bl	80a5930 <_ZNK6String6equalsEPKc>
 80a13b4:	b108      	cbz	r0, 80a13ba <_Z16particleCommandsPKcS0_+0xd6>
        unlock();
 80a13b6:	f7ff fedb 	bl	80a1170 <_Z6unlockv>
parameters: none
returns: none
*/
    
void particleCommands(const char *event, const char *data){
    String buffer = data; 
 80a13ba:	4668      	mov	r0, sp
 80a13bc:	f004 fa44 	bl	80a5848 <_ZN6StringD1Ev>
    }
    if(buffer.equals("unlock")){
        unlock();
    }
    
}
 80a13c0:	b005      	add	sp, #20
 80a13c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80a13c6:	bf00      	nop
 80a13c8:	080a846c 	.word	0x080a846c
 80a13cc:	20000300 	.word	0x20000300
 80a13d0:	080a8475 	.word	0x080a8475
 80a13d4:	080a847d 	.word	0x080a847d
 80a13d8:	080a8484 	.word	0x080a8484
 80a13dc:	080a8317 	.word	0x080a8317
 80a13e0:	200003c4 	.word	0x200003c4
 80a13e4:	080a848a 	.word	0x080a848a
 80a13e8:	20000feb 	.word	0x20000feb
 80a13ec:	080a8494 	.word	0x080a8494
 80a13f0:	080a849b 	.word	0x080a849b
 80a13f4:	20001020 	.word	0x20001020
 80a13f8:	20000540 	.word	0x20000540
 80a13fc:	20000474 	.word	0x20000474
 80a1400:	2000048c 	.word	0x2000048c
 80a1404:	080a84a1 	.word	0x080a84a1
 80a1408:	080a84a8 	.word	0x080a84a8
 80a140c:	080a84a6 	.word	0x080a84a6

080a1410 <loop>:
    
    lock();
    initCloudRequests();
}

void loop(){
 80a1410:	b538      	push	{r3, r4, r5, lr}
#endif

#include "timer_hal.h"
#include "delay_hal.h"

inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
 80a1412:	f003 fe21 	bl	80a5058 <HAL_Timer_Get_Milli_Seconds>
    
    // just keeping where we are for determining how long we need to wait later. 
    counter.ms_per_tick = millis();
 80a1416:	4c20      	ldr	r4, [pc, #128]	; (80a1498 <loop+0x88>)
    
    // No uploading of any kind when the system is locked. 
    if(!lockStatus.system_locked){
 80a1418:	4b20      	ldr	r3, [pc, #128]	; (80a149c <loop+0x8c>)
}

void loop(){
    
    // just keeping where we are for determining how long we need to wait later. 
    counter.ms_per_tick = millis();
 80a141a:	6060      	str	r0, [r4, #4]
    
    // No uploading of any kind when the system is locked. 
    if(!lockStatus.system_locked){
 80a141c:	781b      	ldrb	r3, [r3, #0]
 80a141e:	b913      	cbnz	r3, 80a1426 <loop+0x16>
        hmiScreen.run();
 80a1420:	481f      	ldr	r0, [pc, #124]	; (80a14a0 <loop+0x90>)
 80a1422:	f7ff f823 	bl	80a046c <_ZN9HMIScreen3runEv>
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
 80a1426:	f003 fe17 	bl	80a5058 <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
 80a142a:	4b1e      	ldr	r3, [pc, #120]	; (80a14a4 <loop+0x94>)
 80a142c:	6018      	str	r0, [r3, #0]
        spark_cloud_flag_connect();
    }
    static void disconnect(void) { spark_cloud_flag_disconnect(); }
    static void process(void) {
    		application_checkin();
    		spark_process();
 80a142e:	f004 f831 	bl	80a5494 <spark_process>
 80a1432:	f003 fe11 	bl	80a5058 <HAL_Timer_Get_Milli_Seconds>
    // Process that need to be run continuously, doesn't matter if system is locked or not. 
    Particle.process();
    
    // Once we get through everything, we delay as much time is needed, or we don't delay at all and keep going
    // if need be!
    counter.current_ms = millis();
 80a1436:	60a0      	str	r0, [r4, #8]
    counter.loop_tick++; 
 80a1438:	8823      	ldrh	r3, [r4, #0]
    // Process that need to be run continuously, doesn't matter if system is locked or not. 
    Particle.process();
    
    // Once we get through everything, we delay as much time is needed, or we don't delay at all and keep going
    // if need be!
    counter.current_ms = millis();
 80a143a:	4a17      	ldr	r2, [pc, #92]	; (80a1498 <loop+0x88>)
    counter.loop_tick++; 
 80a143c:	3301      	adds	r3, #1
 80a143e:	b29b      	uxth	r3, r3
 80a1440:	8023      	strh	r3, [r4, #0]
    if(counter.loop_tick == 1200){
 80a1442:	8823      	ldrh	r3, [r4, #0]
 80a1444:	b29b      	uxth	r3, r3
 80a1446:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
 80a144a:	d108      	bne.n	80a145e <loop+0x4e>
        if(!counter.stagger_push){
 80a144c:	7b13      	ldrb	r3, [r2, #12]
 80a144e:	2500      	movs	r5, #0
 80a1450:	b91b      	cbnz	r3, 80a145a <loop+0x4a>
            // Update the clock twice a minute. 
            tftDisplay.updateTimeDisplay();   
 80a1452:	4815      	ldr	r0, [pc, #84]	; (80a14a8 <loop+0x98>)
 80a1454:	f7ff f86a 	bl	80a052c <_ZN10TFTDisplay17updateTimeDisplayEv>
 80a1458:	e000      	b.n	80a145c <loop+0x4c>
        }
        else{
            counter.stagger_push = false; 
 80a145a:	7315      	strb	r5, [r2, #12]
        }
        counter.loop_tick = 0; 
 80a145c:	8025      	strh	r5, [r4, #0]
    }
    if(counter.loop_tick == 600){
 80a145e:	8823      	ldrh	r3, [r4, #0]
 80a1460:	4a0d      	ldr	r2, [pc, #52]	; (80a1498 <loop+0x88>)
 80a1462:	b29b      	uxth	r3, r3
 80a1464:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
 80a1468:	d107      	bne.n	80a147a <loop+0x6a>
        if(!counter.stagger_push){
 80a146a:	7b13      	ldrb	r3, [r2, #12]
 80a146c:	b91b      	cbnz	r3, 80a1476 <loop+0x66>
            // Update the clock twice a minute. 
            tftDisplay.updateTimeDisplay();   
 80a146e:	480e      	ldr	r0, [pc, #56]	; (80a14a8 <loop+0x98>)
 80a1470:	f7ff f85c 	bl	80a052c <_ZN10TFTDisplay17updateTimeDisplayEv>
 80a1474:	e001      	b.n	80a147a <loop+0x6a>
        }
        else{
            counter.stagger_push = false; 
 80a1476:	2300      	movs	r3, #0
 80a1478:	7313      	strb	r3, [r2, #12]
        }
    }
    
    if((counter.ms_per_tick + 50) > counter.current_ms){
 80a147a:	6863      	ldr	r3, [r4, #4]
 80a147c:	68a1      	ldr	r1, [r4, #8]
 80a147e:	3332      	adds	r3, #50	; 0x32
 80a1480:	428b      	cmp	r3, r1
 80a1482:	4a05      	ldr	r2, [pc, #20]	; (80a1498 <loop+0x88>)
 80a1484:	d907      	bls.n	80a1496 <loop+0x86>
        unsigned long wait_time = 50 - (counter.current_ms - counter.ms_per_tick);
 80a1486:	6853      	ldr	r3, [r2, #4]
 80a1488:	6890      	ldr	r0, [r2, #8]
        delay(wait_time);
 80a148a:	3332      	adds	r3, #50	; 0x32
 80a148c:	1a18      	subs	r0, r3, r0
    }
}
 80a148e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        }
    }
    
    if((counter.ms_per_tick + 50) > counter.current_ms){
        unsigned long wait_time = 50 - (counter.current_ms - counter.ms_per_tick);
        delay(wait_time);
 80a1492:	f004 bc33 	b.w	80a5cfc <delay>
 80a1496:	bd38      	pop	{r3, r4, r5, pc}
 80a1498:	20001040 	.word	0x20001040
 80a149c:	20000fea 	.word	0x20000fea
 80a14a0:	20000540 	.word	0x20000540
 80a14a4:	20001544 	.word	0x20001544
 80a14a8:	20000fec 	.word	0x20000fec

080a14ac <_Z9hmi_setupv>:
    clock_control.setup(&Udp);
}

// Since the HMI is the most difficult and complex to setup, we will next it 
// in it's own function
void hmi_setup(void){
 80a14ac:	b510      	push	{r4, lr}
    hmiScreen.setup();
 80a14ae:	4c26      	ldr	r4, [pc, #152]	; (80a1548 <_Z9hmi_setupv+0x9c>)
 80a14b0:	4620      	mov	r0, r4
 80a14b2:	f7fe ff7f 	bl	80a03b4 <_ZN9HMIScreen5setupEv>
    hmiScreen.sleepMode.attachPop(sleepModeCallback,&hmiScreen.sleepMode);//sleepmode
 80a14b6:	1d22      	adds	r2, r4, #4
 80a14b8:	4610      	mov	r0, r2
 80a14ba:	4924      	ldr	r1, [pc, #144]	; (80a154c <_Z9hmi_setupv+0xa0>)
 80a14bc:	f003 fcf1 	bl	80a4ea2 <_ZN8NexTouch9attachPopEPFvPvES0_>
    hmiScreen.getTextKeyboard.attachPop(keyBoardCallback,&hmiScreen.getTextKeyboard);//sleepmode
 80a14c0:	f504 720b 	add.w	r2, r4, #556	; 0x22c
 80a14c4:	4610      	mov	r0, r2
 80a14c6:	4922      	ldr	r1, [pc, #136]	; (80a1550 <_Z9hmi_setupv+0xa4>)
 80a14c8:	f003 fceb 	bl	80a4ea2 <_ZN8NexTouch9attachPopEPFvPvES0_>
    hmiScreen.toggleLEDStrip.attachPush(toggleLEDCallback, &hmiScreen.toggleLEDStrip);//toggle led
 80a14cc:	f104 0228 	add.w	r2, r4, #40	; 0x28
 80a14d0:	4610      	mov	r0, r2
 80a14d2:	4920      	ldr	r1, [pc, #128]	; (80a1554 <_Z9hmi_setupv+0xa8>)
 80a14d4:	f003 fce2 	bl	80a4e9c <_ZN8NexTouch10attachPushEPFvPvES0_>
    hmiScreen.toggleWifi.attachPop(toggleWifiCallback, &hmiScreen.toggleWifi);//turn on/off wifi
 80a14d8:	f104 024c 	add.w	r2, r4, #76	; 0x4c
 80a14dc:	4610      	mov	r0, r2
 80a14de:	491e      	ldr	r1, [pc, #120]	; (80a1558 <_Z9hmi_setupv+0xac>)
 80a14e0:	f003 fcdf 	bl	80a4ea2 <_ZN8NexTouch9attachPopEPFvPvES0_>
    hmiScreen.wakeUpButton.attachPush(wakeUpCallback, &hmiScreen.wakeUpButton);
 80a14e4:	f104 0270 	add.w	r2, r4, #112	; 0x70
 80a14e8:	4610      	mov	r0, r2
 80a14ea:	491c      	ldr	r1, [pc, #112]	; (80a155c <_Z9hmi_setupv+0xb0>)
 80a14ec:	f003 fcd6 	bl	80a4e9c <_ZN8NexTouch10attachPushEPFvPvES0_>
    hmiScreen.QuickMessage.attachPop(quickMessageJump, &hmiScreen.QuickMessage);
 80a14f0:	f504 727a 	add.w	r2, r4, #1000	; 0x3e8
 80a14f4:	4610      	mov	r0, r2
 80a14f6:	491a      	ldr	r1, [pc, #104]	; (80a1560 <_Z9hmi_setupv+0xb4>)
 80a14f8:	f003 fcd3 	bl	80a4ea2 <_ZN8NexTouch9attachPopEPFvPvES0_>
    hmiScreen.QuickMessage6.attachPop(quickMessage6Function, &hmiScreen.QuickMessage6);
 80a14fc:	f504 7202 	add.w	r2, r4, #520	; 0x208
 80a1500:	4610      	mov	r0, r2
 80a1502:	4918      	ldr	r1, [pc, #96]	; (80a1564 <_Z9hmi_setupv+0xb8>)
 80a1504:	f003 fccd 	bl	80a4ea2 <_ZN8NexTouch9attachPopEPFvPvES0_>
    hmiScreen.QuickMessage5.attachPop(quickMessage5Function, &hmiScreen.QuickMessage5);
 80a1508:	f504 72f2 	add.w	r2, r4, #484	; 0x1e4
 80a150c:	4610      	mov	r0, r2
 80a150e:	4916      	ldr	r1, [pc, #88]	; (80a1568 <_Z9hmi_setupv+0xbc>)
 80a1510:	f003 fcc7 	bl	80a4ea2 <_ZN8NexTouch9attachPopEPFvPvES0_>
    hmiScreen.QuickMessage4.attachPop(quickMessage4Function, &hmiScreen.QuickMessage4);
 80a1514:	f504 72e0 	add.w	r2, r4, #448	; 0x1c0
 80a1518:	4610      	mov	r0, r2
 80a151a:	4914      	ldr	r1, [pc, #80]	; (80a156c <_Z9hmi_setupv+0xc0>)
 80a151c:	f003 fcc1 	bl	80a4ea2 <_ZN8NexTouch9attachPopEPFvPvES0_>
    hmiScreen.QuickMessage3.attachPop(quickMessage3Function, &hmiScreen.QuickMessage3);
 80a1520:	f504 72ce 	add.w	r2, r4, #412	; 0x19c
 80a1524:	4610      	mov	r0, r2
 80a1526:	4912      	ldr	r1, [pc, #72]	; (80a1570 <_Z9hmi_setupv+0xc4>)
 80a1528:	f003 fcbb 	bl	80a4ea2 <_ZN8NexTouch9attachPopEPFvPvES0_>
    hmiScreen.QuickMessage2.attachPop(quickMessage2Function, &hmiScreen.QuickMessage2);
 80a152c:	f504 72bc 	add.w	r2, r4, #376	; 0x178
 80a1530:	4610      	mov	r0, r2
 80a1532:	4910      	ldr	r1, [pc, #64]	; (80a1574 <_Z9hmi_setupv+0xc8>)
 80a1534:	f003 fcb5 	bl	80a4ea2 <_ZN8NexTouch9attachPopEPFvPvES0_>
    hmiScreen.QuickMessage1.attachPop(quickMessage1Function, &hmiScreen.QuickMessage1);
 80a1538:	f504 72aa 	add.w	r2, r4, #340	; 0x154
 80a153c:	490e      	ldr	r1, [pc, #56]	; (80a1578 <_Z9hmi_setupv+0xcc>)
 80a153e:	4610      	mov	r0, r2
}
 80a1540:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    hmiScreen.QuickMessage6.attachPop(quickMessage6Function, &hmiScreen.QuickMessage6);
    hmiScreen.QuickMessage5.attachPop(quickMessage5Function, &hmiScreen.QuickMessage5);
    hmiScreen.QuickMessage4.attachPop(quickMessage4Function, &hmiScreen.QuickMessage4);
    hmiScreen.QuickMessage3.attachPop(quickMessage3Function, &hmiScreen.QuickMessage3);
    hmiScreen.QuickMessage2.attachPop(quickMessage2Function, &hmiScreen.QuickMessage2);
    hmiScreen.QuickMessage1.attachPop(quickMessage1Function, &hmiScreen.QuickMessage1);
 80a1544:	f003 bcad 	b.w	80a4ea2 <_ZN8NexTouch9attachPopEPFvPvES0_>
 80a1548:	20000540 	.word	0x20000540
 80a154c:	080a0721 	.word	0x080a0721
 80a1550:	080a0791 	.word	0x080a0791
 80a1554:	080a06e5 	.word	0x080a06e5
 80a1558:	080a0761 	.word	0x080a0761
 80a155c:	080a0765 	.word	0x080a0765
 80a1560:	080a06c1 	.word	0x080a06c1
 80a1564:	080a06f1 	.word	0x080a06f1
 80a1568:	080a1745 	.word	0x080a1745
 80a156c:	080a1761 	.word	0x080a1761
 80a1570:	080a177d 	.word	0x080a177d
 80a1574:	080a1799 	.word	0x080a1799
 80a1578:	080a17b5 	.word	0x080a17b5

080a157c <_Z17peripherals_setupv>:
        unsigned long wait_time = 50 - (counter.current_ms - counter.ms_per_tick);
        delay(wait_time);
    }
}

void peripherals_setup(void){
 80a157c:	b570      	push	{r4, r5, r6, lr}
    Time.zone(-7);
 80a157e:	483e      	ldr	r0, [pc, #248]	; (80a1678 <_Z17peripherals_setupv+0xfc>)
        unsigned long wait_time = 50 - (counter.current_ms - counter.ms_per_tick);
        delay(wait_time);
    }
}

void peripherals_setup(void){
 80a1580:	b086      	sub	sp, #24
    hmi_setup();
    
    // Setting up the alarm relay. 
    alarm.setupRelay(DAC);
    // alarm.beepOnce(400);
    hmiScreen.setProgressBar(15);
 80a1582:	4c3e      	ldr	r4, [pc, #248]	; (80a167c <_Z17peripherals_setupv+0x100>)
        delay(wait_time);
    }
}

void peripherals_setup(void){
    Time.zone(-7);
 80a1584:	f004 fb3c 	bl	80a5c00 <_ZN9TimeClass4zoneEf>
    alarm.setupRelay(DAC);
    // alarm.beepOnce(400);
    hmiScreen.setProgressBar(15);
    
    // Setting up the notification ring in the middle of the heart. 
    notifLight.setupLEDs();
 80a1588:	4d3d      	ldr	r5, [pc, #244]	; (80a1680 <_Z17peripherals_setupv+0x104>)
    }
}

void peripherals_setup(void){
    Time.zone(-7);
    hmi_setup();
 80a158a:	f7ff ff8f 	bl	80a14ac <_Z9hmi_setupv>
    
    // Setting up the alarm relay. 
    alarm.setupRelay(DAC);
 80a158e:	2110      	movs	r1, #16
 80a1590:	483c      	ldr	r0, [pc, #240]	; (80a1684 <_Z17peripherals_setupv+0x108>)
 80a1592:	f7fe ff71 	bl	80a0478 <_ZN10alarmRelay10setupRelayEi>
    // alarm.beepOnce(400);
    hmiScreen.setProgressBar(15);
 80a1596:	210f      	movs	r1, #15
 80a1598:	4620      	mov	r0, r4
 80a159a:	f7fe ff55 	bl	80a0448 <_ZN9HMIScreen14setProgressBarEi>
    
    // Setting up the notification ring in the middle of the heart. 
    notifLight.setupLEDs();
 80a159e:	4628      	mov	r0, r5
 80a15a0:	f7fe fdae 	bl	80a0100 <_ZN17notificationLight9setupLEDsEv>
    notifLight.setStrip(100, 100, 100);
 80a15a4:	2364      	movs	r3, #100	; 0x64
 80a15a6:	461a      	mov	r2, r3
 80a15a8:	4619      	mov	r1, r3
 80a15aa:	4628      	mov	r0, r5
    hmiScreen.setProgressBar(30);
    
    // Setting up the lamp features of the heart. 
    lampLight.setupLEDStrip();
 80a15ac:	4d36      	ldr	r5, [pc, #216]	; (80a1688 <_Z17peripherals_setupv+0x10c>)
    // alarm.beepOnce(400);
    hmiScreen.setProgressBar(15);
    
    // Setting up the notification ring in the middle of the heart. 
    notifLight.setupLEDs();
    notifLight.setStrip(100, 100, 100);
 80a15ae:	f7fe fdb4 	bl	80a011a <_ZN17notificationLight8setStripEhhh>
    hmiScreen.setProgressBar(30);
 80a15b2:	211e      	movs	r1, #30
 80a15b4:	4620      	mov	r0, r4
 80a15b6:	f7fe ff47 	bl	80a0448 <_ZN9HMIScreen14setProgressBarEi>
    
    // Setting up the lamp features of the heart. 
    lampLight.setupLEDStrip();
 80a15ba:	4628      	mov	r0, r5
 80a15bc:	f7fe fe13 	bl	80a01e6 <_ZN8LEDRelay13setupLEDStripEv>
    lampLight.setLED(1);
 80a15c0:	2101      	movs	r1, #1
 80a15c2:	4628      	mov	r0, r5
 80a15c4:	f7fe fe2c 	bl	80a0220 <_ZN8LEDRelay6setLEDEb>
    delay(500);
 80a15c8:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80a15cc:	f004 fb96 	bl	80a5cfc <delay>
    lampLight.setLED(0);
 80a15d0:	4628      	mov	r0, r5
 80a15d2:	2100      	movs	r1, #0
    hmiScreen.setProgressBar(45);
    
    
    // Setting up the TFT side/notification display. 
    tftDisplay.setupTFTDisplay();
 80a15d4:	4d2d      	ldr	r5, [pc, #180]	; (80a168c <_Z17peripherals_setupv+0x110>)
    
    // Setting up the lamp features of the heart. 
    lampLight.setupLEDStrip();
    lampLight.setLED(1);
    delay(500);
    lampLight.setLED(0);
 80a15d6:	f7fe fe23 	bl	80a0220 <_ZN8LEDRelay6setLEDEb>
    hmiScreen.setProgressBar(45);
 80a15da:	212d      	movs	r1, #45	; 0x2d
 80a15dc:	4620      	mov	r0, r4
 80a15de:	f7fe ff33 	bl	80a0448 <_ZN9HMIScreen14setProgressBarEi>
    
    
    // Setting up the TFT side/notification display. 
    tftDisplay.setupTFTDisplay();
    tftDisplay.printTFT(20, 20, 2, "Setting up...");
 80a15e2:	ae02      	add	r6, sp, #8
    lampLight.setLED(0);
    hmiScreen.setProgressBar(45);
    
    
    // Setting up the TFT side/notification display. 
    tftDisplay.setupTFTDisplay();
 80a15e4:	4628      	mov	r0, r5
 80a15e6:	f7fe ff77 	bl	80a04d8 <_ZN10TFTDisplay15setupTFTDisplayEv>
    tftDisplay.printTFT(20, 20, 2, "Setting up...");
 80a15ea:	4929      	ldr	r1, [pc, #164]	; (80a1690 <_Z17peripherals_setupv+0x114>)
 80a15ec:	4630      	mov	r0, r6
 80a15ee:	f004 f972 	bl	80a58d6 <_ZN6StringC1EPK19__FlashStringHelper>
 80a15f2:	2214      	movs	r2, #20
 80a15f4:	2302      	movs	r3, #2
 80a15f6:	4611      	mov	r1, r2
 80a15f8:	4628      	mov	r0, r5
 80a15fa:	9600      	str	r6, [sp, #0]
 80a15fc:	f7fe ff58 	bl	80a04b0 <_ZN10TFTDisplay8printTFTEiii6String>
 80a1600:	4630      	mov	r0, r6
 80a1602:	f004 f921 	bl	80a5848 <_ZN6StringD1Ev>
    hmiScreen.setProgressBar(70);
 80a1606:	2146      	movs	r1, #70	; 0x46
 80a1608:	4620      	mov	r0, r4
 80a160a:	f7fe ff1d 	bl	80a0448 <_ZN9HMIScreen14setProgressBarEi>
    
    // Setting up the rfid card reader 
    cardReader.setupCardReader();
 80a160e:	4821      	ldr	r0, [pc, #132]	; (80a1694 <_Z17peripherals_setupv+0x118>)
 80a1610:	f7fe fe94 	bl	80a033c <_ZN10rfidReader15setupCardReaderEv>
    hmiScreen.setProgressBar(85);
 80a1614:	2155      	movs	r1, #85	; 0x55
 80a1616:	4620      	mov	r0, r4
 80a1618:	f7fe ff16 	bl	80a0448 <_ZN9HMIScreen14setProgressBarEi>
    
    // Setting up the 6DOF IMU sensor. 
    motionSensor.setupAccel();
 80a161c:	481e      	ldr	r0, [pc, #120]	; (80a1698 <_Z17peripherals_setupv+0x11c>)
 80a161e:	f7fe fd55 	bl	80a00cc <_ZN9IMUSensor10setupAccelEv>
    hmiScreen.setProgressBar(90);
 80a1622:	215a      	movs	r1, #90	; 0x5a
 80a1624:	4620      	mov	r0, r4
 80a1626:	f7fe ff0f 	bl	80a0448 <_ZN9HMIScreen14setProgressBarEi>
    
    // Since we don't have access to the inside of the Heart, we will disable the internal status LED.
    RGB.control(true);
 80a162a:	2001      	movs	r0, #1
 80a162c:	f004 fd74 	bl	80a6118 <_ZN8RGBClass7controlEb>
    RGB.color(0, 0, 0);
 80a1630:	2200      	movs	r2, #0
 80a1632:	4611      	mov	r1, r2
 80a1634:	4610      	mov	r0, r2
 80a1636:	f004 fd7f 	bl	80a6138 <_ZN8RGBClass5colorEiii>
    RGB.brightness(0);
 80a163a:	2101      	movs	r1, #1
 80a163c:	2000      	movs	r0, #0
 80a163e:	f004 fd8e 	bl	80a615e <_ZN8RGBClass10brightnessEhb>
    RGB.control(false);
 80a1642:	2000      	movs	r0, #0
 80a1644:	f004 fd68 	bl	80a6118 <_ZN8RGBClass7controlEb>
    
    tftDisplay.updateTimeDisplay();
 80a1648:	4628      	mov	r0, r5
 80a164a:	f7fe ff6f 	bl	80a052c <_ZN10TFTDisplay17updateTimeDisplayEv>
    hmiScreen.setProgressBar(100);
 80a164e:	2164      	movs	r1, #100	; 0x64
 80a1650:	4620      	mov	r0, r4
 80a1652:	f7fe fef9 	bl	80a0448 <_ZN9HMIScreen14setProgressBarEi>
    hmiScreen.home();
 80a1656:	4620      	mov	r0, r4
    
    Udp.begin(4250);
 80a1658:	4c10      	ldr	r4, [pc, #64]	; (80a169c <_Z17peripherals_setupv+0x120>)
    RGB.brightness(0);
    RGB.control(false);
    
    tftDisplay.updateTimeDisplay();
    hmiScreen.setProgressBar(100);
    hmiScreen.home();
 80a165a:	f7fe fed3 	bl	80a0404 <_ZN9HMIScreen4homeEv>
    
    Udp.begin(4250);
 80a165e:	2200      	movs	r2, #0
 80a1660:	f241 019a 	movw	r1, #4250	; 0x109a
 80a1664:	4620      	mov	r0, r4
 80a1666:	f004 fb91 	bl	80a5d8c <_ZN3UDP5beginEtm>
    clock_control.setup(&Udp);
 80a166a:	4621      	mov	r1, r4
 80a166c:	480c      	ldr	r0, [pc, #48]	; (80a16a0 <_Z17peripherals_setupv+0x124>)
 80a166e:	f7fe fddd 	bl	80a022c <_ZN12ClockControl5setupEP3UDP>
}
 80a1672:	b006      	add	sp, #24
 80a1674:	bd70      	pop	{r4, r5, r6, pc}
 80a1676:	bf00      	nop
 80a1678:	c0e00000 	.word	0xc0e00000
 80a167c:	20000540 	.word	0x20000540
 80a1680:	20000474 	.word	0x20000474
 80a1684:	200003c4 	.word	0x200003c4
 80a1688:	20000feb 	.word	0x20000feb
 80a168c:	20000fec 	.word	0x20000fec
 80a1690:	080a84ad 	.word	0x080a84ad
 80a1694:	20000fd8 	.word	0x20000fd8
 80a1698:	20000424 	.word	0x20000424
 80a169c:	200004bc 	.word	0x200004bc
 80a16a0:	2000048c 	.word	0x2000048c

080a16a4 <_Z13threads_setupv>:
void quickMessage1Function(void *ptr){
    Particle.publish("QuickMessage", "Hey Babe");
}

// Starts up all the threads for the system!
void threads_setup(void){
 80a16a4:	b508      	push	{r3, lr}
    bool resetFromISR() { return _reset(0, true); }
    bool changePeriodFromISR(unsigned period) { return _changePeriod(period, 0, true); }

    static const unsigned default_wait = 0x7FFFFFFF;

    bool start(unsigned block=default_wait) { return _start(block, false); }
 80a16a6:	2200      	movs	r2, #0
 80a16a8:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 80a16ac:	4804      	ldr	r0, [pc, #16]	; (80a16c0 <_Z13threads_setupv+0x1c>)
 80a16ae:	f7ff fa28 	bl	80a0b02 <_ZN5Timer6_startEjb>
 80a16b2:	2200      	movs	r2, #0
 80a16b4:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 80a16b8:	4802      	ldr	r0, [pc, #8]	; (80a16c4 <_Z13threads_setupv+0x20>)
 80a16ba:	f7ff fa22 	bl	80a0b02 <_ZN5Timer6_startEjb>
 80a16be:	bd08      	pop	{r3, pc}
 80a16c0:	20000408 	.word	0x20000408
 80a16c4:	200003cc 	.word	0x200003cc

080a16c8 <_Z17initCloudRequestsv>:
function: initCloudRequests()
description: initializes all the cloud requests. so you can send and recieve data on the particle.io console. 
parameters: none
returns: none
*/
void initCloudRequests(void){
 80a16c8:	b508      	push	{r3, lr}
    Particle.subscribe("push", push, MY_DEVICES);
 80a16ca:	4907      	ldr	r1, [pc, #28]	; (80a16e8 <_Z17initCloudRequestsv+0x20>)
 80a16cc:	4807      	ldr	r0, [pc, #28]	; (80a16ec <_Z17initCloudRequestsv+0x24>)
 80a16ce:	f7ff f9c1 	bl	80a0a54 <_ZN10CloudClass9subscribeEPKcPFvS1_S1_E32Spark_Subscription_Scope_TypeDef.isra.5.constprop.20>
    //Particle.subscribe("quiet", pushQuiet,MY_DEVICES);
    Particle.subscribe("loud", pushLoud, MY_DEVICES);
 80a16d2:	4907      	ldr	r1, [pc, #28]	; (80a16f0 <_Z17initCloudRequestsv+0x28>)
 80a16d4:	4807      	ldr	r0, [pc, #28]	; (80a16f4 <_Z17initCloudRequestsv+0x2c>)
 80a16d6:	f7ff f9bd 	bl	80a0a54 <_ZN10CloudClass9subscribeEPKcPFvS1_S1_E32Spark_Subscription_Scope_TypeDef.isra.5.constprop.20>
    //Particle.subscribe("commandHMI", particleCommandHMI, MY_DEVICES);//particle functioin to command the nextion display. 
    //Particle.subscribe("updateQR", particleUpdateQR, MY_DEVICES);
    Particle.subscribe("command", particleCommands, MY_DEVICES);
    //Particle.subscribe("toggleSleepMode", particleToggleSleepMode, MY_DEVICES);//particle function to toggle sleep mode. 
    //Particle.subscribe("hook-response/get_weather", getWeatherData, MY_DEVICES);
}
 80a16da:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Particle.subscribe("loud", pushLoud, MY_DEVICES);
    //Particle.subscribe("toggleLED", particleToggleLED, MY_DEVICES);//allows the led Strip to be toggled remotely. 
    //Particle.subscribe("printTFT", particlePrintTFT);//particle function to print data to the TFT display
    //Particle.subscribe("commandHMI", particleCommandHMI, MY_DEVICES);//particle functioin to command the nextion display. 
    //Particle.subscribe("updateQR", particleUpdateQR, MY_DEVICES);
    Particle.subscribe("command", particleCommands, MY_DEVICES);
 80a16de:	4906      	ldr	r1, [pc, #24]	; (80a16f8 <_Z17initCloudRequestsv+0x30>)
 80a16e0:	4806      	ldr	r0, [pc, #24]	; (80a16fc <_Z17initCloudRequestsv+0x34>)
 80a16e2:	f7ff b9b7 	b.w	80a0a54 <_ZN10CloudClass9subscribeEPKcPFvS1_S1_E32Spark_Subscription_Scope_TypeDef.isra.5.constprop.20>
 80a16e6:	bf00      	nop
 80a16e8:	080a0979 	.word	0x080a0979
 80a16ec:	080a84bb 	.word	0x080a84bb
 80a16f0:	080a0a69 	.word	0x080a0a69
 80a16f4:	080a84c0 	.word	0x080a84c0
 80a16f8:	080a12e5 	.word	0x080a12e5
 80a16fc:	080a84c5 	.word	0x080a84c5

080a1700 <setup>:
    
}

// TIMERS FUNCTIONS END // 

void setup() {
 80a1700:	b508      	push	{r3, lr}
    // Setting up all the electronics in the device. 
    peripherals_setup();
 80a1702:	f7ff ff3b 	bl	80a157c <_Z17peripherals_setupv>
    
    threads_setup();
 80a1706:	f7ff ffcd 	bl	80a16a4 <_Z13threads_setupv>
    
    lock();
 80a170a:	f7ff fd17 	bl	80a113c <_Z4lockv>
    initCloudRequests();
}
 80a170e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    peripherals_setup();
    
    threads_setup();
    
    lock();
    initCloudRequests();
 80a1712:	f7ff bfd9 	b.w	80a16c8 <_Z17initCloudRequestsv>

080a1716 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>:
      explicit __shared_count(const __weak_count<_Lp>& __r);

      // Does not throw if __r._M_get_use_count() == 0, caller must check.
      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
 80a1716:	b538      	push	{r3, r4, r5, lr}
      {
	if (_M_pi != nullptr)
 80a1718:	6804      	ldr	r4, [r0, #0]
      explicit __shared_count(const __weak_count<_Lp>& __r);

      // Does not throw if __r._M_get_use_count() == 0, caller must check.
      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
 80a171a:	4605      	mov	r5, r0
      {
	if (_M_pi != nullptr)
 80a171c:	b17c      	cbz	r4, 80a173e <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev+0x28>

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
    {
      if (--_M_use_count == 0)
 80a171e:	6863      	ldr	r3, [r4, #4]
 80a1720:	3b01      	subs	r3, #1
 80a1722:	6063      	str	r3, [r4, #4]
 80a1724:	b95b      	cbnz	r3, 80a173e <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev+0x28>
        {
          _M_dispose();
 80a1726:	6823      	ldr	r3, [r4, #0]
 80a1728:	4620      	mov	r0, r4
 80a172a:	689b      	ldr	r3, [r3, #8]
 80a172c:	4798      	blx	r3
          if (--_M_weak_count == 0)
 80a172e:	68a3      	ldr	r3, [r4, #8]
 80a1730:	3b01      	subs	r3, #1
 80a1732:	60a3      	str	r3, [r4, #8]
 80a1734:	b91b      	cbnz	r3, 80a173e <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev+0x28>
            _M_destroy();
 80a1736:	6823      	ldr	r3, [r4, #0]
 80a1738:	4620      	mov	r0, r4
 80a173a:	68db      	ldr	r3, [r3, #12]
 80a173c:	4798      	blx	r3

      ~__shared_count() noexcept
      {
	if (_M_pi != nullptr)
	  _M_pi->_M_release();
      }
 80a173e:	4628      	mov	r0, r5
 80a1740:	bd38      	pop	{r3, r4, r5, pc}
	...

080a1744 <_Z21quickMessage5FunctionPv>:
function: quickMessage5Function(void *ptr)
description: publishes a paritcle event with a given message!
parameters: none 
returns: none
*/
void quickMessage5Function(void *ptr){
 80a1744:	b507      	push	{r0, r1, r2, lr}
    Particle.publish("QuickMessage", "What are you doing?");
 80a1746:	4905      	ldr	r1, [pc, #20]	; (80a175c <_Z21quickMessage5FunctionPv+0x18>)
 80a1748:	4668      	mov	r0, sp
 80a174a:	f7ff f971 	bl	80a0a30 <_ZN10CloudClass7publishEPKcS1_.isra.11.constprop.17>
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
 80a174e:	a801      	add	r0, sp, #4
 80a1750:	f7ff ffe1 	bl	80a1716 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
}
 80a1754:	b003      	add	sp, #12
 80a1756:	f85d fb04 	ldr.w	pc, [sp], #4
 80a175a:	bf00      	nop
 80a175c:	080a84cd 	.word	0x080a84cd

080a1760 <_Z21quickMessage4FunctionPv>:

void quickMessage4Function(void *ptr){
 80a1760:	b507      	push	{r0, r1, r2, lr}
    Particle.publish("QuickMessage", "I miss you :(");
 80a1762:	4905      	ldr	r1, [pc, #20]	; (80a1778 <_Z21quickMessage4FunctionPv+0x18>)
 80a1764:	4668      	mov	r0, sp
 80a1766:	f7ff f963 	bl	80a0a30 <_ZN10CloudClass7publishEPKcS1_.isra.11.constprop.17>
 80a176a:	a801      	add	r0, sp, #4
 80a176c:	f7ff ffd3 	bl	80a1716 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
}
 80a1770:	b003      	add	sp, #12
 80a1772:	f85d fb04 	ldr.w	pc, [sp], #4
 80a1776:	bf00      	nop
 80a1778:	080a84e1 	.word	0x080a84e1

080a177c <_Z21quickMessage3FunctionPv>:

void quickMessage3Function(void *ptr){
 80a177c:	b507      	push	{r0, r1, r2, lr}
    Particle.publish("QuickMessage", "Are you in your dorm?");
 80a177e:	4905      	ldr	r1, [pc, #20]	; (80a1794 <_Z21quickMessage3FunctionPv+0x18>)
 80a1780:	4668      	mov	r0, sp
 80a1782:	f7ff f955 	bl	80a0a30 <_ZN10CloudClass7publishEPKcS1_.isra.11.constprop.17>
 80a1786:	a801      	add	r0, sp, #4
 80a1788:	f7ff ffc5 	bl	80a1716 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
}
 80a178c:	b003      	add	sp, #12
 80a178e:	f85d fb04 	ldr.w	pc, [sp], #4
 80a1792:	bf00      	nop
 80a1794:	080a84ef 	.word	0x080a84ef

080a1798 <_Z21quickMessage2FunctionPv>:

void quickMessage2Function(void *ptr){
 80a1798:	b507      	push	{r0, r1, r2, lr}
    Particle.publish("QuickMessage", "How are you doing?");
 80a179a:	4905      	ldr	r1, [pc, #20]	; (80a17b0 <_Z21quickMessage2FunctionPv+0x18>)
 80a179c:	4668      	mov	r0, sp
 80a179e:	f7ff f947 	bl	80a0a30 <_ZN10CloudClass7publishEPKcS1_.isra.11.constprop.17>
 80a17a2:	a801      	add	r0, sp, #4
 80a17a4:	f7ff ffb7 	bl	80a1716 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
}
 80a17a8:	b003      	add	sp, #12
 80a17aa:	f85d fb04 	ldr.w	pc, [sp], #4
 80a17ae:	bf00      	nop
 80a17b0:	080a8505 	.word	0x080a8505

080a17b4 <_Z21quickMessage1FunctionPv>:

void quickMessage1Function(void *ptr){
 80a17b4:	b507      	push	{r0, r1, r2, lr}
    Particle.publish("QuickMessage", "Hey Babe");
 80a17b6:	4905      	ldr	r1, [pc, #20]	; (80a17cc <_Z21quickMessage1FunctionPv+0x18>)
 80a17b8:	4668      	mov	r0, sp
 80a17ba:	f7ff f939 	bl	80a0a30 <_ZN10CloudClass7publishEPKcS1_.isra.11.constprop.17>
 80a17be:	a801      	add	r0, sp, #4
 80a17c0:	f7ff ffa9 	bl	80a1716 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
}
 80a17c4:	b003      	add	sp, #12
 80a17c6:	f85d fb04 	ldr.w	pc, [sp], #4
 80a17ca:	bf00      	nop
 80a17cc:	080a8518 	.word	0x080a8518

080a17d0 <_GLOBAL__sub_I_alarm>:
parameters: none
returns: none
*/
void sysReset(const char *event, const char *data){
    System.reset();
 80a17d0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80a17d4:	4b77      	ldr	r3, [pc, #476]	; (80a19b4 <_GLOBAL__sub_I_alarm+0x1e4>)
 80a17d6:	4e78      	ldr	r6, [pc, #480]	; (80a19b8 <_GLOBAL__sub_I_alarm+0x1e8>)
 80a17d8:	b088      	sub	sp, #32

// Relay controlling the beeper built into the system. 
alarmRelay alarm; 

// Neopixel Notification Light. 
notificationLight notifLight;
 80a17da:	4c78      	ldr	r4, [pc, #480]	; (80a19bc <_GLOBAL__sub_I_alarm+0x1ec>)
 80a17dc:	2500      	movs	r5, #0
 80a17de:	701d      	strb	r5, [r3, #0]
 80a17e0:	f003 fbb2 	bl	80a4f48 <HAL_Pin_Map>
 80a17e4:	2302      	movs	r3, #2
 80a17e6:	220a      	movs	r2, #10
 80a17e8:	2118      	movs	r1, #24
 80a17ea:	4630      	mov	r0, r6
 80a17ec:	f001 faea 	bl	80a2dc4 <_ZN17Adafruit_NeoPixelC1Ethh>
 80a17f0:	82b5      	strh	r5, [r6, #20]
 80a17f2:	82f5      	strh	r5, [r6, #22]
 80a17f4:	4622      	mov	r2, r4
 80a17f6:	4972      	ldr	r1, [pc, #456]	; (80a19c0 <_GLOBAL__sub_I_alarm+0x1f0>)
 80a17f8:	4630      	mov	r0, r6
 80a17fa:	4e72      	ldr	r6, [pc, #456]	; (80a19c4 <_GLOBAL__sub_I_alarm+0x1f4>)
 80a17fc:	f005 fad2 	bl	80a6da4 <__aeabi_atexit>
 80a1800:	2104      	movs	r1, #4
 80a1802:	2207      	movs	r2, #7
 80a1804:	2303      	movs	r3, #3
 80a1806:	e88d 000e 	stmia.w	sp, {r1, r2, r3}
 80a180a:	4630      	mov	r0, r6
 80a180c:	2302      	movs	r3, #2
 80a180e:	2206      	movs	r2, #6
 80a1810:	2105      	movs	r1, #5
 80a1812:	f000 f94d 	bl	80a1ab0 <_ZN16Adafruit_ILI9341C1Eaaaaaa>

// Lamp Light, allows us to have lamp features. 
LEDRelay lampLight;

// Display for publishing notifications onto heart. 
TFTDisplay tftDisplay; 
 80a1816:	4630      	mov	r0, r6

// PIN DENOMINATIONS // 
#define SS_PIN SS
#define RST_PIN D2

class rfidReader{
 80a1818:	4e6b      	ldr	r6, [pc, #428]	; (80a19c8 <_GLOBAL__sub_I_alarm+0x1f8>)
 80a181a:	4622      	mov	r2, r4
 80a181c:	496b      	ldr	r1, [pc, #428]	; (80a19cc <_GLOBAL__sub_I_alarm+0x1fc>)
 80a181e:	f005 fac1 	bl	80a6da4 <__aeabi_atexit>
 80a1822:	2202      	movs	r2, #2
 80a1824:	210c      	movs	r1, #12
 80a1826:	4630      	mov	r0, r6
 80a1828:	f000 fe6a 	bl	80a2500 <_ZN7MFRC522C1Ehh>
 80a182c:	f8c6 500e 	str.w	r5, [r6, #14]
 80a1830:	4e67      	ldr	r6, [pc, #412]	; (80a19d0 <_GLOBAL__sub_I_alarm+0x200>)

// GLOBAL VARIABLES END // 

// TIMERS HANDLERS BEGIN // 

Timer ms_100_task_handler(100, ms_100_task);
 80a1832:	f8df 91dc 	ldr.w	r9, [pc, #476]	; 80a1a10 <_GLOBAL__sub_I_alarm+0x240>
 80a1836:	4630      	mov	r0, r6
 80a1838:	f002 fe2c 	bl	80a4494 <_ZN15Adafruit_LIS3DHC1Ev>
LockStatus lockStatus; 

NotificationSettings notifications; 

// Allows us to detect motion interacting with the heart. 
IMUSensor motionSensor; 
 80a183c:	4622      	mov	r2, r4
 80a183e:	4965      	ldr	r1, [pc, #404]	; (80a19d4 <_GLOBAL__sub_I_alarm+0x204>)
 80a1840:	4630      	mov	r0, r6
 80a1842:	f005 faaf 	bl	80a6da4 <__aeabi_atexit>

// HMI variables live here!
HMIScreen hmiScreen;  
 80a1846:	4864      	ldr	r0, [pc, #400]	; (80a19d8 <_GLOBAL__sub_I_alarm+0x208>)
 80a1848:	f7ff f9a4 	bl	80a0b94 <_ZN9HMIScreenC1Ev>

// Allows us to keep sleep mode information saved. 
SleepMode sleepMode; 

// For whatever reason the HMI needs the serial device to be defined like this(not preferable, if I rewrite the firwmware to the HMI, I'll do it differently)
USARTSerial& nexSerial = Serial1;//chooses the right serial device
 80a184c:	f005 f93c 	bl	80a6ac8 <_Z22__fetch_global_Serial1v>
 80a1850:	4b62      	ldr	r3, [pc, #392]	; (80a19dc <_GLOBAL__sub_I_alarm+0x20c>)
 80a1852:	4e63      	ldr	r6, [pc, #396]	; (80a19e0 <_GLOBAL__sub_I_alarm+0x210>)
 80a1854:	6018      	str	r0, [r3, #0]
 80a1856:	2318      	movs	r3, #24
 80a1858:	9300      	str	r3, [sp, #0]
 80a185a:	22a8      	movs	r2, #168	; 0xa8
 80a185c:	2301      	movs	r3, #1
 80a185e:	21c0      	movs	r1, #192	; 0xc0
 80a1860:	1d30      	adds	r0, r6, #4
 80a1862:	f005 f815 	bl	80a6890 <_ZN9IPAddressC1Ehhhh>
 80a1866:	f241 0372 	movw	r3, #4210	; 0x1072
 80a186a:	61f3      	str	r3, [r6, #28]
 80a186c:	4b5d      	ldr	r3, [pc, #372]	; (80a19e4 <_GLOBAL__sub_I_alarm+0x214>)

// Counters for dealing with timing operations in the main loop 
Counters counter;

// Handler for controlling the clock. 
ClockControl clock_control;
 80a186e:	495e      	ldr	r1, [pc, #376]	; (80a19e8 <_GLOBAL__sub_I_alarm+0x218>)
 80a1870:	791a      	ldrb	r2, [r3, #4]
 80a1872:	6818      	ldr	r0, [r3, #0]
 80a1874:	f886 2024 	strb.w	r2, [r6, #36]	; 0x24
 80a1878:	f853 2f05 	ldr.w	r2, [r3, #5]!
 80a187c:	6230      	str	r0, [r6, #32]
 80a187e:	791b      	ldrb	r3, [r3, #4]
 80a1880:	f8c6 2025 	str.w	r2, [r6, #37]	; 0x25
 80a1884:	f886 3029 	strb.w	r3, [r6, #41]	; 0x29
 80a1888:	4630      	mov	r0, r6
UDP Udp;
 80a188a:	4e58      	ldr	r6, [pc, #352]	; (80a19ec <_GLOBAL__sub_I_alarm+0x21c>)

// Counters for dealing with timing operations in the main loop 
Counters counter;

// Handler for controlling the clock. 
ClockControl clock_control;
 80a188c:	4622      	mov	r2, r4
 80a188e:	f005 fa89 	bl	80a6da4 <__aeabi_atexit>
UDP Udp;
 80a1892:	4630      	mov	r0, r6
 80a1894:	f004 fbbe 	bl	80a6014 <_ZN3UDPC1Ev>
 80a1898:	4622      	mov	r2, r4
 80a189a:	4955      	ldr	r1, [pc, #340]	; (80a19f0 <_GLOBAL__sub_I_alarm+0x220>)
 80a189c:	4630      	mov	r0, r6
 80a189e:	f005 fa81 	bl	80a6da4 <__aeabi_atexit>
	  { return true; }

      private:
	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }
 80a18a2:	4b54      	ldr	r3, [pc, #336]	; (80a19f4 <_GLOBAL__sub_I_alarm+0x224>)
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
 80a18a4:	f8df 816c 	ldr.w	r8, [pc, #364]	; 80a1a14 <_GLOBAL__sub_I_alarm+0x244>
	    _M_manager = &_My_handler::_M_manager;
 80a18a8:	4f53      	ldr	r7, [pc, #332]	; (80a19f8 <_GLOBAL__sub_I_alarm+0x228>)

// GLOBAL VARIABLES END // 

// TIMERS HANDLERS BEGIN // 

Timer ms_100_task_handler(100, ms_100_task);
 80a18aa:	4e54      	ldr	r6, [pc, #336]	; (80a19fc <_GLOBAL__sub_I_alarm+0x22c>)
 80a18ac:	aa04      	add	r2, sp, #16
	  { return true; }

      private:
	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }
 80a18ae:	9304      	str	r3, [sp, #16]
 80a18b0:	2164      	movs	r1, #100	; 0x64
 80a18b2:	462b      	mov	r3, r5
 80a18b4:	4648      	mov	r0, r9

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
	    _M_manager = &_My_handler::_M_manager;
 80a18b6:	9706      	str	r7, [sp, #24]
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
 80a18b8:	f8cd 801c 	str.w	r8, [sp, #28]
 80a18bc:	f7ff f8e0 	bl	80a0a80 <_ZN5TimerC1EjSt8functionIFvvEEb>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a18c0:	a804      	add	r0, sp, #16
 80a18c2:	f7ff f8d3 	bl	80a0a6c <_ZNSt14_Function_baseD1Ev>
 80a18c6:	4622      	mov	r2, r4
 80a18c8:	4631      	mov	r1, r6
 80a18ca:	4648      	mov	r0, r9
 80a18cc:	f005 fa6a 	bl	80a6da4 <__aeabi_atexit>
Timer ms_300_task_handler(200, ms_300_task);
 80a18d0:	f8df 9144 	ldr.w	r9, [pc, #324]	; 80a1a18 <_GLOBAL__sub_I_alarm+0x248>
	  { return true; }

      private:
	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }
 80a18d4:	4b4a      	ldr	r3, [pc, #296]	; (80a1a00 <_GLOBAL__sub_I_alarm+0x230>)
 80a18d6:	aa04      	add	r2, sp, #16
 80a18d8:	9304      	str	r3, [sp, #16]
 80a18da:	21c8      	movs	r1, #200	; 0xc8
 80a18dc:	462b      	mov	r3, r5
 80a18de:	4648      	mov	r0, r9

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
	    _M_manager = &_My_handler::_M_manager;
 80a18e0:	9706      	str	r7, [sp, #24]
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
 80a18e2:	f8cd 801c 	str.w	r8, [sp, #28]
 80a18e6:	f7ff f8cb 	bl	80a0a80 <_ZN5TimerC1EjSt8functionIFvvEEb>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a18ea:	a804      	add	r0, sp, #16
 80a18ec:	f7ff f8be 	bl	80a0a6c <_ZNSt14_Function_baseD1Ev>
 80a18f0:	4622      	mov	r2, r4
 80a18f2:	4631      	mov	r1, r6
 80a18f4:	4648      	mov	r0, r9
 80a18f6:	f005 fa55 	bl	80a6da4 <__aeabi_atexit>
Timer ms_1000_task_handler(1000, ms_1000_task);
 80a18fa:	f8df 9120 	ldr.w	r9, [pc, #288]	; 80a1a1c <_GLOBAL__sub_I_alarm+0x24c>
	  { return true; }

      private:
	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }
 80a18fe:	4b41      	ldr	r3, [pc, #260]	; (80a1a04 <_GLOBAL__sub_I_alarm+0x234>)
 80a1900:	aa04      	add	r2, sp, #16
 80a1902:	9304      	str	r3, [sp, #16]
 80a1904:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 80a1908:	462b      	mov	r3, r5
 80a190a:	4648      	mov	r0, r9

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
	    _M_manager = &_My_handler::_M_manager;
 80a190c:	9706      	str	r7, [sp, #24]
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
 80a190e:	f8cd 801c 	str.w	r8, [sp, #28]
 80a1912:	f7ff f8b5 	bl	80a0a80 <_ZN5TimerC1EjSt8functionIFvvEEb>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a1916:	a804      	add	r0, sp, #16
 80a1918:	f7ff f8a8 	bl	80a0a6c <_ZNSt14_Function_baseD1Ev>
 80a191c:	4622      	mov	r2, r4
 80a191e:	4631      	mov	r1, r6
 80a1920:	4648      	mov	r0, r9
 80a1922:	f005 fa3f 	bl	80a6da4 <__aeabi_atexit>
Timer s_10_task_handler(10000, s_10_task);
 80a1926:	f8df 90f8 	ldr.w	r9, [pc, #248]	; 80a1a20 <_GLOBAL__sub_I_alarm+0x250>
	  { return true; }

      private:
	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }
 80a192a:	4b37      	ldr	r3, [pc, #220]	; (80a1a08 <_GLOBAL__sub_I_alarm+0x238>)
 80a192c:	aa04      	add	r2, sp, #16
 80a192e:	9304      	str	r3, [sp, #16]
 80a1930:	f242 7110 	movw	r1, #10000	; 0x2710
 80a1934:	462b      	mov	r3, r5
 80a1936:	4648      	mov	r0, r9

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
	    _M_manager = &_My_handler::_M_manager;
 80a1938:	9706      	str	r7, [sp, #24]
Timer s_30_task_handler(30000, s_30_task);
 80a193a:	f8df a0e8 	ldr.w	sl, [pc, #232]	; 80a1a24 <_GLOBAL__sub_I_alarm+0x254>
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
 80a193e:	f8cd 801c 	str.w	r8, [sp, #28]
// TIMERS HANDLERS BEGIN // 

Timer ms_100_task_handler(100, ms_100_task);
Timer ms_300_task_handler(200, ms_300_task);
Timer ms_1000_task_handler(1000, ms_1000_task);
Timer s_10_task_handler(10000, s_10_task);
 80a1942:	f7ff f89d 	bl	80a0a80 <_ZN5TimerC1EjSt8functionIFvvEEb>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a1946:	a804      	add	r0, sp, #16
 80a1948:	f7ff f890 	bl	80a0a6c <_ZNSt14_Function_baseD1Ev>
 80a194c:	4622      	mov	r2, r4
 80a194e:	4631      	mov	r1, r6
 80a1950:	4648      	mov	r0, r9
	  { return true; }

      private:
	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }
 80a1952:	f8df 90d4 	ldr.w	r9, [pc, #212]	; 80a1a28 <_GLOBAL__sub_I_alarm+0x258>
 80a1956:	f005 fa25 	bl	80a6da4 <__aeabi_atexit>
Timer s_30_task_handler(30000, s_30_task);
 80a195a:	462b      	mov	r3, r5
 80a195c:	aa04      	add	r2, sp, #16
 80a195e:	f247 5130 	movw	r1, #30000	; 0x7530
 80a1962:	4650      	mov	r0, sl

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
	    _M_manager = &_My_handler::_M_manager;
 80a1964:	9706      	str	r7, [sp, #24]
	  { return true; }

      private:
	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }
 80a1966:	f8cd 9010 	str.w	r9, [sp, #16]
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
 80a196a:	f8cd 801c 	str.w	r8, [sp, #28]
 80a196e:	f7ff f887 	bl	80a0a80 <_ZN5TimerC1EjSt8functionIFvvEEb>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a1972:	a804      	add	r0, sp, #16
 80a1974:	f7ff f87a 	bl	80a0a6c <_ZNSt14_Function_baseD1Ev>
 80a1978:	4622      	mov	r2, r4
 80a197a:	4631      	mov	r1, r6
 80a197c:	4650      	mov	r0, sl
 80a197e:	f005 fa11 	bl	80a6da4 <__aeabi_atexit>

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
	    _M_manager = &_My_handler::_M_manager;
 80a1982:	9706      	str	r7, [sp, #24]
Timer s_60_task_handler(60000, s_30_task);
 80a1984:	4f21      	ldr	r7, [pc, #132]	; (80a1a0c <_GLOBAL__sub_I_alarm+0x23c>)
 80a1986:	462b      	mov	r3, r5
 80a1988:	aa04      	add	r2, sp, #16
 80a198a:	f64e 2160 	movw	r1, #60000	; 0xea60
 80a198e:	4638      	mov	r0, r7
	  { return true; }

      private:
	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }
 80a1990:	f8cd 9010 	str.w	r9, [sp, #16]
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
 80a1994:	f8cd 801c 	str.w	r8, [sp, #28]
 80a1998:	f7ff f872 	bl	80a0a80 <_ZN5TimerC1EjSt8functionIFvvEEb>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a199c:	a804      	add	r0, sp, #16
 80a199e:	f7ff f865 	bl	80a0a6c <_ZNSt14_Function_baseD1Ev>
 80a19a2:	4622      	mov	r2, r4
 80a19a4:	4631      	mov	r1, r6
 80a19a6:	4638      	mov	r0, r7
 80a19a8:	f005 f9fc 	bl	80a6da4 <__aeabi_atexit>
parameters: none
returns: none
*/
void sysReset(const char *event, const char *data){
    System.reset();
 80a19ac:	b008      	add	sp, #32
 80a19ae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a19b2:	bf00      	nop
 80a19b4:	20000404 	.word	0x20000404
 80a19b8:	20000474 	.word	0x20000474
 80a19bc:	200003bc 	.word	0x200003bc
 80a19c0:	080a094d 	.word	0x080a094d
 80a19c4:	20000fec 	.word	0x20000fec
 80a19c8:	20000fd8 	.word	0x20000fd8
 80a19cc:	080a06df 	.word	0x080a06df
 80a19d0:	20000424 	.word	0x20000424
 80a19d4:	080a06e1 	.word	0x080a06e1
 80a19d8:	20000540 	.word	0x20000540
 80a19dc:	200004b8 	.word	0x200004b8
 80a19e0:	2000048c 	.word	0x2000048c
 80a19e4:	080a8208 	.word	0x080a8208
 80a19e8:	080a06e3 	.word	0x080a06e3
 80a19ec:	200004bc 	.word	0x200004bc
 80a19f0:	080a092d 	.word	0x080a092d
 80a19f4:	080a119d 	.word	0x080a119d
 80a19f8:	080a06c7 	.word	0x080a06c7
 80a19fc:	080a0b31 	.word	0x080a0b31
 80a1a00:	080a12b1 	.word	0x080a12b1
 80a1a04:	080a0a6b 	.word	0x080a0a6b
 80a1a08:	080a06fd 	.word	0x080a06fd
 80a1a0c:	20000508 	.word	0x20000508
 80a1a10:	20000408 	.word	0x20000408
 80a1a14:	080a06c3 	.word	0x080a06c3
 80a1a18:	200003cc 	.word	0x200003cc
 80a1a1c:	20000524 	.word	0x20000524
 80a1a20:	20001024 	.word	0x20001024
 80a1a24:	200003e8 	.word	0x200003e8
 80a1a28:	080a0709 	.word	0x080a0709

080a1a2c <_ZN16Adafruit_ILI934110fillScreenEt>:
  digitalWrite(_cs, HIGH);
#endif
  if (hwSPI) spi_end();
}

void Adafruit_ILI9341::fillScreen(uint16_t color) {
 80a1a2c:	b513      	push	{r0, r1, r4, lr}
  fillRect(0, 0,  _width, _height, color);
 80a1a2e:	f9b0 200e 	ldrsh.w	r2, [r0, #14]
 80a1a32:	6804      	ldr	r4, [r0, #0]
 80a1a34:	9101      	str	r1, [sp, #4]
 80a1a36:	9200      	str	r2, [sp, #0]
 80a1a38:	2200      	movs	r2, #0
 80a1a3a:	f9b0 300c 	ldrsh.w	r3, [r0, #12]
 80a1a3e:	6a64      	ldr	r4, [r4, #36]	; 0x24
 80a1a40:	4611      	mov	r1, r2
 80a1a42:	47a0      	blx	r4
}
 80a1a44:	b002      	add	sp, #8
 80a1a46:	bd10      	pop	{r4, pc}

080a1a48 <_ZN16Adafruit_ILI9341D1Ev>:
#define ILI9341_WHITE       0xFFFF      /* 255, 255, 255 */
#define ILI9341_ORANGE      0xFD20      /* 255, 165,   0 */
#define ILI9341_GREENYELLOW 0xAFE5      /* 173, 255,  47 */
#define ILI9341_PINK        0xF81F

class Adafruit_ILI9341 : public Adafruit_GFX {
 80a1a48:	4770      	bx	lr
	...

080a1a4c <_ZNK8particle13__SPISettings7printToER5Print>:
  bool operator!=(const __SPISettings& other) const
  {
    return !(other == *this);
  }

  virtual size_t printTo(Print& p) const
 80a1a4c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 80a1a4e:	4602      	mov	r2, r0
  {
    if (default_ && clock_ == 0)
 80a1a50:	7913      	ldrb	r3, [r2, #4]
  bool operator!=(const __SPISettings& other) const
  {
    return !(other == *this);
  }

  virtual size_t printTo(Print& p) const
 80a1a52:	4608      	mov	r0, r1
 80a1a54:	6895      	ldr	r5, [r2, #8]
  {
    if (default_ && clock_ == 0)
 80a1a56:	b133      	cbz	r3, 80a1a66 <_ZNK8particle13__SPISettings7printToER5Print+0x1a>
 80a1a58:	b93d      	cbnz	r5, 80a1a6a <_ZNK8particle13__SPISettings7printToER5Print+0x1e>
      return p.print("<SPISettings default>");
 80a1a5a:	490c      	ldr	r1, [pc, #48]	; (80a1a8c <_ZNK8particle13__SPISettings7printToER5Print+0x40>)
    else
      return p.printf("<SPISettings %s%lu %s MODE%d>", default_ ? "default " : "", clock_, bitOrder_ == MSBFIRST ? "MSB" : "LSB", dataMode_);
  }
 80a1a5c:	b004      	add	sp, #16
 80a1a5e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  }

  virtual size_t printTo(Print& p) const
  {
    if (default_ && clock_ == 0)
      return p.print("<SPISettings default>");
 80a1a62:	f003 bfab 	b.w	80a59bc <_ZN5Print5printEPKc>
    else
      return p.printf("<SPISettings %s%lu %s MODE%d>", default_ ? "default " : "", clock_, bitOrder_ == MSBFIRST ? "MSB" : "LSB", dataMode_);
 80a1a66:	4b0a      	ldr	r3, [pc, #40]	; (80a1a90 <_ZNK8particle13__SPISettings7printToER5Print+0x44>)
 80a1a68:	e000      	b.n	80a1a6c <_ZNK8particle13__SPISettings7printToER5Print+0x20>
 80a1a6a:	4b0a      	ldr	r3, [pc, #40]	; (80a1a94 <_ZNK8particle13__SPISettings7printToER5Print+0x48>)
 80a1a6c:	7b16      	ldrb	r6, [r2, #12]
 80a1a6e:	4c0a      	ldr	r4, [pc, #40]	; (80a1a98 <_ZNK8particle13__SPISettings7printToER5Print+0x4c>)
 80a1a70:	490a      	ldr	r1, [pc, #40]	; (80a1a9c <_ZNK8particle13__SPISettings7printToER5Print+0x50>)
    size_t println(const __FlashStringHelper*);

    template <typename... Args>
    inline size_t printf(const char* format, Args... args)
    {
        return this->printf_impl(false, format, args...);
 80a1a72:	7b52      	ldrb	r2, [r2, #13]
 80a1a74:	2e01      	cmp	r6, #1
 80a1a76:	bf08      	it	eq
 80a1a78:	4621      	moveq	r1, r4
 80a1a7a:	9202      	str	r2, [sp, #8]
 80a1a7c:	9101      	str	r1, [sp, #4]
 80a1a7e:	9500      	str	r5, [sp, #0]
 80a1a80:	4a07      	ldr	r2, [pc, #28]	; (80a1aa0 <_ZNK8particle13__SPISettings7printToER5Print+0x54>)
 80a1a82:	2100      	movs	r1, #0
 80a1a84:	f003 fffd 	bl	80a5a82 <_ZN5Print11printf_implEbPKcz>
  }
 80a1a88:	b004      	add	sp, #16
 80a1a8a:	bd70      	pop	{r4, r5, r6, pc}
 80a1a8c:	080a857d 	.word	0x080a857d
 80a1a90:	080a92e8 	.word	0x080a92e8
 80a1a94:	080a856c 	.word	0x080a856c
 80a1a98:	080a8575 	.word	0x080a8575
 80a1a9c:	080a8579 	.word	0x080a8579
 80a1aa0:	080a8593 	.word	0x080a8593

080a1aa4 <_ZN16Adafruit_ILI9341D0Ev>:
 80a1aa4:	b510      	push	{r4, lr}
 80a1aa6:	4604      	mov	r4, r0
 80a1aa8:	f7fe fafb 	bl	80a00a2 <_ZdlPv>
 80a1aac:	4620      	mov	r0, r4
 80a1aae:	bd10      	pop	{r4, pc}

080a1ab0 <_ZN16Adafruit_ILI9341C1Eaaaaaa>:
#define spi_end()
#endif


// Constructor when using software SPI.  All output pins are configurable.
Adafruit_ILI9341::Adafruit_ILI9341(int8_t cs, int8_t dc, int8_t mosi,
 80a1ab0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a1ab2:	4604      	mov	r4, r0
 80a1ab4:	461d      	mov	r5, r3
 80a1ab6:	460f      	mov	r7, r1
 80a1ab8:	4616      	mov	r6, r2
				   int8_t sclk, int8_t rst, int8_t miso) : Adafruit_GFX(ILI9341_TFTWIDTH, ILI9341_TFTHEIGHT) {
 80a1aba:	21f0      	movs	r1, #240	; 0xf0
 80a1abc:	f44f 72a0 	mov.w	r2, #320	; 0x140
 80a1ac0:	f002 fbf2 	bl	80a42a8 <_ZN12Adafruit_GFXC1Ess>
 80a1ac4:	4b0c      	ldr	r3, [pc, #48]	; (80a1af8 <_ZN16Adafruit_ILI9341C1Eaaaaaa+0x48>)
  _cs   = cs;
 80a1ac6:	f884 702b 	strb.w	r7, [r4, #43]	; 0x2b
#endif


// Constructor when using software SPI.  All output pins are configurable.
Adafruit_ILI9341::Adafruit_ILI9341(int8_t cs, int8_t dc, int8_t mosi,
				   int8_t sclk, int8_t rst, int8_t miso) : Adafruit_GFX(ILI9341_TFTWIDTH, ILI9341_TFTHEIGHT) {
 80a1aca:	6023      	str	r3, [r4, #0]
  _cs   = cs;
  _dc   = dc;
  _mosi  = mosi;
  _miso = miso;
 80a1acc:	f99d 3020 	ldrsb.w	r3, [sp, #32]

// Constructor when using software SPI.  All output pins are configurable.
Adafruit_ILI9341::Adafruit_ILI9341(int8_t cs, int8_t dc, int8_t mosi,
				   int8_t sclk, int8_t rst, int8_t miso) : Adafruit_GFX(ILI9341_TFTWIDTH, ILI9341_TFTHEIGHT) {
  _cs   = cs;
  _dc   = dc;
 80a1ad0:	f884 602c 	strb.w	r6, [r4, #44]	; 0x2c
  _mosi  = mosi;
  _miso = miso;
 80a1ad4:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
  _sclk = sclk;
 80a1ad8:	f99d 3018 	ldrsb.w	r3, [sp, #24]
// Constructor when using software SPI.  All output pins are configurable.
Adafruit_ILI9341::Adafruit_ILI9341(int8_t cs, int8_t dc, int8_t mosi,
				   int8_t sclk, int8_t rst, int8_t miso) : Adafruit_GFX(ILI9341_TFTWIDTH, ILI9341_TFTHEIGHT) {
  _cs   = cs;
  _dc   = dc;
  _mosi  = mosi;
 80a1adc:	f884 502e 	strb.w	r5, [r4, #46]	; 0x2e
  _miso = miso;
  _sclk = sclk;
 80a1ae0:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
  _rst  = rst;
 80a1ae4:	f99d 301c 	ldrsb.w	r3, [sp, #28]
  hwSPI = false;
}
 80a1ae8:	4620      	mov	r0, r4
  _cs   = cs;
  _dc   = dc;
  _mosi  = mosi;
  _miso = miso;
  _sclk = sclk;
  _rst  = rst;
 80a1aea:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
  hwSPI = false;
 80a1aee:	2300      	movs	r3, #0
 80a1af0:	f884 302a 	strb.w	r3, [r4, #42]	; 0x2a
}
 80a1af4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a1af6:	bf00      	nop
 80a1af8:	080a8538 	.word	0x080a8538

080a1afc <_ZN16Adafruit_ILI93418spiwriteEh>:
  _rst  = rst;
  hwSPI = true;
  _mosi  = _sclk = 0;
}

void Adafruit_ILI9341::spiwrite(uint8_t c) {
 80a1afc:	b4f0      	push	{r4, r5, r6, r7}

  //Serial.print("0x"); Serial.print(c, HEX); Serial.print(", ");

  if (hwSPI) {
 80a1afe:	f890 302a 	ldrb.w	r3, [r0, #42]	; 0x2a
  _rst  = rst;
  hwSPI = true;
  _mosi  = _sclk = 0;
}

void Adafruit_ILI9341::spiwrite(uint8_t c) {
 80a1b02:	460d      	mov	r5, r1

  //Serial.print("0x"); Serial.print(c, HEX); Serial.print(", ");

  if (hwSPI) {
 80a1b04:	b11b      	cbz	r3, 80a1b0e <_ZN16Adafruit_ILI93418spiwriteEh+0x12>
      //digitalWrite(_sclk, LOW);
      *clkport &= ~clkpinmask;
    }
#endif
  }
}
 80a1b06:	bcf0      	pop	{r4, r5, r6, r7}
    while(!(SPSR & _BV(SPIF)));
  #ifndef SPI_HAS_TRANSACTION
    SPCR = backupSPCR;
  #endif
#else
    SPI.transfer(c);
 80a1b08:	4817      	ldr	r0, [pc, #92]	; (80a1b68 <_ZN16Adafruit_ILI93418spiwriteEh+0x6c>)
 80a1b0a:	f003 be2d 	b.w	80a5768 <_ZN8SPIClass8transferEh>
inline void pinResetFast(pin_t _pin) __attribute__((always_inline));
inline int32_t pinReadFast(pin_t _pin) __attribute__((always_inline));

inline void pinSetFast(pin_t _pin)
{
    PIN_MAP[_pin].gpio_peripheral->BSRRL = PIN_MAP[_pin].gpio_pin;
 80a1b0e:	4b17      	ldr	r3, [pc, #92]	; (80a1b6c <_ZN16Adafruit_ILI93418spiwriteEh+0x70>)
 80a1b10:	2408      	movs	r4, #8
 80a1b12:	681a      	ldr	r2, [r3, #0]
 80a1b14:	2680      	movs	r6, #128	; 0x80
 80a1b16:	211c      	movs	r1, #28
 80a1b18:	f990 302e 	ldrsb.w	r3, [r0, #46]	; 0x2e
#endif
  } else {
#if defined (PARTICLE)
    for(uint8_t bit = 0x80; bit; bit >>= 1) {
      if(c & bit) {
 80a1b1c:	4235      	tst	r5, r6
 80a1b1e:	b29b      	uxth	r3, r3
 80a1b20:	fb01 f303 	mul.w	r3, r1, r3
 80a1b24:	eb02 0703 	add.w	r7, r2, r3
 80a1b28:	88bf      	ldrh	r7, [r7, #4]
 80a1b2a:	58d3      	ldr	r3, [r2, r3]
#else
    SPI.transfer(c);
#endif
  } else {
#if defined (PARTICLE)
    for(uint8_t bit = 0x80; bit; bit >>= 1) {
 80a1b2c:	ea4f 0656 	mov.w	r6, r6, lsr #1
 80a1b30:	bf14      	ite	ne
 80a1b32:	831f      	strhne	r7, [r3, #24]
}

inline void pinResetFast(pin_t _pin)
{
    PIN_MAP[_pin].gpio_peripheral->BSRRH = PIN_MAP[_pin].gpio_pin;
 80a1b34:	835f      	strheq	r7, [r3, #26]
inline void pinResetFast(pin_t _pin) __attribute__((always_inline));
inline int32_t pinReadFast(pin_t _pin) __attribute__((always_inline));

inline void pinSetFast(pin_t _pin)
{
    PIN_MAP[_pin].gpio_peripheral->BSRRL = PIN_MAP[_pin].gpio_pin;
 80a1b36:	f990 3030 	ldrsb.w	r3, [r0, #48]	; 0x30
 80a1b3a:	3c01      	subs	r4, #1
 80a1b3c:	b29b      	uxth	r3, r3
 80a1b3e:	fb01 f303 	mul.w	r3, r1, r3
 80a1b42:	eb02 0703 	add.w	r7, r2, r3
 80a1b46:	88bf      	ldrh	r7, [r7, #4]
 80a1b48:	58d3      	ldr	r3, [r2, r3]
 80a1b4a:	831f      	strh	r7, [r3, #24]
}

inline void pinResetFast(pin_t _pin)
{
    PIN_MAP[_pin].gpio_peripheral->BSRRH = PIN_MAP[_pin].gpio_pin;
 80a1b4c:	f990 3030 	ldrsb.w	r3, [r0, #48]	; 0x30
 80a1b50:	b29b      	uxth	r3, r3
 80a1b52:	fb01 f303 	mul.w	r3, r1, r3
 80a1b56:	eb02 0703 	add.w	r7, r2, r3
 80a1b5a:	88bf      	ldrh	r7, [r7, #4]
 80a1b5c:	58d3      	ldr	r3, [r2, r3]
 80a1b5e:	835f      	strh	r7, [r3, #26]
 80a1b60:	d1da      	bne.n	80a1b18 <_ZN16Adafruit_ILI93418spiwriteEh+0x1c>
      //digitalWrite(_sclk, LOW);
      *clkport &= ~clkpinmask;
    }
#endif
  }
}
 80a1b62:	bcf0      	pop	{r4, r5, r6, r7}
 80a1b64:	4770      	bx	lr
 80a1b66:	bf00      	nop
 80a1b68:	20001524 	.word	0x20001524
 80a1b6c:	20001050 	.word	0x20001050

080a1b70 <_ZN16Adafruit_ILI934112writecommandEh>:


void Adafruit_ILI9341::writecommand(uint8_t c) {
 80a1b70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a1b72:	f990 302c 	ldrsb.w	r3, [r0, #44]	; 0x2c
 80a1b76:	4606      	mov	r6, r0
 80a1b78:	241c      	movs	r4, #28
 80a1b7a:	b29b      	uxth	r3, r3
 80a1b7c:	4363      	muls	r3, r4
 80a1b7e:	4d11      	ldr	r5, [pc, #68]	; (80a1bc4 <_ZN16Adafruit_ILI934112writecommandEh+0x54>)
 80a1b80:	682a      	ldr	r2, [r5, #0]
 80a1b82:	18d7      	adds	r7, r2, r3
 80a1b84:	88bf      	ldrh	r7, [r7, #4]
 80a1b86:	58d3      	ldr	r3, [r2, r3]
 80a1b88:	835f      	strh	r7, [r3, #26]
 80a1b8a:	f990 3030 	ldrsb.w	r3, [r0, #48]	; 0x30
 80a1b8e:	b29b      	uxth	r3, r3
 80a1b90:	4363      	muls	r3, r4
 80a1b92:	18d7      	adds	r7, r2, r3
 80a1b94:	88bf      	ldrh	r7, [r7, #4]
 80a1b96:	58d3      	ldr	r3, [r2, r3]
 80a1b98:	835f      	strh	r7, [r3, #26]
 80a1b9a:	f990 302b 	ldrsb.w	r3, [r0, #43]	; 0x2b
 80a1b9e:	b29b      	uxth	r3, r3
 80a1ba0:	4363      	muls	r3, r4
 80a1ba2:	18d7      	adds	r7, r2, r3
 80a1ba4:	58d3      	ldr	r3, [r2, r3]
 80a1ba6:	88ba      	ldrh	r2, [r7, #4]
 80a1ba8:	835a      	strh	r2, [r3, #26]
  digitalWrite(_dc, LOW);
  digitalWrite(_sclk, LOW);
  digitalWrite(_cs, LOW);
#endif

  spiwrite(c);
 80a1baa:	f7ff ffa7 	bl	80a1afc <_ZN16Adafruit_ILI93418spiwriteEh>
inline void pinResetFast(pin_t _pin) __attribute__((always_inline));
inline int32_t pinReadFast(pin_t _pin) __attribute__((always_inline));

inline void pinSetFast(pin_t _pin)
{
    PIN_MAP[_pin].gpio_peripheral->BSRRL = PIN_MAP[_pin].gpio_pin;
 80a1bae:	f996 302b 	ldrsb.w	r3, [r6, #43]	; 0x2b
 80a1bb2:	b29b      	uxth	r3, r3
 80a1bb4:	435c      	muls	r4, r3
 80a1bb6:	682b      	ldr	r3, [r5, #0]
 80a1bb8:	191a      	adds	r2, r3, r4
 80a1bba:	8892      	ldrh	r2, [r2, #4]
 80a1bbc:	591b      	ldr	r3, [r3, r4]
 80a1bbe:	831a      	strh	r2, [r3, #24]
 80a1bc0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a1bc2:	bf00      	nop
 80a1bc4:	20001050 	.word	0x20001050

080a1bc8 <_ZN16Adafruit_ILI934113invertDisplayEb>:
  }
  if (hwSPI) spi_end();
}


void Adafruit_ILI9341::invertDisplay(boolean i) {
 80a1bc8:	b530      	push	{r4, r5, lr}
  if (hwSPI) spi_begin();
 80a1bca:	f890 302a 	ldrb.w	r3, [r0, #42]	; 0x2a
  }
  if (hwSPI) spi_end();
}


void Adafruit_ILI9341::invertDisplay(boolean i) {
 80a1bce:	b085      	sub	sp, #20
 80a1bd0:	4604      	mov	r4, r0
 80a1bd2:	460d      	mov	r5, r1
  if (hwSPI) spi_begin();
 80a1bd4:	b17b      	cbz	r3, 80a1bf6 <_ZN16Adafruit_ILI934113invertDisplayEb+0x2e>
public:
  __SPISettings(uint32_t clock, uint8_t bitOrder, uint8_t dataMode)
    : default_{false},
      clock_{clock},
      bitOrder_{bitOrder},
      dataMode_{dataMode}
 80a1bd6:	4b0f      	ldr	r3, [pc, #60]	; (80a1c14 <_ZN16Adafruit_ILI934113invertDisplayEb+0x4c>)
 80a1bd8:	4a0f      	ldr	r2, [pc, #60]	; (80a1c18 <_ZN16Adafruit_ILI934113invertDisplayEb+0x50>)
 80a1bda:	9300      	str	r3, [sp, #0]
 80a1bdc:	9202      	str	r2, [sp, #8]
 80a1bde:	2300      	movs	r3, #0
 80a1be0:	2201      	movs	r2, #1
#ifdef SPI_HAS_TRANSACTION
static inline void spi_begin(void) __attribute__((always_inline));
static inline void spi_begin(void) {
#if defined (PARTICLE)
  // max speed!
  SPI.beginTransaction(SPISettings(30000000, MSBFIRST, SPI_MODE0));
 80a1be2:	4669      	mov	r1, sp
 80a1be4:	480d      	ldr	r0, [pc, #52]	; (80a1c1c <_ZN16Adafruit_ILI934113invertDisplayEb+0x54>)
 80a1be6:	f88d 3004 	strb.w	r3, [sp, #4]
 80a1bea:	f88d 200c 	strb.w	r2, [sp, #12]
 80a1bee:	f88d 300d 	strb.w	r3, [sp, #13]
 80a1bf2:	f003 fd13 	bl	80a561c <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE>
}


void Adafruit_ILI9341::invertDisplay(boolean i) {
  if (hwSPI) spi_begin();
  writecommand(i ? ILI9341_INVON : ILI9341_INVOFF);
 80a1bf6:	2d00      	cmp	r5, #0
 80a1bf8:	bf14      	ite	ne
 80a1bfa:	2121      	movne	r1, #33	; 0x21
 80a1bfc:	2120      	moveq	r1, #32
 80a1bfe:	4620      	mov	r0, r4
 80a1c00:	f7ff ffb6 	bl	80a1b70 <_ZN16Adafruit_ILI934112writecommandEh>
  if (hwSPI) spi_end();
 80a1c04:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
 80a1c08:	b113      	cbz	r3, 80a1c10 <_ZN16Adafruit_ILI934113invertDisplayEb+0x48>
  SPI.beginTransaction(SPISettings(24000000, MSBFIRST, SPI_MODE0));
#endif
}
static inline void spi_end(void) __attribute__((always_inline));
static inline void spi_end(void) {
  SPI.endTransaction();
 80a1c0a:	4804      	ldr	r0, [pc, #16]	; (80a1c1c <_ZN16Adafruit_ILI934113invertDisplayEb+0x54>)
 80a1c0c:	f003 fcdf 	bl	80a55ce <_ZN8SPIClass14endTransactionEv>

void Adafruit_ILI9341::invertDisplay(boolean i) {
  if (hwSPI) spi_begin();
  writecommand(i ? ILI9341_INVON : ILI9341_INVOFF);
  if (hwSPI) spi_end();
}
 80a1c10:	b005      	add	sp, #20
 80a1c12:	bd30      	pop	{r4, r5, pc}
 80a1c14:	080a852c 	.word	0x080a852c
 80a1c18:	01c9c380 	.word	0x01c9c380
 80a1c1c:	20001524 	.word	0x20001524

080a1c20 <_ZN16Adafruit_ILI93419writedataEh>:
  digitalWrite(_cs, HIGH);
#endif
}


void Adafruit_ILI9341::writedata(uint8_t c) {
 80a1c20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a1c22:	4606      	mov	r6, r0
 80a1c24:	f990 302c 	ldrsb.w	r3, [r0, #44]	; 0x2c
 80a1c28:	241c      	movs	r4, #28
 80a1c2a:	b29b      	uxth	r3, r3
 80a1c2c:	4363      	muls	r3, r4
 80a1c2e:	4d0d      	ldr	r5, [pc, #52]	; (80a1c64 <_ZN16Adafruit_ILI93419writedataEh+0x44>)
 80a1c30:	682a      	ldr	r2, [r5, #0]
 80a1c32:	18d7      	adds	r7, r2, r3
 80a1c34:	88bf      	ldrh	r7, [r7, #4]
 80a1c36:	58d3      	ldr	r3, [r2, r3]
 80a1c38:	831f      	strh	r7, [r3, #24]
}

inline void pinResetFast(pin_t _pin)
{
    PIN_MAP[_pin].gpio_peripheral->BSRRH = PIN_MAP[_pin].gpio_pin;
 80a1c3a:	f990 302b 	ldrsb.w	r3, [r0, #43]	; 0x2b
 80a1c3e:	b29b      	uxth	r3, r3
 80a1c40:	4363      	muls	r3, r4
 80a1c42:	18d7      	adds	r7, r2, r3
 80a1c44:	58d3      	ldr	r3, [r2, r3]
 80a1c46:	88ba      	ldrh	r2, [r7, #4]
 80a1c48:	835a      	strh	r2, [r3, #26]
#else
  digitalWrite(_dc, HIGH);
  digitalWrite(_cs, LOW);
#endif

  spiwrite(c);
 80a1c4a:	f7ff ff57 	bl	80a1afc <_ZN16Adafruit_ILI93418spiwriteEh>
inline void pinResetFast(pin_t _pin) __attribute__((always_inline));
inline int32_t pinReadFast(pin_t _pin) __attribute__((always_inline));

inline void pinSetFast(pin_t _pin)
{
    PIN_MAP[_pin].gpio_peripheral->BSRRL = PIN_MAP[_pin].gpio_pin;
 80a1c4e:	f996 302b 	ldrsb.w	r3, [r6, #43]	; 0x2b
 80a1c52:	b29b      	uxth	r3, r3
 80a1c54:	435c      	muls	r4, r3
 80a1c56:	682b      	ldr	r3, [r5, #0]
 80a1c58:	191a      	adds	r2, r3, r4
 80a1c5a:	8892      	ldrh	r2, [r2, #4]
 80a1c5c:	591b      	ldr	r3, [r3, r4]
 80a1c5e:	831a      	strh	r2, [r3, #24]
 80a1c60:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a1c62:	bf00      	nop
 80a1c64:	20001050 	.word	0x20001050

080a1c68 <_ZN16Adafruit_ILI93415beginEv>:
    }
  }
}


void Adafruit_ILI9341::begin(void) {
 80a1c68:	b530      	push	{r4, r5, lr}
 80a1c6a:	4604      	mov	r4, r0
  if (_rst > 0) {
 80a1c6c:	f990 002d 	ldrsb.w	r0, [r0, #45]	; 0x2d
    }
  }
}


void Adafruit_ILI9341::begin(void) {
 80a1c70:	b085      	sub	sp, #20
  if (_rst > 0) {
 80a1c72:	2800      	cmp	r0, #0
 80a1c74:	dd09      	ble.n	80a1c8a <_ZN16Adafruit_ILI93415beginEv+0x22>
    pinMode(_rst, OUTPUT);
 80a1c76:	2101      	movs	r1, #1
 80a1c78:	b280      	uxth	r0, r0
 80a1c7a:	f004 fffb 	bl	80a6c74 <pinMode>
    digitalWrite(_rst, LOW);
 80a1c7e:	f994 002d 	ldrsb.w	r0, [r4, #45]	; 0x2d
 80a1c82:	2100      	movs	r1, #0
 80a1c84:	b280      	uxth	r0, r0
 80a1c86:	f005 f806 	bl	80a6c96 <digitalWrite>
  }

  pinMode(_dc, OUTPUT);
 80a1c8a:	f994 002c 	ldrsb.w	r0, [r4, #44]	; 0x2c
 80a1c8e:	2101      	movs	r1, #1
 80a1c90:	b280      	uxth	r0, r0
 80a1c92:	f004 ffef 	bl	80a6c74 <pinMode>
  pinMode(_cs, OUTPUT);
 80a1c96:	f994 002b 	ldrsb.w	r0, [r4, #43]	; 0x2b
 80a1c9a:	2101      	movs	r1, #1
 80a1c9c:	b280      	uxth	r0, r0
 80a1c9e:	f004 ffe9 	bl	80a6c74 <pinMode>
  cspinmask = digitalPinToBitMask(_cs);
  dcport    = portOutputRegister(digitalPinToPort(_dc));
  dcpinmask = digitalPinToBitMask(_dc);
#endif

  if(hwSPI) { // Using hardware SPI
 80a1ca2:	f894 502a 	ldrb.w	r5, [r4, #42]	; 0x2a
 80a1ca6:	b135      	cbz	r5, 80a1cb6 <_ZN16Adafruit_ILI93415beginEv+0x4e>
#if defined(PARTICLE)
    SPI.begin(_cs);
 80a1ca8:	f994 102b 	ldrsb.w	r1, [r4, #43]	; 0x2b
 80a1cac:	48e1      	ldr	r0, [pc, #900]	; (80a2034 <_ZN16Adafruit_ILI93415beginEv+0x3cc>)
 80a1cae:	b289      	uxth	r1, r1
 80a1cb0:	f003 fc81 	bl	80a55b6 <_ZN8SPIClass5beginEt>
 80a1cb4:	e011      	b.n	80a1cda <_ZN16Adafruit_ILI93415beginEv+0x72>
  #elif defined (__arm__)
    SPI.setClockDivider(11); // 8-ish MHz (full! speed!)
  #endif
#endif
  } else {
    pinMode(_sclk, OUTPUT);
 80a1cb6:	f994 0030 	ldrsb.w	r0, [r4, #48]	; 0x30
 80a1cba:	2101      	movs	r1, #1
 80a1cbc:	b280      	uxth	r0, r0
 80a1cbe:	f004 ffd9 	bl	80a6c74 <pinMode>
    pinMode(_mosi, OUTPUT);
 80a1cc2:	f994 002e 	ldrsb.w	r0, [r4, #46]	; 0x2e
 80a1cc6:	2101      	movs	r1, #1
 80a1cc8:	b280      	uxth	r0, r0
 80a1cca:	f004 ffd3 	bl	80a6c74 <pinMode>
    pinMode(_miso, INPUT);
 80a1cce:	f994 002f 	ldrsb.w	r0, [r4, #47]	; 0x2f
 80a1cd2:	4629      	mov	r1, r5
 80a1cd4:	b280      	uxth	r0, r0
 80a1cd6:	f004 ffcd 	bl	80a6c74 <pinMode>
    *mosiport  &= ~mosipinmask;
#endif
  }

  // toggle RST low to reset
  if (_rst > 0) {
 80a1cda:	f994 002d 	ldrsb.w	r0, [r4, #45]	; 0x2d
 80a1cde:	2800      	cmp	r0, #0
 80a1ce0:	dd18      	ble.n	80a1d14 <_ZN16Adafruit_ILI93415beginEv+0xac>
    digitalWrite(_rst, HIGH);
 80a1ce2:	2101      	movs	r1, #1
 80a1ce4:	b280      	uxth	r0, r0
 80a1ce6:	f004 ffd6 	bl	80a6c96 <digitalWrite>
    delay(5);
 80a1cea:	2005      	movs	r0, #5
 80a1cec:	f004 f806 	bl	80a5cfc <delay>
    digitalWrite(_rst, LOW);
 80a1cf0:	f994 002d 	ldrsb.w	r0, [r4, #45]	; 0x2d
 80a1cf4:	2100      	movs	r1, #0
 80a1cf6:	b280      	uxth	r0, r0
 80a1cf8:	f004 ffcd 	bl	80a6c96 <digitalWrite>
    delay(20);
 80a1cfc:	2014      	movs	r0, #20
 80a1cfe:	f003 fffd 	bl	80a5cfc <delay>
    digitalWrite(_rst, HIGH);
 80a1d02:	f994 002d 	ldrsb.w	r0, [r4, #45]	; 0x2d
 80a1d06:	2101      	movs	r1, #1
 80a1d08:	b280      	uxth	r0, r0
 80a1d0a:	f004 ffc4 	bl	80a6c96 <digitalWrite>
    delay(150);
 80a1d0e:	2096      	movs	r0, #150	; 0x96
 80a1d10:	f003 fff4 	bl	80a5cfc <delay>
  x = readcommand8(ILI9341_RDSELFDIAG);
  Serial.print("\nSelf Diagnostic: 0x"); Serial.println(x, HEX);
*/
  //if(cmdList) commandList(cmdList);
  
  if (hwSPI) spi_begin();
 80a1d14:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
 80a1d18:	b17b      	cbz	r3, 80a1d3a <_ZN16Adafruit_ILI93415beginEv+0xd2>
 80a1d1a:	4bc7      	ldr	r3, [pc, #796]	; (80a2038 <_ZN16Adafruit_ILI93415beginEv+0x3d0>)
 80a1d1c:	4ac7      	ldr	r2, [pc, #796]	; (80a203c <_ZN16Adafruit_ILI93415beginEv+0x3d4>)
 80a1d1e:	9300      	str	r3, [sp, #0]
 80a1d20:	9202      	str	r2, [sp, #8]
 80a1d22:	2300      	movs	r3, #0
 80a1d24:	2201      	movs	r2, #1
#ifdef SPI_HAS_TRANSACTION
static inline void spi_begin(void) __attribute__((always_inline));
static inline void spi_begin(void) {
#if defined (PARTICLE)
  // max speed!
  SPI.beginTransaction(SPISettings(30000000, MSBFIRST, SPI_MODE0));
 80a1d26:	4669      	mov	r1, sp
 80a1d28:	48c2      	ldr	r0, [pc, #776]	; (80a2034 <_ZN16Adafruit_ILI93415beginEv+0x3cc>)
 80a1d2a:	f88d 3004 	strb.w	r3, [sp, #4]
 80a1d2e:	f88d 200c 	strb.w	r2, [sp, #12]
 80a1d32:	f88d 300d 	strb.w	r3, [sp, #13]
 80a1d36:	f003 fc71 	bl	80a561c <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE>
  Serial.print("\nSelf Diagnostic: 0x"); Serial.println(x, HEX);
*/
  //if(cmdList) commandList(cmdList);
  
  if (hwSPI) spi_begin();
  writecommand(0xEF);
 80a1d3a:	21ef      	movs	r1, #239	; 0xef
 80a1d3c:	4620      	mov	r0, r4
 80a1d3e:	f7ff ff17 	bl	80a1b70 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x03);
 80a1d42:	2103      	movs	r1, #3
 80a1d44:	4620      	mov	r0, r4
 80a1d46:	f7ff ff6b 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x80);
 80a1d4a:	2180      	movs	r1, #128	; 0x80
 80a1d4c:	4620      	mov	r0, r4
 80a1d4e:	f7ff ff67 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x02);
 80a1d52:	2102      	movs	r1, #2
 80a1d54:	4620      	mov	r0, r4
 80a1d56:	f7ff ff63 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>

  writecommand(0xCF);  
 80a1d5a:	21cf      	movs	r1, #207	; 0xcf
 80a1d5c:	4620      	mov	r0, r4
 80a1d5e:	f7ff ff07 	bl	80a1b70 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x00); 
 80a1d62:	2100      	movs	r1, #0
 80a1d64:	4620      	mov	r0, r4
 80a1d66:	f7ff ff5b 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0XC1); 
 80a1d6a:	21c1      	movs	r1, #193	; 0xc1
 80a1d6c:	4620      	mov	r0, r4
 80a1d6e:	f7ff ff57 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0X30); 
 80a1d72:	2130      	movs	r1, #48	; 0x30
 80a1d74:	4620      	mov	r0, r4
 80a1d76:	f7ff ff53 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>

  writecommand(0xED);  
 80a1d7a:	21ed      	movs	r1, #237	; 0xed
 80a1d7c:	4620      	mov	r0, r4
 80a1d7e:	f7ff fef7 	bl	80a1b70 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x64); 
 80a1d82:	2164      	movs	r1, #100	; 0x64
 80a1d84:	4620      	mov	r0, r4
 80a1d86:	f7ff ff4b 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x03); 
 80a1d8a:	2103      	movs	r1, #3
 80a1d8c:	4620      	mov	r0, r4
 80a1d8e:	f7ff ff47 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0X12); 
 80a1d92:	2112      	movs	r1, #18
 80a1d94:	4620      	mov	r0, r4
 80a1d96:	f7ff ff43 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0X81); 
 80a1d9a:	2181      	movs	r1, #129	; 0x81
 80a1d9c:	4620      	mov	r0, r4
 80a1d9e:	f7ff ff3f 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
 
  writecommand(0xE8);  
 80a1da2:	21e8      	movs	r1, #232	; 0xe8
 80a1da4:	4620      	mov	r0, r4
 80a1da6:	f7ff fee3 	bl	80a1b70 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x85); 
 80a1daa:	2185      	movs	r1, #133	; 0x85
 80a1dac:	4620      	mov	r0, r4
 80a1dae:	f7ff ff37 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x00); 
 80a1db2:	2100      	movs	r1, #0
 80a1db4:	4620      	mov	r0, r4
 80a1db6:	f7ff ff33 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x78); 
 80a1dba:	2178      	movs	r1, #120	; 0x78
 80a1dbc:	4620      	mov	r0, r4
 80a1dbe:	f7ff ff2f 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>

  writecommand(0xCB);  
 80a1dc2:	21cb      	movs	r1, #203	; 0xcb
 80a1dc4:	4620      	mov	r0, r4
 80a1dc6:	f7ff fed3 	bl	80a1b70 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x39); 
 80a1dca:	2139      	movs	r1, #57	; 0x39
 80a1dcc:	4620      	mov	r0, r4
 80a1dce:	f7ff ff27 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x2C); 
 80a1dd2:	212c      	movs	r1, #44	; 0x2c
 80a1dd4:	4620      	mov	r0, r4
 80a1dd6:	f7ff ff23 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x00); 
 80a1dda:	2100      	movs	r1, #0
 80a1ddc:	4620      	mov	r0, r4
 80a1dde:	f7ff ff1f 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x34); 
 80a1de2:	2134      	movs	r1, #52	; 0x34
 80a1de4:	4620      	mov	r0, r4
 80a1de6:	f7ff ff1b 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x02); 
 80a1dea:	2102      	movs	r1, #2
 80a1dec:	4620      	mov	r0, r4
 80a1dee:	f7ff ff17 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
 
  writecommand(0xF7);  
 80a1df2:	21f7      	movs	r1, #247	; 0xf7
 80a1df4:	4620      	mov	r0, r4
 80a1df6:	f7ff febb 	bl	80a1b70 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x20); 
 80a1dfa:	2120      	movs	r1, #32
 80a1dfc:	4620      	mov	r0, r4
 80a1dfe:	f7ff ff0f 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>

  writecommand(0xEA);  
 80a1e02:	21ea      	movs	r1, #234	; 0xea
 80a1e04:	4620      	mov	r0, r4
 80a1e06:	f7ff feb3 	bl	80a1b70 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x00); 
 80a1e0a:	2100      	movs	r1, #0
 80a1e0c:	4620      	mov	r0, r4
 80a1e0e:	f7ff ff07 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x00); 
 80a1e12:	2100      	movs	r1, #0
 80a1e14:	4620      	mov	r0, r4
 80a1e16:	f7ff ff03 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
 
  writecommand(ILI9341_PWCTR1);    //Power control 
 80a1e1a:	21c0      	movs	r1, #192	; 0xc0
 80a1e1c:	4620      	mov	r0, r4
 80a1e1e:	f7ff fea7 	bl	80a1b70 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x23);   //VRH[5:0] 
 80a1e22:	2123      	movs	r1, #35	; 0x23
 80a1e24:	4620      	mov	r0, r4
 80a1e26:	f7ff fefb 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
 
  writecommand(ILI9341_PWCTR2);    //Power control 
 80a1e2a:	21c1      	movs	r1, #193	; 0xc1
 80a1e2c:	4620      	mov	r0, r4
 80a1e2e:	f7ff fe9f 	bl	80a1b70 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x10);   //SAP[2:0];BT[3:0] 
 80a1e32:	2110      	movs	r1, #16
 80a1e34:	4620      	mov	r0, r4
 80a1e36:	f7ff fef3 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
 
  writecommand(ILI9341_VMCTR1);    //VCM control 
 80a1e3a:	21c5      	movs	r1, #197	; 0xc5
 80a1e3c:	4620      	mov	r0, r4
 80a1e3e:	f7ff fe97 	bl	80a1b70 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x3e); //¶Ô±È¶Èµ÷½Ú
 80a1e42:	213e      	movs	r1, #62	; 0x3e
 80a1e44:	4620      	mov	r0, r4
 80a1e46:	f7ff feeb 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x28); 
 80a1e4a:	2128      	movs	r1, #40	; 0x28
 80a1e4c:	4620      	mov	r0, r4
 80a1e4e:	f7ff fee7 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  
  writecommand(ILI9341_VMCTR2);    //VCM control2 
 80a1e52:	21c7      	movs	r1, #199	; 0xc7
 80a1e54:	4620      	mov	r0, r4
 80a1e56:	f7ff fe8b 	bl	80a1b70 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x86);  //--
 80a1e5a:	2186      	movs	r1, #134	; 0x86
 80a1e5c:	4620      	mov	r0, r4
 80a1e5e:	f7ff fedf 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
 
  writecommand(ILI9341_MADCTL);    // Memory Access Control 
 80a1e62:	2136      	movs	r1, #54	; 0x36
 80a1e64:	4620      	mov	r0, r4
 80a1e66:	f7ff fe83 	bl	80a1b70 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x48);
 80a1e6a:	2148      	movs	r1, #72	; 0x48
 80a1e6c:	4620      	mov	r0, r4
 80a1e6e:	f7ff fed7 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>

  writecommand(ILI9341_PIXFMT);    
 80a1e72:	213a      	movs	r1, #58	; 0x3a
 80a1e74:	4620      	mov	r0, r4
 80a1e76:	f7ff fe7b 	bl	80a1b70 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x55); 
 80a1e7a:	2155      	movs	r1, #85	; 0x55
 80a1e7c:	4620      	mov	r0, r4
 80a1e7e:	f7ff fecf 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  
  writecommand(ILI9341_FRMCTR1);    
 80a1e82:	21b1      	movs	r1, #177	; 0xb1
 80a1e84:	4620      	mov	r0, r4
 80a1e86:	f7ff fe73 	bl	80a1b70 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x00);  
 80a1e8a:	2100      	movs	r1, #0
 80a1e8c:	4620      	mov	r0, r4
 80a1e8e:	f7ff fec7 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x18); 
 80a1e92:	2118      	movs	r1, #24
 80a1e94:	4620      	mov	r0, r4
 80a1e96:	f7ff fec3 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
 
  writecommand(ILI9341_DFUNCTR);    // Display Function Control 
 80a1e9a:	21b6      	movs	r1, #182	; 0xb6
 80a1e9c:	4620      	mov	r0, r4
 80a1e9e:	f7ff fe67 	bl	80a1b70 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x08); 
 80a1ea2:	2108      	movs	r1, #8
 80a1ea4:	4620      	mov	r0, r4
 80a1ea6:	f7ff febb 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x82);
 80a1eaa:	2182      	movs	r1, #130	; 0x82
 80a1eac:	4620      	mov	r0, r4
 80a1eae:	f7ff feb7 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x27);  
 80a1eb2:	2127      	movs	r1, #39	; 0x27
 80a1eb4:	4620      	mov	r0, r4
 80a1eb6:	f7ff feb3 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
 
  writecommand(0xF2);    // 3Gamma Function Disable 
 80a1eba:	21f2      	movs	r1, #242	; 0xf2
 80a1ebc:	4620      	mov	r0, r4
 80a1ebe:	f7ff fe57 	bl	80a1b70 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x00); 
 80a1ec2:	2100      	movs	r1, #0
 80a1ec4:	4620      	mov	r0, r4
 80a1ec6:	f7ff feab 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
 
  writecommand(ILI9341_GAMMASET);    //Gamma curve selected 
 80a1eca:	2126      	movs	r1, #38	; 0x26
 80a1ecc:	4620      	mov	r0, r4
 80a1ece:	f7ff fe4f 	bl	80a1b70 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x01); 
 80a1ed2:	2101      	movs	r1, #1
 80a1ed4:	4620      	mov	r0, r4
 80a1ed6:	f7ff fea3 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
 
  writecommand(ILI9341_GMCTRP1);    //Set Gamma 
 80a1eda:	21e0      	movs	r1, #224	; 0xe0
 80a1edc:	4620      	mov	r0, r4
 80a1ede:	f7ff fe47 	bl	80a1b70 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x0F); 
 80a1ee2:	210f      	movs	r1, #15
 80a1ee4:	4620      	mov	r0, r4
 80a1ee6:	f7ff fe9b 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x31); 
 80a1eea:	2131      	movs	r1, #49	; 0x31
 80a1eec:	4620      	mov	r0, r4
 80a1eee:	f7ff fe97 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x2B); 
 80a1ef2:	212b      	movs	r1, #43	; 0x2b
 80a1ef4:	4620      	mov	r0, r4
 80a1ef6:	f7ff fe93 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x0C); 
 80a1efa:	210c      	movs	r1, #12
 80a1efc:	4620      	mov	r0, r4
 80a1efe:	f7ff fe8f 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x0E); 
 80a1f02:	210e      	movs	r1, #14
 80a1f04:	4620      	mov	r0, r4
 80a1f06:	f7ff fe8b 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x08); 
 80a1f0a:	2108      	movs	r1, #8
 80a1f0c:	4620      	mov	r0, r4
 80a1f0e:	f7ff fe87 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x4E); 
 80a1f12:	214e      	movs	r1, #78	; 0x4e
 80a1f14:	4620      	mov	r0, r4
 80a1f16:	f7ff fe83 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0xF1); 
 80a1f1a:	21f1      	movs	r1, #241	; 0xf1
 80a1f1c:	4620      	mov	r0, r4
 80a1f1e:	f7ff fe7f 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x37); 
 80a1f22:	2137      	movs	r1, #55	; 0x37
 80a1f24:	4620      	mov	r0, r4
 80a1f26:	f7ff fe7b 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x07); 
 80a1f2a:	2107      	movs	r1, #7
 80a1f2c:	4620      	mov	r0, r4
 80a1f2e:	f7ff fe77 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x10); 
 80a1f32:	2110      	movs	r1, #16
 80a1f34:	4620      	mov	r0, r4
 80a1f36:	f7ff fe73 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x03); 
 80a1f3a:	2103      	movs	r1, #3
 80a1f3c:	4620      	mov	r0, r4
 80a1f3e:	f7ff fe6f 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x0E); 
 80a1f42:	210e      	movs	r1, #14
 80a1f44:	4620      	mov	r0, r4
 80a1f46:	f7ff fe6b 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x09); 
 80a1f4a:	2109      	movs	r1, #9
 80a1f4c:	4620      	mov	r0, r4
 80a1f4e:	f7ff fe67 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x00); 
 80a1f52:	2100      	movs	r1, #0
 80a1f54:	4620      	mov	r0, r4
 80a1f56:	f7ff fe63 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  
  writecommand(ILI9341_GMCTRN1);    //Set Gamma 
 80a1f5a:	21e1      	movs	r1, #225	; 0xe1
 80a1f5c:	4620      	mov	r0, r4
 80a1f5e:	f7ff fe07 	bl	80a1b70 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x00); 
 80a1f62:	2100      	movs	r1, #0
 80a1f64:	4620      	mov	r0, r4
 80a1f66:	f7ff fe5b 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x0E); 
 80a1f6a:	210e      	movs	r1, #14
 80a1f6c:	4620      	mov	r0, r4
 80a1f6e:	f7ff fe57 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x14); 
 80a1f72:	2114      	movs	r1, #20
 80a1f74:	4620      	mov	r0, r4
 80a1f76:	f7ff fe53 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x03); 
 80a1f7a:	2103      	movs	r1, #3
 80a1f7c:	4620      	mov	r0, r4
 80a1f7e:	f7ff fe4f 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x11); 
 80a1f82:	2111      	movs	r1, #17
 80a1f84:	4620      	mov	r0, r4
 80a1f86:	f7ff fe4b 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x07); 
 80a1f8a:	2107      	movs	r1, #7
 80a1f8c:	4620      	mov	r0, r4
 80a1f8e:	f7ff fe47 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x31); 
 80a1f92:	2131      	movs	r1, #49	; 0x31
 80a1f94:	4620      	mov	r0, r4
 80a1f96:	f7ff fe43 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0xC1); 
 80a1f9a:	21c1      	movs	r1, #193	; 0xc1
 80a1f9c:	4620      	mov	r0, r4
 80a1f9e:	f7ff fe3f 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x48); 
 80a1fa2:	2148      	movs	r1, #72	; 0x48
 80a1fa4:	4620      	mov	r0, r4
 80a1fa6:	f7ff fe3b 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x08); 
 80a1faa:	2108      	movs	r1, #8
 80a1fac:	4620      	mov	r0, r4
 80a1fae:	f7ff fe37 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x0F); 
 80a1fb2:	210f      	movs	r1, #15
 80a1fb4:	4620      	mov	r0, r4
 80a1fb6:	f7ff fe33 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x0C); 
 80a1fba:	210c      	movs	r1, #12
 80a1fbc:	4620      	mov	r0, r4
 80a1fbe:	f7ff fe2f 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x31); 
 80a1fc2:	2131      	movs	r1, #49	; 0x31
 80a1fc4:	4620      	mov	r0, r4
 80a1fc6:	f7ff fe2b 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x36); 
 80a1fca:	2136      	movs	r1, #54	; 0x36
 80a1fcc:	4620      	mov	r0, r4
 80a1fce:	f7ff fe27 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x0F); 
 80a1fd2:	210f      	movs	r1, #15
 80a1fd4:	4620      	mov	r0, r4
 80a1fd6:	f7ff fe23 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>

  writecommand(ILI9341_SLPOUT);    //Exit Sleep 
 80a1fda:	2111      	movs	r1, #17
 80a1fdc:	4620      	mov	r0, r4
 80a1fde:	f7ff fdc7 	bl	80a1b70 <_ZN16Adafruit_ILI934112writecommandEh>
  if (hwSPI) spi_end();
 80a1fe2:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
 80a1fe6:	b113      	cbz	r3, 80a1fee <_ZN16Adafruit_ILI93415beginEv+0x386>
  SPI.beginTransaction(SPISettings(24000000, MSBFIRST, SPI_MODE0));
#endif
}
static inline void spi_end(void) __attribute__((always_inline));
static inline void spi_end(void) {
  SPI.endTransaction();
 80a1fe8:	4812      	ldr	r0, [pc, #72]	; (80a2034 <_ZN16Adafruit_ILI93415beginEv+0x3cc>)
 80a1fea:	f003 faf0 	bl	80a55ce <_ZN8SPIClass14endTransactionEv>
  writedata(0x36); 
  writedata(0x0F); 

  writecommand(ILI9341_SLPOUT);    //Exit Sleep 
  if (hwSPI) spi_end();
  delay(120); 		
 80a1fee:	2078      	movs	r0, #120	; 0x78
 80a1ff0:	f003 fe84 	bl	80a5cfc <delay>
  if (hwSPI) spi_begin();
 80a1ff4:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
 80a1ff8:	b17b      	cbz	r3, 80a201a <_ZN16Adafruit_ILI93415beginEv+0x3b2>
 80a1ffa:	4b0f      	ldr	r3, [pc, #60]	; (80a2038 <_ZN16Adafruit_ILI93415beginEv+0x3d0>)
 80a1ffc:	4a0f      	ldr	r2, [pc, #60]	; (80a203c <_ZN16Adafruit_ILI93415beginEv+0x3d4>)
 80a1ffe:	9300      	str	r3, [sp, #0]
 80a2000:	9202      	str	r2, [sp, #8]
 80a2002:	2300      	movs	r3, #0
 80a2004:	2201      	movs	r2, #1
#ifdef SPI_HAS_TRANSACTION
static inline void spi_begin(void) __attribute__((always_inline));
static inline void spi_begin(void) {
#if defined (PARTICLE)
  // max speed!
  SPI.beginTransaction(SPISettings(30000000, MSBFIRST, SPI_MODE0));
 80a2006:	4669      	mov	r1, sp
 80a2008:	480a      	ldr	r0, [pc, #40]	; (80a2034 <_ZN16Adafruit_ILI93415beginEv+0x3cc>)
 80a200a:	f88d 3004 	strb.w	r3, [sp, #4]
 80a200e:	f88d 200c 	strb.w	r2, [sp, #12]
 80a2012:	f88d 300d 	strb.w	r3, [sp, #13]
 80a2016:	f003 fb01 	bl	80a561c <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE>

  writecommand(ILI9341_SLPOUT);    //Exit Sleep 
  if (hwSPI) spi_end();
  delay(120); 		
  if (hwSPI) spi_begin();
  writecommand(ILI9341_DISPON);    //Display on 
 80a201a:	2129      	movs	r1, #41	; 0x29
 80a201c:	4620      	mov	r0, r4
 80a201e:	f7ff fda7 	bl	80a1b70 <_ZN16Adafruit_ILI934112writecommandEh>
  if (hwSPI) spi_end();
 80a2022:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
 80a2026:	b113      	cbz	r3, 80a202e <_ZN16Adafruit_ILI93415beginEv+0x3c6>
  SPI.beginTransaction(SPISettings(24000000, MSBFIRST, SPI_MODE0));
#endif
}
static inline void spi_end(void) __attribute__((always_inline));
static inline void spi_end(void) {
  SPI.endTransaction();
 80a2028:	4802      	ldr	r0, [pc, #8]	; (80a2034 <_ZN16Adafruit_ILI93415beginEv+0x3cc>)
 80a202a:	f003 fad0 	bl	80a55ce <_ZN8SPIClass14endTransactionEv>
  delay(120); 		
  if (hwSPI) spi_begin();
  writecommand(ILI9341_DISPON);    //Display on 
  if (hwSPI) spi_end();

}
 80a202e:	b005      	add	sp, #20
 80a2030:	bd30      	pop	{r4, r5, pc}
 80a2032:	bf00      	nop
 80a2034:	20001524 	.word	0x20001524
 80a2038:	080a852c 	.word	0x080a852c
 80a203c:	01c9c380 	.word	0x01c9c380

080a2040 <_ZN16Adafruit_ILI934113setAddrWindowEtttt>:


void Adafruit_ILI9341::setAddrWindow(uint16_t x0, uint16_t y0, uint16_t x1,
 uint16_t y1) {
 80a2040:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a2044:	4604      	mov	r4, r0
 80a2046:	4688      	mov	r8, r1
 80a2048:	461f      	mov	r7, r3
 80a204a:	4616      	mov	r6, r2

  writecommand(ILI9341_CASET); // Column addr set
 80a204c:	212a      	movs	r1, #42	; 0x2a

}


void Adafruit_ILI9341::setAddrWindow(uint16_t x0, uint16_t y0, uint16_t x1,
 uint16_t y1) {
 80a204e:	f8bd 5018 	ldrh.w	r5, [sp, #24]

  writecommand(ILI9341_CASET); // Column addr set
 80a2052:	f7ff fd8d 	bl	80a1b70 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(x0 >> 8);
 80a2056:	ea4f 2118 	mov.w	r1, r8, lsr #8
 80a205a:	4620      	mov	r0, r4
 80a205c:	f7ff fde0 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(x0 & 0xFF);     // XSTART 
 80a2060:	fa5f f188 	uxtb.w	r1, r8
 80a2064:	4620      	mov	r0, r4
 80a2066:	f7ff fddb 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(x1 >> 8);
 80a206a:	0a39      	lsrs	r1, r7, #8
 80a206c:	4620      	mov	r0, r4
 80a206e:	f7ff fdd7 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(x1 & 0xFF);     // XEND
 80a2072:	b2f9      	uxtb	r1, r7
 80a2074:	4620      	mov	r0, r4
 80a2076:	f7ff fdd3 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>

  writecommand(ILI9341_PASET); // Row addr set
 80a207a:	4620      	mov	r0, r4
 80a207c:	212b      	movs	r1, #43	; 0x2b
 80a207e:	f7ff fd77 	bl	80a1b70 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(y0>>8);
 80a2082:	0a31      	lsrs	r1, r6, #8
 80a2084:	4620      	mov	r0, r4
 80a2086:	f7ff fdcb 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(y0);     // YSTART
 80a208a:	b2f1      	uxtb	r1, r6
 80a208c:	4620      	mov	r0, r4
 80a208e:	f7ff fdc7 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(y1>>8);
 80a2092:	0a29      	lsrs	r1, r5, #8
 80a2094:	4620      	mov	r0, r4
 80a2096:	f7ff fdc3 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(y1);     // YEND
 80a209a:	b2e9      	uxtb	r1, r5
 80a209c:	4620      	mov	r0, r4
 80a209e:	f7ff fdbf 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>

  writecommand(ILI9341_RAMWR); // write to RAM
 80a20a2:	4620      	mov	r0, r4
}
 80a20a4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  writedata(y0>>8);
  writedata(y0);     // YSTART
  writedata(y1>>8);
  writedata(y1);     // YEND

  writecommand(ILI9341_RAMWR); // write to RAM
 80a20a8:	212c      	movs	r1, #44	; 0x2c
 80a20aa:	f7ff bd61 	b.w	80a1b70 <_ZN16Adafruit_ILI934112writecommandEh>
	...

080a20b0 <_ZN16Adafruit_ILI934113drawFastHLineEssst>:
  if (hwSPI) spi_end();
}


void Adafruit_ILI9341::drawFastHLine(int16_t x, int16_t y, int16_t w,
  uint16_t color) {
 80a20b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a20b4:	4617      	mov	r7, r2

  // Rudimentary clipping
  if((x >= _width) || (y >= _height)) return;
 80a20b6:	f9b0 200c 	ldrsh.w	r2, [r0, #12]
  if (hwSPI) spi_end();
}


void Adafruit_ILI9341::drawFastHLine(int16_t x, int16_t y, int16_t w,
  uint16_t color) {
 80a20ba:	b086      	sub	sp, #24

  // Rudimentary clipping
  if((x >= _width) || (y >= _height)) return;
 80a20bc:	428a      	cmp	r2, r1
  if (hwSPI) spi_end();
}


void Adafruit_ILI9341::drawFastHLine(int16_t x, int16_t y, int16_t w,
  uint16_t color) {
 80a20be:	4605      	mov	r5, r0
 80a20c0:	460e      	mov	r6, r1
 80a20c2:	461c      	mov	r4, r3
 80a20c4:	f8bd 8030 	ldrh.w	r8, [sp, #48]	; 0x30

  // Rudimentary clipping
  if((x >= _width) || (y >= _height)) return;
 80a20c8:	dd5d      	ble.n	80a2186 <_ZN16Adafruit_ILI934113drawFastHLineEssst+0xd6>
 80a20ca:	f9b0 300e 	ldrsh.w	r3, [r0, #14]
 80a20ce:	42bb      	cmp	r3, r7
 80a20d0:	dd59      	ble.n	80a2186 <_ZN16Adafruit_ILI934113drawFastHLineEssst+0xd6>
  if((x+w-1) >= _width)  w = _width-x;
 80a20d2:	190b      	adds	r3, r1, r4
 80a20d4:	4293      	cmp	r3, r2
  if (hwSPI) spi_begin();
 80a20d6:	f890 302a 	ldrb.w	r3, [r0, #42]	; 0x2a
void Adafruit_ILI9341::drawFastHLine(int16_t x, int16_t y, int16_t w,
  uint16_t color) {

  // Rudimentary clipping
  if((x >= _width) || (y >= _height)) return;
  if((x+w-1) >= _width)  w = _width-x;
 80a20da:	bfc4      	itt	gt
 80a20dc:	1a52      	subgt	r2, r2, r1
 80a20de:	b214      	sxthgt	r4, r2
  if (hwSPI) spi_begin();
 80a20e0:	b17b      	cbz	r3, 80a2102 <_ZN16Adafruit_ILI934113drawFastHLineEssst+0x52>
 80a20e2:	4b2a      	ldr	r3, [pc, #168]	; (80a218c <_ZN16Adafruit_ILI934113drawFastHLineEssst+0xdc>)
 80a20e4:	4a2a      	ldr	r2, [pc, #168]	; (80a2190 <_ZN16Adafruit_ILI934113drawFastHLineEssst+0xe0>)
 80a20e6:	9302      	str	r3, [sp, #8]
 80a20e8:	9204      	str	r2, [sp, #16]
 80a20ea:	2300      	movs	r3, #0
 80a20ec:	2201      	movs	r2, #1
#ifdef SPI_HAS_TRANSACTION
static inline void spi_begin(void) __attribute__((always_inline));
static inline void spi_begin(void) {
#if defined (PARTICLE)
  // max speed!
  SPI.beginTransaction(SPISettings(30000000, MSBFIRST, SPI_MODE0));
 80a20ee:	a902      	add	r1, sp, #8
 80a20f0:	4828      	ldr	r0, [pc, #160]	; (80a2194 <_ZN16Adafruit_ILI934113drawFastHLineEssst+0xe4>)
 80a20f2:	f88d 300c 	strb.w	r3, [sp, #12]
 80a20f6:	f88d 2014 	strb.w	r2, [sp, #20]
 80a20fa:	f88d 3015 	strb.w	r3, [sp, #21]
 80a20fe:	f003 fa8d 	bl	80a561c <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE>

  // Rudimentary clipping
  if((x >= _width) || (y >= _height)) return;
  if((x+w-1) >= _width)  w = _width-x;
  if (hwSPI) spi_begin();
  setAddrWindow(x, y, x+w-1, y);
 80a2102:	b2b1      	uxth	r1, r6
 80a2104:	1e4b      	subs	r3, r1, #1
 80a2106:	b2a4      	uxth	r4, r4
 80a2108:	b2ba      	uxth	r2, r7
 80a210a:	4423      	add	r3, r4
 80a210c:	9200      	str	r2, [sp, #0]
 80a210e:	b29b      	uxth	r3, r3
 80a2110:	4628      	mov	r0, r5
 80a2112:	f7ff ff95 	bl	80a2040 <_ZN16Adafruit_ILI934113setAddrWindowEtttt>
 80a2116:	4920      	ldr	r1, [pc, #128]	; (80a2198 <_ZN16Adafruit_ILI934113drawFastHLineEssst+0xe8>)

  uint8_t hi = color >> 8, lo = color;
 80a2118:	ea4f 2718 	mov.w	r7, r8, lsr #8
 80a211c:	fa5f f688 	uxtb.w	r6, r8
 80a2120:	4688      	mov	r8, r1
 80a2122:	f995 302c 	ldrsb.w	r3, [r5, #44]	; 0x2c
 80a2126:	221c      	movs	r2, #28
 80a2128:	b29b      	uxth	r3, r3
 80a212a:	4353      	muls	r3, r2
 80a212c:	6808      	ldr	r0, [r1, #0]
 80a212e:	eb00 0e03 	add.w	lr, r0, r3
 80a2132:	f8be e004 	ldrh.w	lr, [lr, #4]
 80a2136:	58c3      	ldr	r3, [r0, r3]
 80a2138:	f8a3 e018 	strh.w	lr, [r3, #24]
}

inline void pinResetFast(pin_t _pin)
{
    PIN_MAP[_pin].gpio_peripheral->BSRRH = PIN_MAP[_pin].gpio_pin;
 80a213c:	f995 302b 	ldrsb.w	r3, [r5, #43]	; 0x2b
 80a2140:	b29b      	uxth	r3, r3
 80a2142:	4353      	muls	r3, r2
 80a2144:	18c2      	adds	r2, r0, r3
 80a2146:	8892      	ldrh	r2, [r2, #4]
 80a2148:	58c3      	ldr	r3, [r0, r3]
 80a214a:	835a      	strh	r2, [r3, #26]
  *csport &= ~cspinmask;
#else
  digitalWrite(_dc, HIGH);
  digitalWrite(_cs, LOW);
#endif
  while (w--) {
 80a214c:	b154      	cbz	r4, 80a2164 <_ZN16Adafruit_ILI934113drawFastHLineEssst+0xb4>
    spiwrite(hi);
 80a214e:	4639      	mov	r1, r7
 80a2150:	4628      	mov	r0, r5
 80a2152:	f7ff fcd3 	bl	80a1afc <_ZN16Adafruit_ILI93418spiwriteEh>
 80a2156:	3c01      	subs	r4, #1
    spiwrite(lo);
 80a2158:	4631      	mov	r1, r6
 80a215a:	4628      	mov	r0, r5
 80a215c:	f7ff fcce 	bl	80a1afc <_ZN16Adafruit_ILI93418spiwriteEh>
 80a2160:	b2a4      	uxth	r4, r4
  *csport &= ~cspinmask;
#else
  digitalWrite(_dc, HIGH);
  digitalWrite(_cs, LOW);
#endif
  while (w--) {
 80a2162:	e7f3      	b.n	80a214c <_ZN16Adafruit_ILI934113drawFastHLineEssst+0x9c>
inline void pinResetFast(pin_t _pin) __attribute__((always_inline));
inline int32_t pinReadFast(pin_t _pin) __attribute__((always_inline));

inline void pinSetFast(pin_t _pin)
{
    PIN_MAP[_pin].gpio_peripheral->BSRRL = PIN_MAP[_pin].gpio_pin;
 80a2164:	f995 302b 	ldrsb.w	r3, [r5, #43]	; 0x2b
 80a2168:	b29a      	uxth	r2, r3
 80a216a:	231c      	movs	r3, #28
 80a216c:	4353      	muls	r3, r2
 80a216e:	f8d8 2000 	ldr.w	r2, [r8]
 80a2172:	18d1      	adds	r1, r2, r3
 80a2174:	58d3      	ldr	r3, [r2, r3]
 80a2176:	888a      	ldrh	r2, [r1, #4]
 80a2178:	831a      	strh	r2, [r3, #24]
#elif defined(USE_FAST_PINIO)
  *csport |= cspinmask;
#else
  digitalWrite(_cs, HIGH);
#endif
  if (hwSPI) spi_end();
 80a217a:	f895 302a 	ldrb.w	r3, [r5, #42]	; 0x2a
 80a217e:	b113      	cbz	r3, 80a2186 <_ZN16Adafruit_ILI934113drawFastHLineEssst+0xd6>
  SPI.beginTransaction(SPISettings(24000000, MSBFIRST, SPI_MODE0));
#endif
}
static inline void spi_end(void) __attribute__((always_inline));
static inline void spi_end(void) {
  SPI.endTransaction();
 80a2180:	4804      	ldr	r0, [pc, #16]	; (80a2194 <_ZN16Adafruit_ILI934113drawFastHLineEssst+0xe4>)
 80a2182:	f003 fa24 	bl	80a55ce <_ZN8SPIClass14endTransactionEv>
  *csport |= cspinmask;
#else
  digitalWrite(_cs, HIGH);
#endif
  if (hwSPI) spi_end();
}
 80a2186:	b006      	add	sp, #24
 80a2188:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a218c:	080a852c 	.word	0x080a852c
 80a2190:	01c9c380 	.word	0x01c9c380
 80a2194:	20001524 	.word	0x20001524
 80a2198:	20001050 	.word	0x20001050

080a219c <_ZN16Adafruit_ILI93418fillRectEsssst>:
  fillRect(0, 0,  _width, _height, color);
}

// fill a rectangle
void Adafruit_ILI9341::fillRect(int16_t x, int16_t y, int16_t w, int16_t h,
  uint16_t color) {
 80a219c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80a21a0:	4617      	mov	r7, r2

  // rudimentary clipping (drawChar w/big text requires this)
  if((x >= _width) || (y >= _height)) return;
 80a21a2:	f9b0 200c 	ldrsh.w	r2, [r0, #12]
  fillRect(0, 0,  _width, _height, color);
}

// fill a rectangle
void Adafruit_ILI9341::fillRect(int16_t x, int16_t y, int16_t w, int16_t h,
  uint16_t color) {
 80a21a6:	b086      	sub	sp, #24

  // rudimentary clipping (drawChar w/big text requires this)
  if((x >= _width) || (y >= _height)) return;
 80a21a8:	428a      	cmp	r2, r1
  fillRect(0, 0,  _width, _height, color);
}

// fill a rectangle
void Adafruit_ILI9341::fillRect(int16_t x, int16_t y, int16_t w, int16_t h,
  uint16_t color) {
 80a21aa:	4604      	mov	r4, r0
 80a21ac:	460e      	mov	r6, r1
 80a21ae:	4698      	mov	r8, r3
 80a21b0:	f9bd 5038 	ldrsh.w	r5, [sp, #56]	; 0x38
 80a21b4:	f8bd 903c 	ldrh.w	r9, [sp, #60]	; 0x3c

  // rudimentary clipping (drawChar w/big text requires this)
  if((x >= _width) || (y >= _height)) return;
 80a21b8:	dd6d      	ble.n	80a2296 <_ZN16Adafruit_ILI93418fillRectEsssst+0xfa>
 80a21ba:	f9b0 300e 	ldrsh.w	r3, [r0, #14]
 80a21be:	42bb      	cmp	r3, r7
 80a21c0:	dd69      	ble.n	80a2296 <_ZN16Adafruit_ILI93418fillRectEsssst+0xfa>
  if((x + w - 1) >= _width)  w = _width  - x;
 80a21c2:	4441      	add	r1, r8
 80a21c4:	4291      	cmp	r1, r2
 80a21c6:	bfc8      	it	gt
 80a21c8:	ebc6 0802 	rsbgt	r8, r6, r2
  if((y + h - 1) >= _height) h = _height - y;
 80a21cc:	eb07 0205 	add.w	r2, r7, r5
void Adafruit_ILI9341::fillRect(int16_t x, int16_t y, int16_t w, int16_t h,
  uint16_t color) {

  // rudimentary clipping (drawChar w/big text requires this)
  if((x >= _width) || (y >= _height)) return;
  if((x + w - 1) >= _width)  w = _width  - x;
 80a21d0:	bfc8      	it	gt
 80a21d2:	fa0f f888 	sxthgt.w	r8, r8
  if((y + h - 1) >= _height) h = _height - y;
 80a21d6:	429a      	cmp	r2, r3
 80a21d8:	bfc8      	it	gt
 80a21da:	1bdd      	subgt	r5, r3, r7

  if (hwSPI) spi_begin();
 80a21dc:	f890 302a 	ldrb.w	r3, [r0, #42]	; 0x2a
  uint16_t color) {

  // rudimentary clipping (drawChar w/big text requires this)
  if((x >= _width) || (y >= _height)) return;
  if((x + w - 1) >= _width)  w = _width  - x;
  if((y + h - 1) >= _height) h = _height - y;
 80a21e0:	bfc8      	it	gt
 80a21e2:	b22d      	sxthgt	r5, r5

  if (hwSPI) spi_begin();
 80a21e4:	b17b      	cbz	r3, 80a2206 <_ZN16Adafruit_ILI93418fillRectEsssst+0x6a>
 80a21e6:	4b2d      	ldr	r3, [pc, #180]	; (80a229c <_ZN16Adafruit_ILI93418fillRectEsssst+0x100>)
 80a21e8:	4a2d      	ldr	r2, [pc, #180]	; (80a22a0 <_ZN16Adafruit_ILI93418fillRectEsssst+0x104>)
 80a21ea:	9302      	str	r3, [sp, #8]
 80a21ec:	9204      	str	r2, [sp, #16]
 80a21ee:	2300      	movs	r3, #0
 80a21f0:	2201      	movs	r2, #1
#ifdef SPI_HAS_TRANSACTION
static inline void spi_begin(void) __attribute__((always_inline));
static inline void spi_begin(void) {
#if defined (PARTICLE)
  // max speed!
  SPI.beginTransaction(SPISettings(30000000, MSBFIRST, SPI_MODE0));
 80a21f2:	a902      	add	r1, sp, #8
 80a21f4:	482b      	ldr	r0, [pc, #172]	; (80a22a4 <_ZN16Adafruit_ILI93418fillRectEsssst+0x108>)
 80a21f6:	f88d 300c 	strb.w	r3, [sp, #12]
 80a21fa:	f88d 2014 	strb.w	r2, [sp, #20]
 80a21fe:	f88d 3015 	strb.w	r3, [sp, #21]
 80a2202:	f003 fa0b 	bl	80a561c <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE>
  if((x >= _width) || (y >= _height)) return;
  if((x + w - 1) >= _width)  w = _width  - x;
  if((y + h - 1) >= _height) h = _height - y;

  if (hwSPI) spi_begin();
  setAddrWindow(x, y, x+w-1, y+h-1);
 80a2206:	b2ba      	uxth	r2, r7
 80a2208:	b2b1      	uxth	r1, r6
 80a220a:	1e50      	subs	r0, r2, #1
 80a220c:	1e4b      	subs	r3, r1, #1
 80a220e:	4428      	add	r0, r5
 80a2210:	b280      	uxth	r0, r0
 80a2212:	4443      	add	r3, r8
 80a2214:	9000      	str	r0, [sp, #0]
 80a2216:	b29b      	uxth	r3, r3
 80a2218:	4620      	mov	r0, r4
 80a221a:	f7ff ff11 	bl	80a2040 <_ZN16Adafruit_ILI934113setAddrWindowEtttt>
 80a221e:	4822      	ldr	r0, [pc, #136]	; (80a22a8 <_ZN16Adafruit_ILI93418fillRectEsssst+0x10c>)
 80a2220:	f994 302c 	ldrsb.w	r3, [r4, #44]	; 0x2c
 80a2224:	4682      	mov	sl, r0
 80a2226:	221c      	movs	r2, #28
 80a2228:	b29b      	uxth	r3, r3
 80a222a:	4353      	muls	r3, r2
 80a222c:	6801      	ldr	r1, [r0, #0]

  uint8_t hi = color >> 8, lo = color;
 80a222e:	ea4f 2619 	mov.w	r6, r9, lsr #8
 80a2232:	18cf      	adds	r7, r1, r3
 80a2234:	88bf      	ldrh	r7, [r7, #4]
 80a2236:	58cb      	ldr	r3, [r1, r3]
 80a2238:	fa5f f989 	uxtb.w	r9, r9
 80a223c:	831f      	strh	r7, [r3, #24]
}

inline void pinResetFast(pin_t _pin)
{
    PIN_MAP[_pin].gpio_peripheral->BSRRH = PIN_MAP[_pin].gpio_pin;
 80a223e:	f994 302b 	ldrsb.w	r3, [r4, #43]	; 0x2b
 80a2242:	b29b      	uxth	r3, r3
 80a2244:	4353      	muls	r3, r2
 80a2246:	18ca      	adds	r2, r1, r3
 80a2248:	8892      	ldrh	r2, [r2, #4]
 80a224a:	58cb      	ldr	r3, [r1, r3]
 80a224c:	835a      	strh	r2, [r3, #26]
#else
  digitalWrite(_dc, HIGH);
  digitalWrite(_cs, LOW);
#endif

  for(y=h; y>0; y--) {
 80a224e:	2d00      	cmp	r5, #0
 80a2250:	dd10      	ble.n	80a2274 <_ZN16Adafruit_ILI93418fillRectEsssst+0xd8>
 80a2252:	4647      	mov	r7, r8
    for(x=w; x>0; x--) {
 80a2254:	2f00      	cmp	r7, #0
 80a2256:	dd0a      	ble.n	80a226e <_ZN16Adafruit_ILI93418fillRectEsssst+0xd2>
      spiwrite(hi);
 80a2258:	4631      	mov	r1, r6
 80a225a:	4620      	mov	r0, r4
 80a225c:	f7ff fc4e 	bl	80a1afc <_ZN16Adafruit_ILI93418spiwriteEh>
 80a2260:	3f01      	subs	r7, #1
      spiwrite(lo);
 80a2262:	4649      	mov	r1, r9
 80a2264:	4620      	mov	r0, r4
 80a2266:	f7ff fc49 	bl	80a1afc <_ZN16Adafruit_ILI93418spiwriteEh>
 80a226a:	b23f      	sxth	r7, r7
  digitalWrite(_dc, HIGH);
  digitalWrite(_cs, LOW);
#endif

  for(y=h; y>0; y--) {
    for(x=w; x>0; x--) {
 80a226c:	e7f2      	b.n	80a2254 <_ZN16Adafruit_ILI93418fillRectEsssst+0xb8>
 80a226e:	3d01      	subs	r5, #1
 80a2270:	b22d      	sxth	r5, r5
#else
  digitalWrite(_dc, HIGH);
  digitalWrite(_cs, LOW);
#endif

  for(y=h; y>0; y--) {
 80a2272:	e7ec      	b.n	80a224e <_ZN16Adafruit_ILI93418fillRectEsssst+0xb2>
inline void pinResetFast(pin_t _pin) __attribute__((always_inline));
inline int32_t pinReadFast(pin_t _pin) __attribute__((always_inline));

inline void pinSetFast(pin_t _pin)
{
    PIN_MAP[_pin].gpio_peripheral->BSRRL = PIN_MAP[_pin].gpio_pin;
 80a2274:	f994 302b 	ldrsb.w	r3, [r4, #43]	; 0x2b
 80a2278:	b29a      	uxth	r2, r3
 80a227a:	231c      	movs	r3, #28
 80a227c:	4353      	muls	r3, r2
 80a227e:	f8da 2000 	ldr.w	r2, [sl]
 80a2282:	18d1      	adds	r1, r2, r3
 80a2284:	58d3      	ldr	r3, [r2, r3]
 80a2286:	888a      	ldrh	r2, [r1, #4]
 80a2288:	831a      	strh	r2, [r3, #24]
  *csport |= cspinmask;
#else
  digitalWrite(_cs, HIGH);
#endif

  if (hwSPI) spi_end();
 80a228a:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
 80a228e:	b113      	cbz	r3, 80a2296 <_ZN16Adafruit_ILI93418fillRectEsssst+0xfa>
  SPI.beginTransaction(SPISettings(24000000, MSBFIRST, SPI_MODE0));
#endif
}
static inline void spi_end(void) __attribute__((always_inline));
static inline void spi_end(void) {
  SPI.endTransaction();
 80a2290:	4804      	ldr	r0, [pc, #16]	; (80a22a4 <_ZN16Adafruit_ILI93418fillRectEsssst+0x108>)
 80a2292:	f003 f99c 	bl	80a55ce <_ZN8SPIClass14endTransactionEv>
#else
  digitalWrite(_cs, HIGH);
#endif

  if (hwSPI) spi_end();
}
 80a2296:	b006      	add	sp, #24
 80a2298:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a229c:	080a852c 	.word	0x080a852c
 80a22a0:	01c9c380 	.word	0x01c9c380
 80a22a4:	20001524 	.word	0x20001524
 80a22a8:	20001050 	.word	0x20001050

080a22ac <_ZN16Adafruit_ILI93419drawPixelEsst>:
#endif

  if (hwSPI) spi_end();
}

void Adafruit_ILI9341::drawPixel(int16_t x, int16_t y, uint16_t color) {
 80a22ac:	b5f0      	push	{r4, r5, r6, r7, lr}

  if((x < 0) ||(x >= _width) || (y < 0) || (y >= _height)) return;
 80a22ae:	1e0f      	subs	r7, r1, #0
#endif

  if (hwSPI) spi_end();
}

void Adafruit_ILI9341::drawPixel(int16_t x, int16_t y, uint16_t color) {
 80a22b0:	b087      	sub	sp, #28
 80a22b2:	4604      	mov	r4, r0
 80a22b4:	4615      	mov	r5, r2
 80a22b6:	461e      	mov	r6, r3

  if((x < 0) ||(x >= _width) || (y < 0) || (y >= _height)) return;
 80a22b8:	db50      	blt.n	80a235c <_ZN16Adafruit_ILI93419drawPixelEsst+0xb0>
 80a22ba:	f9b0 300c 	ldrsh.w	r3, [r0, #12]
 80a22be:	42bb      	cmp	r3, r7
 80a22c0:	dd4c      	ble.n	80a235c <_ZN16Adafruit_ILI93419drawPixelEsst+0xb0>
 80a22c2:	2a00      	cmp	r2, #0
 80a22c4:	db4a      	blt.n	80a235c <_ZN16Adafruit_ILI93419drawPixelEsst+0xb0>
 80a22c6:	f9b0 300e 	ldrsh.w	r3, [r0, #14]
 80a22ca:	4293      	cmp	r3, r2
 80a22cc:	dd46      	ble.n	80a235c <_ZN16Adafruit_ILI93419drawPixelEsst+0xb0>

  if (hwSPI) spi_begin();
 80a22ce:	f890 302a 	ldrb.w	r3, [r0, #42]	; 0x2a
 80a22d2:	b17b      	cbz	r3, 80a22f4 <_ZN16Adafruit_ILI93419drawPixelEsst+0x48>
 80a22d4:	4b22      	ldr	r3, [pc, #136]	; (80a2360 <_ZN16Adafruit_ILI93419drawPixelEsst+0xb4>)
 80a22d6:	4a23      	ldr	r2, [pc, #140]	; (80a2364 <_ZN16Adafruit_ILI93419drawPixelEsst+0xb8>)
 80a22d8:	9302      	str	r3, [sp, #8]
 80a22da:	9204      	str	r2, [sp, #16]
 80a22dc:	2300      	movs	r3, #0
 80a22de:	2201      	movs	r2, #1
#ifdef SPI_HAS_TRANSACTION
static inline void spi_begin(void) __attribute__((always_inline));
static inline void spi_begin(void) {
#if defined (PARTICLE)
  // max speed!
  SPI.beginTransaction(SPISettings(30000000, MSBFIRST, SPI_MODE0));
 80a22e0:	a902      	add	r1, sp, #8
 80a22e2:	4821      	ldr	r0, [pc, #132]	; (80a2368 <_ZN16Adafruit_ILI93419drawPixelEsst+0xbc>)
 80a22e4:	f88d 300c 	strb.w	r3, [sp, #12]
 80a22e8:	f88d 2014 	strb.w	r2, [sp, #20]
 80a22ec:	f88d 3015 	strb.w	r3, [sp, #21]
 80a22f0:	f003 f994 	bl	80a561c <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE>
void Adafruit_ILI9341::drawPixel(int16_t x, int16_t y, uint16_t color) {

  if((x < 0) ||(x >= _width) || (y < 0) || (y >= _height)) return;

  if (hwSPI) spi_begin();
  setAddrWindow(x,y,x+1,y+1);
 80a22f4:	b2aa      	uxth	r2, r5
 80a22f6:	b2b9      	uxth	r1, r7
 80a22f8:	1c50      	adds	r0, r2, #1
 80a22fa:	1c4b      	adds	r3, r1, #1
 80a22fc:	b280      	uxth	r0, r0
 80a22fe:	9000      	str	r0, [sp, #0]
 80a2300:	b29b      	uxth	r3, r3
 80a2302:	4620      	mov	r0, r4
 80a2304:	f7ff fe9c 	bl	80a2040 <_ZN16Adafruit_ILI934113setAddrWindowEtttt>
 80a2308:	f994 302c 	ldrsb.w	r3, [r4, #44]	; 0x2c
 80a230c:	251c      	movs	r5, #28
 80a230e:	b29b      	uxth	r3, r3
 80a2310:	436b      	muls	r3, r5
 80a2312:	4f16      	ldr	r7, [pc, #88]	; (80a236c <_ZN16Adafruit_ILI93419drawPixelEsst+0xc0>)
#else
  digitalWrite(_dc, HIGH);
  digitalWrite(_cs, LOW);
#endif

  spiwrite(color >> 8);
 80a2314:	4620      	mov	r0, r4
 80a2316:	683a      	ldr	r2, [r7, #0]
 80a2318:	18d1      	adds	r1, r2, r3
 80a231a:	8889      	ldrh	r1, [r1, #4]
 80a231c:	58d3      	ldr	r3, [r2, r3]
 80a231e:	8319      	strh	r1, [r3, #24]
}

inline void pinResetFast(pin_t _pin)
{
    PIN_MAP[_pin].gpio_peripheral->BSRRH = PIN_MAP[_pin].gpio_pin;
 80a2320:	f994 302b 	ldrsb.w	r3, [r4, #43]	; 0x2b
 80a2324:	b29b      	uxth	r3, r3
 80a2326:	436b      	muls	r3, r5
 80a2328:	18d1      	adds	r1, r2, r3
 80a232a:	58d3      	ldr	r3, [r2, r3]
 80a232c:	888a      	ldrh	r2, [r1, #4]
 80a232e:	0a31      	lsrs	r1, r6, #8
 80a2330:	835a      	strh	r2, [r3, #26]
 80a2332:	f7ff fbe3 	bl	80a1afc <_ZN16Adafruit_ILI93418spiwriteEh>
  spiwrite(color);
 80a2336:	b2f1      	uxtb	r1, r6
 80a2338:	4620      	mov	r0, r4
 80a233a:	f7ff fbdf 	bl	80a1afc <_ZN16Adafruit_ILI93418spiwriteEh>
inline void pinResetFast(pin_t _pin) __attribute__((always_inline));
inline int32_t pinReadFast(pin_t _pin) __attribute__((always_inline));

inline void pinSetFast(pin_t _pin)
{
    PIN_MAP[_pin].gpio_peripheral->BSRRL = PIN_MAP[_pin].gpio_pin;
 80a233e:	f994 302b 	ldrsb.w	r3, [r4, #43]	; 0x2b
 80a2342:	b29b      	uxth	r3, r3
 80a2344:	435d      	muls	r5, r3
 80a2346:	683b      	ldr	r3, [r7, #0]
 80a2348:	195a      	adds	r2, r3, r5
 80a234a:	8892      	ldrh	r2, [r2, #4]
 80a234c:	595b      	ldr	r3, [r3, r5]
 80a234e:	831a      	strh	r2, [r3, #24]
  *csport |= cspinmask;
#else
  digitalWrite(_cs, HIGH);
#endif

  if (hwSPI) spi_end();
 80a2350:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
 80a2354:	b113      	cbz	r3, 80a235c <_ZN16Adafruit_ILI93419drawPixelEsst+0xb0>
  SPI.beginTransaction(SPISettings(24000000, MSBFIRST, SPI_MODE0));
#endif
}
static inline void spi_end(void) __attribute__((always_inline));
static inline void spi_end(void) {
  SPI.endTransaction();
 80a2356:	4804      	ldr	r0, [pc, #16]	; (80a2368 <_ZN16Adafruit_ILI93419drawPixelEsst+0xbc>)
 80a2358:	f003 f939 	bl	80a55ce <_ZN8SPIClass14endTransactionEv>
#else
  digitalWrite(_cs, HIGH);
#endif

  if (hwSPI) spi_end();
}
 80a235c:	b007      	add	sp, #28
 80a235e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a2360:	080a852c 	.word	0x080a852c
 80a2364:	01c9c380 	.word	0x01c9c380
 80a2368:	20001524 	.word	0x20001524
 80a236c:	20001050 	.word	0x20001050

080a2370 <_ZN16Adafruit_ILI934113drawFastVLineEssst>:


void Adafruit_ILI9341::drawFastVLine(int16_t x, int16_t y, int16_t h,
 uint16_t color) {
 80a2370:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a2374:	461c      	mov	r4, r3

  // Rudimentary clipping
  if((x >= _width) || (y >= _height)) return;
 80a2376:	f9b0 300c 	ldrsh.w	r3, [r0, #12]
  if (hwSPI) spi_end();
}


void Adafruit_ILI9341::drawFastVLine(int16_t x, int16_t y, int16_t h,
 uint16_t color) {
 80a237a:	b086      	sub	sp, #24

  // Rudimentary clipping
  if((x >= _width) || (y >= _height)) return;
 80a237c:	428b      	cmp	r3, r1
  if (hwSPI) spi_end();
}


void Adafruit_ILI9341::drawFastVLine(int16_t x, int16_t y, int16_t h,
 uint16_t color) {
 80a237e:	4605      	mov	r5, r0
 80a2380:	460f      	mov	r7, r1
 80a2382:	4616      	mov	r6, r2
 80a2384:	f8bd 8030 	ldrh.w	r8, [sp, #48]	; 0x30

  // Rudimentary clipping
  if((x >= _width) || (y >= _height)) return;
 80a2388:	dd5e      	ble.n	80a2448 <_ZN16Adafruit_ILI934113drawFastVLineEssst+0xd8>
 80a238a:	f9b0 200e 	ldrsh.w	r2, [r0, #14]
 80a238e:	4296      	cmp	r6, r2
 80a2390:	da5a      	bge.n	80a2448 <_ZN16Adafruit_ILI934113drawFastVLineEssst+0xd8>

  if((y+h-1) >= _height) 
 80a2392:	1933      	adds	r3, r6, r4
 80a2394:	4293      	cmp	r3, r2
    h = _height-y;

  if (hwSPI) spi_begin();
 80a2396:	f890 302a 	ldrb.w	r3, [r0, #42]	; 0x2a

  // Rudimentary clipping
  if((x >= _width) || (y >= _height)) return;

  if((y+h-1) >= _height) 
    h = _height-y;
 80a239a:	bfc4      	itt	gt
 80a239c:	1b92      	subgt	r2, r2, r6
 80a239e:	b214      	sxthgt	r4, r2

  if (hwSPI) spi_begin();
 80a23a0:	b17b      	cbz	r3, 80a23c2 <_ZN16Adafruit_ILI934113drawFastVLineEssst+0x52>
 80a23a2:	4b2b      	ldr	r3, [pc, #172]	; (80a2450 <_ZN16Adafruit_ILI934113drawFastVLineEssst+0xe0>)
 80a23a4:	4a2b      	ldr	r2, [pc, #172]	; (80a2454 <_ZN16Adafruit_ILI934113drawFastVLineEssst+0xe4>)
 80a23a6:	9302      	str	r3, [sp, #8]
 80a23a8:	9204      	str	r2, [sp, #16]
 80a23aa:	2300      	movs	r3, #0
 80a23ac:	2201      	movs	r2, #1
#ifdef SPI_HAS_TRANSACTION
static inline void spi_begin(void) __attribute__((always_inline));
static inline void spi_begin(void) {
#if defined (PARTICLE)
  // max speed!
  SPI.beginTransaction(SPISettings(30000000, MSBFIRST, SPI_MODE0));
 80a23ae:	a902      	add	r1, sp, #8
 80a23b0:	4829      	ldr	r0, [pc, #164]	; (80a2458 <_ZN16Adafruit_ILI934113drawFastVLineEssst+0xe8>)
 80a23b2:	f88d 300c 	strb.w	r3, [sp, #12]
 80a23b6:	f88d 2014 	strb.w	r2, [sp, #20]
 80a23ba:	f88d 3015 	strb.w	r3, [sp, #21]
 80a23be:	f003 f92d 	bl	80a561c <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE>

  if((y+h-1) >= _height) 
    h = _height-y;

  if (hwSPI) spi_begin();
  setAddrWindow(x, y, x, y+h-1);
 80a23c2:	b2b2      	uxth	r2, r6
 80a23c4:	1e50      	subs	r0, r2, #1
 80a23c6:	b2a4      	uxth	r4, r4
 80a23c8:	4420      	add	r0, r4
 80a23ca:	b2bb      	uxth	r3, r7
 80a23cc:	b280      	uxth	r0, r0
 80a23ce:	4619      	mov	r1, r3
 80a23d0:	9000      	str	r0, [sp, #0]
 80a23d2:	4628      	mov	r0, r5
 80a23d4:	f7ff fe34 	bl	80a2040 <_ZN16Adafruit_ILI934113setAddrWindowEtttt>
 80a23d8:	4920      	ldr	r1, [pc, #128]	; (80a245c <_ZN16Adafruit_ILI934113drawFastVLineEssst+0xec>)

  uint8_t hi = color >> 8, lo = color;
 80a23da:	ea4f 2718 	mov.w	r7, r8, lsr #8
 80a23de:	fa5f f688 	uxtb.w	r6, r8
 80a23e2:	4688      	mov	r8, r1
 80a23e4:	f995 302c 	ldrsb.w	r3, [r5, #44]	; 0x2c
 80a23e8:	221c      	movs	r2, #28
 80a23ea:	b29b      	uxth	r3, r3
 80a23ec:	4353      	muls	r3, r2
 80a23ee:	6808      	ldr	r0, [r1, #0]
 80a23f0:	eb00 0e03 	add.w	lr, r0, r3
 80a23f4:	f8be e004 	ldrh.w	lr, [lr, #4]
 80a23f8:	58c3      	ldr	r3, [r0, r3]
 80a23fa:	f8a3 e018 	strh.w	lr, [r3, #24]
}

inline void pinResetFast(pin_t _pin)
{
    PIN_MAP[_pin].gpio_peripheral->BSRRH = PIN_MAP[_pin].gpio_pin;
 80a23fe:	f995 302b 	ldrsb.w	r3, [r5, #43]	; 0x2b
 80a2402:	b29b      	uxth	r3, r3
 80a2404:	4353      	muls	r3, r2
 80a2406:	18c2      	adds	r2, r0, r3
 80a2408:	8892      	ldrh	r2, [r2, #4]
 80a240a:	58c3      	ldr	r3, [r0, r3]
 80a240c:	835a      	strh	r2, [r3, #26]
#else
  digitalWrite(_dc, HIGH);
  digitalWrite(_cs, LOW);
#endif

  while (h--) {
 80a240e:	b154      	cbz	r4, 80a2426 <_ZN16Adafruit_ILI934113drawFastVLineEssst+0xb6>
    spiwrite(hi);
 80a2410:	4639      	mov	r1, r7
 80a2412:	4628      	mov	r0, r5
 80a2414:	f7ff fb72 	bl	80a1afc <_ZN16Adafruit_ILI93418spiwriteEh>
 80a2418:	3c01      	subs	r4, #1
    spiwrite(lo);
 80a241a:	4631      	mov	r1, r6
 80a241c:	4628      	mov	r0, r5
 80a241e:	f7ff fb6d 	bl	80a1afc <_ZN16Adafruit_ILI93418spiwriteEh>
 80a2422:	b2a4      	uxth	r4, r4
 80a2424:	e7f3      	b.n	80a240e <_ZN16Adafruit_ILI934113drawFastVLineEssst+0x9e>
inline void pinResetFast(pin_t _pin) __attribute__((always_inline));
inline int32_t pinReadFast(pin_t _pin) __attribute__((always_inline));

inline void pinSetFast(pin_t _pin)
{
    PIN_MAP[_pin].gpio_peripheral->BSRRL = PIN_MAP[_pin].gpio_pin;
 80a2426:	f995 302b 	ldrsb.w	r3, [r5, #43]	; 0x2b
 80a242a:	b29a      	uxth	r2, r3
 80a242c:	231c      	movs	r3, #28
 80a242e:	4353      	muls	r3, r2
 80a2430:	f8d8 2000 	ldr.w	r2, [r8]
 80a2434:	18d1      	adds	r1, r2, r3
 80a2436:	58d3      	ldr	r3, [r2, r3]
 80a2438:	888a      	ldrh	r2, [r1, #4]
 80a243a:	831a      	strh	r2, [r3, #24]
  *csport |= cspinmask;
#else
  digitalWrite(_cs, HIGH);
#endif

  if (hwSPI) spi_end();
 80a243c:	f895 302a 	ldrb.w	r3, [r5, #42]	; 0x2a
 80a2440:	b113      	cbz	r3, 80a2448 <_ZN16Adafruit_ILI934113drawFastVLineEssst+0xd8>
  SPI.beginTransaction(SPISettings(24000000, MSBFIRST, SPI_MODE0));
#endif
}
static inline void spi_end(void) __attribute__((always_inline));
static inline void spi_end(void) {
  SPI.endTransaction();
 80a2442:	4805      	ldr	r0, [pc, #20]	; (80a2458 <_ZN16Adafruit_ILI934113drawFastVLineEssst+0xe8>)
 80a2444:	f003 f8c3 	bl	80a55ce <_ZN8SPIClass14endTransactionEv>
#else
  digitalWrite(_cs, HIGH);
#endif

  if (hwSPI) spi_end();
}
 80a2448:	b006      	add	sp, #24
 80a244a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a244e:	bf00      	nop
 80a2450:	080a852c 	.word	0x080a852c
 80a2454:	01c9c380 	.word	0x01c9c380
 80a2458:	20001524 	.word	0x20001524
 80a245c:	20001050 	.word	0x20001050

080a2460 <_ZN16Adafruit_ILI934111setRotationEh>:
#define MADCTL_ML  0x10
#define MADCTL_RGB 0x00
#define MADCTL_BGR 0x08
#define MADCTL_MH  0x04

void Adafruit_ILI9341::setRotation(uint8_t m) {
 80a2460:	b530      	push	{r4, r5, lr}

  if (hwSPI) spi_begin();
 80a2462:	f890 302a 	ldrb.w	r3, [r0, #42]	; 0x2a
#define MADCTL_ML  0x10
#define MADCTL_RGB 0x00
#define MADCTL_BGR 0x08
#define MADCTL_MH  0x04

void Adafruit_ILI9341::setRotation(uint8_t m) {
 80a2466:	b085      	sub	sp, #20
 80a2468:	4604      	mov	r4, r0
 80a246a:	460d      	mov	r5, r1

  if (hwSPI) spi_begin();
 80a246c:	b17b      	cbz	r3, 80a248e <_ZN16Adafruit_ILI934111setRotationEh+0x2e>
 80a246e:	4b1d      	ldr	r3, [pc, #116]	; (80a24e4 <_ZN16Adafruit_ILI934111setRotationEh+0x84>)
 80a2470:	4a1d      	ldr	r2, [pc, #116]	; (80a24e8 <_ZN16Adafruit_ILI934111setRotationEh+0x88>)
 80a2472:	9300      	str	r3, [sp, #0]
 80a2474:	9202      	str	r2, [sp, #8]
 80a2476:	2300      	movs	r3, #0
 80a2478:	2201      	movs	r2, #1
#ifdef SPI_HAS_TRANSACTION
static inline void spi_begin(void) __attribute__((always_inline));
static inline void spi_begin(void) {
#if defined (PARTICLE)
  // max speed!
  SPI.beginTransaction(SPISettings(30000000, MSBFIRST, SPI_MODE0));
 80a247a:	4669      	mov	r1, sp
 80a247c:	481b      	ldr	r0, [pc, #108]	; (80a24ec <_ZN16Adafruit_ILI934111setRotationEh+0x8c>)
 80a247e:	f88d 3004 	strb.w	r3, [sp, #4]
 80a2482:	f88d 200c 	strb.w	r2, [sp, #12]
 80a2486:	f88d 300d 	strb.w	r3, [sp, #13]
 80a248a:	f003 f8c7 	bl	80a561c <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE>
#define MADCTL_MH  0x04

void Adafruit_ILI9341::setRotation(uint8_t m) {

  if (hwSPI) spi_begin();
  writecommand(ILI9341_MADCTL);
 80a248e:	2136      	movs	r1, #54	; 0x36
 80a2490:	4620      	mov	r0, r4
 80a2492:	f7ff fb6d 	bl	80a1b70 <_ZN16Adafruit_ILI934112writecommandEh>
  rotation = m % 4; // can't be higher than 3
 80a2496:	f005 0103 	and.w	r1, r5, #3
  switch (rotation) {
 80a249a:	2902      	cmp	r1, #2

void Adafruit_ILI9341::setRotation(uint8_t m) {

  if (hwSPI) spi_begin();
  writecommand(ILI9341_MADCTL);
  rotation = m % 4; // can't be higher than 3
 80a249c:	7661      	strb	r1, [r4, #25]
  switch (rotation) {
 80a249e:	d007      	beq.n	80a24b0 <_ZN16Adafruit_ILI934111setRotationEh+0x50>
 80a24a0:	2903      	cmp	r1, #3
 80a24a2:	d00e      	beq.n	80a24c2 <_ZN16Adafruit_ILI934111setRotationEh+0x62>
 80a24a4:	2901      	cmp	r1, #1
 80a24a6:	d001      	beq.n	80a24ac <_ZN16Adafruit_ILI934111setRotationEh+0x4c>
   case 0:
     writedata(MADCTL_MX | MADCTL_BGR);
 80a24a8:	2148      	movs	r1, #72	; 0x48
 80a24aa:	e002      	b.n	80a24b2 <_ZN16Adafruit_ILI934111setRotationEh+0x52>
     _width  = ILI9341_TFTWIDTH;
     _height = ILI9341_TFTHEIGHT;
     break;
   case 1:
     writedata(MADCTL_MV | MADCTL_BGR);
 80a24ac:	2128      	movs	r1, #40	; 0x28
 80a24ae:	e009      	b.n	80a24c4 <_ZN16Adafruit_ILI934111setRotationEh+0x64>
     _width  = ILI9341_TFTHEIGHT;
     _height = ILI9341_TFTWIDTH;
     break;
  case 2:
    writedata(MADCTL_MY | MADCTL_BGR);
 80a24b0:	2188      	movs	r1, #136	; 0x88
 80a24b2:	4620      	mov	r0, r4
 80a24b4:	f7ff fbb4 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
     _width  = ILI9341_TFTWIDTH;
 80a24b8:	23f0      	movs	r3, #240	; 0xf0
 80a24ba:	81a3      	strh	r3, [r4, #12]
     _height = ILI9341_TFTHEIGHT;
 80a24bc:	f44f 73a0 	mov.w	r3, #320	; 0x140
 80a24c0:	e007      	b.n	80a24d2 <_ZN16Adafruit_ILI934111setRotationEh+0x72>
    break;
   case 3:
     writedata(MADCTL_MX | MADCTL_MY | MADCTL_MV | MADCTL_BGR);
 80a24c2:	21e8      	movs	r1, #232	; 0xe8
 80a24c4:	4620      	mov	r0, r4
 80a24c6:	f7ff fbab 	bl	80a1c20 <_ZN16Adafruit_ILI93419writedataEh>
     _width  = ILI9341_TFTHEIGHT;
 80a24ca:	f44f 73a0 	mov.w	r3, #320	; 0x140
 80a24ce:	81a3      	strh	r3, [r4, #12]
     _height = ILI9341_TFTWIDTH;
 80a24d0:	23f0      	movs	r3, #240	; 0xf0
 80a24d2:	81e3      	strh	r3, [r4, #14]
     break;
  }
  if (hwSPI) spi_end();
 80a24d4:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
 80a24d8:	b113      	cbz	r3, 80a24e0 <_ZN16Adafruit_ILI934111setRotationEh+0x80>
  SPI.beginTransaction(SPISettings(24000000, MSBFIRST, SPI_MODE0));
#endif
}
static inline void spi_end(void) __attribute__((always_inline));
static inline void spi_end(void) {
  SPI.endTransaction();
 80a24da:	4804      	ldr	r0, [pc, #16]	; (80a24ec <_ZN16Adafruit_ILI934111setRotationEh+0x8c>)
 80a24dc:	f003 f877 	bl	80a55ce <_ZN8SPIClass14endTransactionEv>
     _width  = ILI9341_TFTHEIGHT;
     _height = ILI9341_TFTWIDTH;
     break;
  }
  if (hwSPI) spi_end();
}
 80a24e0:	b005      	add	sp, #20
 80a24e2:	bd30      	pop	{r4, r5, pc}
 80a24e4:	080a852c 	.word	0x080a852c
 80a24e8:	01c9c380 	.word	0x01c9c380
 80a24ec:	20001524 	.word	0x20001524

080a24f0 <_GLOBAL__sub_I__ZN16Adafruit_ILI9341C2Eaaaaaa>:
   uint8_t r = spiread();
   digitalWrite(_cs, HIGH);
#endif
   if (hwSPI) spi_end();
   return r;
}
 80a24f0:	b508      	push	{r3, lr}
inline int32_t pinReadFast(pin_t _pin)
{
	return ((PIN_MAP[_pin].gpio_peripheral->IDR & PIN_MAP[_pin].gpio_pin) == 0 ? LOW : HIGH);
}
#elif defined(STM32F2XX)
static STM32_Pin_Info* PIN_MAP = HAL_Pin_Map();
 80a24f2:	f002 fd29 	bl	80a4f48 <HAL_Pin_Map>
 80a24f6:	4b01      	ldr	r3, [pc, #4]	; (80a24fc <_GLOBAL__sub_I__ZN16Adafruit_ILI9341C2Eaaaaaa+0xc>)
 80a24f8:	6018      	str	r0, [r3, #0]
 80a24fa:	bd08      	pop	{r3, pc}
 80a24fc:	20001050 	.word	0x20001050

080a2500 <_ZN7MFRC522C1Ehh>:

/**
 * Constructor.
 * Prepares the output pins.
 */
MFRC522::MFRC522(	byte chipSelectPin,		///< Arduino pin connected to MFRC522's SPI slave select input (Pin 24, NSS, active low)
 80a2500:	b538      	push	{r3, r4, r5, lr}
 80a2502:	4604      	mov	r4, r0
 80a2504:	4615      	mov	r5, r2
 80a2506:	4608      	mov	r0, r1
					byte resetPowerDownPin	///< Arduino pin connected to MFRC522's reset and power down input (Pin 6, NRSTPD, active low)
				) {
	// Set the chipSelectPin as digital output, do not select the slave yet
	_chipSelectPin = chipSelectPin;
 80a2508:	7321      	strb	r1, [r4, #12]
	pinMode(_chipSelectPin, OUTPUT);
 80a250a:	2101      	movs	r1, #1
 80a250c:	f004 fbb2 	bl	80a6c74 <pinMode>
	digitalWrite(_chipSelectPin, HIGH);
 80a2510:	7b20      	ldrb	r0, [r4, #12]
 80a2512:	2101      	movs	r1, #1
 80a2514:	f004 fbbf 	bl	80a6c96 <digitalWrite>
	
	// Set the resetPowerDownPin as digital output, do not reset or power down.
	_resetPowerDownPin = resetPowerDownPin;
	pinMode(_resetPowerDownPin, OUTPUT);
 80a2518:	4628      	mov	r0, r5
	_chipSelectPin = chipSelectPin;
	pinMode(_chipSelectPin, OUTPUT);
	digitalWrite(_chipSelectPin, HIGH);
	
	// Set the resetPowerDownPin as digital output, do not reset or power down.
	_resetPowerDownPin = resetPowerDownPin;
 80a251a:	7365      	strb	r5, [r4, #13]
	pinMode(_resetPowerDownPin, OUTPUT);
 80a251c:	2101      	movs	r1, #1
 80a251e:	f004 fba9 	bl	80a6c74 <pinMode>
	digitalWrite(_resetPowerDownPin, LOW);
 80a2522:	7b60      	ldrb	r0, [r4, #13]
 80a2524:	2100      	movs	r1, #0
 80a2526:	f004 fbb6 	bl	80a6c96 <digitalWrite>
	
	// Set SPI bus to work with MFRC522 chip.
	//setSPIConfig();
} // End constructor
 80a252a:	4620      	mov	r0, r4
 80a252c:	bd38      	pop	{r3, r4, r5, pc}
	...

080a2530 <_ZN7MFRC52212setSPIConfigEv>:

/**
 * Set SPI bus to work with MFRC522 chip.
 * Please call this function if you have changed the SPI config since the MFRC522 constructor was run.
 */
void MFRC522::setSPIConfig() {
 80a2530:	b510      	push	{r4, lr}
	SPI.begin();			// Init SPI bus
 80a2532:	4c09      	ldr	r4, [pc, #36]	; (80a2558 <_ZN7MFRC52212setSPIConfigEv+0x28>)
 80a2534:	4620      	mov	r0, r4
 80a2536:	f003 f839 	bl	80a55ac <_ZN8SPIClass5beginEv>
	SPI.setClockDivider(SPI_CLOCK_DIV8);
 80a253a:	4620      	mov	r0, r4
 80a253c:	2110      	movs	r1, #16
 80a253e:	f003 f8ff 	bl	80a5740 <_ZN8SPIClass15setClockDividerEh>
	SPI.setBitOrder(MSBFIRST);
 80a2542:	4620      	mov	r0, r4
 80a2544:	2101      	movs	r1, #1
 80a2546:	f003 f83c 	bl	80a55c2 <_ZN8SPIClass11setBitOrderEh>
	SPI.setDataMode(SPI_MODE0);
 80a254a:	4620      	mov	r0, r4
} // End setSPIConfig()
 80a254c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 */
void MFRC522::setSPIConfig() {
	SPI.begin();			// Init SPI bus
	SPI.setClockDivider(SPI_CLOCK_DIV8);
	SPI.setBitOrder(MSBFIRST);
	SPI.setDataMode(SPI_MODE0);
 80a2550:	2100      	movs	r1, #0
 80a2552:	f003 b839 	b.w	80a55c8 <_ZN8SPIClass11setDataModeEh>
 80a2556:	bf00      	nop
 80a2558:	20001524 	.word	0x20001524

080a255c <_ZN7MFRC52217PCD_WriteRegisterEhh>:
 * Writes a byte to the specified register in the MFRC522 chip.
 * The interface is described in the datasheet section 8.1.2.
 */
void MFRC522::PCD_WriteRegister(	byte reg,		///< The register to write to. One of the PCD_Register enums.
									byte value		///< The value to write.
								) {
 80a255c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a255e:	460f      	mov	r7, r1
 80a2560:	4616      	mov	r6, r2
 80a2562:	4604      	mov	r4, r0
	digitalWrite(_chipSelectPin, LOW);		// Select slave
	SPI.transfer(reg & 0x7E);					// MSB == 0 is for writing. LSB is not used in address. Datasheet section 8.1.2.3.
 80a2564:	4d09      	ldr	r5, [pc, #36]	; (80a258c <_ZN7MFRC52217PCD_WriteRegisterEhh+0x30>)
 * The interface is described in the datasheet section 8.1.2.
 */
void MFRC522::PCD_WriteRegister(	byte reg,		///< The register to write to. One of the PCD_Register enums.
									byte value		///< The value to write.
								) {
	digitalWrite(_chipSelectPin, LOW);		// Select slave
 80a2566:	2100      	movs	r1, #0
 80a2568:	7b00      	ldrb	r0, [r0, #12]
 80a256a:	f004 fb94 	bl	80a6c96 <digitalWrite>
	SPI.transfer(reg & 0x7E);					// MSB == 0 is for writing. LSB is not used in address. Datasheet section 8.1.2.3.
 80a256e:	f007 017e 	and.w	r1, r7, #126	; 0x7e
 80a2572:	4628      	mov	r0, r5
 80a2574:	f003 f8f8 	bl	80a5768 <_ZN8SPIClass8transferEh>
	SPI.transfer(value);
 80a2578:	4631      	mov	r1, r6
 80a257a:	4628      	mov	r0, r5
 80a257c:	f003 f8f4 	bl	80a5768 <_ZN8SPIClass8transferEh>
	digitalWrite(_chipSelectPin, HIGH);		// Release slave again
 80a2580:	7b20      	ldrb	r0, [r4, #12]
 80a2582:	2101      	movs	r1, #1
} // End PCD_WriteRegister()
 80a2584:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
									byte value		///< The value to write.
								) {
	digitalWrite(_chipSelectPin, LOW);		// Select slave
	SPI.transfer(reg & 0x7E);					// MSB == 0 is for writing. LSB is not used in address. Datasheet section 8.1.2.3.
	SPI.transfer(value);
	digitalWrite(_chipSelectPin, HIGH);		// Release slave again
 80a2588:	f004 bb85 	b.w	80a6c96 <digitalWrite>
 80a258c:	20001524 	.word	0x20001524

080a2590 <_ZN7MFRC52217PCD_WriteRegisterEhhPh>:
 * The interface is described in the datasheet section 8.1.2.
 */
void MFRC522::PCD_WriteRegister(	byte reg,		///< The register to write to. One of the PCD_Register enums.
									byte count,		///< The number of bytes to write to the register
									byte *values	///< The values to write. Byte array.
								) {
 80a2590:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a2592:	460d      	mov	r5, r1
 80a2594:	4614      	mov	r4, r2
	digitalWrite(_chipSelectPin, LOW);		// Select slave
 80a2596:	2100      	movs	r1, #0
 * The interface is described in the datasheet section 8.1.2.
 */
void MFRC522::PCD_WriteRegister(	byte reg,		///< The register to write to. One of the PCD_Register enums.
									byte count,		///< The number of bytes to write to the register
									byte *values	///< The values to write. Byte array.
								) {
 80a2598:	4606      	mov	r6, r0
	digitalWrite(_chipSelectPin, LOW);		// Select slave
 80a259a:	7b00      	ldrb	r0, [r0, #12]
 * The interface is described in the datasheet section 8.1.2.
 */
void MFRC522::PCD_WriteRegister(	byte reg,		///< The register to write to. One of the PCD_Register enums.
									byte count,		///< The number of bytes to write to the register
									byte *values	///< The values to write. Byte array.
								) {
 80a259c:	461f      	mov	r7, r3
	digitalWrite(_chipSelectPin, LOW);		// Select slave
 80a259e:	f004 fb7a 	bl	80a6c96 <digitalWrite>
	SPI.transfer(reg & 0x7E);				// MSB == 0 is for writing. LSB is not used in address. Datasheet section 8.1.2.3.
 80a25a2:	f005 017e 	and.w	r1, r5, #126	; 0x7e
 80a25a6:	480a      	ldr	r0, [pc, #40]	; (80a25d0 <_ZN7MFRC52217PCD_WriteRegisterEhhPh+0x40>)
 80a25a8:	f003 f8de 	bl	80a5768 <_ZN8SPIClass8transferEh>
 80a25ac:	3c01      	subs	r4, #1
 80a25ae:	1e7d      	subs	r5, r7, #1
 80a25b0:	443c      	add	r4, r7
	for (byte index = 0; index < count; index++) {
 80a25b2:	42a5      	cmp	r5, r4
 80a25b4:	d005      	beq.n	80a25c2 <_ZN7MFRC52217PCD_WriteRegisterEhhPh+0x32>
		SPI.transfer(values[index]);
 80a25b6:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 80a25ba:	4805      	ldr	r0, [pc, #20]	; (80a25d0 <_ZN7MFRC52217PCD_WriteRegisterEhhPh+0x40>)
 80a25bc:	f003 f8d4 	bl	80a5768 <_ZN8SPIClass8transferEh>
									byte count,		///< The number of bytes to write to the register
									byte *values	///< The values to write. Byte array.
								) {
	digitalWrite(_chipSelectPin, LOW);		// Select slave
	SPI.transfer(reg & 0x7E);				// MSB == 0 is for writing. LSB is not used in address. Datasheet section 8.1.2.3.
	for (byte index = 0; index < count; index++) {
 80a25c0:	e7f7      	b.n	80a25b2 <_ZN7MFRC52217PCD_WriteRegisterEhhPh+0x22>
		SPI.transfer(values[index]);
	}
	digitalWrite(_chipSelectPin, HIGH);		// Release slave again
 80a25c2:	7b30      	ldrb	r0, [r6, #12]
 80a25c4:	2101      	movs	r1, #1
} // End PCD_WriteRegister()
 80a25c6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	digitalWrite(_chipSelectPin, LOW);		// Select slave
	SPI.transfer(reg & 0x7E);				// MSB == 0 is for writing. LSB is not used in address. Datasheet section 8.1.2.3.
	for (byte index = 0; index < count; index++) {
		SPI.transfer(values[index]);
	}
	digitalWrite(_chipSelectPin, HIGH);		// Release slave again
 80a25ca:	f004 bb64 	b.w	80a6c96 <digitalWrite>
 80a25ce:	bf00      	nop
 80a25d0:	20001524 	.word	0x20001524

080a25d4 <_ZN7MFRC52216PCD_ReadRegisterEh>:
/**
 * Reads a byte from the specified register in the MFRC522 chip.
 * The interface is described in the datasheet section 8.1.2.
 */
byte MFRC522::PCD_ReadRegister(	byte reg	///< The register to read from. One of the PCD_Register enums.
								) {
 80a25d4:	b538      	push	{r3, r4, r5, lr}
 80a25d6:	460c      	mov	r4, r1
 80a25d8:	4605      	mov	r5, r0
	byte value;
	digitalWrite(_chipSelectPin, LOW);			// Select slave
 80a25da:	2100      	movs	r1, #0
 80a25dc:	7b00      	ldrb	r0, [r0, #12]
 80a25de:	f004 fb5a 	bl	80a6c96 <digitalWrite>
	SPI.transfer(0x80 | (reg & 0x7E));			// MSB == 1 is for reading. LSB is not used in address. Datasheet section 8.1.2.3.
 80a25e2:	f004 017e 	and.w	r1, r4, #126	; 0x7e
 80a25e6:	4c08      	ldr	r4, [pc, #32]	; (80a2608 <_ZN7MFRC52216PCD_ReadRegisterEh+0x34>)
 80a25e8:	f041 0180 	orr.w	r1, r1, #128	; 0x80
 80a25ec:	4620      	mov	r0, r4
 80a25ee:	f003 f8bb 	bl	80a5768 <_ZN8SPIClass8transferEh>
	value = SPI.transfer(0);					// Read the value back. Send 0 to stop reading.
 80a25f2:	2100      	movs	r1, #0
 80a25f4:	4620      	mov	r0, r4
 80a25f6:	f003 f8b7 	bl	80a5768 <_ZN8SPIClass8transferEh>
 80a25fa:	4604      	mov	r4, r0
	digitalWrite(_chipSelectPin, HIGH);			// Release slave again
 80a25fc:	2101      	movs	r1, #1
 80a25fe:	7b28      	ldrb	r0, [r5, #12]
 80a2600:	f004 fb49 	bl	80a6c96 <digitalWrite>
	return value;
} // End PCD_ReadRegister()
 80a2604:	4620      	mov	r0, r4
 80a2606:	bd38      	pop	{r3, r4, r5, pc}
 80a2608:	20001524 	.word	0x20001524

080a260c <_ZN7MFRC52216PCD_ReadRegisterEhhPhh>:
 */
void MFRC522::PCD_ReadRegister(	byte reg,		///< The register to read from. One of the PCD_Register enums.
								byte count,		///< The number of bytes to read
								byte *values,	///< Byte array to store the values in.
								byte rxAlign	///< Only bit positions rxAlign..7 in values[0] are updated.
								) {
 80a260c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a2610:	4680      	mov	r8, r0
 80a2612:	461f      	mov	r7, r3
 80a2614:	f89d 9028 	ldrb.w	r9, [sp, #40]	; 0x28
	if (count == 0) {
 80a2618:	4615      	mov	r5, r2
 80a261a:	2a00      	cmp	r2, #0
 80a261c:	d043      	beq.n	80a26a6 <_ZN7MFRC52216PCD_ReadRegisterEhhPhh+0x9a>
		return;
	}
	//Serial.print("Reading "); 	Serial.print(count); Serial.println(" bytes from register.");
	byte address = 0x80 | (reg & 0x7E);		// MSB == 1 is for reading. LSB is not used in address. Datasheet section 8.1.2.3.
 80a261e:	f001 017e 	and.w	r1, r1, #126	; 0x7e
 80a2622:	f041 0680 	orr.w	r6, r1, #128	; 0x80
	byte index = 0;							// Index in values array.
	digitalWrite(_chipSelectPin, LOW);		// Select slave
 80a2626:	7b00      	ldrb	r0, [r0, #12]
 80a2628:	2100      	movs	r1, #0
 80a262a:	f004 fb34 	bl	80a6c96 <digitalWrite>
	count--;								// One read is performed outside of the loop
	SPI.transfer(address);					// Tell MFRC522 which address we want to read
 80a262e:	4631      	mov	r1, r6
 80a2630:	481e      	ldr	r0, [pc, #120]	; (80a26ac <_ZN7MFRC52216PCD_ReadRegisterEhhPhh+0xa0>)
 80a2632:	f003 f899 	bl	80a5768 <_ZN8SPIClass8transferEh>
	}
	//Serial.print("Reading "); 	Serial.print(count); Serial.println(" bytes from register.");
	byte address = 0x80 | (reg & 0x7E);		// MSB == 1 is for reading. LSB is not used in address. Datasheet section 8.1.2.3.
	byte index = 0;							// Index in values array.
	digitalWrite(_chipSelectPin, LOW);		// Select slave
	count--;								// One read is performed outside of the loop
 80a2636:	3d01      	subs	r5, #1
 80a2638:	b2ed      	uxtb	r5, r5
	SPI.transfer(address);					// Tell MFRC522 which address we want to read
 80a263a:	f04f 0b00 	mov.w	fp, #0
	while (index < count) {
		if (index == 0 && rxAlign) { // Only update bit positions rxAlign..7 in values[0]
			// Create bit mask for bit positions rxAlign..7
			byte mask = 0;
			for (byte i = rxAlign; i <= 7; i++) {
				mask |= (1 << i);
 80a263e:	f04f 0a01 	mov.w	sl, #1
 80a2642:	fa5f f48b 	uxtb.w	r4, fp
	byte address = 0x80 | (reg & 0x7E);		// MSB == 1 is for reading. LSB is not used in address. Datasheet section 8.1.2.3.
	byte index = 0;							// Index in values array.
	digitalWrite(_chipSelectPin, LOW);		// Select slave
	count--;								// One read is performed outside of the loop
	SPI.transfer(address);					// Tell MFRC522 which address we want to read
	while (index < count) {
 80a2646:	42a5      	cmp	r5, r4
 80a2648:	d921      	bls.n	80a268e <_ZN7MFRC52216PCD_ReadRegisterEhhPhh+0x82>
		if (index == 0 && rxAlign) { // Only update bit positions rxAlign..7 in values[0]
 80a264a:	b9bc      	cbnz	r4, 80a267c <_ZN7MFRC52216PCD_ReadRegisterEhhPhh+0x70>
 80a264c:	f1b9 0f00 	cmp.w	r9, #0
 80a2650:	d014      	beq.n	80a267c <_ZN7MFRC52216PCD_ReadRegisterEhhPhh+0x70>
 80a2652:	464b      	mov	r3, r9
			// Create bit mask for bit positions rxAlign..7
			byte mask = 0;
			for (byte i = rxAlign; i <= 7; i++) {
 80a2654:	2b07      	cmp	r3, #7
 80a2656:	d806      	bhi.n	80a2666 <_ZN7MFRC52216PCD_ReadRegisterEhhPhh+0x5a>
				mask |= (1 << i);
 80a2658:	fa0a f003 	lsl.w	r0, sl, r3
 80a265c:	4304      	orrs	r4, r0
	SPI.transfer(address);					// Tell MFRC522 which address we want to read
	while (index < count) {
		if (index == 0 && rxAlign) { // Only update bit positions rxAlign..7 in values[0]
			// Create bit mask for bit positions rxAlign..7
			byte mask = 0;
			for (byte i = rxAlign; i <= 7; i++) {
 80a265e:	3301      	adds	r3, #1
				mask |= (1 << i);
 80a2660:	b2e4      	uxtb	r4, r4
	SPI.transfer(address);					// Tell MFRC522 which address we want to read
	while (index < count) {
		if (index == 0 && rxAlign) { // Only update bit positions rxAlign..7 in values[0]
			// Create bit mask for bit positions rxAlign..7
			byte mask = 0;
			for (byte i = rxAlign; i <= 7; i++) {
 80a2662:	b2db      	uxtb	r3, r3
 80a2664:	e7f6      	b.n	80a2654 <_ZN7MFRC52216PCD_ReadRegisterEhhPhh+0x48>
				mask |= (1 << i);
			}
			// Read value and tell that we want to read the same address again.
			byte value = SPI.transfer(address);	
 80a2666:	4631      	mov	r1, r6
 80a2668:	4810      	ldr	r0, [pc, #64]	; (80a26ac <_ZN7MFRC52216PCD_ReadRegisterEhhPhh+0xa0>)
 80a266a:	f003 f87d 	bl	80a5768 <_ZN8SPIClass8transferEh>
			// Apply mask to both current value of values[0] and the new data in value.
			values[0] = (values[index] & ~mask) | (value & mask);
 80a266e:	783b      	ldrb	r3, [r7, #0]
 80a2670:	4020      	ands	r0, r4
 80a2672:	ea23 0304 	bic.w	r3, r3, r4
 80a2676:	4318      	orrs	r0, r3
 80a2678:	7038      	strb	r0, [r7, #0]
 80a267a:	e005      	b.n	80a2688 <_ZN7MFRC52216PCD_ReadRegisterEhhPhh+0x7c>
		}
		else { // Normal case
			values[index] = SPI.transfer(address);	// Read value and tell that we want to read the same address again.
 80a267c:	4631      	mov	r1, r6
 80a267e:	480b      	ldr	r0, [pc, #44]	; (80a26ac <_ZN7MFRC52216PCD_ReadRegisterEhhPhh+0xa0>)
 80a2680:	f003 f872 	bl	80a5768 <_ZN8SPIClass8transferEh>
 80a2684:	f807 000b 	strb.w	r0, [r7, fp]
 80a2688:	f10b 0b01 	add.w	fp, fp, #1
 80a268c:	e7d9      	b.n	80a2642 <_ZN7MFRC52216PCD_ReadRegisterEhhPhh+0x36>
		}
		index++;
	}
	values[index] = SPI.transfer(0);			// Read the final byte. Send 0 to stop reading.
 80a268e:	2100      	movs	r1, #0
 80a2690:	4806      	ldr	r0, [pc, #24]	; (80a26ac <_ZN7MFRC52216PCD_ReadRegisterEhhPhh+0xa0>)
 80a2692:	f003 f869 	bl	80a5768 <_ZN8SPIClass8transferEh>
 80a2696:	5578      	strb	r0, [r7, r5]
	digitalWrite(_chipSelectPin, HIGH);			// Release slave again
 80a2698:	f898 000c 	ldrb.w	r0, [r8, #12]
 80a269c:	2101      	movs	r1, #1
} // End PCD_ReadRegister()
 80a269e:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
			values[index] = SPI.transfer(address);	// Read value and tell that we want to read the same address again.
		}
		index++;
	}
	values[index] = SPI.transfer(0);			// Read the final byte. Send 0 to stop reading.
	digitalWrite(_chipSelectPin, HIGH);			// Release slave again
 80a26a2:	f004 baf8 	b.w	80a6c96 <digitalWrite>
 80a26a6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a26aa:	bf00      	nop
 80a26ac:	20001524 	.word	0x20001524

080a26b0 <_ZN7MFRC52222PCD_SetRegisterBitMaskEhh>:
/**
 * Sets the bits given in mask in register reg.
 */
void MFRC522::PCD_SetRegisterBitMask(	byte reg,	///< The register to update. One of the PCD_Register enums.
										byte mask	///< The bits to set.
									) { 
 80a26b0:	b570      	push	{r4, r5, r6, lr}
 80a26b2:	4605      	mov	r5, r0
 80a26b4:	460e      	mov	r6, r1
 80a26b6:	4614      	mov	r4, r2
	byte tmp;
	tmp = PCD_ReadRegister(reg);
 80a26b8:	f7ff ff8c 	bl	80a25d4 <_ZN7MFRC52216PCD_ReadRegisterEh>
	PCD_WriteRegister(reg, tmp | mask);			// set bit mask
 80a26bc:	ea40 0204 	orr.w	r2, r0, r4
 80a26c0:	4631      	mov	r1, r6
 80a26c2:	4628      	mov	r0, r5
} // End PCD_SetRegisterBitMask()
 80a26c4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
void MFRC522::PCD_SetRegisterBitMask(	byte reg,	///< The register to update. One of the PCD_Register enums.
										byte mask	///< The bits to set.
									) { 
	byte tmp;
	tmp = PCD_ReadRegister(reg);
	PCD_WriteRegister(reg, tmp | mask);			// set bit mask
 80a26c8:	b2d2      	uxtb	r2, r2
 80a26ca:	f7ff bf47 	b.w	80a255c <_ZN7MFRC52217PCD_WriteRegisterEhh>

080a26ce <_ZN7MFRC52224PCD_ClearRegisterBitMaskEhh>:
/**
 * Clears the bits given in mask from register reg.
 */
void MFRC522::PCD_ClearRegisterBitMask(	byte reg,	///< The register to update. One of the PCD_Register enums.
										byte mask	///< The bits to clear.
									  ) {
 80a26ce:	b570      	push	{r4, r5, r6, lr}
 80a26d0:	4605      	mov	r5, r0
 80a26d2:	460e      	mov	r6, r1
 80a26d4:	4614      	mov	r4, r2
	byte tmp;
	tmp = PCD_ReadRegister(reg);
 80a26d6:	f7ff ff7d 	bl	80a25d4 <_ZN7MFRC52216PCD_ReadRegisterEh>
	PCD_WriteRegister(reg, tmp & (~mask));		// clear bit mask
 80a26da:	ea20 0204 	bic.w	r2, r0, r4
 80a26de:	4631      	mov	r1, r6
 80a26e0:	4628      	mov	r0, r5
} // End PCD_ClearRegisterBitMask()
 80a26e2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
void MFRC522::PCD_ClearRegisterBitMask(	byte reg,	///< The register to update. One of the PCD_Register enums.
										byte mask	///< The bits to clear.
									  ) {
	byte tmp;
	tmp = PCD_ReadRegister(reg);
	PCD_WriteRegister(reg, tmp & (~mask));		// clear bit mask
 80a26e6:	b2d2      	uxtb	r2, r2
 80a26e8:	f7ff bf38 	b.w	80a255c <_ZN7MFRC52217PCD_WriteRegisterEhh>

080a26ec <_ZN7MFRC52216PCD_CalculateCRCEPhhS0_>:
 * @return STATUS_OK on success, STATUS_??? otherwise.
 */
byte MFRC522::PCD_CalculateCRC(	byte *data,		///< In: Pointer to the data to transfer to the FIFO for CRC calculation.
								byte length,	///< In: The number of bytes to transfer.
								byte *result	///< Out: Pointer to result buffer. Result is written to result[0..1], low byte first.
					 ) {
 80a26ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a26ee:	4604      	mov	r4, r0
 80a26f0:	4615      	mov	r5, r2
 80a26f2:	460f      	mov	r7, r1
	PCD_WriteRegister(CommandReg, PCD_Idle);			// Stop any active command.
 80a26f4:	2200      	movs	r2, #0
 80a26f6:	2102      	movs	r1, #2
 * @return STATUS_OK on success, STATUS_??? otherwise.
 */
byte MFRC522::PCD_CalculateCRC(	byte *data,		///< In: Pointer to the data to transfer to the FIFO for CRC calculation.
								byte length,	///< In: The number of bytes to transfer.
								byte *result	///< Out: Pointer to result buffer. Result is written to result[0..1], low byte first.
					 ) {
 80a26f8:	461e      	mov	r6, r3
	PCD_WriteRegister(CommandReg, PCD_Idle);			// Stop any active command.
 80a26fa:	f7ff ff2f 	bl	80a255c <_ZN7MFRC52217PCD_WriteRegisterEhh>
	PCD_WriteRegister(DivIrqReg, 0x04);					// Clear the CRCIRq interrupt request bit
 80a26fe:	2204      	movs	r2, #4
 80a2700:	210a      	movs	r1, #10
 80a2702:	4620      	mov	r0, r4
 80a2704:	f7ff ff2a 	bl	80a255c <_ZN7MFRC52217PCD_WriteRegisterEhh>
	PCD_SetRegisterBitMask(FIFOLevelReg, 0x80);		// FlushBuffer = 1, FIFO initialization
 80a2708:	2280      	movs	r2, #128	; 0x80
 80a270a:	2114      	movs	r1, #20
 80a270c:	4620      	mov	r0, r4
 80a270e:	f7ff ffcf 	bl	80a26b0 <_ZN7MFRC52222PCD_SetRegisterBitMaskEhh>
	PCD_WriteRegister(FIFODataReg, length, data);		// Write data to the FIFO
 80a2712:	462a      	mov	r2, r5
 80a2714:	463b      	mov	r3, r7
 80a2716:	2112      	movs	r1, #18
 80a2718:	4620      	mov	r0, r4
 80a271a:	f7ff ff39 	bl	80a2590 <_ZN7MFRC52217PCD_WriteRegisterEhhPh>
	PCD_WriteRegister(CommandReg, PCD_CalcCRC);		// Start the calculation
 80a271e:	2203      	movs	r2, #3
 80a2720:	2102      	movs	r1, #2
 80a2722:	4620      	mov	r0, r4
 80a2724:	f7ff ff1a 	bl	80a255c <_ZN7MFRC52217PCD_WriteRegisterEhh>
 80a2728:	f241 3588 	movw	r5, #5000	; 0x1388
	
	// Wait for the CRC calculation to complete. Each iteration of the while-loop takes 17.73�s.
	word i = 5000;
	byte n;
	while (1) {
		n = PCD_ReadRegister(DivIrqReg);	// DivIrqReg[7..0] bits are: Set2 reserved reserved MfinActIRq   reserved CRCIRq reserved reserved
 80a272c:	210a      	movs	r1, #10
 80a272e:	4620      	mov	r0, r4
 80a2730:	f7ff ff50 	bl	80a25d4 <_ZN7MFRC52216PCD_ReadRegisterEh>
		if (n & 0x04) {						// CRCIRq bit set - calculation done
 80a2734:	0743      	lsls	r3, r0, #29
 80a2736:	d405      	bmi.n	80a2744 <_ZN7MFRC52216PCD_CalculateCRCEPhhS0_+0x58>
 80a2738:	3d01      	subs	r5, #1
 80a273a:	b2ad      	uxth	r5, r5
			break;
		}
		if (--i == 0) {						// The emergency break. We will eventually terminate on this one after 89ms. Communication with the MFRC522 might be down.
 80a273c:	2d00      	cmp	r5, #0
 80a273e:	d1f5      	bne.n	80a272c <_ZN7MFRC52216PCD_CalculateCRCEPhhS0_+0x40>
			return STATUS_TIMEOUT;
 80a2740:	2004      	movs	r0, #4
	
	// Transfer the result from the registers to the result buffer
	result[0] = PCD_ReadRegister(CRCResultRegL);
	result[1] = PCD_ReadRegister(CRCResultRegH);
	return STATUS_OK;
} // End PCD_CalculateCRC()
 80a2742:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		}
		if (--i == 0) {						// The emergency break. We will eventually terminate on this one after 89ms. Communication with the MFRC522 might be down.
			return STATUS_TIMEOUT;
		}
	}
	PCD_WriteRegister(CommandReg, PCD_Idle);			// Stop calculating CRC for new content in the FIFO.
 80a2744:	2200      	movs	r2, #0
 80a2746:	4620      	mov	r0, r4
 80a2748:	2102      	movs	r1, #2
 80a274a:	f7ff ff07 	bl	80a255c <_ZN7MFRC52217PCD_WriteRegisterEhh>
	
	// Transfer the result from the registers to the result buffer
	result[0] = PCD_ReadRegister(CRCResultRegL);
 80a274e:	2144      	movs	r1, #68	; 0x44
 80a2750:	4620      	mov	r0, r4
 80a2752:	f7ff ff3f 	bl	80a25d4 <_ZN7MFRC52216PCD_ReadRegisterEh>
	result[1] = PCD_ReadRegister(CRCResultRegH);
 80a2756:	2142      	movs	r1, #66	; 0x42
		}
	}
	PCD_WriteRegister(CommandReg, PCD_Idle);			// Stop calculating CRC for new content in the FIFO.
	
	// Transfer the result from the registers to the result buffer
	result[0] = PCD_ReadRegister(CRCResultRegL);
 80a2758:	7030      	strb	r0, [r6, #0]
	result[1] = PCD_ReadRegister(CRCResultRegH);
 80a275a:	4620      	mov	r0, r4
 80a275c:	f7ff ff3a 	bl	80a25d4 <_ZN7MFRC52216PCD_ReadRegisterEh>
 80a2760:	7070      	strb	r0, [r6, #1]
	return STATUS_OK;
 80a2762:	2001      	movs	r0, #1
 80a2764:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a2766 <_ZN7MFRC5229PCD_ResetEv>:
} // End PCD_Init()

/**
 * Performs a soft reset on the MFRC522 chip and waits for it to be ready again.
 */
void MFRC522::PCD_Reset() {
 80a2766:	b510      	push	{r4, lr}
	PCD_WriteRegister(CommandReg, PCD_SoftReset);	// Issue the SoftReset command.
 80a2768:	220f      	movs	r2, #15
 80a276a:	2102      	movs	r1, #2
} // End PCD_Init()

/**
 * Performs a soft reset on the MFRC522 chip and waits for it to be ready again.
 */
void MFRC522::PCD_Reset() {
 80a276c:	4604      	mov	r4, r0
	PCD_WriteRegister(CommandReg, PCD_SoftReset);	// Issue the SoftReset command.
 80a276e:	f7ff fef5 	bl	80a255c <_ZN7MFRC52217PCD_WriteRegisterEhh>
	// The datasheet does not mention how long the SoftRest command takes to complete.
	// But the MFRC522 might have been in soft power-down mode (triggered by bit 4 of CommandReg) 
	// Section 8.8.2 in the datasheet says the oscillator start-up time is the start up time of the crystal + 37,74�s. Let us be generous: 50ms.
	delay(50);
 80a2772:	2032      	movs	r0, #50	; 0x32
 80a2774:	f003 fac2 	bl	80a5cfc <delay>
	// Wait for the PowerDown bit in CommandReg to be cleared
	while (PCD_ReadRegister(CommandReg) & (1<<4)) {
 80a2778:	2102      	movs	r1, #2
 80a277a:	4620      	mov	r0, r4
 80a277c:	f7ff ff2a 	bl	80a25d4 <_ZN7MFRC52216PCD_ReadRegisterEh>
 80a2780:	06c3      	lsls	r3, r0, #27
 80a2782:	d4f9      	bmi.n	80a2778 <_ZN7MFRC5229PCD_ResetEv+0x12>
		// PCD still restarting - unlikely after waiting 50ms, but better safe than sorry.
	}
} // End PCD_Reset()
 80a2784:	bd10      	pop	{r4, pc}

080a2786 <_ZN7MFRC52213PCD_AntennaOnEv>:

/**
 * Turns the antenna on by enabling pins TX1 and TX2.
 * After a reset these pins disabled.
 */
void MFRC522::PCD_AntennaOn() {
 80a2786:	b510      	push	{r4, lr}
	byte value = PCD_ReadRegister(TxControlReg);
 80a2788:	2128      	movs	r1, #40	; 0x28

/**
 * Turns the antenna on by enabling pins TX1 and TX2.
 * After a reset these pins disabled.
 */
void MFRC522::PCD_AntennaOn() {
 80a278a:	4604      	mov	r4, r0
	byte value = PCD_ReadRegister(TxControlReg);
 80a278c:	f7ff ff22 	bl	80a25d4 <_ZN7MFRC52216PCD_ReadRegisterEh>
	if ((value & 0x03) != 0x03) {
 80a2790:	f000 0303 	and.w	r3, r0, #3
 80a2794:	2b03      	cmp	r3, #3
 80a2796:	d008      	beq.n	80a27aa <_ZN7MFRC52213PCD_AntennaOnEv+0x24>
		PCD_WriteRegister(TxControlReg, value | 0x03);
 80a2798:	f040 0203 	orr.w	r2, r0, #3
 80a279c:	b2d2      	uxtb	r2, r2
 80a279e:	4620      	mov	r0, r4
	}
} // End PCD_AntennaOn()
 80a27a0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 * After a reset these pins disabled.
 */
void MFRC522::PCD_AntennaOn() {
	byte value = PCD_ReadRegister(TxControlReg);
	if ((value & 0x03) != 0x03) {
		PCD_WriteRegister(TxControlReg, value | 0x03);
 80a27a4:	2128      	movs	r1, #40	; 0x28
 80a27a6:	f7ff bed9 	b.w	80a255c <_ZN7MFRC52217PCD_WriteRegisterEhh>
 80a27aa:	bd10      	pop	{r4, pc}

080a27ac <_ZN7MFRC5228PCD_InitEv>:
/////////////////////////////////////////////////////////////////////////////////////

/**
 * Initializes the MFRC522 chip.
 */
void MFRC522::PCD_Init() {
 80a27ac:	b510      	push	{r4, lr}
 80a27ae:	4604      	mov	r4, r0
	if (digitalRead(_resetPowerDownPin) == LOW) { //The MFRC522 chip is in power down mode.
 80a27b0:	7b40      	ldrb	r0, [r0, #13]
 80a27b2:	f004 fa89 	bl	80a6cc8 <digitalRead>
 80a27b6:	b938      	cbnz	r0, 80a27c8 <_ZN7MFRC5228PCD_InitEv+0x1c>
		digitalWrite(_resetPowerDownPin, HIGH);	// Exit power down mode. This triggers a hard reset.
 80a27b8:	7b60      	ldrb	r0, [r4, #13]
 80a27ba:	2101      	movs	r1, #1
 80a27bc:	f004 fa6b 	bl	80a6c96 <digitalWrite>
		// Section 8.8.2 in the datasheet says the oscillator start-up time is the start up time of the crystal + 37,74�s. Let us be generous: 50ms.
		delay(50);
 80a27c0:	2032      	movs	r0, #50	; 0x32
 80a27c2:	f003 fa9b 	bl	80a5cfc <delay>
 80a27c6:	e002      	b.n	80a27ce <_ZN7MFRC5228PCD_InitEv+0x22>
	}
	else { // Perform a soft reset
		PCD_Reset();
 80a27c8:	4620      	mov	r0, r4
 80a27ca:	f7ff ffcc 	bl	80a2766 <_ZN7MFRC5229PCD_ResetEv>
	}
	
	// When communicating with a PICC we need a timeout if something goes wrong.
	// f_timer = 13.56 MHz / (2*TPreScaler+1) where TPreScaler = [TPrescaler_Hi:TPrescaler_Lo].
	// TPrescaler_Hi are the four low bits in TModeReg. TPrescaler_Lo is TPrescalerReg.
    PCD_WriteRegister(TModeReg, 0x80);			// TAuto=1; timer starts automatically at the end of the transmission in all communication modes at all speeds
 80a27ce:	4620      	mov	r0, r4
 80a27d0:	2280      	movs	r2, #128	; 0x80
 80a27d2:	2154      	movs	r1, #84	; 0x54
 80a27d4:	f7ff fec2 	bl	80a255c <_ZN7MFRC52217PCD_WriteRegisterEhh>
    PCD_WriteRegister(TPrescalerReg, 0xA9);	// TPreScaler = TModeReg[3..0]:TPrescalerReg, ie 0x0A9 = 169 => f_timer=40kHz, ie a timer period of 25�s.
 80a27d8:	4620      	mov	r0, r4
 80a27da:	22a9      	movs	r2, #169	; 0xa9
 80a27dc:	2156      	movs	r1, #86	; 0x56
 80a27de:	f7ff febd 	bl	80a255c <_ZN7MFRC52217PCD_WriteRegisterEhh>
    PCD_WriteRegister(TReloadRegH, 0x03);		// Reload timer with 0x3E8 = 1000, ie 25ms before timeout.
 80a27e2:	4620      	mov	r0, r4
 80a27e4:	2203      	movs	r2, #3
 80a27e6:	2158      	movs	r1, #88	; 0x58
 80a27e8:	f7ff feb8 	bl	80a255c <_ZN7MFRC52217PCD_WriteRegisterEhh>
    PCD_WriteRegister(TReloadRegL, 0xE8);
 80a27ec:	4620      	mov	r0, r4
 80a27ee:	22e8      	movs	r2, #232	; 0xe8
 80a27f0:	215a      	movs	r1, #90	; 0x5a
 80a27f2:	f7ff feb3 	bl	80a255c <_ZN7MFRC52217PCD_WriteRegisterEhh>
	
	PCD_WriteRegister(TxASKReg, 0x40);		// Default 0x00. Force a 100 % ASK modulation independent of the ModGsPReg register setting
 80a27f6:	4620      	mov	r0, r4
 80a27f8:	2240      	movs	r2, #64	; 0x40
 80a27fa:	212a      	movs	r1, #42	; 0x2a
 80a27fc:	f7ff feae 	bl	80a255c <_ZN7MFRC52217PCD_WriteRegisterEhh>
	PCD_WriteRegister(ModeReg, 0x3D);		// Default 0x3F. Set the preset value for the CRC coprocessor for the CalcCRC command to 0x6363 (ISO 14443-3 part 6.2.4)
 80a2800:	4620      	mov	r0, r4
 80a2802:	223d      	movs	r2, #61	; 0x3d
 80a2804:	2122      	movs	r1, #34	; 0x22
 80a2806:	f7ff fea9 	bl	80a255c <_ZN7MFRC52217PCD_WriteRegisterEhh>
	PCD_AntennaOn();						// Enable the antenna driver pins TX1 and TX2 (they were disabled by the reset)
 80a280a:	4620      	mov	r0, r4
} // End PCD_Init()
 80a280c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    PCD_WriteRegister(TReloadRegH, 0x03);		// Reload timer with 0x3E8 = 1000, ie 25ms before timeout.
    PCD_WriteRegister(TReloadRegL, 0xE8);
	
	PCD_WriteRegister(TxASKReg, 0x40);		// Default 0x00. Force a 100 % ASK modulation independent of the ModGsPReg register setting
	PCD_WriteRegister(ModeReg, 0x3D);		// Default 0x3F. Set the preset value for the CRC coprocessor for the CalcCRC command to 0x6363 (ISO 14443-3 part 6.2.4)
	PCD_AntennaOn();						// Enable the antenna driver pins TX1 and TX2 (they were disabled by the reset)
 80a2810:	f7ff bfb9 	b.w	80a2786 <_ZN7MFRC52213PCD_AntennaOnEv>

080a2814 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb>:
										byte *backData,		///< NULL or pointer to buffer if data should be read back after executing the command.
										byte *backLen,		///< In: Max number of bytes to write to *backData. Out: The number of bytes returned.
										byte *validBits,	///< In/Out: The number of valid bits in the last byte. 0 for 8 valid bits.
										byte rxAlign,		///< In: Defines the bit position in backData[0] for the first bit received. Default 0.
										bool checkCRC		///< In: True => The last two bytes of the response is assumed to be a CRC_A that must be validated.
									 ) {
 80a2814:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a2818:	b087      	sub	sp, #28
 80a281a:	f8dd 804c 	ldr.w	r8, [sp, #76]	; 0x4c
 80a281e:	4604      	mov	r4, r0
 80a2820:	468b      	mov	fp, r1
 80a2822:	9202      	str	r2, [sp, #8]
 80a2824:	9f11      	ldr	r7, [sp, #68]	; 0x44
 80a2826:	9d12      	ldr	r5, [sp, #72]	; 0x48
 80a2828:	f89d a050 	ldrb.w	sl, [sp, #80]	; 0x50
	byte n, _validBits;
	unsigned int i;

	// Prepare values for BitFramingReg
	byte txLastBits = validBits ? *validBits : 0;
 80a282c:	f1b8 0f00 	cmp.w	r8, #0
 80a2830:	d002      	beq.n	80a2838 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x24>
 80a2832:	f898 6000 	ldrb.w	r6, [r8]
 80a2836:	e000      	b.n	80a283a <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x26>
 80a2838:	4646      	mov	r6, r8
	byte bitFraming	= (rxAlign << 4) + txLastBits;		// RxAlign = BitFramingReg[6..4]. TxLastBits = BitFramingReg[2..0]
	
	PCD_WriteRegister(CommandReg, PCD_Idle);			// Stop any active command.
 80a283a:	2200      	movs	r2, #0
 80a283c:	2102      	movs	r1, #2
 80a283e:	4620      	mov	r0, r4
 80a2840:	9303      	str	r3, [sp, #12]
 80a2842:	f7ff fe8b 	bl	80a255c <_ZN7MFRC52217PCD_WriteRegisterEhh>
	PCD_WriteRegister(ComIrqReg, 0x7F);					// Clear all seven interrupt request bits
 80a2846:	227f      	movs	r2, #127	; 0x7f
 80a2848:	2108      	movs	r1, #8
 80a284a:	4620      	mov	r0, r4
 80a284c:	f7ff fe86 	bl	80a255c <_ZN7MFRC52217PCD_WriteRegisterEhh>
	byte n, _validBits;
	unsigned int i;

	// Prepare values for BitFramingReg
	byte txLastBits = validBits ? *validBits : 0;
	byte bitFraming	= (rxAlign << 4) + txLastBits;		// RxAlign = BitFramingReg[6..4]. TxLastBits = BitFramingReg[2..0]
 80a2850:	eb06 160a 	add.w	r6, r6, sl, lsl #4
	
	PCD_WriteRegister(CommandReg, PCD_Idle);			// Stop any active command.
	PCD_WriteRegister(ComIrqReg, 0x7F);					// Clear all seven interrupt request bits
	PCD_SetRegisterBitMask(FIFOLevelReg, 0x80);		// FlushBuffer = 1, FIFO initialization
 80a2854:	2280      	movs	r2, #128	; 0x80
 80a2856:	2114      	movs	r1, #20
 80a2858:	4620      	mov	r0, r4
 80a285a:	f7ff ff29 	bl	80a26b0 <_ZN7MFRC52222PCD_SetRegisterBitMaskEhh>
	byte n, _validBits;
	unsigned int i;

	// Prepare values for BitFramingReg
	byte txLastBits = validBits ? *validBits : 0;
	byte bitFraming	= (rxAlign << 4) + txLastBits;		// RxAlign = BitFramingReg[6..4]. TxLastBits = BitFramingReg[2..0]
 80a285e:	b2f6      	uxtb	r6, r6
	
	PCD_WriteRegister(CommandReg, PCD_Idle);			// Stop any active command.
	PCD_WriteRegister(ComIrqReg, 0x7F);					// Clear all seven interrupt request bits
	PCD_SetRegisterBitMask(FIFOLevelReg, 0x80);		// FlushBuffer = 1, FIFO initialization
	PCD_WriteRegister(FIFODataReg, sendLen, sendData);	// Write sendData to the FIFO
 80a2860:	9b03      	ldr	r3, [sp, #12]
 80a2862:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
 80a2866:	2112      	movs	r1, #18
 80a2868:	4620      	mov	r0, r4
 80a286a:	f7ff fe91 	bl	80a2590 <_ZN7MFRC52217PCD_WriteRegisterEhhPh>
	PCD_WriteRegister(BitFramingReg, bitFraming);		// Bit adjustments
 80a286e:	4632      	mov	r2, r6
 80a2870:	211a      	movs	r1, #26
 80a2872:	4620      	mov	r0, r4
 80a2874:	f7ff fe72 	bl	80a255c <_ZN7MFRC52217PCD_WriteRegisterEhh>
	PCD_WriteRegister(CommandReg, command);			// Execute the command
 80a2878:	465a      	mov	r2, fp
 80a287a:	2102      	movs	r1, #2
 80a287c:	4620      	mov	r0, r4
 80a287e:	f7ff fe6d 	bl	80a255c <_ZN7MFRC52217PCD_WriteRegisterEhh>
	if (command == PCD_Transceive) 	{
 80a2882:	f1bb 0f0c 	cmp.w	fp, #12
 80a2886:	d104      	bne.n	80a2892 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x7e>
		PCD_SetRegisterBitMask(BitFramingReg, 0x80);	// StartSend=1, transmission of data starts
 80a2888:	2280      	movs	r2, #128	; 0x80
 80a288a:	211a      	movs	r1, #26
 80a288c:	4620      	mov	r0, r4
 80a288e:	f7ff ff0f 	bl	80a26b0 <_ZN7MFRC52222PCD_SetRegisterBitMaskEhh>
									 ) {
	byte n, _validBits;
	unsigned int i;

	// Prepare values for BitFramingReg
	byte txLastBits = validBits ? *validBits : 0;
 80a2892:	f44f 66fa 	mov.w	r6, #2000	; 0x7d0
	// Wait for the command to complete.
	// In PCD_Init() we set the TAuto flag in TModeReg. This means the timer automatically starts when the PCD stops transmitting.
	// Each iteration of the do-while-loop takes 17.86�s.
	i = 2000;
	while (1) {
		n = PCD_ReadRegister(ComIrqReg);	// ComIrqReg[7..0] bits are: Set1 TxIRq RxIRq IdleIRq   HiAlertIRq LoAlertIRq ErrIRq TimerIRq
 80a2896:	2108      	movs	r1, #8
 80a2898:	4620      	mov	r0, r4
 80a289a:	f7ff fe9b 	bl	80a25d4 <_ZN7MFRC52216PCD_ReadRegisterEh>
		if (n & waitIRq) {					// One of the interrupts that signal success has been set.
 80a289e:	9b02      	ldr	r3, [sp, #8]
 80a28a0:	4218      	tst	r0, r3
 80a28a2:	d104      	bne.n	80a28ae <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x9a>
			break;
		}
		if (n & 0x01) {						// Timer interrupt - nothing received in 25ms
 80a28a4:	07c2      	lsls	r2, r0, #31
 80a28a6:	d452      	bmi.n	80a294e <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x13a>
			return STATUS_TIMEOUT;
		}
		if (--i == 0) {						// The emergency break. If all other condions fail we will eventually terminate on this one after 35.7ms. Communication with the MFRC522 might be down.
 80a28a8:	3e01      	subs	r6, #1
 80a28aa:	d1f4      	bne.n	80a2896 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x82>
 80a28ac:	e04f      	b.n	80a294e <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x13a>
			return STATUS_TIMEOUT;
		}
	}
	
	// Stop now if any errors except collisions were detected.
	byte errorRegValue = PCD_ReadRegister(ErrorReg); // ErrorReg[7..0] bits are: WrErr TempErr reserved BufferOvfl   CollErr CRCErr ParityErr ProtocolErr
 80a28ae:	210c      	movs	r1, #12
 80a28b0:	4620      	mov	r0, r4
 80a28b2:	f7ff fe8f 	bl	80a25d4 <_ZN7MFRC52216PCD_ReadRegisterEh>
	if (errorRegValue & 0x13) {	 // BufferOvfl ParityErr ProtocolErr
 80a28b6:	f010 0f13 	tst.w	r0, #19
			return STATUS_TIMEOUT;
		}
	}
	
	// Stop now if any errors except collisions were detected.
	byte errorRegValue = PCD_ReadRegister(ErrorReg); // ErrorReg[7..0] bits are: WrErr TempErr reserved BufferOvfl   CollErr CRCErr ParityErr ProtocolErr
 80a28ba:	4606      	mov	r6, r0
	if (errorRegValue & 0x13) {	 // BufferOvfl ParityErr ProtocolErr
 80a28bc:	d149      	bne.n	80a2952 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x13e>
		return STATUS_ERROR;
	}	

	// If the caller wants data back, get it from the MFRC522.
	if (backData && backLen) {
 80a28be:	b1df      	cbz	r7, 80a28f8 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0xe4>
 80a28c0:	b1d5      	cbz	r5, 80a28f8 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0xe4>
		n = PCD_ReadRegister(FIFOLevelReg);						// Number of bytes in the FIFO
 80a28c2:	2114      	movs	r1, #20
 80a28c4:	4620      	mov	r0, r4
 80a28c6:	f7ff fe85 	bl	80a25d4 <_ZN7MFRC52216PCD_ReadRegisterEh>
		if (n > *backLen) {
 80a28ca:	782b      	ldrb	r3, [r5, #0]
		return STATUS_ERROR;
	}	

	// If the caller wants data back, get it from the MFRC522.
	if (backData && backLen) {
		n = PCD_ReadRegister(FIFOLevelReg);						// Number of bytes in the FIFO
 80a28cc:	4602      	mov	r2, r0
		if (n > *backLen) {
 80a28ce:	4283      	cmp	r3, r0
 80a28d0:	d341      	bcc.n	80a2956 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x142>
			return STATUS_NO_ROOM;
		}
		*backLen = n;												// Number of bytes returned
 80a28d2:	7028      	strb	r0, [r5, #0]
		PCD_ReadRegister(FIFODataReg, n, backData, rxAlign);		// Get received data from FIFO
 80a28d4:	463b      	mov	r3, r7
 80a28d6:	2112      	movs	r1, #18
 80a28d8:	4620      	mov	r0, r4
 80a28da:	f8cd a000 	str.w	sl, [sp]
 80a28de:	f7ff fe95 	bl	80a260c <_ZN7MFRC52216PCD_ReadRegisterEhhPhh>
		_validBits = PCD_ReadRegister(ControlReg) & 0x07;	// RxLastBits[2:0] indicates the number of valid bits in the last received byte. If this value is 000b, the whole byte is valid.
 80a28e2:	2118      	movs	r1, #24
 80a28e4:	4620      	mov	r0, r4
 80a28e6:	f7ff fe75 	bl	80a25d4 <_ZN7MFRC52216PCD_ReadRegisterEh>
 80a28ea:	f000 0907 	and.w	r9, r0, #7
		if (validBits) {
 80a28ee:	f1b8 0f00 	cmp.w	r8, #0
 80a28f2:	d001      	beq.n	80a28f8 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0xe4>
			*validBits = _validBits;
 80a28f4:	f888 9000 	strb.w	r9, [r8]
		}
	}
	
	// Tell about collisions
	if (errorRegValue & 0x08) { // CollErr
 80a28f8:	0733      	lsls	r3, r6, #28
 80a28fa:	d42e      	bmi.n	80a295a <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x146>
		return STATUS_COLLISION;
	}
	
	// Perform CRC_A validation if requested.
	if (backData && backLen && checkCRC) {
 80a28fc:	b37f      	cbz	r7, 80a295e <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x14a>
 80a28fe:	b375      	cbz	r5, 80a295e <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x14a>
 80a2900:	f89d 3054 	ldrb.w	r3, [sp, #84]	; 0x54
 80a2904:	b35b      	cbz	r3, 80a295e <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x14a>
		// In this case a MIFARE Classic NAK is not OK.
		if (*backLen == 1 && _validBits == 4) {
 80a2906:	782a      	ldrb	r2, [r5, #0]
 80a2908:	2a01      	cmp	r2, #1
 80a290a:	d104      	bne.n	80a2916 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x102>
 80a290c:	f1b9 0f04 	cmp.w	r9, #4
 80a2910:	d127      	bne.n	80a2962 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x14e>
			return STATUS_MIFARE_NACK;
 80a2912:	2009      	movs	r0, #9
 80a2914:	e026      	b.n	80a2964 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x150>
		}
		// We need at least the CRC_A value and all 8 bits of the last byte must be received.
		if (*backLen < 2 || _validBits != 0) {
 80a2916:	d924      	bls.n	80a2962 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x14e>
 80a2918:	f1b9 0f00 	cmp.w	r9, #0
 80a291c:	d121      	bne.n	80a2962 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x14e>
			return STATUS_CRC_WRONG;
		}
		// Verify CRC_A - do our own calculation and store the control in controlBuffer.
		byte controlBuffer[2]; 
		n = PCD_CalculateCRC(&backData[0], *backLen - 2, &controlBuffer[0]);
 80a291e:	3a02      	subs	r2, #2
 80a2920:	ab05      	add	r3, sp, #20
 80a2922:	b2d2      	uxtb	r2, r2
 80a2924:	4639      	mov	r1, r7
 80a2926:	4620      	mov	r0, r4
 80a2928:	f7ff fee0 	bl	80a26ec <_ZN7MFRC52216PCD_CalculateCRCEPhhS0_>
		if (n != STATUS_OK) {
 80a292c:	2801      	cmp	r0, #1
 80a292e:	d119      	bne.n	80a2964 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x150>
			return n;
		}
		if ((backData[*backLen - 2] != controlBuffer[0]) || (backData[*backLen - 1] != controlBuffer[1])) {
 80a2930:	782b      	ldrb	r3, [r5, #0]
 80a2932:	441f      	add	r7, r3
 80a2934:	f817 2c02 	ldrb.w	r2, [r7, #-2]
 80a2938:	f89d 3014 	ldrb.w	r3, [sp, #20]
 80a293c:	429a      	cmp	r2, r3
 80a293e:	d110      	bne.n	80a2962 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x14e>
 80a2940:	f817 2c01 	ldrb.w	r2, [r7, #-1]
 80a2944:	f89d 3015 	ldrb.w	r3, [sp, #21]
 80a2948:	429a      	cmp	r2, r3
 80a294a:	d10a      	bne.n	80a2962 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x14e>
 80a294c:	e00a      	b.n	80a2964 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x150>
		n = PCD_ReadRegister(ComIrqReg);	// ComIrqReg[7..0] bits are: Set1 TxIRq RxIRq IdleIRq   HiAlertIRq LoAlertIRq ErrIRq TimerIRq
		if (n & waitIRq) {					// One of the interrupts that signal success has been set.
			break;
		}
		if (n & 0x01) {						// Timer interrupt - nothing received in 25ms
			return STATUS_TIMEOUT;
 80a294e:	2004      	movs	r0, #4
 80a2950:	e008      	b.n	80a2964 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x150>
	}
	
	// Stop now if any errors except collisions were detected.
	byte errorRegValue = PCD_ReadRegister(ErrorReg); // ErrorReg[7..0] bits are: WrErr TempErr reserved BufferOvfl   CollErr CRCErr ParityErr ProtocolErr
	if (errorRegValue & 0x13) {	 // BufferOvfl ParityErr ProtocolErr
		return STATUS_ERROR;
 80a2952:	2002      	movs	r0, #2
 80a2954:	e006      	b.n	80a2964 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x150>

	// If the caller wants data back, get it from the MFRC522.
	if (backData && backLen) {
		n = PCD_ReadRegister(FIFOLevelReg);						// Number of bytes in the FIFO
		if (n > *backLen) {
			return STATUS_NO_ROOM;
 80a2956:	2005      	movs	r0, #5
 80a2958:	e004      	b.n	80a2964 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x150>
		}
	}
	
	// Tell about collisions
	if (errorRegValue & 0x08) { // CollErr
		return STATUS_COLLISION;
 80a295a:	2003      	movs	r0, #3
 80a295c:	e002      	b.n	80a2964 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x150>
		if ((backData[*backLen - 2] != controlBuffer[0]) || (backData[*backLen - 1] != controlBuffer[1])) {
			return STATUS_CRC_WRONG;
		}
	}
	
	return STATUS_OK;
 80a295e:	2001      	movs	r0, #1
 80a2960:	e000      	b.n	80a2964 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x150>
		if (*backLen == 1 && _validBits == 4) {
			return STATUS_MIFARE_NACK;
		}
		// We need at least the CRC_A value and all 8 bits of the last byte must be received.
		if (*backLen < 2 || _validBits != 0) {
			return STATUS_CRC_WRONG;
 80a2962:	2008      	movs	r0, #8
			return STATUS_CRC_WRONG;
		}
	}
	
	return STATUS_OK;
} // End PCD_CommunicateWithPICC()
 80a2964:	b007      	add	sp, #28
 80a2966:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080a296a <_ZN7MFRC52218PCD_TransceiveDataEPhhS0_S0_S0_hb>:
									byte *backData,		///< NULL or pointer to buffer if data should be read back after executing the command.
									byte *backLen,		///< In: Max number of bytes to write to *backData. Out: The number of bytes returned.
									byte *validBits,	///< In/Out: The number of valid bits in the last byte. 0 for 8 valid bits. Default NULL.
									byte rxAlign,		///< In: Defines the bit position in backData[0] for the first bit received. Default 0.
									bool checkCRC		///< In: True => The last two bytes of the response is assumed to be a CRC_A that must be validated.
								 ) {
 80a296a:	b510      	push	{r4, lr}
 80a296c:	b086      	sub	sp, #24
	byte waitIRq = 0x30;		// RxIRq and IdleIRq
	return PCD_CommunicateWithPICC(PCD_Transceive, waitIRq, sendData, sendLen, backData, backLen, validBits, rxAlign, checkCRC);
 80a296e:	f89d 402c 	ldrb.w	r4, [sp, #44]	; 0x2c
 80a2972:	9405      	str	r4, [sp, #20]
 80a2974:	f89d 4028 	ldrb.w	r4, [sp, #40]	; 0x28
 80a2978:	9404      	str	r4, [sp, #16]
 80a297a:	9c09      	ldr	r4, [sp, #36]	; 0x24
 80a297c:	9403      	str	r4, [sp, #12]
 80a297e:	9c08      	ldr	r4, [sp, #32]
 80a2980:	e88d 001c 	stmia.w	sp, {r2, r3, r4}
 80a2984:	460b      	mov	r3, r1
 80a2986:	2230      	movs	r2, #48	; 0x30
 80a2988:	210c      	movs	r1, #12
 80a298a:	f7ff ff43 	bl	80a2814 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb>
} // End PCD_TransceiveData()
 80a298e:	b006      	add	sp, #24
 80a2990:	bd10      	pop	{r4, pc}

080a2992 <_ZN7MFRC52217PICC_REQA_or_WUPAEhPhS0_>:
 * @return STATUS_OK on success, STATUS_??? otherwise.
 */ 
byte MFRC522::PICC_REQA_or_WUPA(	byte command, 		///< The command to send - PICC_CMD_REQA or PICC_CMD_WUPA
									byte *bufferATQA,	///< The buffer to store the ATQA (Answer to request) in
									byte *bufferSize	///< Buffer size, at least two bytes. Also number of bytes returned if STATUS_OK.
							   ) {
 80a2992:	b570      	push	{r4, r5, r6, lr}
 80a2994:	b088      	sub	sp, #32
 80a2996:	4606      	mov	r6, r0
 80a2998:	461c      	mov	r4, r3
 80a299a:	f88d 1017 	strb.w	r1, [sp, #23]
	byte validBits;
	byte status;
	
	if (bufferATQA == NULL || *bufferSize < 2) {	// The ATQA response is 2 bytes long.
 80a299e:	4615      	mov	r5, r2
 80a29a0:	b312      	cbz	r2, 80a29e8 <_ZN7MFRC52217PICC_REQA_or_WUPAEhPhS0_+0x56>
 80a29a2:	781b      	ldrb	r3, [r3, #0]
 80a29a4:	2b01      	cmp	r3, #1
 80a29a6:	d91f      	bls.n	80a29e8 <_ZN7MFRC52217PICC_REQA_or_WUPAEhPhS0_+0x56>
		return STATUS_NO_ROOM;
	}
	PCD_ClearRegisterBitMask(CollReg, 0x80);			// ValuesAfterColl=1 => Bits received after collision are cleared.
 80a29a8:	2280      	movs	r2, #128	; 0x80
 80a29aa:	211c      	movs	r1, #28
 80a29ac:	f7ff fe8f 	bl	80a26ce <_ZN7MFRC52224PCD_ClearRegisterBitMaskEhh>
	validBits = 7;										// For REQA and WUPA we need the short frame format - transmit only 7 bits of the last (and only) byte. TxLastBits = BitFramingReg[2..0]
 80a29b0:	2307      	movs	r3, #7
 80a29b2:	f88d 301f 	strb.w	r3, [sp, #31]
	status = PCD_TransceiveData(&command, 1, bufferATQA, bufferSize, &validBits);
 80a29b6:	2300      	movs	r3, #0
 80a29b8:	9303      	str	r3, [sp, #12]
 80a29ba:	9302      	str	r3, [sp, #8]
 80a29bc:	f10d 031f 	add.w	r3, sp, #31
 80a29c0:	9301      	str	r3, [sp, #4]
 80a29c2:	9400      	str	r4, [sp, #0]
 80a29c4:	462b      	mov	r3, r5
 80a29c6:	2201      	movs	r2, #1
 80a29c8:	f10d 0117 	add.w	r1, sp, #23
 80a29cc:	4630      	mov	r0, r6
 80a29ce:	f7ff ffcc 	bl	80a296a <_ZN7MFRC52218PCD_TransceiveDataEPhhS0_S0_S0_hb>
	if (status != STATUS_OK) {
 80a29d2:	2801      	cmp	r0, #1
 80a29d4:	d10b      	bne.n	80a29ee <_ZN7MFRC52217PICC_REQA_or_WUPAEhPhS0_+0x5c>
		return status;
	}
	if (*bufferSize != 2 || validBits != 0) {		// ATQA must be exactly 16 bits.
 80a29d6:	7820      	ldrb	r0, [r4, #0]
 80a29d8:	2802      	cmp	r0, #2
 80a29da:	d107      	bne.n	80a29ec <_ZN7MFRC52217PICC_REQA_or_WUPAEhPhS0_+0x5a>
 80a29dc:	f89d 301f 	ldrb.w	r3, [sp, #31]
 80a29e0:	2b00      	cmp	r3, #0
		return STATUS_ERROR;
	}
	return STATUS_OK;
 80a29e2:	bf08      	it	eq
 80a29e4:	2001      	moveq	r0, #1
 80a29e6:	e002      	b.n	80a29ee <_ZN7MFRC52217PICC_REQA_or_WUPAEhPhS0_+0x5c>
							   ) {
	byte validBits;
	byte status;
	
	if (bufferATQA == NULL || *bufferSize < 2) {	// The ATQA response is 2 bytes long.
		return STATUS_NO_ROOM;
 80a29e8:	2005      	movs	r0, #5
 80a29ea:	e000      	b.n	80a29ee <_ZN7MFRC52217PICC_REQA_or_WUPAEhPhS0_+0x5c>
	status = PCD_TransceiveData(&command, 1, bufferATQA, bufferSize, &validBits);
	if (status != STATUS_OK) {
		return status;
	}
	if (*bufferSize != 2 || validBits != 0) {		// ATQA must be exactly 16 bits.
		return STATUS_ERROR;
 80a29ec:	2002      	movs	r0, #2
	}
	return STATUS_OK;
} // End PICC_REQA_or_WUPA()
 80a29ee:	b008      	add	sp, #32
 80a29f0:	bd70      	pop	{r4, r5, r6, pc}

080a29f2 <_ZN7MFRC52213PICC_RequestAEPhS0_>:
 * @return STATUS_OK on success, STATUS_??? otherwise.
 */
byte MFRC522::PICC_RequestA(byte *bufferATQA,	///< The buffer to store the ATQA (Answer to request) in
							byte *bufferSize	///< Buffer size, at least two bytes. Also number of bytes returned if STATUS_OK.
							) {
	return PICC_REQA_or_WUPA(PICC_CMD_REQA, bufferATQA, bufferSize);
 80a29f2:	4613      	mov	r3, r2
 80a29f4:	460a      	mov	r2, r1
 80a29f6:	2126      	movs	r1, #38	; 0x26
 80a29f8:	f7ff bfcb 	b.w	80a2992 <_ZN7MFRC52217PICC_REQA_or_WUPAEhPhS0_>

080a29fc <_ZN7MFRC52211PICC_SelectEPNS_3UidEh>:
 * 
 * @return STATUS_OK on success, STATUS_??? otherwise.
 */
byte MFRC522::PICC_Select(	Uid *uid,			///< Pointer to Uid struct. Normally output, but can also be used to supply a known UID.
							byte validBits		///< The number of known UID bits supplied in *uid. Normally 0. If set you must also supply uid->size.
						 ) {
 80a29fc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	//		10 bytes		1			CT		uid0	uid1	uid2
	//						2			CT		uid3	uid4	uid5
	//						3			uid6	uid7	uid8	uid9
	
	// Sanity checks
	if (validBits > 80) {
 80a2a00:	2a50      	cmp	r2, #80	; 0x50
 * 
 * @return STATUS_OK on success, STATUS_??? otherwise.
 */
byte MFRC522::PICC_Select(	Uid *uid,			///< Pointer to Uid struct. Normally output, but can also be used to supply a known UID.
							byte validBits		///< The number of known UID bits supplied in *uid. Normally 0. If set you must also supply uid->size.
						 ) {
 80a2a02:	b08b      	sub	sp, #44	; 0x2c
 80a2a04:	4683      	mov	fp, r0
 80a2a06:	468a      	mov	sl, r1
 80a2a08:	4617      	mov	r7, r2
	//		10 bytes		1			CT		uid0	uid1	uid2
	//						2			CT		uid3	uid4	uid5
	//						3			uid6	uid7	uid8	uid9
	
	// Sanity checks
	if (validBits > 80) {
 80a2a0a:	f200 80f6 	bhi.w	80a2bfa <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x1fe>
		return STATUS_INVALID;
	}

	// Prepare MFRC522
	PCD_ClearRegisterBitMask(CollReg, 0x80);			// ValuesAfterColl=1 => Bits received after collision are cleared.
 80a2a0e:	2280      	movs	r2, #128	; 0x80
 80a2a10:	211c      	movs	r1, #28
 80a2a12:	f7ff fe5c 	bl	80a26ce <_ZN7MFRC52224PCD_ClearRegisterBitMaskEhh>
							byte validBits		///< The number of known UID bits supplied in *uid. Normally 0. If set you must also supply uid->size.
						 ) {
	bool uidComplete;
	bool selectDone;
	bool useCascadeTag;
	byte cascadeLevel	= 1; 
 80a2a16:	2501      	movs	r5, #1

	// Repeat Cascade Level loop until we have a complete UID.
	uidComplete = false;
	while ( ! uidComplete) {
		// Set the Cascade Level in the SEL byte, find out if we need to use the Cascade Tag in byte 2.
		switch (cascadeLevel) {
 80a2a18:	2d02      	cmp	r5, #2
 80a2a1a:	d010      	beq.n	80a2a3e <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x42>
 80a2a1c:	2d03      	cmp	r5, #3
 80a2a1e:	d01b      	beq.n	80a2a58 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x5c>
 80a2a20:	2d01      	cmp	r5, #1
 80a2a22:	f040 80ec 	bne.w	80a2bfe <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x202>
			case 1:
				buffer[0] = PICC_CMD_SEL_CL1;
 80a2a26:	2393      	movs	r3, #147	; 0x93
 80a2a28:	f88d 301c 	strb.w	r3, [sp, #28]
				uidIndex = 0;
				useCascadeTag = validBits && uid->size > 4;	// When we know that the UID has more than 4 bytes
 80a2a2c:	b1d7      	cbz	r7, 80a2a64 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x68>
 80a2a2e:	f89a 3000 	ldrb.w	r3, [sl]
	while ( ! uidComplete) {
		// Set the Cascade Level in the SEL byte, find out if we need to use the Cascade Tag in byte 2.
		switch (cascadeLevel) {
			case 1:
				buffer[0] = PICC_CMD_SEL_CL1;
				uidIndex = 0;
 80a2a32:	2600      	movs	r6, #0
				useCascadeTag = validBits && uid->size > 4;	// When we know that the UID has more than 4 bytes
 80a2a34:	2b04      	cmp	r3, #4
 80a2a36:	bf94      	ite	ls
 80a2a38:	2300      	movls	r3, #0
 80a2a3a:	2301      	movhi	r3, #1
 80a2a3c:	e016      	b.n	80a2a6c <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x70>
				break;
			
			case 2:
				buffer[0] = PICC_CMD_SEL_CL2;
 80a2a3e:	f06f 036a 	mvn.w	r3, #106	; 0x6a
 80a2a42:	f88d 301c 	strb.w	r3, [sp, #28]
				uidIndex = 3;
				useCascadeTag = validBits && uid->size > 7;	// When we know that the UID has more than 7 bytes
 80a2a46:	b17f      	cbz	r7, 80a2a68 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x6c>
 80a2a48:	f89a 3000 	ldrb.w	r3, [sl]
				useCascadeTag = validBits && uid->size > 4;	// When we know that the UID has more than 4 bytes
				break;
			
			case 2:
				buffer[0] = PICC_CMD_SEL_CL2;
				uidIndex = 3;
 80a2a4c:	2603      	movs	r6, #3
				useCascadeTag = validBits && uid->size > 7;	// When we know that the UID has more than 7 bytes
 80a2a4e:	2b07      	cmp	r3, #7
 80a2a50:	bf94      	ite	ls
 80a2a52:	2300      	movls	r3, #0
 80a2a54:	2301      	movhi	r3, #1
 80a2a56:	e009      	b.n	80a2a6c <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x70>
				break;
			
			case 3:
				buffer[0] = PICC_CMD_SEL_CL3;
 80a2a58:	2397      	movs	r3, #151	; 0x97
 80a2a5a:	f88d 301c 	strb.w	r3, [sp, #28]
				uidIndex = 6;
 80a2a5e:	2606      	movs	r6, #6
				useCascadeTag = false;						// Never used in CL3.
 80a2a60:	2300      	movs	r3, #0
				break;
 80a2a62:	e003      	b.n	80a2a6c <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x70>
	while ( ! uidComplete) {
		// Set the Cascade Level in the SEL byte, find out if we need to use the Cascade Tag in byte 2.
		switch (cascadeLevel) {
			case 1:
				buffer[0] = PICC_CMD_SEL_CL1;
				uidIndex = 0;
 80a2a64:	463e      	mov	r6, r7
 80a2a66:	e000      	b.n	80a2a6a <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x6e>
				useCascadeTag = validBits && uid->size > 4;	// When we know that the UID has more than 4 bytes
				break;
			
			case 2:
				buffer[0] = PICC_CMD_SEL_CL2;
				uidIndex = 3;
 80a2a68:	2603      	movs	r6, #3
				useCascadeTag = validBits && uid->size > 7;	// When we know that the UID has more than 7 bytes
 80a2a6a:	463b      	mov	r3, r7
				return STATUS_INTERNAL_ERROR;
				break;
		}
		
		// How many UID bits are known in this Cascade Level?
		currentLevelKnownBits = validBits - (8 * uidIndex);
 80a2a6c:	eba7 04c6 	sub.w	r4, r7, r6, lsl #3
 80a2a70:	b264      	sxtb	r4, r4
 80a2a72:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
		if (currentLevelKnownBits < 0) {
			currentLevelKnownBits = 0;
		}
		// Copy the known bits from uid->uidByte[] to buffer[]
		index = 2; // destination index in buffer[]
		if (useCascadeTag) {
 80a2a76:	b12b      	cbz	r3, 80a2a84 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x88>
			buffer[index++] = PICC_CMD_CT;
 80a2a78:	2288      	movs	r2, #136	; 0x88
 80a2a7a:	f88d 201e 	strb.w	r2, [sp, #30]
 80a2a7e:	f04f 0803 	mov.w	r8, #3
 80a2a82:	e001      	b.n	80a2a88 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x8c>
		currentLevelKnownBits = validBits - (8 * uidIndex);
		if (currentLevelKnownBits < 0) {
			currentLevelKnownBits = 0;
		}
		// Copy the known bits from uid->uidByte[] to buffer[]
		index = 2; // destination index in buffer[]
 80a2a84:	f04f 0802 	mov.w	r8, #2
		if (useCascadeTag) {
			buffer[index++] = PICC_CMD_CT;
		}
		byte bytesToCopy = currentLevelKnownBits / 8 + (currentLevelKnownBits % 8 ? 1 : 0); // The number of bytes needed to represent the known bits for this level.
 80a2a88:	b2e1      	uxtb	r1, r4
 80a2a8a:	f011 0207 	ands.w	r2, r1, #7
 80a2a8e:	bf18      	it	ne
 80a2a90:	2201      	movne	r2, #1
 80a2a92:	eb02 02e4 	add.w	r2, r2, r4, asr #3
		if (bytesToCopy) {
 80a2a96:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
 80a2a9a:	d106      	bne.n	80a2aaa <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0xae>
			for (count = 0; count < bytesToCopy; count++) {
				buffer[index++] = uid->uidByte[uidIndex + count];
			}
		}
		// Now that the data has been copied we need to include the 8 bits in CT in currentLevelKnownBits
		if (useCascadeTag) {
 80a2a9c:	2b00      	cmp	r3, #0
 80a2a9e:	f000 808c 	beq.w	80a2bba <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x1be>
			currentLevelKnownBits += 8;
 80a2aa2:	f101 0408 	add.w	r4, r1, #8
 80a2aa6:	b264      	sxtb	r4, r4
 80a2aa8:	e087      	b.n	80a2bba <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x1be>
		if (useCascadeTag) {
			buffer[index++] = PICC_CMD_CT;
		}
		byte bytesToCopy = currentLevelKnownBits / 8 + (currentLevelKnownBits % 8 ? 1 : 0); // The number of bytes needed to represent the known bits for this level.
		if (bytesToCopy) {
			byte maxBytes = useCascadeTag ? 3 : 4; // Max 4 bytes in each Cascade Level. Only 3 left if we use the Cascade Tag
 80a2aaa:	2b00      	cmp	r3, #0
 80a2aac:	bf14      	ite	ne
 80a2aae:	2003      	movne	r0, #3
 80a2ab0:	2004      	moveq	r0, #4
 80a2ab2:	4282      	cmp	r2, r0
 80a2ab4:	bf28      	it	cs
 80a2ab6:	4602      	movcs	r2, r0
 80a2ab8:	2000      	movs	r0, #0
			if (bytesToCopy > maxBytes) { 
				bytesToCopy = maxBytes;
			}
			for (count = 0; count < bytesToCopy; count++) {
				buffer[index++] = uid->uidByte[uidIndex + count];
 80a2aba:	eb08 0e00 	add.w	lr, r8, r0
 80a2abe:	f10d 0c28 	add.w	ip, sp, #40	; 0x28
 80a2ac2:	fa5f fe8e 	uxtb.w	lr, lr
 80a2ac6:	44e6      	add	lr, ip
 80a2ac8:	eb06 0c00 	add.w	ip, r6, r0
 80a2acc:	44d4      	add	ip, sl
 80a2ace:	f89c c001 	ldrb.w	ip, [ip, #1]
 80a2ad2:	3001      	adds	r0, #1
 80a2ad4:	f80e cc0c 	strb.w	ip, [lr, #-12]
		if (bytesToCopy) {
			byte maxBytes = useCascadeTag ? 3 : 4; // Max 4 bytes in each Cascade Level. Only 3 left if we use the Cascade Tag
			if (bytesToCopy > maxBytes) { 
				bytesToCopy = maxBytes;
			}
			for (count = 0; count < bytesToCopy; count++) {
 80a2ad8:	fa5f fe80 	uxtb.w	lr, r0
 80a2adc:	4596      	cmp	lr, r2
 80a2ade:	d3ec      	bcc.n	80a2aba <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0xbe>
 80a2ae0:	e7dc      	b.n	80a2a9c <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0xa0>
				currentLevelKnownBits = collisionPos;
				count			= (currentLevelKnownBits - 1) % 8; // The bit to modify
				index			= 1 + (currentLevelKnownBits / 8) + (count ? 1 : 0); // First byte is index 0.
				buffer[index]	|= (1 << count); 
			}
			else if (result != STATUS_OK) {
 80a2ae2:	2801      	cmp	r0, #1
 80a2ae4:	f040 808d 	bne.w	80a2c02 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x206>
				return result;
			}
			else { // STATUS_OK
				if (currentLevelKnownBits >= 32) { // This was a SELECT.
 80a2ae8:	2c1f      	cmp	r4, #31
 80a2aea:	f300 808c 	bgt.w	80a2c06 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x20a>
					selectDone = true; // No more anticollision 
					// We continue below outside the while.
				}
				else { // This was an ANTICOLLISION.
					// We now have all 32 bits of the UID in this Cascade Level
					currentLevelKnownBits = 32;
 80a2aee:	2420      	movs	r4, #32
		selectDone = false;
		while ( ! selectDone) {
			// Find out how many bits and bytes to send and receive.
			if (currentLevelKnownBits >= 32) { // All UID bits in this Cascade Level are known. This is a SELECT.
				//Serial.print("SELECT: currentLevelKnownBits="); Serial.println(currentLevelKnownBits, DEC);
				buffer[1] = 0x70; // NVB - Number of Valid Bits: Seven whole bytes
 80a2af0:	f04f 0370 	mov.w	r3, #112	; 0x70
				// Calulate BCC - Block Check Character
				buffer[6] = buffer[2] ^ buffer[3] ^ buffer[4] ^ buffer[5];
 80a2af4:	f89d 201e 	ldrb.w	r2, [sp, #30]
		selectDone = false;
		while ( ! selectDone) {
			// Find out how many bits and bytes to send and receive.
			if (currentLevelKnownBits >= 32) { // All UID bits in this Cascade Level are known. This is a SELECT.
				//Serial.print("SELECT: currentLevelKnownBits="); Serial.println(currentLevelKnownBits, DEC);
				buffer[1] = 0x70; // NVB - Number of Valid Bits: Seven whole bytes
 80a2af8:	f88d 301d 	strb.w	r3, [sp, #29]
				// Calulate BCC - Block Check Character
				buffer[6] = buffer[2] ^ buffer[3] ^ buffer[4] ^ buffer[5];
 80a2afc:	f89d 301f 	ldrb.w	r3, [sp, #31]
				// Calculate CRC_A
				result = PCD_CalculateCRC(buffer, 7, &buffer[7]);
 80a2b00:	a907      	add	r1, sp, #28
			// Find out how many bits and bytes to send and receive.
			if (currentLevelKnownBits >= 32) { // All UID bits in this Cascade Level are known. This is a SELECT.
				//Serial.print("SELECT: currentLevelKnownBits="); Serial.println(currentLevelKnownBits, DEC);
				buffer[1] = 0x70; // NVB - Number of Valid Bits: Seven whole bytes
				// Calulate BCC - Block Check Character
				buffer[6] = buffer[2] ^ buffer[3] ^ buffer[4] ^ buffer[5];
 80a2b02:	4053      	eors	r3, r2
 80a2b04:	f89d 2020 	ldrb.w	r2, [sp, #32]
				// Calculate CRC_A
				result = PCD_CalculateCRC(buffer, 7, &buffer[7]);
 80a2b08:	4658      	mov	r0, fp
			// Find out how many bits and bytes to send and receive.
			if (currentLevelKnownBits >= 32) { // All UID bits in this Cascade Level are known. This is a SELECT.
				//Serial.print("SELECT: currentLevelKnownBits="); Serial.println(currentLevelKnownBits, DEC);
				buffer[1] = 0x70; // NVB - Number of Valid Bits: Seven whole bytes
				// Calulate BCC - Block Check Character
				buffer[6] = buffer[2] ^ buffer[3] ^ buffer[4] ^ buffer[5];
 80a2b0a:	405a      	eors	r2, r3
 80a2b0c:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
 80a2b10:	4053      	eors	r3, r2
 80a2b12:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
				// Calculate CRC_A
				result = PCD_CalculateCRC(buffer, 7, &buffer[7]);
 80a2b16:	2207      	movs	r2, #7
 80a2b18:	f10d 0323 	add.w	r3, sp, #35	; 0x23
 80a2b1c:	f7ff fde6 	bl	80a26ec <_ZN7MFRC52216PCD_CalculateCRCEPhhS0_>
				if (result != STATUS_OK) {
 80a2b20:	2801      	cmp	r0, #1
 80a2b22:	f040 80b7 	bne.w	80a2c94 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x298>
					return result;
				}
				txLastBits		= 0; // 0 => All 8 bits are valid.
 80a2b26:	f04f 0300 	mov.w	r3, #0
 80a2b2a:	f88d 301a 	strb.w	r3, [sp, #26]
				bufferUsed		= 9;
				// Store response in the last 3 bytes of buffer (BCC and CRC_A - not needed after tx)
				responseBuffer	= &buffer[6];
				responseLength	= 3;
 80a2b2e:	2303      	movs	r3, #3
 80a2b30:	f88d 301b 	strb.w	r3, [sp, #27]
				result = PCD_CalculateCRC(buffer, 7, &buffer[7]);
				if (result != STATUS_OK) {
					return result;
				}
				txLastBits		= 0; // 0 => All 8 bits are valid.
				bufferUsed		= 9;
 80a2b34:	2309      	movs	r3, #9
				// Store response in the last 3 bytes of buffer (BCC and CRC_A - not needed after tx)
				responseBuffer	= &buffer[6];
 80a2b36:	f10d 0922 	add.w	r9, sp, #34	; 0x22
				result = PCD_CalculateCRC(buffer, 7, &buffer[7]);
				if (result != STATUS_OK) {
					return result;
				}
				txLastBits		= 0; // 0 => All 8 bits are valid.
				bufferUsed		= 9;
 80a2b3a:	9304      	str	r3, [sp, #16]
				responseBuffer	= &buffer[index];
				responseLength	= sizeof(buffer) - index;
			}

			// Set bit adjustments
			rxAlign = txLastBits;											// Having a seperate variable is overkill. But it makes the next line easier to read.
 80a2b3c:	f10d 0828 	add.w	r8, sp, #40	; 0x28
 80a2b40:	f818 3d0e 	ldrb.w	r3, [r8, #-14]!
			PCD_WriteRegister(BitFramingReg, (rxAlign << 4) + txLastBits);	// RxAlign = BitFramingReg[6..4]. TxLastBits = BitFramingReg[2..0]
 80a2b44:	211a      	movs	r1, #26
 80a2b46:	eb03 1203 	add.w	r2, r3, r3, lsl #4
 80a2b4a:	b2d2      	uxtb	r2, r2
 80a2b4c:	4658      	mov	r0, fp
 80a2b4e:	9305      	str	r3, [sp, #20]
 80a2b50:	f7ff fd04 	bl	80a255c <_ZN7MFRC52217PCD_WriteRegisterEhh>

			// Transmit the buffer and receive the response.
			result = PCD_TransceiveData(buffer, bufferUsed, responseBuffer, &responseLength, &txLastBits, rxAlign);			
 80a2b54:	2300      	movs	r3, #0
 80a2b56:	9303      	str	r3, [sp, #12]
 80a2b58:	9b05      	ldr	r3, [sp, #20]
 80a2b5a:	f8cd 8004 	str.w	r8, [sp, #4]
 80a2b5e:	9302      	str	r3, [sp, #8]
 80a2b60:	f10d 031b 	add.w	r3, sp, #27
 80a2b64:	9300      	str	r3, [sp, #0]
 80a2b66:	9a04      	ldr	r2, [sp, #16]
 80a2b68:	464b      	mov	r3, r9
 80a2b6a:	a907      	add	r1, sp, #28
 80a2b6c:	4658      	mov	r0, fp
 80a2b6e:	f7ff fefc 	bl	80a296a <_ZN7MFRC52218PCD_TransceiveDataEPhhS0_S0_S0_hb>
			if (result == STATUS_COLLISION) { // More than one PICC in the field => collision.
 80a2b72:	2803      	cmp	r0, #3
			// Set bit adjustments
			rxAlign = txLastBits;											// Having a seperate variable is overkill. But it makes the next line easier to read.
			PCD_WriteRegister(BitFramingReg, (rxAlign << 4) + txLastBits);	// RxAlign = BitFramingReg[6..4]. TxLastBits = BitFramingReg[2..0]

			// Transmit the buffer and receive the response.
			result = PCD_TransceiveData(buffer, bufferUsed, responseBuffer, &responseLength, &txLastBits, rxAlign);			
 80a2b74:	4680      	mov	r8, r0
			if (result == STATUS_COLLISION) { // More than one PICC in the field => collision.
 80a2b76:	d1b4      	bne.n	80a2ae2 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0xe6>
				result = PCD_ReadRegister(CollReg); // CollReg[7..0] bits are: ValuesAfterColl reserved CollPosNotValid CollPos[4:0]
 80a2b78:	211c      	movs	r1, #28
 80a2b7a:	4658      	mov	r0, fp
 80a2b7c:	f7ff fd2a 	bl	80a25d4 <_ZN7MFRC52216PCD_ReadRegisterEh>
				if (result & 0x20) { // CollPosNotValid
 80a2b80:	0681      	lsls	r1, r0, #26
 80a2b82:	d43e      	bmi.n	80a2c02 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x206>
					return STATUS_COLLISION; // Without a valid collision position we cannot continue
				}
				byte collisionPos = result & 0x1F; // Values 0-31, 0 means bit 32.
				if (collisionPos == 0) {
					collisionPos = 32;
 80a2b84:	f010 001f 	ands.w	r0, r0, #31
 80a2b88:	bf08      	it	eq
 80a2b8a:	2020      	moveq	r0, #32
				}
				if (collisionPos <= currentLevelKnownBits) { // No progress - should not happen 
 80a2b8c:	42a0      	cmp	r0, r4
 80a2b8e:	dd36      	ble.n	80a2bfe <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x202>
					return STATUS_INTERNAL_ERROR;
				}
				// Choose the PICC with the bit set.
				currentLevelKnownBits = collisionPos;
 80a2b90:	b244      	sxtb	r4, r0
				count			= (currentLevelKnownBits - 1) % 8; // The bit to modify
 80a2b92:	3801      	subs	r0, #1
				index			= 1 + (currentLevelKnownBits / 8) + (count ? 1 : 0); // First byte is index 0.
				buffer[index]	|= (1 << count); 
 80a2b94:	f000 0307 	and.w	r3, r0, #7
 80a2b98:	f010 0007 	ands.w	r0, r0, #7
 80a2b9c:	bf18      	it	ne
 80a2b9e:	2001      	movne	r0, #1
 80a2ba0:	eb00 00e4 	add.w	r0, r0, r4, asr #3
 80a2ba4:	aa0a      	add	r2, sp, #40	; 0x28
 80a2ba6:	3001      	adds	r0, #1
 80a2ba8:	4410      	add	r0, r2
 80a2baa:	2201      	movs	r2, #1
 80a2bac:	fa02 f303 	lsl.w	r3, r2, r3
 80a2bb0:	f810 2c0c 	ldrb.w	r2, [r0, #-12]
 80a2bb4:	4313      	orrs	r3, r2
 80a2bb6:	f800 3c0c 	strb.w	r3, [r0, #-12]
		
		// Repeat anti collision loop until we can transmit all UID bits + BCC and receive a SAK - max 32 iterations.
		selectDone = false;
		while ( ! selectDone) {
			// Find out how many bits and bytes to send and receive.
			if (currentLevelKnownBits >= 32) { // All UID bits in this Cascade Level are known. This is a SELECT.
 80a2bba:	2c1f      	cmp	r4, #31
 80a2bbc:	dc98      	bgt.n	80a2af0 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0xf4>
			}
			else { // This is an ANTICOLLISION.
				//Serial.print("ANTICOLLISION: currentLevelKnownBits="); Serial.println(currentLevelKnownBits, DEC);
				txLastBits		= currentLevelKnownBits % 8;
				count			= currentLevelKnownBits / 8;	// Number of whole bytes in the UID part.
				index			= 2 + count;					// Number of whole bytes: SEL + NVB + UIDs
 80a2bbe:	10e3      	asrs	r3, r4, #3
 80a2bc0:	3302      	adds	r3, #2
 80a2bc2:	b2db      	uxtb	r3, r3
				responseBuffer	= &buffer[6];
				responseLength	= 3;
			}
			else { // This is an ANTICOLLISION.
				//Serial.print("ANTICOLLISION: currentLevelKnownBits="); Serial.println(currentLevelKnownBits, DEC);
				txLastBits		= currentLevelKnownBits % 8;
 80a2bc4:	f004 0807 	and.w	r8, r4, #7
 80a2bc8:	fa5f f288 	uxtb.w	r2, r8
				count			= currentLevelKnownBits / 8;	// Number of whole bytes in the UID part.
				index			= 2 + count;					// Number of whole bytes: SEL + NVB + UIDs
				buffer[1]		= (index << 4) + txLastBits;	// NVB - Number of Valid Bits
				bufferUsed		= index + (txLastBits ? 1 : 0);
 80a2bcc:	f1b8 0f00 	cmp.w	r8, #0
 80a2bd0:	bf0c      	ite	eq
 80a2bd2:	4698      	moveq	r8, r3
 80a2bd4:	f103 0801 	addne.w	r8, r3, #1
				responseBuffer	= &buffer[6];
				responseLength	= 3;
			}
			else { // This is an ANTICOLLISION.
				//Serial.print("ANTICOLLISION: currentLevelKnownBits="); Serial.println(currentLevelKnownBits, DEC);
				txLastBits		= currentLevelKnownBits % 8;
 80a2bd8:	f88d 201a 	strb.w	r2, [sp, #26]
				count			= currentLevelKnownBits / 8;	// Number of whole bytes in the UID part.
				index			= 2 + count;					// Number of whole bytes: SEL + NVB + UIDs
				buffer[1]		= (index << 4) + txLastBits;	// NVB - Number of Valid Bits
 80a2bdc:	eb02 1203 	add.w	r2, r2, r3, lsl #4
 80a2be0:	f88d 201d 	strb.w	r2, [sp, #29]
				bufferUsed		= index + (txLastBits ? 1 : 0);
 80a2be4:	fa5f f288 	uxtb.w	r2, r8
 80a2be8:	9204      	str	r2, [sp, #16]
				// Store response in the unused part of buffer
				responseBuffer	= &buffer[index];
 80a2bea:	aa07      	add	r2, sp, #28
 80a2bec:	eb02 0903 	add.w	r9, r2, r3
				responseLength	= sizeof(buffer) - index;
 80a2bf0:	f1c3 0309 	rsb	r3, r3, #9
 80a2bf4:	f88d 301b 	strb.w	r3, [sp, #27]
 80a2bf8:	e7a0      	b.n	80a2b3c <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x140>
	//						2			CT		uid3	uid4	uid5
	//						3			uid6	uid7	uid8	uid9
	
	// Sanity checks
	if (validBits > 80) {
		return STATUS_INVALID;
 80a2bfa:	2007      	movs	r0, #7
 80a2bfc:	e04a      	b.n	80a2c94 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x298>
				byte collisionPos = result & 0x1F; // Values 0-31, 0 means bit 32.
				if (collisionPos == 0) {
					collisionPos = 32;
				}
				if (collisionPos <= currentLevelKnownBits) { // No progress - should not happen 
					return STATUS_INTERNAL_ERROR;
 80a2bfe:	2006      	movs	r0, #6
 80a2c00:	e048      	b.n	80a2c94 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x298>
			// Set bit adjustments
			rxAlign = txLastBits;											// Having a seperate variable is overkill. But it makes the next line easier to read.
			PCD_WriteRegister(BitFramingReg, (rxAlign << 4) + txLastBits);	// RxAlign = BitFramingReg[6..4]. TxLastBits = BitFramingReg[2..0]

			// Transmit the buffer and receive the response.
			result = PCD_TransceiveData(buffer, bufferUsed, responseBuffer, &responseLength, &txLastBits, rxAlign);			
 80a2c02:	4640      	mov	r0, r8
 80a2c04:	e046      	b.n	80a2c94 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x298>
		} // End of while ( ! selectDone)

		// We do not check the CBB - it was constructed by us above.
		
		// Copy the found UID bytes from buffer[] to uid->uidByte[]
		index			= (buffer[2] == PICC_CMD_CT) ? 3 : 2; // source index in buffer[]
 80a2c06:	f89d 301e 	ldrb.w	r3, [sp, #30]
 80a2c0a:	2b88      	cmp	r3, #136	; 0x88
 80a2c0c:	d03f      	beq.n	80a2c8e <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x292>
 80a2c0e:	2102      	movs	r1, #2
		bytesToCopy		= (buffer[2] == PICC_CMD_CT) ? 3 : 4;
 80a2c10:	2404      	movs	r4, #4
 80a2c12:	2300      	movs	r3, #0
		for (count = 0; count < bytesToCopy; count++) {
			uid->uidByte[uidIndex + count] = buffer[index++];
 80a2c14:	18ca      	adds	r2, r1, r3
 80a2c16:	b2d2      	uxtb	r2, r2
 80a2c18:	f10d 0e28 	add.w	lr, sp, #40	; 0x28
 80a2c1c:	4472      	add	r2, lr
 80a2c1e:	18f0      	adds	r0, r6, r3
 80a2c20:	f812 2c0c 	ldrb.w	r2, [r2, #-12]
 80a2c24:	4450      	add	r0, sl
 80a2c26:	3301      	adds	r3, #1
 80a2c28:	7042      	strb	r2, [r0, #1]
		// We do not check the CBB - it was constructed by us above.
		
		// Copy the found UID bytes from buffer[] to uid->uidByte[]
		index			= (buffer[2] == PICC_CMD_CT) ? 3 : 2; // source index in buffer[]
		bytesToCopy		= (buffer[2] == PICC_CMD_CT) ? 3 : 4;
		for (count = 0; count < bytesToCopy; count++) {
 80a2c2a:	b2da      	uxtb	r2, r3
 80a2c2c:	4294      	cmp	r4, r2
 80a2c2e:	d8f1      	bhi.n	80a2c14 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x218>
			uid->uidByte[uidIndex + count] = buffer[index++];
		}
		
		// Check response SAK (Select Acknowledge)
		if (responseLength != 3 || txLastBits != 0) {		// SAK must be exactly 24 bits (1 byte + CRC_A).
 80a2c30:	f89d 301b 	ldrb.w	r3, [sp, #27]
 80a2c34:	2b03      	cmp	r3, #3
 80a2c36:	d126      	bne.n	80a2c86 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x28a>
 80a2c38:	f89d 301a 	ldrb.w	r3, [sp, #26]
 80a2c3c:	bb1b      	cbnz	r3, 80a2c86 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x28a>
			return STATUS_ERROR;
		}
		// Verify CRC_A - do our own calculation and store the control in buffer[2..3] - those bytes are not needed anymore.
		result = PCD_CalculateCRC(responseBuffer, 1, &buffer[2]);
 80a2c3e:	f10d 031e 	add.w	r3, sp, #30
 80a2c42:	2201      	movs	r2, #1
 80a2c44:	4649      	mov	r1, r9
 80a2c46:	4658      	mov	r0, fp
 80a2c48:	f7ff fd50 	bl	80a26ec <_ZN7MFRC52216PCD_CalculateCRCEPhhS0_>
		if (result != STATUS_OK) {
 80a2c4c:	2801      	cmp	r0, #1
 80a2c4e:	d121      	bne.n	80a2c94 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x298>
			return result;
		}
		if ((buffer[2] != responseBuffer[1]) || (buffer[3] != responseBuffer[2])) {
 80a2c50:	f89d 201e 	ldrb.w	r2, [sp, #30]
 80a2c54:	f899 3001 	ldrb.w	r3, [r9, #1]
 80a2c58:	429a      	cmp	r2, r3
 80a2c5a:	d116      	bne.n	80a2c8a <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x28e>
 80a2c5c:	f89d 201f 	ldrb.w	r2, [sp, #31]
 80a2c60:	f899 3002 	ldrb.w	r3, [r9, #2]
 80a2c64:	429a      	cmp	r2, r3
 80a2c66:	d110      	bne.n	80a2c8a <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x28e>
			return STATUS_CRC_WRONG;
		}
		if (responseBuffer[0] & 0x04) { // Cascade bit set - UID not complete yes
 80a2c68:	f899 3000 	ldrb.w	r3, [r9]
 80a2c6c:	075a      	lsls	r2, r3, #29
 80a2c6e:	d502      	bpl.n	80a2c76 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x27a>
			cascadeLevel++;
 80a2c70:	3501      	adds	r5, #1
 80a2c72:	b2ed      	uxtb	r5, r5
 80a2c74:	e6d0      	b.n	80a2a18 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x1c>
			uid->sak = responseBuffer[0];
		}
	} // End of while ( ! uidComplete)
	
	// Set correct uid->size
	uid->size = 3 * cascadeLevel + 1;
 80a2c76:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 80a2c7a:	3501      	adds	r5, #1
		if (responseBuffer[0] & 0x04) { // Cascade bit set - UID not complete yes
			cascadeLevel++;
		}
		else {
			uidComplete = true;
			uid->sak = responseBuffer[0];
 80a2c7c:	f88a 300b 	strb.w	r3, [sl, #11]
		}
	} // End of while ( ! uidComplete)
	
	// Set correct uid->size
	uid->size = 3 * cascadeLevel + 1;
 80a2c80:	f88a 5000 	strb.w	r5, [sl]

	return STATUS_OK;
 80a2c84:	e006      	b.n	80a2c94 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x298>
			uid->uidByte[uidIndex + count] = buffer[index++];
		}
		
		// Check response SAK (Select Acknowledge)
		if (responseLength != 3 || txLastBits != 0) {		// SAK must be exactly 24 bits (1 byte + CRC_A).
			return STATUS_ERROR;
 80a2c86:	2002      	movs	r0, #2
 80a2c88:	e004      	b.n	80a2c94 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x298>
		result = PCD_CalculateCRC(responseBuffer, 1, &buffer[2]);
		if (result != STATUS_OK) {
			return result;
		}
		if ((buffer[2] != responseBuffer[1]) || (buffer[3] != responseBuffer[2])) {
			return STATUS_CRC_WRONG;
 80a2c8a:	2008      	movs	r0, #8
 80a2c8c:	e002      	b.n	80a2c94 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x298>
		} // End of while ( ! selectDone)

		// We do not check the CBB - it was constructed by us above.
		
		// Copy the found UID bytes from buffer[] to uid->uidByte[]
		index			= (buffer[2] == PICC_CMD_CT) ? 3 : 2; // source index in buffer[]
 80a2c8e:	2103      	movs	r1, #3
		bytesToCopy		= (buffer[2] == PICC_CMD_CT) ? 3 : 4;
 80a2c90:	460c      	mov	r4, r1
 80a2c92:	e7be      	b.n	80a2c12 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x216>
	
	// Set correct uid->size
	uid->size = 3 * cascadeLevel + 1;

	return STATUS_OK;
} // End PICC_Select()
 80a2c94:	b00b      	add	sp, #44	; 0x2c
 80a2c96:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080a2c9a <_ZN7MFRC52210PICC_HaltAEv>:
/**
 * Instructs a PICC in state ACTIVE(*) to go to state HALT.
 *
 * @return STATUS_OK on success, STATUS_??? otherwise.
 */ 
byte MFRC522::PICC_HaltA() {
 80a2c9a:	b570      	push	{r4, r5, r6, lr}
	byte result;
	byte buffer[4]; 

	// Build command buffer
	buffer[0] = PICC_CMD_HLTA;
 80a2c9c:	2350      	movs	r3, #80	; 0x50
/**
 * Instructs a PICC in state ACTIVE(*) to go to state HALT.
 *
 * @return STATUS_OK on success, STATUS_??? otherwise.
 */ 
byte MFRC522::PICC_HaltA() {
 80a2c9e:	b086      	sub	sp, #24
	byte result;
	byte buffer[4]; 

	// Build command buffer
	buffer[0] = PICC_CMD_HLTA;
 80a2ca0:	f88d 3014 	strb.w	r3, [sp, #20]
	buffer[1] = 0;
 80a2ca4:	2500      	movs	r5, #0
	// Calculate CRC_A
	result = PCD_CalculateCRC(buffer, 2, &buffer[2]);
 80a2ca6:	f10d 0316 	add.w	r3, sp, #22
 80a2caa:	2202      	movs	r2, #2
 80a2cac:	a905      	add	r1, sp, #20
/**
 * Instructs a PICC in state ACTIVE(*) to go to state HALT.
 *
 * @return STATUS_OK on success, STATUS_??? otherwise.
 */ 
byte MFRC522::PICC_HaltA() {
 80a2cae:	4606      	mov	r6, r0
	byte result;
	byte buffer[4]; 

	// Build command buffer
	buffer[0] = PICC_CMD_HLTA;
	buffer[1] = 0;
 80a2cb0:	f88d 5015 	strb.w	r5, [sp, #21]
	// Calculate CRC_A
	result = PCD_CalculateCRC(buffer, 2, &buffer[2]);
 80a2cb4:	f7ff fd1a 	bl	80a26ec <_ZN7MFRC52216PCD_CalculateCRCEPhhS0_>
	if (result != STATUS_OK) {
 80a2cb8:	2801      	cmp	r0, #1

	// Build command buffer
	buffer[0] = PICC_CMD_HLTA;
	buffer[1] = 0;
	// Calculate CRC_A
	result = PCD_CalculateCRC(buffer, 2, &buffer[2]);
 80a2cba:	4604      	mov	r4, r0
	if (result != STATUS_OK) {
 80a2cbc:	d10f      	bne.n	80a2cde <_ZN7MFRC52210PICC_HaltAEv+0x44>
	// Send the command.
	// The standard says:
	//		If the PICC responds with any modulation during a period of 1 ms after the end of the frame containing the
	//		HLTA command, this response shall be interpreted as 'not acknowledge'.
	// We interpret that this way: Only STATUS_TIMEOUT is an success.
	result = PCD_TransceiveData(buffer, sizeof(buffer), NULL, 0);
 80a2cbe:	9503      	str	r5, [sp, #12]
 80a2cc0:	9502      	str	r5, [sp, #8]
 80a2cc2:	9501      	str	r5, [sp, #4]
 80a2cc4:	9500      	str	r5, [sp, #0]
 80a2cc6:	462b      	mov	r3, r5
 80a2cc8:	2204      	movs	r2, #4
 80a2cca:	a905      	add	r1, sp, #20
 80a2ccc:	4630      	mov	r0, r6
 80a2cce:	f7ff fe4c 	bl	80a296a <_ZN7MFRC52218PCD_TransceiveDataEPhhS0_S0_S0_hb>
	if (result == STATUS_TIMEOUT) {
 80a2cd2:	2804      	cmp	r0, #4
 80a2cd4:	d003      	beq.n	80a2cde <_ZN7MFRC52210PICC_HaltAEv+0x44>
		return STATUS_OK;
	}
	if (result == STATUS_OK) { // That is ironically NOT ok in this case ;-)
 80a2cd6:	2801      	cmp	r0, #1
 80a2cd8:	bf08      	it	eq
 80a2cda:	2002      	moveq	r0, #2
 80a2cdc:	e000      	b.n	80a2ce0 <_ZN7MFRC52210PICC_HaltAEv+0x46>
	//		If the PICC responds with any modulation during a period of 1 ms after the end of the frame containing the
	//		HLTA command, this response shall be interpreted as 'not acknowledge'.
	// We interpret that this way: Only STATUS_TIMEOUT is an success.
	result = PCD_TransceiveData(buffer, sizeof(buffer), NULL, 0);
	if (result == STATUS_TIMEOUT) {
		return STATUS_OK;
 80a2cde:	4620      	mov	r0, r4
	}
	if (result == STATUS_OK) { // That is ironically NOT ok in this case ;-)
		return STATUS_ERROR;
	}
	return result;
} // End PICC_HaltA()
 80a2ce0:	b006      	add	sp, #24
 80a2ce2:	bd70      	pop	{r4, r5, r6, pc}

080a2ce4 <_ZN7MFRC52215PCD_StopCrypto1Ev>:
 * Used to exit the PCD from its authenticated state.
 * Remember to call this function after communicating with an authenticated PICC - otherwise no new communications can start.
 */
void MFRC522::PCD_StopCrypto1() {
	// Clear MFCrypto1On bit
	PCD_ClearRegisterBitMask(Status2Reg, 0x08); // Status2Reg[7..0] bits are: TempSensClear I2CForceHS reserved reserved   MFCrypto1On ModemState[2:0]
 80a2ce4:	2208      	movs	r2, #8
 80a2ce6:	2110      	movs	r1, #16
 80a2ce8:	f7ff bcf1 	b.w	80a26ce <_ZN7MFRC52224PCD_ClearRegisterBitMaskEhh>

080a2cec <_ZN7MFRC52221PICC_IsNewCardPresentEv>:
 * Returns true if a PICC responds to PICC_CMD_REQA.
 * Only "new" cards in state IDLE are invited. Sleeping cards in state HALT are ignored.
 * 
 * @return bool
 */
bool MFRC522::PICC_IsNewCardPresent() {
 80a2cec:	b507      	push	{r0, r1, r2, lr}
	byte bufferATQA[2];
	byte bufferSize = sizeof(bufferATQA);
 80a2cee:	2302      	movs	r3, #2
 80a2cf0:	aa02      	add	r2, sp, #8
 80a2cf2:	f802 3d05 	strb.w	r3, [r2, #-5]!
	byte result = PICC_RequestA(bufferATQA, &bufferSize);
 80a2cf6:	a901      	add	r1, sp, #4
 80a2cf8:	f7ff fe7b 	bl	80a29f2 <_ZN7MFRC52213PICC_RequestAEPhS0_>
	return (result == STATUS_OK || result == STATUS_COLLISION);
 80a2cfc:	2801      	cmp	r0, #1
 80a2cfe:	d002      	beq.n	80a2d06 <_ZN7MFRC52221PICC_IsNewCardPresentEv+0x1a>
 80a2d00:	1ec3      	subs	r3, r0, #3
 80a2d02:	4258      	negs	r0, r3
 80a2d04:	4158      	adcs	r0, r3
} // End PICC_IsNewCardPresent()
 80a2d06:	b003      	add	sp, #12
 80a2d08:	f85d fb04 	ldr.w	pc, [sp], #4

080a2d0c <_ZN7MFRC52219PICC_ReadCardSerialEv>:
 * Remember to call PICC_IsNewCardPresent(), PICC_RequestA() or PICC_WakeupA() first.
 * The read UID is available in the class variable uid.
 * 
 * @return bool
 */
bool MFRC522::PICC_ReadCardSerial() {
 80a2d0c:	b508      	push	{r3, lr}
	byte result = PICC_Select(&uid);
 80a2d0e:	2200      	movs	r2, #0
 80a2d10:	4601      	mov	r1, r0
 80a2d12:	f7ff fe73 	bl	80a29fc <_ZN7MFRC52211PICC_SelectEPNS_3UidEh>
	return (result == STATUS_OK);
} // End PICC_ReadCardSerial()
 80a2d16:	1e43      	subs	r3, r0, #1
 80a2d18:	4258      	negs	r0, r3
 80a2d1a:	4158      	adcs	r0, r3
 80a2d1c:	bd08      	pop	{r3, pc}

080a2d1e <_GLOBAL__sub_I__ZN7MFRC522C2Ehh>:
 80a2d1e:	f002 b913 	b.w	80a4f48 <HAL_Pin_Map>

080a2d22 <micros>:
inline unsigned long micros(void) { return HAL_Timer_Get_Micro_Seconds(); }
 80a2d22:	f002 b991 	b.w	80a5048 <HAL_Timer_Get_Micro_Seconds>

080a2d26 <_ZN17Adafruit_NeoPixelD1Ev>:
{
  updateLength(n);
  setPin(p);
}

Adafruit_NeoPixel::~Adafruit_NeoPixel() {
 80a2d26:	b510      	push	{r4, lr}
 80a2d28:	4604      	mov	r4, r0
  if (pixels) free(pixels);
 80a2d2a:	68c0      	ldr	r0, [r0, #12]
 80a2d2c:	b108      	cbz	r0, 80a2d32 <_ZN17Adafruit_NeoPixelD1Ev+0xc>
 80a2d2e:	f002 fbf1 	bl	80a5514 <free>
  if (begun) pinMode(pin, INPUT);
 80a2d32:	7823      	ldrb	r3, [r4, #0]
 80a2d34:	b11b      	cbz	r3, 80a2d3e <_ZN17Adafruit_NeoPixelD1Ev+0x18>
 80a2d36:	2100      	movs	r1, #0
 80a2d38:	79e0      	ldrb	r0, [r4, #7]
 80a2d3a:	f003 ff9b 	bl	80a6c74 <pinMode>
}
 80a2d3e:	4620      	mov	r0, r4
 80a2d40:	bd10      	pop	{r4, pc}

080a2d42 <_ZN17Adafruit_NeoPixel12updateLengthEt>:

void Adafruit_NeoPixel::updateLength(uint16_t n) {
 80a2d42:	b538      	push	{r3, r4, r5, lr}
 80a2d44:	4604      	mov	r4, r0
  if (pixels) free(pixels); // Free existing data (if any)
 80a2d46:	68c0      	ldr	r0, [r0, #12]
Adafruit_NeoPixel::~Adafruit_NeoPixel() {
  if (pixels) free(pixels);
  if (begun) pinMode(pin, INPUT);
}

void Adafruit_NeoPixel::updateLength(uint16_t n) {
 80a2d48:	460d      	mov	r5, r1
  if (pixels) free(pixels); // Free existing data (if any)
 80a2d4a:	b108      	cbz	r0, 80a2d50 <_ZN17Adafruit_NeoPixel12updateLengthEt+0xe>
 80a2d4c:	f002 fbe2 	bl	80a5514 <free>

  // Allocate new data -- note: ALL PIXELS ARE CLEARED
  numBytes = n * ((type == SK6812RGBW) ? 4 : 3);
 80a2d50:	79a3      	ldrb	r3, [r4, #6]
 80a2d52:	2b06      	cmp	r3, #6
 80a2d54:	bf0c      	ite	eq
 80a2d56:	2004      	moveq	r0, #4
 80a2d58:	2003      	movne	r0, #3
 80a2d5a:	4368      	muls	r0, r5
 80a2d5c:	b280      	uxth	r0, r0
 80a2d5e:	80a0      	strh	r0, [r4, #4]
  if ((pixels = (uint8_t *)malloc(numBytes))) {
 80a2d60:	f002 fbd0 	bl	80a5504 <malloc>
 80a2d64:	60e0      	str	r0, [r4, #12]
 80a2d66:	b128      	cbz	r0, 80a2d74 <_ZN17Adafruit_NeoPixel12updateLengthEt+0x32>
    memset(pixels, 0, numBytes);
 80a2d68:	88a2      	ldrh	r2, [r4, #4]
 80a2d6a:	2100      	movs	r1, #0
 80a2d6c:	f004 fd75 	bl	80a785a <memset>
    numLEDs = n;
 80a2d70:	8065      	strh	r5, [r4, #2]
 80a2d72:	bd38      	pop	{r3, r4, r5, pc}
  } else {
    numLEDs = numBytes = 0;
 80a2d74:	80a0      	strh	r0, [r4, #4]
 80a2d76:	8060      	strh	r0, [r4, #2]
 80a2d78:	bd38      	pop	{r3, r4, r5, pc}

080a2d7a <_ZN17Adafruit_NeoPixel5beginEv>:
  }
}

void Adafruit_NeoPixel::begin(void) {
 80a2d7a:	b510      	push	{r4, lr}
 80a2d7c:	4604      	mov	r4, r0
  pinMode(pin, OUTPUT);
 80a2d7e:	2101      	movs	r1, #1
 80a2d80:	79c0      	ldrb	r0, [r0, #7]
 80a2d82:	f003 ff77 	bl	80a6c74 <pinMode>
  digitalWrite(pin, LOW);
 80a2d86:	2100      	movs	r1, #0
 80a2d88:	79e0      	ldrb	r0, [r4, #7]
 80a2d8a:	f003 ff84 	bl	80a6c96 <digitalWrite>
  begun = true;
 80a2d8e:	2301      	movs	r3, #1
 80a2d90:	7023      	strb	r3, [r4, #0]
 80a2d92:	bd10      	pop	{r4, pc}

080a2d94 <_ZN17Adafruit_NeoPixel6setPinEh>:
}

// Set the output pin number
void Adafruit_NeoPixel::setPin(uint8_t p) {
 80a2d94:	b538      	push	{r3, r4, r5, lr}
    if (begun) {
 80a2d96:	7803      	ldrb	r3, [r0, #0]
  digitalWrite(pin, LOW);
  begun = true;
}

// Set the output pin number
void Adafruit_NeoPixel::setPin(uint8_t p) {
 80a2d98:	4605      	mov	r5, r0
 80a2d9a:	460c      	mov	r4, r1
    if (begun) {
 80a2d9c:	b11b      	cbz	r3, 80a2da6 <_ZN17Adafruit_NeoPixel6setPinEh+0x12>
        pinMode(pin, INPUT);
 80a2d9e:	2100      	movs	r1, #0
 80a2da0:	79c0      	ldrb	r0, [r0, #7]
 80a2da2:	f003 ff67 	bl	80a6c74 <pinMode>
    }
    pin = p;
    if (begun) {
 80a2da6:	782b      	ldrb	r3, [r5, #0]
// Set the output pin number
void Adafruit_NeoPixel::setPin(uint8_t p) {
    if (begun) {
        pinMode(pin, INPUT);
    }
    pin = p;
 80a2da8:	71ec      	strb	r4, [r5, #7]
    if (begun) {
 80a2daa:	b153      	cbz	r3, 80a2dc2 <_ZN17Adafruit_NeoPixel6setPinEh+0x2e>
        pinMode(p, OUTPUT);
 80a2dac:	b2a4      	uxth	r4, r4
 80a2dae:	4620      	mov	r0, r4
 80a2db0:	2101      	movs	r1, #1
 80a2db2:	f003 ff5f 	bl	80a6c74 <pinMode>
        digitalWrite(p, LOW);
 80a2db6:	4620      	mov	r0, r4
    }
}
 80a2db8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        pinMode(pin, INPUT);
    }
    pin = p;
    if (begun) {
        pinMode(p, OUTPUT);
        digitalWrite(p, LOW);
 80a2dbc:	2100      	movs	r1, #0
 80a2dbe:	f003 bf6a 	b.w	80a6c96 <digitalWrite>
 80a2dc2:	bd38      	pop	{r3, r4, r5, pc}

080a2dc4 <_ZN17Adafruit_NeoPixelC1Ethh>:
  #error "*** PLATFORM_ID not supported by this library. PLATFORM should be Particle Core, Photon, Electron, Argon, Boron, Xenon and RedBear Duo ***"
#endif
// fast pin access
#define pinSet(_pin, _hilo) (_hilo ? pinHI(_pin) : pinLO(_pin))

Adafruit_NeoPixel::Adafruit_NeoPixel(uint16_t n, uint8_t p, uint8_t t) :
 80a2dc4:	b570      	push	{r4, r5, r6, lr}
 80a2dc6:	4604      	mov	r4, r0
 80a2dc8:	4616      	mov	r6, r2
  begun(false), type(t), brightness(0), pixels(NULL), endTime(0)
 80a2dca:	2500      	movs	r5, #0
 80a2dcc:	7183      	strb	r3, [r0, #6]
 80a2dce:	7005      	strb	r5, [r0, #0]
 80a2dd0:	7205      	strb	r5, [r0, #8]
 80a2dd2:	60c5      	str	r5, [r0, #12]
 80a2dd4:	6105      	str	r5, [r0, #16]
{
  updateLength(n);
 80a2dd6:	f7ff ffb4 	bl	80a2d42 <_ZN17Adafruit_NeoPixel12updateLengthEt>
  setPin(p);
 80a2dda:	4620      	mov	r0, r4
 80a2ddc:	4631      	mov	r1, r6
 80a2dde:	f7ff ffd9 	bl	80a2d94 <_ZN17Adafruit_NeoPixel6setPinEh>
}
 80a2de2:	4620      	mov	r0, r4
 80a2de4:	bd70      	pop	{r4, r5, r6, pc}
	...

080a2de8 <_ZN17Adafruit_NeoPixel4showEv>:
        digitalWrite(p, LOW);
    }
}

void Adafruit_NeoPixel::show(void) {
  if(!pixels) return;
 80a2de8:	68c3      	ldr	r3, [r0, #12]
 80a2dea:	2b00      	cmp	r3, #0
 80a2dec:	f000 858e 	beq.w	80a390c <_ZN17Adafruit_NeoPixel4showEv+0xb24>
        pinMode(p, OUTPUT);
        digitalWrite(p, LOW);
    }
}

void Adafruit_NeoPixel::show(void) {
 80a2df0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a2df4:	4604      	mov	r4, r0
 80a2df6:	7983      	ldrb	r3, [r0, #6]
 80a2df8:	b086      	sub	sp, #24
 80a2dfa:	3b02      	subs	r3, #2
 80a2dfc:	b2db      	uxtb	r3, r3
 80a2dfe:	2b04      	cmp	r3, #4
 80a2e00:	bf96      	itet	ls
 80a2e02:	4a29      	ldrls	r2, [pc, #164]	; (80a2ea8 <_ZN17Adafruit_NeoPixel4showEv+0xc0>)
  // the function will simply hold off (if needed) on issuing the
  // subsequent round of data until the latch time has elapsed.  This
  // allows the mainline code to start generating the next frame of data
  // rather than stalling for the latch.
  uint32_t wait_time; // wait time in microseconds.
  switch(type) {
 80a2e04:	2532      	movhi	r5, #50	; 0x32
 80a2e06:	f852 5023 	ldrls.w	r5, [r2, r3, lsl #2]
    case WS2812B2_FAST:
    default: {   // default = 50us reset pulse
        wait_time = 50L;
      } break;
  }
  while((micros() - endTime) < wait_time);
 80a2e0a:	f7ff ff8a 	bl	80a2d22 <micros>
 80a2e0e:	6923      	ldr	r3, [r4, #16]
 80a2e10:	1ac0      	subs	r0, r0, r3
 80a2e12:	42a8      	cmp	r0, r5
 80a2e14:	d3f9      	bcc.n	80a2e0a <_ZN17Adafruit_NeoPixel4showEv+0x22>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i");
 80a2e16:	b672      	cpsid	i
    g,              // Current green byte value
    r,              // Current red byte value
    b,              // Current blue byte value
    w;              // Current white byte value

  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
 80a2e18:	79a1      	ldrb	r1, [r4, #6]
  __disable_irq(); // Need 100% focus on instruction timing

  volatile uint32_t
    c,    // 24-bit/32-bit pixel color
    mask; // 1-bit mask
  volatile uint16_t i = numBytes; // Output loop counter
 80a2e1a:	88a3      	ldrh	r3, [r4, #4]
    g,              // Current green byte value
    r,              // Current red byte value
    b,              // Current blue byte value
    w;              // Current white byte value

  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
 80a2e1c:	2902      	cmp	r1, #2
  __disable_irq(); // Need 100% focus on instruction timing

  volatile uint32_t
    c,    // 24-bit/32-bit pixel color
    mask; // 1-bit mask
  volatile uint16_t i = numBytes; // Output loop counter
 80a2e1e:	f8ad 300a 	strh.w	r3, [sp, #10]
  volatile uint8_t
    j,              // 8-bit inner loop counter
   *ptr = pixels,   // Pointer to next byte
 80a2e22:	f8d4 e00c 	ldr.w	lr, [r4, #12]
    g,              // Current green byte value
    r,              // Current red byte value
    b,              // Current blue byte value
    w;              // Current white byte value

  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
 80a2e26:	f000 8272 	beq.w	80a330e <_ZN17Adafruit_NeoPixel4showEv+0x526>
 80a2e2a:	2907      	cmp	r1, #7
 80a2e2c:	f000 826f 	beq.w	80a330e <_ZN17Adafruit_NeoPixel4showEv+0x526>
        }
        mask >>= 1;
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else if(type == SK6812RGBW) { // similar to WS2812, 800 KHz bitstream but with RGB+W components
 80a2e30:	2906      	cmp	r1, #6
 80a2e32:	f000 8432 	beq.w	80a369a <_ZN17Adafruit_NeoPixel4showEv+0x8b2>
        }
        mask >>= 1;
      } while ( ++j < 32 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else if(type == WS2812B2 || type == WS2812B2_FAST) { // WS2812B with DWT timer
 80a2e36:	2905      	cmp	r1, #5
 80a2e38:	f000 83ab 	beq.w	80a3592 <_ZN17Adafruit_NeoPixel4showEv+0x7aa>
 80a2e3c:	2908      	cmp	r1, #8
 80a2e3e:	f000 83a8 	beq.w	80a3592 <_ZN17Adafruit_NeoPixel4showEv+0x7aa>
        mask >>= 1;
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
#endif
  }
  else if(type == WS2811) { // WS2811, 400 KHz bitstream
 80a2e42:	2900      	cmp	r1, #0
 80a2e44:	f040 8563 	bne.w	80a390e <_ZN17Adafruit_NeoPixel4showEv+0xb26>
 80a2e48:	4a18      	ldr	r2, [pc, #96]	; (80a2eac <_ZN17Adafruit_NeoPixel4showEv+0xc4>)
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
 80a2e4a:	f44f 0600 	mov.w	r6, #8388608	; 0x800000
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
#endif
  }
  else if(type == WS2811) { // WS2811, 400 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a2e4e:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a2e52:	b29b      	uxth	r3, r3
 80a2e54:	2b00      	cmp	r3, #0
 80a2e56:	f000 8395 	beq.w	80a3584 <_ZN17Adafruit_NeoPixel4showEv+0x79c>
      mask = 0x800000; // reset the mask
 80a2e5a:	9604      	str	r6, [sp, #16]
      i = i-3;      // decrement bytes remaining
 80a2e5c:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a2e60:	f10e 0503 	add.w	r5, lr, #3
 80a2e64:	3b03      	subs	r3, #3
 80a2e66:	b29b      	uxth	r3, r3
 80a2e68:	f8ad 300a 	strh.w	r3, [sp, #10]
      r = *ptr++;   // Next red byte value
 80a2e6c:	f89e 3000 	ldrb.w	r3, [lr]
 80a2e70:	b2db      	uxtb	r3, r3
 80a2e72:	f88d 3007 	strb.w	r3, [sp, #7]
      g = *ptr++;   // Next green byte value
 80a2e76:	f89e 3001 	ldrb.w	r3, [lr, #1]
 80a2e7a:	b2db      	uxtb	r3, r3
 80a2e7c:	f88d 3006 	strb.w	r3, [sp, #6]
      b = *ptr++;   // Next blue byte value
 80a2e80:	f89e 3002 	ldrb.w	r3, [lr, #2]
 80a2e84:	b2db      	uxtb	r3, r3
 80a2e86:	f88d 3008 	strb.w	r3, [sp, #8]
      c = ((uint32_t)r << 16) | ((uint32_t)g <<  8) | b; // Pack the next 3 bytes to keep timing tight
 80a2e8a:	f89d 7007 	ldrb.w	r7, [sp, #7]
 80a2e8e:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a2e92:	f89d 0008 	ldrb.w	r0, [sp, #8]
 80a2e96:	021b      	lsls	r3, r3, #8
 80a2e98:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 80a2e9c:	4303      	orrs	r3, r0
 80a2e9e:	9303      	str	r3, [sp, #12]
      j = 0;        // reset the 24-bit counter
 80a2ea0:	f88d 1005 	strb.w	r1, [sp, #5]
 80a2ea4:	e11b      	b.n	80a30de <_ZN17Adafruit_NeoPixel4showEv+0x2f6>
 80a2ea6:	bf00      	nop
 80a2ea8:	080a85b4 	.word	0x080a85b4
 80a2eac:	20001054 	.word	0x20001054
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a2eb0:	4600      	mov	r0, r0
 80a2eb2:	bf00      	nop
 80a2eb4:	bf00      	nop
 80a2eb6:	bf00      	nop
 80a2eb8:	bf00      	nop
 80a2eba:	bf00      	nop
 80a2ebc:	bf00      	nop
 80a2ebe:	bf00      	nop
 80a2ec0:	bf00      	nop
 80a2ec2:	bf00      	nop
 80a2ec4:	bf00      	nop
 80a2ec6:	bf00      	nop
 80a2ec8:	bf00      	nop
 80a2eca:	bf00      	nop
 80a2ecc:	bf00      	nop
 80a2ece:	bf00      	nop
 80a2ed0:	bf00      	nop
 80a2ed2:	bf00      	nop
 80a2ed4:	bf00      	nop
 80a2ed6:	bf00      	nop
 80a2ed8:	bf00      	nop
 80a2eda:	bf00      	nop
 80a2edc:	bf00      	nop
 80a2ede:	bf00      	nop
 80a2ee0:	bf00      	nop
 80a2ee2:	bf00      	nop
 80a2ee4:	bf00      	nop
 80a2ee6:	bf00      	nop
 80a2ee8:	bf00      	nop
 80a2eea:	bf00      	nop
 80a2eec:	bf00      	nop
 80a2eee:	bf00      	nop
 80a2ef0:	bf00      	nop
 80a2ef2:	bf00      	nop
 80a2ef4:	bf00      	nop
 80a2ef6:	bf00      	nop
 80a2ef8:	bf00      	nop
 80a2efa:	bf00      	nop
 80a2efc:	bf00      	nop
 80a2efe:	bf00      	nop
 80a2f00:	bf00      	nop
 80a2f02:	bf00      	nop
 80a2f04:	bf00      	nop
 80a2f06:	bf00      	nop
 80a2f08:	bf00      	nop
 80a2f0a:	bf00      	nop
 80a2f0c:	bf00      	nop
 80a2f0e:	bf00      	nop
 80a2f10:	bf00      	nop
 80a2f12:	bf00      	nop
 80a2f14:	bf00      	nop
 80a2f16:	bf00      	nop
 80a2f18:	bf00      	nop
 80a2f1a:	bf00      	nop
 80a2f1c:	bf00      	nop
 80a2f1e:	bf00      	nop
 80a2f20:	bf00      	nop
 80a2f22:	bf00      	nop
 80a2f24:	bf00      	nop
 80a2f26:	bf00      	nop
 80a2f28:	bf00      	nop
 80a2f2a:	bf00      	nop
 80a2f2c:	bf00      	nop
 80a2f2e:	bf00      	nop
 80a2f30:	bf00      	nop
 80a2f32:	bf00      	nop
 80a2f34:	bf00      	nop
 80a2f36:	bf00      	nop
 80a2f38:	bf00      	nop
 80a2f3a:	bf00      	nop
 80a2f3c:	bf00      	nop
 80a2f3e:	bf00      	nop
 80a2f40:	bf00      	nop
 80a2f42:	bf00      	nop
 80a2f44:	bf00      	nop
 80a2f46:	bf00      	nop
 80a2f48:	bf00      	nop
 80a2f4a:	bf00      	nop
 80a2f4c:	bf00      	nop
 80a2f4e:	bf00      	nop
 80a2f50:	bf00      	nop
 80a2f52:	bf00      	nop
 80a2f54:	bf00      	nop
 80a2f56:	bf00      	nop
 80a2f58:	bf00      	nop
 80a2f5a:	bf00      	nop
 80a2f5c:	bf00      	nop
 80a2f5e:	bf00      	nop
 80a2f60:	bf00      	nop
 80a2f62:	bf00      	nop
 80a2f64:	bf00      	nop
 80a2f66:	bf00      	nop
 80a2f68:	bf00      	nop
 80a2f6a:	bf00      	nop
 80a2f6c:	bf00      	nop
 80a2f6e:	bf00      	nop
 80a2f70:	bf00      	nop
 80a2f72:	bf00      	nop
 80a2f74:	bf00      	nop
 80a2f76:	bf00      	nop
 80a2f78:	bf00      	nop
 80a2f7a:	bf00      	nop
 80a2f7c:	bf00      	nop
 80a2f7e:	bf00      	nop
 80a2f80:	bf00      	nop
 80a2f82:	bf00      	nop
 80a2f84:	bf00      	nop
 80a2f86:	bf00      	nop
 80a2f88:	bf00      	nop
 80a2f8a:	bf00      	nop
 80a2f8c:	bf00      	nop
 80a2f8e:	bf00      	nop
 80a2f90:	bf00      	nop
 80a2f92:	bf00      	nop
 80a2f94:	bf00      	nop
 80a2f96:	bf00      	nop
 80a2f98:	bf00      	nop
 80a2f9a:	bf00      	nop
 80a2f9c:	bf00      	nop
 80a2f9e:	bf00      	nop
 80a2fa0:	bf00      	nop
 80a2fa2:	bf00      	nop
 80a2fa4:	bf00      	nop
 80a2fa6:	bf00      	nop
 80a2fa8:	bf00      	nop
 80a2faa:	bf00      	nop
 80a2fac:	bf00      	nop
 80a2fae:	bf00      	nop
 80a2fb0:	bf00      	nop
 80a2fb2:	bf00      	nop
 80a2fb4:	bf00      	nop
 80a2fb6:	bf00      	nop
          // WS2811 spec             1.30us LOW
          // Adafruit on Arduino    (meas. 1.25us)
          // This lib on Spark Core (meas. 1.24us)
          // This lib on Photon     (meas. 1.24us)
          pinSet(pin, LOW); // LOW
 80a2fb8:	79e3      	ldrb	r3, [r4, #7]
 80a2fba:	6810      	ldr	r0, [r2, #0]
 80a2fbc:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a2fc0:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a2fc4:	88bf      	ldrh	r7, [r7, #4]
 80a2fc6:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a2fca:	835f      	strh	r7, [r3, #26]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a2fcc:	4600      	mov	r0, r0
 80a2fce:	bf00      	nop
 80a2fd0:	bf00      	nop
 80a2fd2:	bf00      	nop
 80a2fd4:	bf00      	nop
 80a2fd6:	bf00      	nop
 80a2fd8:	bf00      	nop
 80a2fda:	bf00      	nop
 80a2fdc:	bf00      	nop
 80a2fde:	bf00      	nop
 80a2fe0:	bf00      	nop
 80a2fe2:	bf00      	nop
 80a2fe4:	bf00      	nop
 80a2fe6:	bf00      	nop
 80a2fe8:	bf00      	nop
 80a2fea:	bf00      	nop
 80a2fec:	bf00      	nop
 80a2fee:	bf00      	nop
 80a2ff0:	bf00      	nop
 80a2ff2:	bf00      	nop
 80a2ff4:	bf00      	nop
 80a2ff6:	bf00      	nop
 80a2ff8:	bf00      	nop
 80a2ffa:	bf00      	nop
 80a2ffc:	bf00      	nop
 80a2ffe:	bf00      	nop
 80a3000:	bf00      	nop
 80a3002:	bf00      	nop
 80a3004:	bf00      	nop
 80a3006:	bf00      	nop
 80a3008:	bf00      	nop
 80a300a:	bf00      	nop
 80a300c:	bf00      	nop
 80a300e:	bf00      	nop
 80a3010:	bf00      	nop
 80a3012:	bf00      	nop
 80a3014:	bf00      	nop
 80a3016:	bf00      	nop
 80a3018:	bf00      	nop
 80a301a:	bf00      	nop
 80a301c:	bf00      	nop
 80a301e:	bf00      	nop
 80a3020:	bf00      	nop
 80a3022:	bf00      	nop
 80a3024:	bf00      	nop
 80a3026:	bf00      	nop
 80a3028:	bf00      	nop
 80a302a:	bf00      	nop
 80a302c:	bf00      	nop
 80a302e:	bf00      	nop
 80a3030:	bf00      	nop
 80a3032:	bf00      	nop
 80a3034:	bf00      	nop
 80a3036:	bf00      	nop
 80a3038:	bf00      	nop
 80a303a:	bf00      	nop
 80a303c:	bf00      	nop
 80a303e:	bf00      	nop
 80a3040:	bf00      	nop
 80a3042:	bf00      	nop
 80a3044:	bf00      	nop
 80a3046:	bf00      	nop
 80a3048:	bf00      	nop
 80a304a:	bf00      	nop
 80a304c:	bf00      	nop
 80a304e:	bf00      	nop
 80a3050:	bf00      	nop
 80a3052:	bf00      	nop
 80a3054:	bf00      	nop
 80a3056:	bf00      	nop
 80a3058:	bf00      	nop
 80a305a:	bf00      	nop
 80a305c:	bf00      	nop
 80a305e:	bf00      	nop
 80a3060:	bf00      	nop
 80a3062:	bf00      	nop
 80a3064:	bf00      	nop
 80a3066:	bf00      	nop
 80a3068:	bf00      	nop
 80a306a:	bf00      	nop
 80a306c:	bf00      	nop
 80a306e:	bf00      	nop
 80a3070:	bf00      	nop
 80a3072:	bf00      	nop
 80a3074:	bf00      	nop
 80a3076:	bf00      	nop
 80a3078:	bf00      	nop
 80a307a:	bf00      	nop
 80a307c:	bf00      	nop
 80a307e:	bf00      	nop
 80a3080:	bf00      	nop
 80a3082:	bf00      	nop
 80a3084:	bf00      	nop
 80a3086:	bf00      	nop
 80a3088:	bf00      	nop
 80a308a:	bf00      	nop
 80a308c:	bf00      	nop
 80a308e:	bf00      	nop
 80a3090:	bf00      	nop
 80a3092:	bf00      	nop
 80a3094:	bf00      	nop
 80a3096:	bf00      	nop
 80a3098:	bf00      	nop
 80a309a:	bf00      	nop
 80a309c:	bf00      	nop
 80a309e:	bf00      	nop
 80a30a0:	bf00      	nop
 80a30a2:	bf00      	nop
 80a30a4:	bf00      	nop
 80a30a6:	bf00      	nop
 80a30a8:	bf00      	nop
 80a30aa:	bf00      	nop
 80a30ac:	bf00      	nop
 80a30ae:	bf00      	nop
 80a30b0:	bf00      	nop
 80a30b2:	bf00      	nop
 80a30b4:	bf00      	nop
 80a30b6:	bf00      	nop
 80a30b8:	bf00      	nop
 80a30ba:	bf00      	nop
 80a30bc:	bf00      	nop
 80a30be:	bf00      	nop
 80a30c0:	bf00      	nop
 80a30c2:	bf00      	nop
 80a30c4:	bf00      	nop
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
        }
        mask >>= 1;
 80a30c6:	9b04      	ldr	r3, [sp, #16]
 80a30c8:	085b      	lsrs	r3, r3, #1
 80a30ca:	9304      	str	r3, [sp, #16]
      } while ( ++j < 24 ); // ... pixel done
 80a30cc:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a30d0:	3301      	adds	r3, #1
 80a30d2:	b2db      	uxtb	r3, r3
      r = *ptr++;   // Next red byte value
      g = *ptr++;   // Next green byte value
      b = *ptr++;   // Next blue byte value
      c = ((uint32_t)r << 16) | ((uint32_t)g <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      do {
 80a30d4:	2b17      	cmp	r3, #23
 80a30d6:	f88d 3005 	strb.w	r3, [sp, #5]
 80a30da:	f200 82db 	bhi.w	80a3694 <_ZN17Adafruit_NeoPixel4showEv+0x8ac>
        pinSet(pin, HIGH); // HIGH
 80a30de:	79e3      	ldrb	r3, [r4, #7]
 80a30e0:	6810      	ldr	r0, [r2, #0]
 80a30e2:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a30e6:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a30ea:	88bf      	ldrh	r7, [r7, #4]
 80a30ec:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a30f0:	831f      	strh	r7, [r3, #24]
        if (c & mask) { // if masked bit is high
 80a30f2:	9803      	ldr	r0, [sp, #12]
 80a30f4:	9b04      	ldr	r3, [sp, #16]
 80a30f6:	4218      	tst	r0, r3
 80a30f8:	f47f aeda 	bne.w	80a2eb0 <_ZN17Adafruit_NeoPixel4showEv+0xc8>
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            "nop" "\n\t" "nop" "\n\t"
            ::: "r0", "cc", "memory");
 80a30fc:	4600      	mov	r0, r0
 80a30fe:	bf00      	nop
 80a3100:	bf00      	nop
 80a3102:	bf00      	nop
 80a3104:	bf00      	nop
 80a3106:	bf00      	nop
 80a3108:	bf00      	nop
 80a310a:	bf00      	nop
 80a310c:	bf00      	nop
 80a310e:	bf00      	nop
 80a3110:	bf00      	nop
 80a3112:	bf00      	nop
 80a3114:	bf00      	nop
 80a3116:	bf00      	nop
 80a3118:	bf00      	nop
 80a311a:	bf00      	nop
 80a311c:	bf00      	nop
 80a311e:	bf00      	nop
 80a3120:	bf00      	nop
 80a3122:	bf00      	nop
 80a3124:	bf00      	nop
 80a3126:	bf00      	nop
 80a3128:	bf00      	nop
 80a312a:	bf00      	nop
 80a312c:	bf00      	nop
 80a312e:	bf00      	nop
 80a3130:	bf00      	nop
 80a3132:	bf00      	nop
 80a3134:	bf00      	nop
 80a3136:	bf00      	nop
 80a3138:	bf00      	nop
 80a313a:	bf00      	nop
 80a313c:	bf00      	nop
 80a313e:	bf00      	nop
 80a3140:	bf00      	nop
 80a3142:	bf00      	nop
 80a3144:	bf00      	nop
 80a3146:	bf00      	nop
 80a3148:	bf00      	nop
 80a314a:	bf00      	nop
 80a314c:	bf00      	nop
          // WS2811 spec             2.000us LOW
          // Adafruit on Arduino    (meas. 2.000us)
          // This lib on Spark Core (meas. 2.000us)
          // This lib on Photon     (meas. 2.000us)
          pinSet(pin, LOW); // LOW
 80a314e:	79e3      	ldrb	r3, [r4, #7]
 80a3150:	6810      	ldr	r0, [r2, #0]
 80a3152:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a3156:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a315a:	88bf      	ldrh	r7, [r7, #4]
 80a315c:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a3160:	835f      	strh	r7, [r3, #26]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a3162:	4600      	mov	r0, r0
 80a3164:	bf00      	nop
 80a3166:	bf00      	nop
 80a3168:	bf00      	nop
 80a316a:	bf00      	nop
 80a316c:	bf00      	nop
 80a316e:	bf00      	nop
 80a3170:	bf00      	nop
 80a3172:	bf00      	nop
 80a3174:	bf00      	nop
 80a3176:	bf00      	nop
 80a3178:	bf00      	nop
 80a317a:	bf00      	nop
 80a317c:	bf00      	nop
 80a317e:	bf00      	nop
 80a3180:	bf00      	nop
 80a3182:	bf00      	nop
 80a3184:	bf00      	nop
 80a3186:	bf00      	nop
 80a3188:	bf00      	nop
 80a318a:	bf00      	nop
 80a318c:	bf00      	nop
 80a318e:	bf00      	nop
 80a3190:	bf00      	nop
 80a3192:	bf00      	nop
 80a3194:	bf00      	nop
 80a3196:	bf00      	nop
 80a3198:	bf00      	nop
 80a319a:	bf00      	nop
 80a319c:	bf00      	nop
 80a319e:	bf00      	nop
 80a31a0:	bf00      	nop
 80a31a2:	bf00      	nop
 80a31a4:	bf00      	nop
 80a31a6:	bf00      	nop
 80a31a8:	bf00      	nop
 80a31aa:	bf00      	nop
 80a31ac:	bf00      	nop
 80a31ae:	bf00      	nop
 80a31b0:	bf00      	nop
 80a31b2:	bf00      	nop
 80a31b4:	bf00      	nop
 80a31b6:	bf00      	nop
 80a31b8:	bf00      	nop
 80a31ba:	bf00      	nop
 80a31bc:	bf00      	nop
 80a31be:	bf00      	nop
 80a31c0:	bf00      	nop
 80a31c2:	bf00      	nop
 80a31c4:	bf00      	nop
 80a31c6:	bf00      	nop
 80a31c8:	bf00      	nop
 80a31ca:	bf00      	nop
 80a31cc:	bf00      	nop
 80a31ce:	bf00      	nop
 80a31d0:	bf00      	nop
 80a31d2:	bf00      	nop
 80a31d4:	bf00      	nop
 80a31d6:	bf00      	nop
 80a31d8:	bf00      	nop
 80a31da:	bf00      	nop
 80a31dc:	bf00      	nop
 80a31de:	bf00      	nop
 80a31e0:	bf00      	nop
 80a31e2:	bf00      	nop
 80a31e4:	bf00      	nop
 80a31e6:	bf00      	nop
 80a31e8:	bf00      	nop
 80a31ea:	bf00      	nop
 80a31ec:	bf00      	nop
 80a31ee:	bf00      	nop
 80a31f0:	bf00      	nop
 80a31f2:	bf00      	nop
 80a31f4:	bf00      	nop
 80a31f6:	bf00      	nop
 80a31f8:	bf00      	nop
 80a31fa:	bf00      	nop
 80a31fc:	bf00      	nop
 80a31fe:	bf00      	nop
 80a3200:	bf00      	nop
 80a3202:	bf00      	nop
 80a3204:	bf00      	nop
 80a3206:	bf00      	nop
 80a3208:	bf00      	nop
 80a320a:	bf00      	nop
 80a320c:	bf00      	nop
 80a320e:	bf00      	nop
 80a3210:	bf00      	nop
 80a3212:	bf00      	nop
 80a3214:	bf00      	nop
 80a3216:	bf00      	nop
 80a3218:	bf00      	nop
 80a321a:	bf00      	nop
 80a321c:	bf00      	nop
 80a321e:	bf00      	nop
 80a3220:	bf00      	nop
 80a3222:	bf00      	nop
 80a3224:	bf00      	nop
 80a3226:	bf00      	nop
 80a3228:	bf00      	nop
 80a322a:	bf00      	nop
 80a322c:	bf00      	nop
 80a322e:	bf00      	nop
 80a3230:	bf00      	nop
 80a3232:	bf00      	nop
 80a3234:	bf00      	nop
 80a3236:	bf00      	nop
 80a3238:	bf00      	nop
 80a323a:	bf00      	nop
 80a323c:	bf00      	nop
 80a323e:	bf00      	nop
 80a3240:	bf00      	nop
 80a3242:	bf00      	nop
 80a3244:	bf00      	nop
 80a3246:	bf00      	nop
 80a3248:	bf00      	nop
 80a324a:	bf00      	nop
 80a324c:	bf00      	nop
 80a324e:	bf00      	nop
 80a3250:	bf00      	nop
 80a3252:	bf00      	nop
 80a3254:	bf00      	nop
 80a3256:	bf00      	nop
 80a3258:	bf00      	nop
 80a325a:	bf00      	nop
 80a325c:	bf00      	nop
 80a325e:	bf00      	nop
 80a3260:	bf00      	nop
 80a3262:	bf00      	nop
 80a3264:	bf00      	nop
 80a3266:	bf00      	nop
 80a3268:	bf00      	nop
 80a326a:	bf00      	nop
 80a326c:	bf00      	nop
 80a326e:	bf00      	nop
 80a3270:	bf00      	nop
 80a3272:	bf00      	nop
 80a3274:	bf00      	nop
 80a3276:	bf00      	nop
 80a3278:	bf00      	nop
 80a327a:	bf00      	nop
 80a327c:	bf00      	nop
 80a327e:	bf00      	nop
 80a3280:	bf00      	nop
 80a3282:	bf00      	nop
 80a3284:	bf00      	nop
 80a3286:	bf00      	nop
 80a3288:	bf00      	nop
 80a328a:	bf00      	nop
 80a328c:	bf00      	nop
 80a328e:	bf00      	nop
 80a3290:	bf00      	nop
 80a3292:	bf00      	nop
 80a3294:	bf00      	nop
 80a3296:	bf00      	nop
 80a3298:	bf00      	nop
 80a329a:	bf00      	nop
 80a329c:	bf00      	nop
 80a329e:	bf00      	nop
 80a32a0:	bf00      	nop
 80a32a2:	bf00      	nop
 80a32a4:	bf00      	nop
 80a32a6:	bf00      	nop
 80a32a8:	bf00      	nop
 80a32aa:	bf00      	nop
 80a32ac:	bf00      	nop
 80a32ae:	bf00      	nop
 80a32b0:	bf00      	nop
 80a32b2:	bf00      	nop
 80a32b4:	bf00      	nop
 80a32b6:	bf00      	nop
 80a32b8:	bf00      	nop
 80a32ba:	bf00      	nop
 80a32bc:	bf00      	nop
 80a32be:	bf00      	nop
 80a32c0:	bf00      	nop
 80a32c2:	bf00      	nop
 80a32c4:	bf00      	nop
 80a32c6:	bf00      	nop
 80a32c8:	bf00      	nop
 80a32ca:	bf00      	nop
 80a32cc:	bf00      	nop
 80a32ce:	bf00      	nop
 80a32d0:	bf00      	nop
 80a32d2:	bf00      	nop
 80a32d4:	bf00      	nop
 80a32d6:	bf00      	nop
 80a32d8:	bf00      	nop
 80a32da:	bf00      	nop
 80a32dc:	bf00      	nop
 80a32de:	bf00      	nop
 80a32e0:	bf00      	nop
 80a32e2:	bf00      	nop
 80a32e4:	bf00      	nop
 80a32e6:	bf00      	nop
 80a32e8:	bf00      	nop
 80a32ea:	bf00      	nop
 80a32ec:	bf00      	nop
 80a32ee:	bf00      	nop
 80a32f0:	bf00      	nop
 80a32f2:	bf00      	nop
 80a32f4:	bf00      	nop
 80a32f6:	bf00      	nop
 80a32f8:	bf00      	nop
 80a32fa:	bf00      	nop
 80a32fc:	bf00      	nop
 80a32fe:	bf00      	nop
 80a3300:	bf00      	nop
 80a3302:	bf00      	nop
 80a3304:	bf00      	nop
 80a3306:	bf00      	nop
 80a3308:	bf00      	nop
 80a330a:	bf00      	nop
 80a330c:	e6db      	b.n	80a30c6 <_ZN17Adafruit_NeoPixel4showEv+0x2de>
    r,              // Current red byte value
    b,              // Current blue byte value
    w;              // Current white byte value

  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a330e:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a3312:	4a17      	ldr	r2, [pc, #92]	; (80a3370 <_ZN17Adafruit_NeoPixel4showEv+0x588>)
 80a3314:	b29b      	uxth	r3, r3
      mask = 0x800000; // reset the mask
 80a3316:	f44f 0500 	mov.w	r5, #8388608	; 0x800000
      i = i-3;      // decrement bytes remaining
      g = *ptr++;   // Next green byte value
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
 80a331a:	2600      	movs	r6, #0
    r,              // Current red byte value
    b,              // Current blue byte value
    w;              // Current white byte value

  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a331c:	2b00      	cmp	r3, #0
 80a331e:	f000 8131 	beq.w	80a3584 <_ZN17Adafruit_NeoPixel4showEv+0x79c>
      mask = 0x800000; // reset the mask
 80a3322:	9504      	str	r5, [sp, #16]
      i = i-3;      // decrement bytes remaining
 80a3324:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a3328:	f10e 0103 	add.w	r1, lr, #3
 80a332c:	3b03      	subs	r3, #3
 80a332e:	b29b      	uxth	r3, r3
 80a3330:	f8ad 300a 	strh.w	r3, [sp, #10]
      g = *ptr++;   // Next green byte value
 80a3334:	f89e 3000 	ldrb.w	r3, [lr]
 80a3338:	b2db      	uxtb	r3, r3
 80a333a:	f88d 3006 	strb.w	r3, [sp, #6]
      r = *ptr++;   // Next red byte value
 80a333e:	f89e 3001 	ldrb.w	r3, [lr, #1]
 80a3342:	b2db      	uxtb	r3, r3
 80a3344:	f88d 3007 	strb.w	r3, [sp, #7]
      b = *ptr++;   // Next blue byte value
 80a3348:	f89e 3002 	ldrb.w	r3, [lr, #2]
 80a334c:	b2db      	uxtb	r3, r3
 80a334e:	f88d 3008 	strb.w	r3, [sp, #8]
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
 80a3352:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a3356:	f89d 0007 	ldrb.w	r0, [sp, #7]
 80a335a:	f89d 7008 	ldrb.w	r7, [sp, #8]
 80a335e:	0200      	lsls	r0, r0, #8
 80a3360:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
 80a3364:	433b      	orrs	r3, r7
 80a3366:	9303      	str	r3, [sp, #12]
      j = 0;        // reset the 24-bit counter
 80a3368:	f88d 6005 	strb.w	r6, [sp, #5]
 80a336c:	e080      	b.n	80a3470 <_ZN17Adafruit_NeoPixel4showEv+0x688>
 80a336e:	bf00      	nop
 80a3370:	20001054 	.word	0x20001054
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a3374:	4600      	mov	r0, r0
 80a3376:	bf00      	nop
 80a3378:	bf00      	nop
 80a337a:	bf00      	nop
 80a337c:	bf00      	nop
 80a337e:	bf00      	nop
 80a3380:	bf00      	nop
 80a3382:	bf00      	nop
 80a3384:	bf00      	nop
 80a3386:	bf00      	nop
 80a3388:	bf00      	nop
 80a338a:	bf00      	nop
 80a338c:	bf00      	nop
 80a338e:	bf00      	nop
 80a3390:	bf00      	nop
 80a3392:	bf00      	nop
 80a3394:	bf00      	nop
 80a3396:	bf00      	nop
 80a3398:	bf00      	nop
 80a339a:	bf00      	nop
 80a339c:	bf00      	nop
 80a339e:	bf00      	nop
 80a33a0:	bf00      	nop
 80a33a2:	bf00      	nop
 80a33a4:	bf00      	nop
 80a33a6:	bf00      	nop
 80a33a8:	bf00      	nop
 80a33aa:	bf00      	nop
 80a33ac:	bf00      	nop
 80a33ae:	bf00      	nop
 80a33b0:	bf00      	nop
 80a33b2:	bf00      	nop
 80a33b4:	bf00      	nop
 80a33b6:	bf00      	nop
 80a33b8:	bf00      	nop
 80a33ba:	bf00      	nop
 80a33bc:	bf00      	nop
 80a33be:	bf00      	nop
 80a33c0:	bf00      	nop
 80a33c2:	bf00      	nop
 80a33c4:	bf00      	nop
 80a33c6:	bf00      	nop
 80a33c8:	bf00      	nop
 80a33ca:	bf00      	nop
 80a33cc:	bf00      	nop
 80a33ce:	bf00      	nop
 80a33d0:	bf00      	nop
 80a33d2:	bf00      	nop
 80a33d4:	bf00      	nop
 80a33d6:	bf00      	nop
 80a33d8:	bf00      	nop
 80a33da:	bf00      	nop
 80a33dc:	bf00      	nop
 80a33de:	bf00      	nop
 80a33e0:	bf00      	nop
 80a33e2:	bf00      	nop
 80a33e4:	bf00      	nop
 80a33e6:	bf00      	nop
 80a33e8:	bf00      	nop
 80a33ea:	bf00      	nop
 80a33ec:	bf00      	nop
 80a33ee:	bf00      	nop
 80a33f0:	bf00      	nop
 80a33f2:	bf00      	nop
 80a33f4:	bf00      	nop
 80a33f6:	bf00      	nop
 80a33f8:	bf00      	nop
 80a33fa:	bf00      	nop
 80a33fc:	bf00      	nop
 80a33fe:	bf00      	nop
 80a3400:	bf00      	nop
 80a3402:	bf00      	nop
 80a3404:	bf00      	nop
 80a3406:	bf00      	nop
 80a3408:	bf00      	nop
 80a340a:	bf00      	nop
 80a340c:	bf00      	nop
          // WS2812 spec             600ns LOW
          // Adafruit on Arduino    (meas. 436ns)
          // This lib on Spark Core (meas. 446ns)
          // This lib on Photon     (meas. 434ns)
          pinSet(pin, LOW); // LOW
 80a340e:	79e3      	ldrb	r3, [r4, #7]
 80a3410:	6810      	ldr	r0, [r2, #0]
 80a3412:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a3416:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a341a:	88bf      	ldrh	r7, [r7, #4]
 80a341c:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a3420:	835f      	strh	r7, [r3, #26]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a3422:	4600      	mov	r0, r0
 80a3424:	bf00      	nop
 80a3426:	bf00      	nop
 80a3428:	bf00      	nop
 80a342a:	bf00      	nop
 80a342c:	bf00      	nop
 80a342e:	bf00      	nop
 80a3430:	bf00      	nop
 80a3432:	bf00      	nop
 80a3434:	bf00      	nop
 80a3436:	bf00      	nop
 80a3438:	bf00      	nop
 80a343a:	bf00      	nop
 80a343c:	bf00      	nop
 80a343e:	bf00      	nop
 80a3440:	bf00      	nop
 80a3442:	bf00      	nop
 80a3444:	bf00      	nop
 80a3446:	bf00      	nop
 80a3448:	bf00      	nop
 80a344a:	bf00      	nop
 80a344c:	bf00      	nop
 80a344e:	bf00      	nop
 80a3450:	bf00      	nop
 80a3452:	bf00      	nop
 80a3454:	bf00      	nop
 80a3456:	bf00      	nop
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
        }
        mask >>= 1;
 80a3458:	9b04      	ldr	r3, [sp, #16]
 80a345a:	085b      	lsrs	r3, r3, #1
 80a345c:	9304      	str	r3, [sp, #16]
      } while ( ++j < 24 ); // ... pixel done
 80a345e:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a3462:	3301      	adds	r3, #1
 80a3464:	b2db      	uxtb	r3, r3
      g = *ptr++;   // Next green byte value
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      do {
 80a3466:	2b17      	cmp	r3, #23
 80a3468:	f88d 3005 	strb.w	r3, [sp, #5]
 80a346c:	f200 8083 	bhi.w	80a3576 <_ZN17Adafruit_NeoPixel4showEv+0x78e>
        pinSet(pin, HIGH); // HIGH
 80a3470:	79e3      	ldrb	r3, [r4, #7]
 80a3472:	6810      	ldr	r0, [r2, #0]
 80a3474:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a3478:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a347c:	88bf      	ldrh	r7, [r7, #4]
 80a347e:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a3482:	831f      	strh	r7, [r3, #24]
        if (c & mask) { // if masked bit is high
 80a3484:	9803      	ldr	r0, [sp, #12]
 80a3486:	9b04      	ldr	r3, [sp, #16]
 80a3488:	4218      	tst	r0, r3
 80a348a:	f47f af73 	bne.w	80a3374 <_ZN17Adafruit_NeoPixel4showEv+0x58c>
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a348e:	4600      	mov	r0, r0
 80a3490:	bf00      	nop
 80a3492:	bf00      	nop
 80a3494:	bf00      	nop
 80a3496:	bf00      	nop
 80a3498:	bf00      	nop
 80a349a:	bf00      	nop
 80a349c:	bf00      	nop
 80a349e:	bf00      	nop
 80a34a0:	bf00      	nop
 80a34a2:	bf00      	nop
 80a34a4:	bf00      	nop
 80a34a6:	bf00      	nop
 80a34a8:	bf00      	nop
 80a34aa:	bf00      	nop
 80a34ac:	bf00      	nop
 80a34ae:	bf00      	nop
 80a34b0:	bf00      	nop
 80a34b2:	bf00      	nop
 80a34b4:	bf00      	nop
          // WS2812 spec             800ns LOW
          // Adafruit on Arduino    (meas. 938ns)
          // This lib on Spark Core (meas. 944ns)
          // This lib on Photon     (meas. 936ns)
          pinSet(pin, LOW); // LOW
 80a34b6:	79e3      	ldrb	r3, [r4, #7]
 80a34b8:	6810      	ldr	r0, [r2, #0]
 80a34ba:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a34be:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a34c2:	88bf      	ldrh	r7, [r7, #4]
 80a34c4:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a34c8:	835f      	strh	r7, [r3, #26]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a34ca:	4600      	mov	r0, r0
 80a34cc:	bf00      	nop
 80a34ce:	bf00      	nop
 80a34d0:	bf00      	nop
 80a34d2:	bf00      	nop
 80a34d4:	bf00      	nop
 80a34d6:	bf00      	nop
 80a34d8:	bf00      	nop
 80a34da:	bf00      	nop
 80a34dc:	bf00      	nop
 80a34de:	bf00      	nop
 80a34e0:	bf00      	nop
 80a34e2:	bf00      	nop
 80a34e4:	bf00      	nop
 80a34e6:	bf00      	nop
 80a34e8:	bf00      	nop
 80a34ea:	bf00      	nop
 80a34ec:	bf00      	nop
 80a34ee:	bf00      	nop
 80a34f0:	bf00      	nop
 80a34f2:	bf00      	nop
 80a34f4:	bf00      	nop
 80a34f6:	bf00      	nop
 80a34f8:	bf00      	nop
 80a34fa:	bf00      	nop
 80a34fc:	bf00      	nop
 80a34fe:	bf00      	nop
 80a3500:	bf00      	nop
 80a3502:	bf00      	nop
 80a3504:	bf00      	nop
 80a3506:	bf00      	nop
 80a3508:	bf00      	nop
 80a350a:	bf00      	nop
 80a350c:	bf00      	nop
 80a350e:	bf00      	nop
 80a3510:	bf00      	nop
 80a3512:	bf00      	nop
 80a3514:	bf00      	nop
 80a3516:	bf00      	nop
 80a3518:	bf00      	nop
 80a351a:	bf00      	nop
 80a351c:	bf00      	nop
 80a351e:	bf00      	nop
 80a3520:	bf00      	nop
 80a3522:	bf00      	nop
 80a3524:	bf00      	nop
 80a3526:	bf00      	nop
 80a3528:	bf00      	nop
 80a352a:	bf00      	nop
 80a352c:	bf00      	nop
 80a352e:	bf00      	nop
 80a3530:	bf00      	nop
 80a3532:	bf00      	nop
 80a3534:	bf00      	nop
 80a3536:	bf00      	nop
 80a3538:	bf00      	nop
 80a353a:	bf00      	nop
 80a353c:	bf00      	nop
 80a353e:	bf00      	nop
 80a3540:	bf00      	nop
 80a3542:	bf00      	nop
 80a3544:	bf00      	nop
 80a3546:	bf00      	nop
 80a3548:	bf00      	nop
 80a354a:	bf00      	nop
 80a354c:	bf00      	nop
 80a354e:	bf00      	nop
 80a3550:	bf00      	nop
 80a3552:	bf00      	nop
 80a3554:	bf00      	nop
 80a3556:	bf00      	nop
 80a3558:	bf00      	nop
 80a355a:	bf00      	nop
 80a355c:	bf00      	nop
 80a355e:	bf00      	nop
 80a3560:	bf00      	nop
 80a3562:	bf00      	nop
 80a3564:	bf00      	nop
 80a3566:	bf00      	nop
 80a3568:	bf00      	nop
 80a356a:	bf00      	nop
 80a356c:	bf00      	nop
 80a356e:	bf00      	nop
 80a3570:	bf00      	nop
 80a3572:	bf00      	nop
 80a3574:	e770      	b.n	80a3458 <_ZN17Adafruit_NeoPixel4showEv+0x670>
    r,              // Current red byte value
    b,              // Current blue byte value
    w;              // Current white byte value

  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a3576:	f8bd 300a 	ldrh.w	r3, [sp, #10]
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      g = *ptr++;   // Next green byte value
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
 80a357a:	468e      	mov	lr, r1
    r,              // Current red byte value
    b,              // Current blue byte value
    w;              // Current white byte value

  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a357c:	b29b      	uxth	r3, r3
 80a357e:	2b00      	cmp	r3, #0
 80a3580:	f47f aecf 	bne.w	80a3322 <_ZN17Adafruit_NeoPixel4showEv+0x53a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i");
 80a3584:	b662      	cpsie	i
  }
// END of NRF52 implementation


#endif
  endTime = micros(); // Save EOD time for latch on next call
 80a3586:	f7ff fbcc 	bl	80a2d22 <micros>
 80a358a:	6120      	str	r0, [r4, #16]
}
 80a358c:	b006      	add	sp, #24
 80a358e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      do {
        cyc = DWT->CYCCNT;
 80a3592:	4b5e      	ldr	r3, [pc, #376]	; (80a370c <_ZN17Adafruit_NeoPixel4showEv+0x924>)
 80a3594:	4a5e      	ldr	r2, [pc, #376]	; (80a3710 <_ZN17Adafruit_NeoPixel4showEv+0x928>)
        pinSet(pin, HIGH); // HIGH
        if (c & mask) { // if masked bit is high
          while(DWT->CYCCNT - cyc < CYCLES_800_T1H);
 80a3596:	4618      	mov	r0, r3
 80a3598:	6811      	ldr	r1, [r2, #0]
    #define CYCLES_800_T1L  8  // 436ns (meas. 425ns)

    volatile uint32_t cyc;

    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
 80a359a:	f44f 0800 	mov.w	r8, #8388608	; 0x800000
      i = i-3;      // decrement bytes remaining
      g = *ptr++;   // Next green byte value
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
 80a359e:	2700      	movs	r7, #0
    #define CYCLES_800_T1H  80 // 812ns (meas. 792ns)
    #define CYCLES_800_T1L  8  // 436ns (meas. 425ns)

    volatile uint32_t cyc;

    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a35a0:	f8bd 200a 	ldrh.w	r2, [sp, #10]
 80a35a4:	b292      	uxth	r2, r2
 80a35a6:	2a00      	cmp	r2, #0
 80a35a8:	d0ec      	beq.n	80a3584 <_ZN17Adafruit_NeoPixel4showEv+0x79c>
      mask = 0x800000; // reset the mask
 80a35aa:	f8cd 8010 	str.w	r8, [sp, #16]
      i = i-3;      // decrement bytes remaining
 80a35ae:	f8bd 200a 	ldrh.w	r2, [sp, #10]
 80a35b2:	f10e 0503 	add.w	r5, lr, #3
 80a35b6:	3a03      	subs	r2, #3
 80a35b8:	b292      	uxth	r2, r2
 80a35ba:	f8ad 200a 	strh.w	r2, [sp, #10]
      g = *ptr++;   // Next green byte value
 80a35be:	f89e 2000 	ldrb.w	r2, [lr]
 80a35c2:	b2d2      	uxtb	r2, r2
 80a35c4:	f88d 2006 	strb.w	r2, [sp, #6]
      r = *ptr++;   // Next red byte value
 80a35c8:	f89e 2001 	ldrb.w	r2, [lr, #1]
 80a35cc:	b2d2      	uxtb	r2, r2
 80a35ce:	f88d 2007 	strb.w	r2, [sp, #7]
      b = *ptr++;   // Next blue byte value
 80a35d2:	f89e 2002 	ldrb.w	r2, [lr, #2]
 80a35d6:	b2d2      	uxtb	r2, r2
 80a35d8:	f88d 2008 	strb.w	r2, [sp, #8]
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
 80a35dc:	f89d 2006 	ldrb.w	r2, [sp, #6]
 80a35e0:	f89d e007 	ldrb.w	lr, [sp, #7]
 80a35e4:	f89d c008 	ldrb.w	ip, [sp, #8]
 80a35e8:	ea4f 2e0e 	mov.w	lr, lr, lsl #8
 80a35ec:	ea4e 4202 	orr.w	r2, lr, r2, lsl #16
 80a35f0:	ea42 020c 	orr.w	r2, r2, ip
 80a35f4:	9203      	str	r2, [sp, #12]
      j = 0;        // reset the 24-bit counter
 80a35f6:	f88d 7005 	strb.w	r7, [sp, #5]
      do {
        cyc = DWT->CYCCNT;
        pinSet(pin, HIGH); // HIGH
 80a35fa:	79e2      	ldrb	r2, [r4, #7]
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      do {
        cyc = DWT->CYCCNT;
 80a35fc:	685e      	ldr	r6, [r3, #4]
        pinSet(pin, HIGH); // HIGH
 80a35fe:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 80a3602:	eb01 0e82 	add.w	lr, r1, r2, lsl #2
 80a3606:	f8be e004 	ldrh.w	lr, [lr, #4]
 80a360a:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      do {
        cyc = DWT->CYCCNT;
 80a360e:	9605      	str	r6, [sp, #20]
        pinSet(pin, HIGH); // HIGH
 80a3610:	f8a2 e018 	strh.w	lr, [r2, #24]
        if (c & mask) { // if masked bit is high
 80a3614:	9e03      	ldr	r6, [sp, #12]
 80a3616:	9a04      	ldr	r2, [sp, #16]
 80a3618:	4216      	tst	r6, r2
 80a361a:	d023      	beq.n	80a3664 <_ZN17Adafruit_NeoPixel4showEv+0x87c>
          while(DWT->CYCCNT - cyc < CYCLES_800_T1H);
 80a361c:	685a      	ldr	r2, [r3, #4]
 80a361e:	9e05      	ldr	r6, [sp, #20]
 80a3620:	1b92      	subs	r2, r2, r6
 80a3622:	2a4f      	cmp	r2, #79	; 0x4f
 80a3624:	d9fa      	bls.n	80a361c <_ZN17Adafruit_NeoPixel4showEv+0x834>
          pinSet(pin, LOW);
 80a3626:	79e2      	ldrb	r2, [r4, #7]
 80a3628:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 80a362c:	eb01 0e82 	add.w	lr, r1, r2, lsl #2
 80a3630:	f8be e004 	ldrh.w	lr, [lr, #4]
 80a3634:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 80a3638:	f8a2 e01a 	strh.w	lr, [r2, #26]
          cyc = DWT->CYCCNT;
 80a363c:	6842      	ldr	r2, [r0, #4]
 80a363e:	9205      	str	r2, [sp, #20]
          while(DWT->CYCCNT - cyc < CYCLES_800_T1L);
 80a3640:	685a      	ldr	r2, [r3, #4]
 80a3642:	9e05      	ldr	r6, [sp, #20]
 80a3644:	1b92      	subs	r2, r2, r6
 80a3646:	2a07      	cmp	r2, #7
 80a3648:	d9fa      	bls.n	80a3640 <_ZN17Adafruit_NeoPixel4showEv+0x858>
          while(DWT->CYCCNT - cyc < CYCLES_800_T0H);
          pinSet(pin, LOW);
          cyc = DWT->CYCCNT;
          while(DWT->CYCCNT - cyc < CYCLES_800_T0L);
        }
        mask >>= 1;
 80a364a:	9a04      	ldr	r2, [sp, #16]
 80a364c:	0852      	lsrs	r2, r2, #1
 80a364e:	9204      	str	r2, [sp, #16]
      } while ( ++j < 24 ); // ... pixel done
 80a3650:	f89d 2005 	ldrb.w	r2, [sp, #5]
 80a3654:	3201      	adds	r2, #1
 80a3656:	b2d2      	uxtb	r2, r2
      g = *ptr++;   // Next green byte value
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      do {
 80a3658:	2a17      	cmp	r2, #23
 80a365a:	f88d 2005 	strb.w	r2, [sp, #5]
 80a365e:	d9cc      	bls.n	80a35fa <_ZN17Adafruit_NeoPixel4showEv+0x812>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      g = *ptr++;   // Next green byte value
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
 80a3660:	46ae      	mov	lr, r5
 80a3662:	e79d      	b.n	80a35a0 <_ZN17Adafruit_NeoPixel4showEv+0x7b8>
          pinSet(pin, LOW);
          cyc = DWT->CYCCNT;
          while(DWT->CYCCNT - cyc < CYCLES_800_T1L);
        }
        else { // else masked bit is low
          while(DWT->CYCCNT - cyc < CYCLES_800_T0H);
 80a3664:	685a      	ldr	r2, [r3, #4]
 80a3666:	9e05      	ldr	r6, [sp, #20]
 80a3668:	1b92      	subs	r2, r2, r6
 80a366a:	2a18      	cmp	r2, #24
 80a366c:	d9fa      	bls.n	80a3664 <_ZN17Adafruit_NeoPixel4showEv+0x87c>
          pinSet(pin, LOW);
 80a366e:	79e2      	ldrb	r2, [r4, #7]
 80a3670:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 80a3674:	eb01 0e82 	add.w	lr, r1, r2, lsl #2
 80a3678:	f8be e004 	ldrh.w	lr, [lr, #4]
 80a367c:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
 80a3680:	f8a2 e01a 	strh.w	lr, [r2, #26]
          cyc = DWT->CYCCNT;
 80a3684:	6842      	ldr	r2, [r0, #4]
 80a3686:	9205      	str	r2, [sp, #20]
          while(DWT->CYCCNT - cyc < CYCLES_800_T0L);
 80a3688:	685a      	ldr	r2, [r3, #4]
 80a368a:	9e05      	ldr	r6, [sp, #20]
 80a368c:	1b92      	subs	r2, r2, r6
 80a368e:	2a45      	cmp	r2, #69	; 0x45
 80a3690:	d9fa      	bls.n	80a3688 <_ZN17Adafruit_NeoPixel4showEv+0x8a0>
 80a3692:	e7da      	b.n	80a364a <_ZN17Adafruit_NeoPixel4showEv+0x862>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      g = *ptr++;   // Next green byte value
      b = *ptr++;   // Next blue byte value
 80a3694:	46ae      	mov	lr, r5
 80a3696:	f7ff bbda 	b.w	80a2e4e <_ZN17Adafruit_NeoPixel4showEv+0x66>
 80a369a:	4a1d      	ldr	r2, [pc, #116]	; (80a3710 <_ZN17Adafruit_NeoPixel4showEv+0x928>)
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else if(type == SK6812RGBW) { // similar to WS2812, 800 KHz bitstream but with RGB+W components
    while(i) { // While bytes left... (4 bytes = 1 pixel)
      mask = 0x80000000; // reset the mask
 80a369c:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
      r = *ptr++;   // Next red byte value
      g = *ptr++;   // Next green byte value
      b = *ptr++;   // Next blue byte value
      w = *ptr++;   // Next white byte value
      c = ((uint32_t)r << 24) | ((uint32_t)g << 16) | ((uint32_t)b <<  8) | w; // Pack the next 4 bytes to keep timing tight
      j = 0;        // reset the 32-bit counter
 80a36a0:	2600      	movs	r6, #0
        mask >>= 1;
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else if(type == SK6812RGBW) { // similar to WS2812, 800 KHz bitstream but with RGB+W components
    while(i) { // While bytes left... (4 bytes = 1 pixel)
 80a36a2:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a36a6:	b29b      	uxth	r3, r3
 80a36a8:	2b00      	cmp	r3, #0
 80a36aa:	f43f af6b 	beq.w	80a3584 <_ZN17Adafruit_NeoPixel4showEv+0x79c>
      mask = 0x80000000; // reset the mask
 80a36ae:	9504      	str	r5, [sp, #16]
      i = i-4;      // decrement bytes remaining
 80a36b0:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a36b4:	f10e 0104 	add.w	r1, lr, #4
 80a36b8:	3b04      	subs	r3, #4
 80a36ba:	b29b      	uxth	r3, r3
 80a36bc:	f8ad 300a 	strh.w	r3, [sp, #10]
      r = *ptr++;   // Next red byte value
 80a36c0:	f89e 3000 	ldrb.w	r3, [lr]
 80a36c4:	b2db      	uxtb	r3, r3
 80a36c6:	f88d 3007 	strb.w	r3, [sp, #7]
      g = *ptr++;   // Next green byte value
 80a36ca:	f89e 3001 	ldrb.w	r3, [lr, #1]
 80a36ce:	b2db      	uxtb	r3, r3
 80a36d0:	f88d 3006 	strb.w	r3, [sp, #6]
      b = *ptr++;   // Next blue byte value
 80a36d4:	f89e 3002 	ldrb.w	r3, [lr, #2]
 80a36d8:	b2db      	uxtb	r3, r3
 80a36da:	f88d 3008 	strb.w	r3, [sp, #8]
      w = *ptr++;   // Next white byte value
 80a36de:	f89e 3003 	ldrb.w	r3, [lr, #3]
 80a36e2:	b2db      	uxtb	r3, r3
 80a36e4:	f88d 3009 	strb.w	r3, [sp, #9]
      c = ((uint32_t)r << 24) | ((uint32_t)g << 16) | ((uint32_t)b <<  8) | w; // Pack the next 4 bytes to keep timing tight
 80a36e8:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80a36ec:	f89d 7006 	ldrb.w	r7, [sp, #6]
 80a36f0:	f89d e008 	ldrb.w	lr, [sp, #8]
 80a36f4:	043f      	lsls	r7, r7, #16
 80a36f6:	f89d 0009 	ldrb.w	r0, [sp, #9]
 80a36fa:	ea47 6303 	orr.w	r3, r7, r3, lsl #24
 80a36fe:	4303      	orrs	r3, r0
 80a3700:	ea43 230e 	orr.w	r3, r3, lr, lsl #8
 80a3704:	9303      	str	r3, [sp, #12]
      j = 0;        // reset the 32-bit counter
 80a3706:	f88d 6005 	strb.w	r6, [sp, #5]
 80a370a:	e07e      	b.n	80a380a <_ZN17Adafruit_NeoPixel4showEv+0xa22>
 80a370c:	e0001000 	.word	0xe0001000
 80a3710:	20001054 	.word	0x20001054
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a3714:	4600      	mov	r0, r0
 80a3716:	bf00      	nop
 80a3718:	bf00      	nop
 80a371a:	bf00      	nop
 80a371c:	bf00      	nop
 80a371e:	bf00      	nop
 80a3720:	bf00      	nop
 80a3722:	bf00      	nop
 80a3724:	bf00      	nop
 80a3726:	bf00      	nop
 80a3728:	bf00      	nop
 80a372a:	bf00      	nop
 80a372c:	bf00      	nop
 80a372e:	bf00      	nop
 80a3730:	bf00      	nop
 80a3732:	bf00      	nop
 80a3734:	bf00      	nop
 80a3736:	bf00      	nop
 80a3738:	bf00      	nop
 80a373a:	bf00      	nop
 80a373c:	bf00      	nop
 80a373e:	bf00      	nop
 80a3740:	bf00      	nop
 80a3742:	bf00      	nop
 80a3744:	bf00      	nop
 80a3746:	bf00      	nop
 80a3748:	bf00      	nop
 80a374a:	bf00      	nop
 80a374c:	bf00      	nop
 80a374e:	bf00      	nop
 80a3750:	bf00      	nop
 80a3752:	bf00      	nop
 80a3754:	bf00      	nop
 80a3756:	bf00      	nop
 80a3758:	bf00      	nop
 80a375a:	bf00      	nop
 80a375c:	bf00      	nop
 80a375e:	bf00      	nop
 80a3760:	bf00      	nop
 80a3762:	bf00      	nop
 80a3764:	bf00      	nop
 80a3766:	bf00      	nop
 80a3768:	bf00      	nop
 80a376a:	bf00      	nop
 80a376c:	bf00      	nop
 80a376e:	bf00      	nop
 80a3770:	bf00      	nop
 80a3772:	bf00      	nop
 80a3774:	bf00      	nop
 80a3776:	bf00      	nop
 80a3778:	bf00      	nop
 80a377a:	bf00      	nop
 80a377c:	bf00      	nop
 80a377e:	bf00      	nop
 80a3780:	bf00      	nop
          // SK6812RGBW spec         600ns LOW
          // WS2812 spec             600ns LOW
          // Adafruit on Arduino    (meas. 436ns)
          // This lib on Spark Core (meas. 598ns)
          // This lib on Photon     (meas. 600ns)
          pinSet(pin, LOW); // LOW
 80a3782:	79e3      	ldrb	r3, [r4, #7]
 80a3784:	6810      	ldr	r0, [r2, #0]
 80a3786:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a378a:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a378e:	88bf      	ldrh	r7, [r7, #4]
 80a3790:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a3794:	835f      	strh	r7, [r3, #26]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a3796:	4600      	mov	r0, r0
 80a3798:	bf00      	nop
 80a379a:	bf00      	nop
 80a379c:	bf00      	nop
 80a379e:	bf00      	nop
 80a37a0:	bf00      	nop
 80a37a2:	bf00      	nop
 80a37a4:	bf00      	nop
 80a37a6:	bf00      	nop
 80a37a8:	bf00      	nop
 80a37aa:	bf00      	nop
 80a37ac:	bf00      	nop
 80a37ae:	bf00      	nop
 80a37b0:	bf00      	nop
 80a37b2:	bf00      	nop
 80a37b4:	bf00      	nop
 80a37b6:	bf00      	nop
 80a37b8:	bf00      	nop
 80a37ba:	bf00      	nop
 80a37bc:	bf00      	nop
 80a37be:	bf00      	nop
 80a37c0:	bf00      	nop
 80a37c2:	bf00      	nop
 80a37c4:	bf00      	nop
 80a37c6:	bf00      	nop
 80a37c8:	bf00      	nop
 80a37ca:	bf00      	nop
 80a37cc:	bf00      	nop
 80a37ce:	bf00      	nop
 80a37d0:	bf00      	nop
 80a37d2:	bf00      	nop
 80a37d4:	bf00      	nop
 80a37d6:	bf00      	nop
 80a37d8:	bf00      	nop
 80a37da:	bf00      	nop
 80a37dc:	bf00      	nop
 80a37de:	bf00      	nop
 80a37e0:	bf00      	nop
 80a37e2:	bf00      	nop
 80a37e4:	bf00      	nop
 80a37e6:	bf00      	nop
 80a37e8:	bf00      	nop
 80a37ea:	bf00      	nop
 80a37ec:	bf00      	nop
 80a37ee:	bf00      	nop
 80a37f0:	bf00      	nop
 80a37f2:	bf00      	nop
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
        }
        mask >>= 1;
 80a37f4:	9b04      	ldr	r3, [sp, #16]
 80a37f6:	085b      	lsrs	r3, r3, #1
 80a37f8:	9304      	str	r3, [sp, #16]
      } while ( ++j < 32 ); // ... pixel done
 80a37fa:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a37fe:	3301      	adds	r3, #1
 80a3800:	b2db      	uxtb	r3, r3
      g = *ptr++;   // Next green byte value
      b = *ptr++;   // Next blue byte value
      w = *ptr++;   // Next white byte value
      c = ((uint32_t)r << 24) | ((uint32_t)g << 16) | ((uint32_t)b <<  8) | w; // Pack the next 4 bytes to keep timing tight
      j = 0;        // reset the 32-bit counter
      do {
 80a3802:	2b1f      	cmp	r3, #31
 80a3804:	f88d 3005 	strb.w	r3, [sp, #5]
 80a3808:	d87e      	bhi.n	80a3908 <_ZN17Adafruit_NeoPixel4showEv+0xb20>
        pinSet(pin, HIGH); // HIGH
 80a380a:	79e3      	ldrb	r3, [r4, #7]
 80a380c:	6810      	ldr	r0, [r2, #0]
 80a380e:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a3812:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a3816:	88bf      	ldrh	r7, [r7, #4]
 80a3818:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a381c:	831f      	strh	r7, [r3, #24]
        if (c & mask) { // if masked bit is high
 80a381e:	9803      	ldr	r0, [sp, #12]
 80a3820:	9b04      	ldr	r3, [sp, #16]
 80a3822:	4218      	tst	r0, r3
 80a3824:	f47f af76 	bne.w	80a3714 <_ZN17Adafruit_NeoPixel4showEv+0x92c>
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a3828:	4600      	mov	r0, r0
 80a382a:	bf00      	nop
 80a382c:	bf00      	nop
 80a382e:	bf00      	nop
 80a3830:	bf00      	nop
 80a3832:	bf00      	nop
 80a3834:	bf00      	nop
 80a3836:	bf00      	nop
 80a3838:	bf00      	nop
 80a383a:	bf00      	nop
 80a383c:	bf00      	nop
 80a383e:	bf00      	nop
 80a3840:	bf00      	nop
 80a3842:	bf00      	nop
 80a3844:	bf00      	nop
 80a3846:	bf00      	nop
 80a3848:	bf00      	nop
 80a384a:	bf00      	nop
 80a384c:	bf00      	nop
 80a384e:	bf00      	nop
          // SK6812RGBW spec         900ns LOW
          // WS2812 spec             800ns LOW
          // Adafruit on Arduino    (meas. 938ns)
          // This lib on Spark Core (meas. 904ns)
          // This lib on Photon     (meas. 900ns)
          pinSet(pin, LOW); // LOW
 80a3850:	79e3      	ldrb	r3, [r4, #7]
 80a3852:	6810      	ldr	r0, [r2, #0]
 80a3854:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a3858:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a385c:	88bf      	ldrh	r7, [r7, #4]
 80a385e:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a3862:	835f      	strh	r7, [r3, #26]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a3864:	4600      	mov	r0, r0
 80a3866:	bf00      	nop
 80a3868:	bf00      	nop
 80a386a:	bf00      	nop
 80a386c:	bf00      	nop
 80a386e:	bf00      	nop
 80a3870:	bf00      	nop
 80a3872:	bf00      	nop
 80a3874:	bf00      	nop
 80a3876:	bf00      	nop
 80a3878:	bf00      	nop
 80a387a:	bf00      	nop
 80a387c:	bf00      	nop
 80a387e:	bf00      	nop
 80a3880:	bf00      	nop
 80a3882:	bf00      	nop
 80a3884:	bf00      	nop
 80a3886:	bf00      	nop
 80a3888:	bf00      	nop
 80a388a:	bf00      	nop
 80a388c:	bf00      	nop
 80a388e:	bf00      	nop
 80a3890:	bf00      	nop
 80a3892:	bf00      	nop
 80a3894:	bf00      	nop
 80a3896:	bf00      	nop
 80a3898:	bf00      	nop
 80a389a:	bf00      	nop
 80a389c:	bf00      	nop
 80a389e:	bf00      	nop
 80a38a0:	bf00      	nop
 80a38a2:	bf00      	nop
 80a38a4:	bf00      	nop
 80a38a6:	bf00      	nop
 80a38a8:	bf00      	nop
 80a38aa:	bf00      	nop
 80a38ac:	bf00      	nop
 80a38ae:	bf00      	nop
 80a38b0:	bf00      	nop
 80a38b2:	bf00      	nop
 80a38b4:	bf00      	nop
 80a38b6:	bf00      	nop
 80a38b8:	bf00      	nop
 80a38ba:	bf00      	nop
 80a38bc:	bf00      	nop
 80a38be:	bf00      	nop
 80a38c0:	bf00      	nop
 80a38c2:	bf00      	nop
 80a38c4:	bf00      	nop
 80a38c6:	bf00      	nop
 80a38c8:	bf00      	nop
 80a38ca:	bf00      	nop
 80a38cc:	bf00      	nop
 80a38ce:	bf00      	nop
 80a38d0:	bf00      	nop
 80a38d2:	bf00      	nop
 80a38d4:	bf00      	nop
 80a38d6:	bf00      	nop
 80a38d8:	bf00      	nop
 80a38da:	bf00      	nop
 80a38dc:	bf00      	nop
 80a38de:	bf00      	nop
 80a38e0:	bf00      	nop
 80a38e2:	bf00      	nop
 80a38e4:	bf00      	nop
 80a38e6:	bf00      	nop
 80a38e8:	bf00      	nop
 80a38ea:	bf00      	nop
 80a38ec:	bf00      	nop
 80a38ee:	bf00      	nop
 80a38f0:	bf00      	nop
 80a38f2:	bf00      	nop
 80a38f4:	bf00      	nop
 80a38f6:	bf00      	nop
 80a38f8:	bf00      	nop
 80a38fa:	bf00      	nop
 80a38fc:	bf00      	nop
 80a38fe:	bf00      	nop
 80a3900:	bf00      	nop
 80a3902:	bf00      	nop
 80a3904:	bf00      	nop
 80a3906:	e775      	b.n	80a37f4 <_ZN17Adafruit_NeoPixel4showEv+0xa0c>
      mask = 0x80000000; // reset the mask
      i = i-4;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      g = *ptr++;   // Next green byte value
      b = *ptr++;   // Next blue byte value
      w = *ptr++;   // Next white byte value
 80a3908:	468e      	mov	lr, r1
 80a390a:	e6ca      	b.n	80a36a2 <_ZN17Adafruit_NeoPixel4showEv+0x8ba>
 80a390c:	4770      	bx	lr
        }
        mask >>= 1;
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else if(type == TM1803) { // TM1803 (Radio Shack Tri-Color Strip), 400 KHz bitstream
 80a390e:	2903      	cmp	r1, #3
 80a3910:	f000 812e 	beq.w	80a3b70 <_ZN17Adafruit_NeoPixel4showEv+0xd88>
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      g = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      pinSet(pin, LOW); // LOW
 80a3914:	4a1e      	ldr	r2, [pc, #120]	; (80a3990 <_ZN17Adafruit_NeoPixel4showEv+0xba8>)
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else { // must be only other option TM1829, 800 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
 80a3916:	f44f 0500 	mov.w	r5, #8388608	; 0x800000
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      g = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
 80a391a:	2600      	movs	r6, #0
        mask >>= 1;
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else { // must be only other option TM1829, 800 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a391c:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a3920:	b29b      	uxth	r3, r3
 80a3922:	2b00      	cmp	r3, #0
 80a3924:	f43f ae2e 	beq.w	80a3584 <_ZN17Adafruit_NeoPixel4showEv+0x79c>
      mask = 0x800000; // reset the mask
 80a3928:	9504      	str	r5, [sp, #16]
      i = i-3;      // decrement bytes remaining
 80a392a:	f8bd 300a 	ldrh.w	r3, [sp, #10]
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      g = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      pinSet(pin, LOW); // LOW
 80a392e:	79e0      	ldrb	r0, [r4, #7]
    } // end while(i) ... no more pixels
  }
  else { // must be only other option TM1829, 800 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
 80a3930:	3b03      	subs	r3, #3
 80a3932:	b29b      	uxth	r3, r3
 80a3934:	f8ad 300a 	strh.w	r3, [sp, #10]
      r = *ptr++;   // Next red byte value
 80a3938:	f89e 3000 	ldrb.w	r3, [lr]
 80a393c:	f10e 0103 	add.w	r1, lr, #3
 80a3940:	b2db      	uxtb	r3, r3
 80a3942:	f88d 3007 	strb.w	r3, [sp, #7]
      b = *ptr++;   // Next blue byte value
 80a3946:	f89e 3001 	ldrb.w	r3, [lr, #1]
      g = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      pinSet(pin, LOW); // LOW
 80a394a:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
  else { // must be only other option TM1829, 800 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
 80a394e:	b2db      	uxtb	r3, r3
 80a3950:	f88d 3008 	strb.w	r3, [sp, #8]
      g = *ptr++;   // Next green byte value
 80a3954:	f89e 3002 	ldrb.w	r3, [lr, #2]
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      pinSet(pin, LOW); // LOW
 80a3958:	f8d2 e000 	ldr.w	lr, [r2]
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      g = *ptr++;   // Next green byte value
 80a395c:	b2db      	uxtb	r3, r3
 80a395e:	f88d 3006 	strb.w	r3, [sp, #6]
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
 80a3962:	f89d 7007 	ldrb.w	r7, [sp, #7]
 80a3966:	f89d 3008 	ldrb.w	r3, [sp, #8]
      j = 0;        // reset the 24-bit counter
      pinSet(pin, LOW); // LOW
 80a396a:	eb0e 0c80 	add.w	ip, lr, r0, lsl #2
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      g = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
 80a396e:	021b      	lsls	r3, r3, #8
 80a3970:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 80a3974:	f89d 7006 	ldrb.w	r7, [sp, #6]
      j = 0;        // reset the 24-bit counter
      pinSet(pin, LOW); // LOW
 80a3978:	f8bc c004 	ldrh.w	ip, [ip, #4]
 80a397c:	f85e 0020 	ldr.w	r0, [lr, r0, lsl #2]
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      b = *ptr++;   // Next blue byte value
      g = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
 80a3980:	433b      	orrs	r3, r7
 80a3982:	9303      	str	r3, [sp, #12]
      j = 0;        // reset the 24-bit counter
 80a3984:	f88d 6005 	strb.w	r6, [sp, #5]
      pinSet(pin, LOW); // LOW
 80a3988:	f8a0 c01a 	strh.w	ip, [r0, #26]
 80a398c:	e07d      	b.n	80a3a8a <_ZN17Adafruit_NeoPixel4showEv+0xca2>
 80a398e:	bf00      	nop
 80a3990:	20001054 	.word	0x20001054
      for( ;; ) {   // ... pixel done
        if (c & mask) { // if masked bit is high
          // TM1829 spec             800ns LOW
          // This lib on Spark Core (meas. 806ns)
          // This lib on Photon     (meas. 792ns)
          mask >>= 1; // Do this task during the long delay of this bit
 80a3994:	9b04      	ldr	r3, [sp, #16]
 80a3996:	085b      	lsrs	r3, r3, #1
 80a3998:	9304      	str	r3, [sp, #16]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a399a:	4600      	mov	r0, r0
 80a399c:	bf00      	nop
 80a399e:	bf00      	nop
 80a39a0:	bf00      	nop
 80a39a2:	bf00      	nop
 80a39a4:	bf00      	nop
 80a39a6:	bf00      	nop
 80a39a8:	bf00      	nop
 80a39aa:	bf00      	nop
 80a39ac:	bf00      	nop
 80a39ae:	bf00      	nop
 80a39b0:	bf00      	nop
 80a39b2:	bf00      	nop
 80a39b4:	bf00      	nop
 80a39b6:	bf00      	nop
 80a39b8:	bf00      	nop
 80a39ba:	bf00      	nop
 80a39bc:	bf00      	nop
 80a39be:	bf00      	nop
 80a39c0:	bf00      	nop
 80a39c2:	bf00      	nop
 80a39c4:	bf00      	nop
 80a39c6:	bf00      	nop
 80a39c8:	bf00      	nop
 80a39ca:	bf00      	nop
 80a39cc:	bf00      	nop
 80a39ce:	bf00      	nop
 80a39d0:	bf00      	nop
 80a39d2:	bf00      	nop
 80a39d4:	bf00      	nop
 80a39d6:	bf00      	nop
 80a39d8:	bf00      	nop
 80a39da:	bf00      	nop
 80a39dc:	bf00      	nop
 80a39de:	bf00      	nop
 80a39e0:	bf00      	nop
 80a39e2:	bf00      	nop
 80a39e4:	bf00      	nop
 80a39e6:	bf00      	nop
 80a39e8:	bf00      	nop
 80a39ea:	bf00      	nop
 80a39ec:	bf00      	nop
 80a39ee:	bf00      	nop
 80a39f0:	bf00      	nop
 80a39f2:	bf00      	nop
 80a39f4:	bf00      	nop
 80a39f6:	bf00      	nop
 80a39f8:	bf00      	nop
 80a39fa:	bf00      	nop
 80a39fc:	bf00      	nop
 80a39fe:	bf00      	nop
 80a3a00:	bf00      	nop
 80a3a02:	bf00      	nop
 80a3a04:	bf00      	nop
 80a3a06:	bf00      	nop
 80a3a08:	bf00      	nop
 80a3a0a:	bf00      	nop
 80a3a0c:	bf00      	nop
 80a3a0e:	bf00      	nop
 80a3a10:	bf00      	nop
 80a3a12:	bf00      	nop
 80a3a14:	bf00      	nop
 80a3a16:	bf00      	nop
 80a3a18:	bf00      	nop
 80a3a1a:	bf00      	nop
 80a3a1c:	bf00      	nop
 80a3a1e:	bf00      	nop
          j++;
          // TM1829 spec             300ns HIGH
          // This lib on Spark Core (meas. 305ns)
          // This lib on Photon     (meas. 300ns)
          pinSet(pin, HIGH); // HIGH
 80a3a20:	79e0      	ldrb	r0, [r4, #7]
 80a3a22:	6817      	ldr	r7, [r2, #0]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
          j++;
 80a3a24:	f89d 3005 	ldrb.w	r3, [sp, #5]
          // TM1829 spec             300ns HIGH
          // This lib on Spark Core (meas. 305ns)
          // This lib on Photon     (meas. 300ns)
          pinSet(pin, HIGH); // HIGH
 80a3a28:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 80a3a2c:	eb07 0e80 	add.w	lr, r7, r0, lsl #2
 80a3a30:	f8be e004 	ldrh.w	lr, [lr, #4]
 80a3a34:	f857 0020 	ldr.w	r0, [r7, r0, lsl #2]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
          j++;
 80a3a38:	3301      	adds	r3, #1
 80a3a3a:	b2db      	uxtb	r3, r3
 80a3a3c:	f88d 3005 	strb.w	r3, [sp, #5]
          // TM1829 spec             300ns HIGH
          // This lib on Spark Core (meas. 305ns)
          // This lib on Photon     (meas. 300ns)
          pinSet(pin, HIGH); // HIGH
 80a3a40:	f8a0 e018 	strh.w	lr, [r0, #24]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a3a44:	4600      	mov	r0, r0
 80a3a46:	bf00      	nop
 80a3a48:	bf00      	nop
 80a3a4a:	bf00      	nop
 80a3a4c:	bf00      	nop
 80a3a4e:	bf00      	nop
 80a3a50:	bf00      	nop
 80a3a52:	bf00      	nop
 80a3a54:	bf00      	nop
 80a3a56:	bf00      	nop
 80a3a58:	bf00      	nop
 80a3a5a:	bf00      	nop
 80a3a5c:	bf00      	nop
 80a3a5e:	bf00      	nop
 80a3a60:	bf00      	nop
 80a3a62:	bf00      	nop
 80a3a64:	bf00      	nop
 80a3a66:	bf00      	nop
 80a3a68:	bf00      	nop
 80a3a6a:	bf00      	nop
 80a3a6c:	bf00      	nop
          if(j==24) break;
 80a3a6e:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a3a72:	2b18      	cmp	r3, #24
 80a3a74:	d07a      	beq.n	80a3b6c <_ZN17Adafruit_NeoPixel4showEv+0xd84>
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
          if(j==24) break;
          pinSet(pin, LOW); // LOW
 80a3a76:	79e3      	ldrb	r3, [r4, #7]
 80a3a78:	6810      	ldr	r0, [r2, #0]
 80a3a7a:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a3a7e:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a3a82:	88bf      	ldrh	r7, [r7, #4]
 80a3a84:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a3a88:	835f      	strh	r7, [r3, #26]
      g = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      pinSet(pin, LOW); // LOW
      for( ;; ) {   // ... pixel done
        if (c & mask) { // if masked bit is high
 80a3a8a:	9803      	ldr	r0, [sp, #12]
 80a3a8c:	9b04      	ldr	r3, [sp, #16]
 80a3a8e:	4218      	tst	r0, r3
 80a3a90:	d180      	bne.n	80a3994 <_ZN17Adafruit_NeoPixel4showEv+0xbac>
            "mov r0, r0" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
            ::: "r0", "cc", "memory");
 80a3a92:	4600      	mov	r0, r0
 80a3a94:	bf00      	nop
 80a3a96:	bf00      	nop
 80a3a98:	bf00      	nop
 80a3a9a:	bf00      	nop
 80a3a9c:	bf00      	nop
 80a3a9e:	bf00      	nop
 80a3aa0:	bf00      	nop
 80a3aa2:	bf00      	nop
 80a3aa4:	bf00      	nop
 80a3aa6:	bf00      	nop
 80a3aa8:	bf00      	nop
 80a3aaa:	bf00      	nop
 80a3aac:	bf00      	nop
 80a3aae:	bf00      	nop
 80a3ab0:	bf00      	nop
 80a3ab2:	bf00      	nop
#endif
          // TM1829 spec             800ns HIGH
          // This lib on Spark Core (meas. 792ns)
          // This lib on Photon     (meas. 800ns)
          pinSet(pin, HIGH); // HIGH
 80a3ab4:	79e3      	ldrb	r3, [r4, #7]
 80a3ab6:	6810      	ldr	r0, [r2, #0]
 80a3ab8:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a3abc:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a3ac0:	88bf      	ldrh	r7, [r7, #4]
 80a3ac2:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a3ac6:	831f      	strh	r7, [r3, #24]
          j++;
 80a3ac8:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a3acc:	3301      	adds	r3, #1
 80a3ace:	b2db      	uxtb	r3, r3
 80a3ad0:	f88d 3005 	strb.w	r3, [sp, #5]
          mask >>= 1; // Do this task during the long delay of this bit
 80a3ad4:	9b04      	ldr	r3, [sp, #16]
 80a3ad6:	085b      	lsrs	r3, r3, #1
 80a3ad8:	9304      	str	r3, [sp, #16]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a3ada:	4600      	mov	r0, r0
 80a3adc:	bf00      	nop
 80a3ade:	bf00      	nop
 80a3ae0:	bf00      	nop
 80a3ae2:	bf00      	nop
 80a3ae4:	bf00      	nop
 80a3ae6:	bf00      	nop
 80a3ae8:	bf00      	nop
 80a3aea:	bf00      	nop
 80a3aec:	bf00      	nop
 80a3aee:	bf00      	nop
 80a3af0:	bf00      	nop
 80a3af2:	bf00      	nop
 80a3af4:	bf00      	nop
 80a3af6:	bf00      	nop
 80a3af8:	bf00      	nop
 80a3afa:	bf00      	nop
 80a3afc:	bf00      	nop
 80a3afe:	bf00      	nop
 80a3b00:	bf00      	nop
 80a3b02:	bf00      	nop
 80a3b04:	bf00      	nop
 80a3b06:	bf00      	nop
 80a3b08:	bf00      	nop
 80a3b0a:	bf00      	nop
 80a3b0c:	bf00      	nop
 80a3b0e:	bf00      	nop
 80a3b10:	bf00      	nop
 80a3b12:	bf00      	nop
 80a3b14:	bf00      	nop
 80a3b16:	bf00      	nop
 80a3b18:	bf00      	nop
 80a3b1a:	bf00      	nop
 80a3b1c:	bf00      	nop
 80a3b1e:	bf00      	nop
 80a3b20:	bf00      	nop
 80a3b22:	bf00      	nop
 80a3b24:	bf00      	nop
 80a3b26:	bf00      	nop
 80a3b28:	bf00      	nop
 80a3b2a:	bf00      	nop
 80a3b2c:	bf00      	nop
 80a3b2e:	bf00      	nop
 80a3b30:	bf00      	nop
 80a3b32:	bf00      	nop
 80a3b34:	bf00      	nop
 80a3b36:	bf00      	nop
 80a3b38:	bf00      	nop
 80a3b3a:	bf00      	nop
 80a3b3c:	bf00      	nop
 80a3b3e:	bf00      	nop
 80a3b40:	bf00      	nop
 80a3b42:	bf00      	nop
 80a3b44:	bf00      	nop
 80a3b46:	bf00      	nop
 80a3b48:	bf00      	nop
 80a3b4a:	bf00      	nop
 80a3b4c:	bf00      	nop
 80a3b4e:	bf00      	nop
 80a3b50:	bf00      	nop
 80a3b52:	bf00      	nop
 80a3b54:	bf00      	nop
 80a3b56:	bf00      	nop
 80a3b58:	bf00      	nop
 80a3b5a:	bf00      	nop
 80a3b5c:	bf00      	nop
 80a3b5e:	bf00      	nop
 80a3b60:	bf00      	nop
 80a3b62:	bf00      	nop
          if(j==24) break;
 80a3b64:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a3b68:	2b18      	cmp	r3, #24
 80a3b6a:	d184      	bne.n	80a3a76 <_ZN17Adafruit_NeoPixel4showEv+0xc8e>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      g = *ptr++;   // Next blue byte value
      b = *ptr++;   // Next green byte value
 80a3b6c:	468e      	mov	lr, r1
 80a3b6e:	e6d5      	b.n	80a391c <_ZN17Adafruit_NeoPixel4showEv+0xb34>
 80a3b70:	4a17      	ldr	r2, [pc, #92]	; (80a3bd0 <_ZN17Adafruit_NeoPixel4showEv+0xde8>)
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else if(type == TM1803) { // TM1803 (Radio Shack Tri-Color Strip), 400 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
 80a3b72:	f44f 0500 	mov.w	r5, #8388608	; 0x800000
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      g = *ptr++;   // Next blue byte value
      b = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)g <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
 80a3b76:	2600      	movs	r6, #0
        mask >>= 1;
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else if(type == TM1803) { // TM1803 (Radio Shack Tri-Color Strip), 400 KHz bitstream
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a3b78:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a3b7c:	b29b      	uxth	r3, r3
 80a3b7e:	2b00      	cmp	r3, #0
 80a3b80:	f43f ad00 	beq.w	80a3584 <_ZN17Adafruit_NeoPixel4showEv+0x79c>
      mask = 0x800000; // reset the mask
 80a3b84:	9504      	str	r5, [sp, #16]
      i = i-3;      // decrement bytes remaining
 80a3b86:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a3b8a:	f10e 0103 	add.w	r1, lr, #3
 80a3b8e:	3b03      	subs	r3, #3
 80a3b90:	b29b      	uxth	r3, r3
 80a3b92:	f8ad 300a 	strh.w	r3, [sp, #10]
      r = *ptr++;   // Next red byte value
 80a3b96:	f89e 3000 	ldrb.w	r3, [lr]
 80a3b9a:	b2db      	uxtb	r3, r3
 80a3b9c:	f88d 3007 	strb.w	r3, [sp, #7]
      g = *ptr++;   // Next blue byte value
 80a3ba0:	f89e 3001 	ldrb.w	r3, [lr, #1]
 80a3ba4:	b2db      	uxtb	r3, r3
 80a3ba6:	f88d 3006 	strb.w	r3, [sp, #6]
      b = *ptr++;   // Next green byte value
 80a3baa:	f89e 3002 	ldrb.w	r3, [lr, #2]
 80a3bae:	b2db      	uxtb	r3, r3
 80a3bb0:	f88d 3008 	strb.w	r3, [sp, #8]
      c = ((uint32_t)r << 16) | ((uint32_t)g <<  8) | b; // Pack the next 3 bytes to keep timing tight
 80a3bb4:	f89d 7007 	ldrb.w	r7, [sp, #7]
 80a3bb8:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a3bbc:	f89d 0008 	ldrb.w	r0, [sp, #8]
 80a3bc0:	021b      	lsls	r3, r3, #8
 80a3bc2:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 80a3bc6:	4303      	orrs	r3, r0
 80a3bc8:	9303      	str	r3, [sp, #12]
      j = 0;        // reset the 24-bit counter
 80a3bca:	f88d 6005 	strb.w	r6, [sp, #5]
 80a3bce:	e0e0      	b.n	80a3d92 <_ZN17Adafruit_NeoPixel4showEv+0xfaa>
 80a3bd0:	20001054 	.word	0x20001054
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a3bd4:	4600      	mov	r0, r0
 80a3bd6:	bf00      	nop
 80a3bd8:	bf00      	nop
 80a3bda:	bf00      	nop
 80a3bdc:	bf00      	nop
 80a3bde:	bf00      	nop
 80a3be0:	bf00      	nop
 80a3be2:	bf00      	nop
 80a3be4:	bf00      	nop
 80a3be6:	bf00      	nop
 80a3be8:	bf00      	nop
 80a3bea:	bf00      	nop
 80a3bec:	bf00      	nop
 80a3bee:	bf00      	nop
 80a3bf0:	bf00      	nop
 80a3bf2:	bf00      	nop
 80a3bf4:	bf00      	nop
 80a3bf6:	bf00      	nop
 80a3bf8:	bf00      	nop
 80a3bfa:	bf00      	nop
 80a3bfc:	bf00      	nop
 80a3bfe:	bf00      	nop
 80a3c00:	bf00      	nop
 80a3c02:	bf00      	nop
 80a3c04:	bf00      	nop
 80a3c06:	bf00      	nop
 80a3c08:	bf00      	nop
 80a3c0a:	bf00      	nop
 80a3c0c:	bf00      	nop
 80a3c0e:	bf00      	nop
 80a3c10:	bf00      	nop
 80a3c12:	bf00      	nop
 80a3c14:	bf00      	nop
 80a3c16:	bf00      	nop
 80a3c18:	bf00      	nop
 80a3c1a:	bf00      	nop
 80a3c1c:	bf00      	nop
 80a3c1e:	bf00      	nop
 80a3c20:	bf00      	nop
 80a3c22:	bf00      	nop
 80a3c24:	bf00      	nop
 80a3c26:	bf00      	nop
 80a3c28:	bf00      	nop
 80a3c2a:	bf00      	nop
 80a3c2c:	bf00      	nop
 80a3c2e:	bf00      	nop
 80a3c30:	bf00      	nop
 80a3c32:	bf00      	nop
 80a3c34:	bf00      	nop
 80a3c36:	bf00      	nop
 80a3c38:	bf00      	nop
 80a3c3a:	bf00      	nop
 80a3c3c:	bf00      	nop
 80a3c3e:	bf00      	nop
 80a3c40:	bf00      	nop
 80a3c42:	bf00      	nop
 80a3c44:	bf00      	nop
 80a3c46:	bf00      	nop
 80a3c48:	bf00      	nop
 80a3c4a:	bf00      	nop
 80a3c4c:	bf00      	nop
 80a3c4e:	bf00      	nop
 80a3c50:	bf00      	nop
 80a3c52:	bf00      	nop
 80a3c54:	bf00      	nop
 80a3c56:	bf00      	nop
 80a3c58:	bf00      	nop
 80a3c5a:	bf00      	nop
 80a3c5c:	bf00      	nop
 80a3c5e:	bf00      	nop
 80a3c60:	bf00      	nop
 80a3c62:	bf00      	nop
 80a3c64:	bf00      	nop
 80a3c66:	bf00      	nop
 80a3c68:	bf00      	nop
 80a3c6a:	bf00      	nop
 80a3c6c:	bf00      	nop
 80a3c6e:	bf00      	nop
 80a3c70:	bf00      	nop
 80a3c72:	bf00      	nop
 80a3c74:	bf00      	nop
 80a3c76:	bf00      	nop
 80a3c78:	bf00      	nop
 80a3c7a:	bf00      	nop
 80a3c7c:	bf00      	nop
 80a3c7e:	bf00      	nop
 80a3c80:	bf00      	nop
 80a3c82:	bf00      	nop
 80a3c84:	bf00      	nop
 80a3c86:	bf00      	nop
 80a3c88:	bf00      	nop
 80a3c8a:	bf00      	nop
 80a3c8c:	bf00      	nop
 80a3c8e:	bf00      	nop
 80a3c90:	bf00      	nop
 80a3c92:	bf00      	nop
 80a3c94:	bf00      	nop
 80a3c96:	bf00      	nop
 80a3c98:	bf00      	nop
 80a3c9a:	bf00      	nop
 80a3c9c:	bf00      	nop
 80a3c9e:	bf00      	nop
 80a3ca0:	bf00      	nop
 80a3ca2:	bf00      	nop
 80a3ca4:	bf00      	nop
 80a3ca6:	bf00      	nop
 80a3ca8:	bf00      	nop
 80a3caa:	bf00      	nop
 80a3cac:	bf00      	nop
 80a3cae:	bf00      	nop
 80a3cb0:	bf00      	nop
 80a3cb2:	bf00      	nop
 80a3cb4:	bf00      	nop
 80a3cb6:	bf00      	nop
 80a3cb8:	bf00      	nop
 80a3cba:	bf00      	nop
 80a3cbc:	bf00      	nop
 80a3cbe:	bf00      	nop
 80a3cc0:	bf00      	nop
 80a3cc2:	bf00      	nop
 80a3cc4:	bf00      	nop
 80a3cc6:	bf00      	nop
 80a3cc8:	bf00      	nop
 80a3cca:	bf00      	nop
 80a3ccc:	bf00      	nop
 80a3cce:	bf00      	nop
 80a3cd0:	bf00      	nop
 80a3cd2:	bf00      	nop
 80a3cd4:	bf00      	nop
 80a3cd6:	bf00      	nop
 80a3cd8:	bf00      	nop
 80a3cda:	bf00      	nop
 80a3cdc:	bf00      	nop
 80a3cde:	bf00      	nop
 80a3ce0:	bf00      	nop
 80a3ce2:	bf00      	nop
 80a3ce4:	bf00      	nop
 80a3ce6:	bf00      	nop
 80a3ce8:	bf00      	nop
 80a3cea:	bf00      	nop
 80a3cec:	bf00      	nop
 80a3cee:	bf00      	nop
 80a3cf0:	bf00      	nop
 80a3cf2:	bf00      	nop
 80a3cf4:	bf00      	nop
          // TM1803 spec             680ns LOW
          // Pololu on Arduino      (meas. 1.024us)
          // This lib on Spark Core (meas. 680ns)
          // This lib on Photon     (meas. 684ns)
          pinSet(pin, LOW); // LOW
 80a3cf6:	79e3      	ldrb	r3, [r4, #7]
 80a3cf8:	6810      	ldr	r0, [r2, #0]
 80a3cfa:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a3cfe:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a3d02:	88bf      	ldrh	r7, [r7, #4]
 80a3d04:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a3d08:	835f      	strh	r7, [r3, #26]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a3d0a:	4600      	mov	r0, r0
 80a3d0c:	bf00      	nop
 80a3d0e:	bf00      	nop
 80a3d10:	bf00      	nop
 80a3d12:	bf00      	nop
 80a3d14:	bf00      	nop
 80a3d16:	bf00      	nop
 80a3d18:	bf00      	nop
 80a3d1a:	bf00      	nop
 80a3d1c:	bf00      	nop
 80a3d1e:	bf00      	nop
 80a3d20:	bf00      	nop
 80a3d22:	bf00      	nop
 80a3d24:	bf00      	nop
 80a3d26:	bf00      	nop
 80a3d28:	bf00      	nop
 80a3d2a:	bf00      	nop
 80a3d2c:	bf00      	nop
 80a3d2e:	bf00      	nop
 80a3d30:	bf00      	nop
 80a3d32:	bf00      	nop
 80a3d34:	bf00      	nop
 80a3d36:	bf00      	nop
 80a3d38:	bf00      	nop
 80a3d3a:	bf00      	nop
 80a3d3c:	bf00      	nop
 80a3d3e:	bf00      	nop
 80a3d40:	bf00      	nop
 80a3d42:	bf00      	nop
 80a3d44:	bf00      	nop
 80a3d46:	bf00      	nop
 80a3d48:	bf00      	nop
 80a3d4a:	bf00      	nop
 80a3d4c:	bf00      	nop
 80a3d4e:	bf00      	nop
 80a3d50:	bf00      	nop
 80a3d52:	bf00      	nop
 80a3d54:	bf00      	nop
 80a3d56:	bf00      	nop
 80a3d58:	bf00      	nop
 80a3d5a:	bf00      	nop
 80a3d5c:	bf00      	nop
 80a3d5e:	bf00      	nop
 80a3d60:	bf00      	nop
 80a3d62:	bf00      	nop
 80a3d64:	bf00      	nop
 80a3d66:	bf00      	nop
 80a3d68:	bf00      	nop
 80a3d6a:	bf00      	nop
 80a3d6c:	bf00      	nop
 80a3d6e:	bf00      	nop
 80a3d70:	bf00      	nop
 80a3d72:	bf00      	nop
 80a3d74:	bf00      	nop
 80a3d76:	bf00      	nop
 80a3d78:	bf00      	nop
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
        }
        mask >>= 1;
 80a3d7a:	9b04      	ldr	r3, [sp, #16]
 80a3d7c:	085b      	lsrs	r3, r3, #1
 80a3d7e:	9304      	str	r3, [sp, #16]
      } while ( ++j < 24 ); // ... pixel done
 80a3d80:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a3d84:	3301      	adds	r3, #1
 80a3d86:	b2db      	uxtb	r3, r3
      r = *ptr++;   // Next red byte value
      g = *ptr++;   // Next blue byte value
      b = *ptr++;   // Next green byte value
      c = ((uint32_t)r << 16) | ((uint32_t)g <<  8) | b; // Pack the next 3 bytes to keep timing tight
      j = 0;        // reset the 24-bit counter
      do {
 80a3d88:	2b17      	cmp	r3, #23
 80a3d8a:	f88d 3005 	strb.w	r3, [sp, #5]
 80a3d8e:	f200 80e3 	bhi.w	80a3f58 <_ZN17Adafruit_NeoPixel4showEv+0x1170>
        pinSet(pin, HIGH); // HIGH
 80a3d92:	79e3      	ldrb	r3, [r4, #7]
 80a3d94:	6810      	ldr	r0, [r2, #0]
 80a3d96:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a3d9a:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a3d9e:	88bf      	ldrh	r7, [r7, #4]
 80a3da0:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a3da4:	831f      	strh	r7, [r3, #24]
        if (c & mask) { // if masked bit is high
 80a3da6:	9803      	ldr	r0, [sp, #12]
 80a3da8:	9b04      	ldr	r3, [sp, #16]
 80a3daa:	4218      	tst	r0, r3
 80a3dac:	f47f af12 	bne.w	80a3bd4 <_ZN17Adafruit_NeoPixel4showEv+0xdec>
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a3db0:	4600      	mov	r0, r0
 80a3db2:	bf00      	nop
 80a3db4:	bf00      	nop
 80a3db6:	bf00      	nop
 80a3db8:	bf00      	nop
 80a3dba:	bf00      	nop
 80a3dbc:	bf00      	nop
 80a3dbe:	bf00      	nop
 80a3dc0:	bf00      	nop
 80a3dc2:	bf00      	nop
 80a3dc4:	bf00      	nop
 80a3dc6:	bf00      	nop
 80a3dc8:	bf00      	nop
 80a3dca:	bf00      	nop
 80a3dcc:	bf00      	nop
 80a3dce:	bf00      	nop
 80a3dd0:	bf00      	nop
 80a3dd2:	bf00      	nop
 80a3dd4:	bf00      	nop
 80a3dd6:	bf00      	nop
 80a3dd8:	bf00      	nop
 80a3dda:	bf00      	nop
 80a3ddc:	bf00      	nop
 80a3dde:	bf00      	nop
 80a3de0:	bf00      	nop
 80a3de2:	bf00      	nop
 80a3de4:	bf00      	nop
 80a3de6:	bf00      	nop
 80a3de8:	bf00      	nop
 80a3dea:	bf00      	nop
 80a3dec:	bf00      	nop
 80a3dee:	bf00      	nop
 80a3df0:	bf00      	nop
 80a3df2:	bf00      	nop
 80a3df4:	bf00      	nop
 80a3df6:	bf00      	nop
 80a3df8:	bf00      	nop
 80a3dfa:	bf00      	nop
 80a3dfc:	bf00      	nop
 80a3dfe:	bf00      	nop
 80a3e00:	bf00      	nop
 80a3e02:	bf00      	nop
 80a3e04:	bf00      	nop
 80a3e06:	bf00      	nop
 80a3e08:	bf00      	nop
 80a3e0a:	bf00      	nop
 80a3e0c:	bf00      	nop
 80a3e0e:	bf00      	nop
 80a3e10:	bf00      	nop
 80a3e12:	bf00      	nop
 80a3e14:	bf00      	nop
 80a3e16:	bf00      	nop
 80a3e18:	bf00      	nop
 80a3e1a:	bf00      	nop
 80a3e1c:	bf00      	nop
 80a3e1e:	bf00      	nop
 80a3e20:	bf00      	nop
 80a3e22:	bf00      	nop
 80a3e24:	bf00      	nop
 80a3e26:	bf00      	nop
 80a3e28:	bf00      	nop
 80a3e2a:	bf00      	nop
 80a3e2c:	bf00      	nop
 80a3e2e:	bf00      	nop
 80a3e30:	bf00      	nop
          // TM1803 spec             1.36us LOW
          // Pololu on Arduino      (meas. 2.00us)
          // This lib on Spark Core (meas. 1.36us)
          // This lib on Photon     (meas. 1.36us)
          pinSet(pin, LOW); // LOW
 80a3e32:	79e3      	ldrb	r3, [r4, #7]
 80a3e34:	6810      	ldr	r0, [r2, #0]
 80a3e36:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a3e3a:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a3e3e:	88bf      	ldrh	r7, [r7, #4]
 80a3e40:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a3e44:	835f      	strh	r7, [r3, #26]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a3e46:	4600      	mov	r0, r0
 80a3e48:	bf00      	nop
 80a3e4a:	bf00      	nop
 80a3e4c:	bf00      	nop
 80a3e4e:	bf00      	nop
 80a3e50:	bf00      	nop
 80a3e52:	bf00      	nop
 80a3e54:	bf00      	nop
 80a3e56:	bf00      	nop
 80a3e58:	bf00      	nop
 80a3e5a:	bf00      	nop
 80a3e5c:	bf00      	nop
 80a3e5e:	bf00      	nop
 80a3e60:	bf00      	nop
 80a3e62:	bf00      	nop
 80a3e64:	bf00      	nop
 80a3e66:	bf00      	nop
 80a3e68:	bf00      	nop
 80a3e6a:	bf00      	nop
 80a3e6c:	bf00      	nop
 80a3e6e:	bf00      	nop
 80a3e70:	bf00      	nop
 80a3e72:	bf00      	nop
 80a3e74:	bf00      	nop
 80a3e76:	bf00      	nop
 80a3e78:	bf00      	nop
 80a3e7a:	bf00      	nop
 80a3e7c:	bf00      	nop
 80a3e7e:	bf00      	nop
 80a3e80:	bf00      	nop
 80a3e82:	bf00      	nop
 80a3e84:	bf00      	nop
 80a3e86:	bf00      	nop
 80a3e88:	bf00      	nop
 80a3e8a:	bf00      	nop
 80a3e8c:	bf00      	nop
 80a3e8e:	bf00      	nop
 80a3e90:	bf00      	nop
 80a3e92:	bf00      	nop
 80a3e94:	bf00      	nop
 80a3e96:	bf00      	nop
 80a3e98:	bf00      	nop
 80a3e9a:	bf00      	nop
 80a3e9c:	bf00      	nop
 80a3e9e:	bf00      	nop
 80a3ea0:	bf00      	nop
 80a3ea2:	bf00      	nop
 80a3ea4:	bf00      	nop
 80a3ea6:	bf00      	nop
 80a3ea8:	bf00      	nop
 80a3eaa:	bf00      	nop
 80a3eac:	bf00      	nop
 80a3eae:	bf00      	nop
 80a3eb0:	bf00      	nop
 80a3eb2:	bf00      	nop
 80a3eb4:	bf00      	nop
 80a3eb6:	bf00      	nop
 80a3eb8:	bf00      	nop
 80a3eba:	bf00      	nop
 80a3ebc:	bf00      	nop
 80a3ebe:	bf00      	nop
 80a3ec0:	bf00      	nop
 80a3ec2:	bf00      	nop
 80a3ec4:	bf00      	nop
 80a3ec6:	bf00      	nop
 80a3ec8:	bf00      	nop
 80a3eca:	bf00      	nop
 80a3ecc:	bf00      	nop
 80a3ece:	bf00      	nop
 80a3ed0:	bf00      	nop
 80a3ed2:	bf00      	nop
 80a3ed4:	bf00      	nop
 80a3ed6:	bf00      	nop
 80a3ed8:	bf00      	nop
 80a3eda:	bf00      	nop
 80a3edc:	bf00      	nop
 80a3ede:	bf00      	nop
 80a3ee0:	bf00      	nop
 80a3ee2:	bf00      	nop
 80a3ee4:	bf00      	nop
 80a3ee6:	bf00      	nop
 80a3ee8:	bf00      	nop
 80a3eea:	bf00      	nop
 80a3eec:	bf00      	nop
 80a3eee:	bf00      	nop
 80a3ef0:	bf00      	nop
 80a3ef2:	bf00      	nop
 80a3ef4:	bf00      	nop
 80a3ef6:	bf00      	nop
 80a3ef8:	bf00      	nop
 80a3efa:	bf00      	nop
 80a3efc:	bf00      	nop
 80a3efe:	bf00      	nop
 80a3f00:	bf00      	nop
 80a3f02:	bf00      	nop
 80a3f04:	bf00      	nop
 80a3f06:	bf00      	nop
 80a3f08:	bf00      	nop
 80a3f0a:	bf00      	nop
 80a3f0c:	bf00      	nop
 80a3f0e:	bf00      	nop
 80a3f10:	bf00      	nop
 80a3f12:	bf00      	nop
 80a3f14:	bf00      	nop
 80a3f16:	bf00      	nop
 80a3f18:	bf00      	nop
 80a3f1a:	bf00      	nop
 80a3f1c:	bf00      	nop
 80a3f1e:	bf00      	nop
 80a3f20:	bf00      	nop
 80a3f22:	bf00      	nop
 80a3f24:	bf00      	nop
 80a3f26:	bf00      	nop
 80a3f28:	bf00      	nop
 80a3f2a:	bf00      	nop
 80a3f2c:	bf00      	nop
 80a3f2e:	bf00      	nop
 80a3f30:	bf00      	nop
 80a3f32:	bf00      	nop
 80a3f34:	bf00      	nop
 80a3f36:	bf00      	nop
 80a3f38:	bf00      	nop
 80a3f3a:	bf00      	nop
 80a3f3c:	bf00      	nop
 80a3f3e:	bf00      	nop
 80a3f40:	bf00      	nop
 80a3f42:	bf00      	nop
 80a3f44:	bf00      	nop
 80a3f46:	bf00      	nop
 80a3f48:	bf00      	nop
 80a3f4a:	bf00      	nop
 80a3f4c:	bf00      	nop
 80a3f4e:	bf00      	nop
 80a3f50:	bf00      	nop
 80a3f52:	bf00      	nop
 80a3f54:	bf00      	nop
 80a3f56:	e710      	b.n	80a3d7a <_ZN17Adafruit_NeoPixel4showEv+0xf92>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
      mask = 0x800000; // reset the mask
      i = i-3;      // decrement bytes remaining
      r = *ptr++;   // Next red byte value
      g = *ptr++;   // Next blue byte value
      b = *ptr++;   // Next green byte value
 80a3f58:	468e      	mov	lr, r1
 80a3f5a:	e60d      	b.n	80a3b78 <_ZN17Adafruit_NeoPixel4showEv+0xd90>

080a3f5c <_ZN17Adafruit_NeoPixel13setPixelColorEthhh>:
  endTime = micros(); // Save EOD time for latch on next call
}

// Set pixel color from separate R,G,B components:
void Adafruit_NeoPixel::setPixelColor(
  uint16_t n, uint8_t r, uint8_t g, uint8_t b) {
 80a3f5c:	b5f0      	push	{r4, r5, r6, r7, lr}
  if(n < numLEDs) {
 80a3f5e:	8844      	ldrh	r4, [r0, #2]
  endTime = micros(); // Save EOD time for latch on next call
}

// Set pixel color from separate R,G,B components:
void Adafruit_NeoPixel::setPixelColor(
  uint16_t n, uint8_t r, uint8_t g, uint8_t b) {
 80a3f60:	f89d 5014 	ldrb.w	r5, [sp, #20]
  if(n < numLEDs) {
 80a3f64:	428c      	cmp	r4, r1
 80a3f66:	d927      	bls.n	80a3fb8 <_ZN17Adafruit_NeoPixel13setPixelColorEthhh+0x5c>
    if(brightness) { // See notes in setBrightness()
 80a3f68:	7a04      	ldrb	r4, [r0, #8]
 80a3f6a:	b144      	cbz	r4, 80a3f7e <_ZN17Adafruit_NeoPixel13setPixelColorEthhh+0x22>
      r = (r * brightness) >> 8;
 80a3f6c:	4362      	muls	r2, r4
      g = (g * brightness) >> 8;
 80a3f6e:	4363      	muls	r3, r4
      b = (b * brightness) >> 8;
 80a3f70:	436c      	muls	r4, r5
// Set pixel color from separate R,G,B components:
void Adafruit_NeoPixel::setPixelColor(
  uint16_t n, uint8_t r, uint8_t g, uint8_t b) {
  if(n < numLEDs) {
    if(brightness) { // See notes in setBrightness()
      r = (r * brightness) >> 8;
 80a3f72:	f3c2 2207 	ubfx	r2, r2, #8, #8
      g = (g * brightness) >> 8;
 80a3f76:	f3c3 2307 	ubfx	r3, r3, #8, #8
      b = (b * brightness) >> 8;
 80a3f7a:	f3c4 2507 	ubfx	r5, r4, #8, #8
    }
    uint8_t *p = &pixels[n * 3];
    switch(type) {
 80a3f7e:	7987      	ldrb	r7, [r0, #6]
    if(brightness) { // See notes in setBrightness()
      r = (r * brightness) >> 8;
      g = (g * brightness) >> 8;
      b = (b * brightness) >> 8;
    }
    uint8_t *p = &pixels[n * 3];
 80a3f80:	68c6      	ldr	r6, [r0, #12]
 80a3f82:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 80a3f86:	2f08      	cmp	r7, #8
 80a3f88:	eb06 0401 	add.w	r4, r6, r1
 80a3f8c:	d811      	bhi.n	80a3fb2 <_ZN17Adafruit_NeoPixel13setPixelColorEthhh+0x56>
 80a3f8e:	2001      	movs	r0, #1
 80a3f90:	40b8      	lsls	r0, r7
 80a3f92:	f410 7fd2 	tst.w	r0, #420	; 0x1a4
 80a3f96:	d108      	bne.n	80a3faa <_ZN17Adafruit_NeoPixel13setPixelColorEthhh+0x4e>
 80a3f98:	06c0      	lsls	r0, r0, #27
 80a3f9a:	d50a      	bpl.n	80a3fb2 <_ZN17Adafruit_NeoPixel13setPixelColorEthhh+0x56>
          *p++ = g;
          *p++ = r;
          *p = b;
        } break;
      case TM1829: { // TM1829 is special RBG order
          if(r == 255) r = 254; // 255 on RED channel causes display to be in a special mode.
 80a3f9c:	2aff      	cmp	r2, #255	; 0xff
 80a3f9e:	bf08      	it	eq
 80a3fa0:	22fe      	moveq	r2, #254	; 0xfe
          *p++ = r;
 80a3fa2:	5472      	strb	r2, [r6, r1]
          *p++ = b;
 80a3fa4:	7065      	strb	r5, [r4, #1]
          *p = g;
 80a3fa6:	70a3      	strb	r3, [r4, #2]
 80a3fa8:	bdf0      	pop	{r4, r5, r6, r7, pc}
    switch(type) {
      case WS2812B: // WS2812, WS2812B & WS2813 is GRB order.
      case WS2812B_FAST:
      case WS2812B2:
      case WS2812B2_FAST: {
          *p++ = g;
 80a3faa:	5473      	strb	r3, [r6, r1]
          *p++ = r;
 80a3fac:	7062      	strb	r2, [r4, #1]
          *p = b;
 80a3fae:	70a5      	strb	r5, [r4, #2]
 80a3fb0:	bdf0      	pop	{r4, r5, r6, r7, pc}
          *p = g;
        } break;
      case WS2811: // WS2811 is RGB order
      case TM1803: // TM1803 is RGB order
      default: {   // default is RGB order
          *p++ = r;
 80a3fb2:	5472      	strb	r2, [r6, r1]
          *p++ = g;
 80a3fb4:	7063      	strb	r3, [r4, #1]
          *p = b;
 80a3fb6:	70a5      	strb	r5, [r4, #2]
 80a3fb8:	bdf0      	pop	{r4, r5, r6, r7, pc}

080a3fba <_ZN17Adafruit_NeoPixel13setBrightnessEh>:
  // This simplifies the actual scaling math later, allowing a fast
  // 8x8-bit multiply and taking the MSB.  'brightness' is a uint8_t,
  // adding 1 here may (intentionally) roll over...so 0 = max brightness
  // (color values are interpreted literally; no scaling), 1 = min
  // brightness (off), 255 = just below max brightness.
  uint8_t newBrightness = b + 1;
 80a3fba:	1c4a      	adds	r2, r1, #1
  if(newBrightness != brightness) { // Compare against prior value
 80a3fbc:	7a03      	ldrb	r3, [r0, #8]
  // This simplifies the actual scaling math later, allowing a fast
  // 8x8-bit multiply and taking the MSB.  'brightness' is a uint8_t,
  // adding 1 here may (intentionally) roll over...so 0 = max brightness
  // (color values are interpreted literally; no scaling), 1 = min
  // brightness (off), 255 = just below max brightness.
  uint8_t newBrightness = b + 1;
 80a3fbe:	b2d2      	uxtb	r2, r2
  if(newBrightness != brightness) { // Compare against prior value
 80a3fc0:	429a      	cmp	r2, r3
// and scale it (subsequent graphics commands also work at this
// brightness level).  If there's a significant step up in brightness,
// the limited number of steps (quantization) in the old data will be
// quite visible in the re-scaled version.  For a non-destructive
// change, you'll need to re-render the full strip data.  C'est la vie.
void Adafruit_NeoPixel::setBrightness(uint8_t b) {
 80a3fc2:	b570      	push	{r4, r5, r6, lr}
  // 8x8-bit multiply and taking the MSB.  'brightness' is a uint8_t,
  // adding 1 here may (intentionally) roll over...so 0 = max brightness
  // (color values are interpreted literally; no scaling), 1 = min
  // brightness (off), 255 = just below max brightness.
  uint8_t newBrightness = b + 1;
  if(newBrightness != brightness) { // Compare against prior value
 80a3fc4:	d01e      	beq.n	80a4004 <_ZN17Adafruit_NeoPixel13setBrightnessEh+0x4a>
    // Brightness has changed -- re-scale existing data in RAM
    uint8_t  c,
            *ptr           = pixels,
             oldBrightness = brightness - 1; // De-wrap old brightness value
 80a3fc6:	3b01      	subs	r3, #1
    uint16_t scale;
    if(oldBrightness == 0) scale = 0; // Avoid /0
 80a3fc8:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
  // brightness (off), 255 = just below max brightness.
  uint8_t newBrightness = b + 1;
  if(newBrightness != brightness) { // Compare against prior value
    // Brightness has changed -- re-scale existing data in RAM
    uint8_t  c,
            *ptr           = pixels,
 80a3fcc:	68c4      	ldr	r4, [r0, #12]
             oldBrightness = brightness - 1; // De-wrap old brightness value
    uint16_t scale;
    if(oldBrightness == 0) scale = 0; // Avoid /0
 80a3fce:	d00c      	beq.n	80a3fea <_ZN17Adafruit_NeoPixel13setBrightnessEh+0x30>
    else if(b == 255) scale = 65535 / oldBrightness;
 80a3fd0:	29ff      	cmp	r1, #255	; 0xff
 80a3fd2:	bf0f      	iteee	eq
 80a3fd4:	f64f 71ff 	movweq	r1, #65535	; 0xffff
    else scale = (((uint16_t)newBrightness << 8) - 1) / oldBrightness;
 80a3fd8:	0211      	lslne	r1, r2, #8
 80a3fda:	f101 31ff 	addne.w	r1, r1, #4294967295
 80a3fde:	fb91 f3f3 	sdivne	r3, r1, r3
    uint8_t  c,
            *ptr           = pixels,
             oldBrightness = brightness - 1; // De-wrap old brightness value
    uint16_t scale;
    if(oldBrightness == 0) scale = 0; // Avoid /0
    else if(b == 255) scale = 65535 / oldBrightness;
 80a3fe2:	bf0c      	ite	eq
 80a3fe4:	fb91 f3f3 	sdiveq	r3, r1, r3
    else scale = (((uint16_t)newBrightness << 8) - 1) / oldBrightness;
 80a3fe8:	b29b      	uxthne	r3, r3
  // brightness (off), 255 = just below max brightness.
  uint8_t newBrightness = b + 1;
  if(newBrightness != brightness) { // Compare against prior value
    // Brightness has changed -- re-scale existing data in RAM
    uint8_t  c,
            *ptr           = pixels,
 80a3fea:	4625      	mov	r5, r4
             oldBrightness = brightness - 1; // De-wrap old brightness value
    uint16_t scale;
    if(oldBrightness == 0) scale = 0; // Avoid /0
    else if(b == 255) scale = 65535 / oldBrightness;
    else scale = (((uint16_t)newBrightness << 8) - 1) / oldBrightness;
    for(uint16_t i=0; i<numBytes; i++) {
 80a3fec:	1b29      	subs	r1, r5, r4
 80a3fee:	8886      	ldrh	r6, [r0, #4]
 80a3ff0:	b289      	uxth	r1, r1
 80a3ff2:	428e      	cmp	r6, r1
 80a3ff4:	d905      	bls.n	80a4002 <_ZN17Adafruit_NeoPixel13setBrightnessEh+0x48>
      c      = *ptr;
 80a3ff6:	7829      	ldrb	r1, [r5, #0]
      *ptr++ = (c * scale) >> 8;
 80a3ff8:	4359      	muls	r1, r3
 80a3ffa:	1209      	asrs	r1, r1, #8
 80a3ffc:	f805 1b01 	strb.w	r1, [r5], #1
             oldBrightness = brightness - 1; // De-wrap old brightness value
    uint16_t scale;
    if(oldBrightness == 0) scale = 0; // Avoid /0
    else if(b == 255) scale = 65535 / oldBrightness;
    else scale = (((uint16_t)newBrightness << 8) - 1) / oldBrightness;
    for(uint16_t i=0; i<numBytes; i++) {
 80a4000:	e7f4      	b.n	80a3fec <_ZN17Adafruit_NeoPixel13setBrightnessEh+0x32>
      c      = *ptr;
      *ptr++ = (c * scale) >> 8;
    }
    brightness = newBrightness;
 80a4002:	7202      	strb	r2, [r0, #8]
 80a4004:	bd70      	pop	{r4, r5, r6, pc}
	...

080a4008 <_GLOBAL__sub_I_PIN_MAP2>:
  return brightness - 1;
}

void Adafruit_NeoPixel::clear(void) {
  memset(pixels, 0, numBytes);
}
 80a4008:	b508      	push	{r3, lr}
 80a400a:	f000 ff9d 	bl	80a4f48 <HAL_Pin_Map>

#if PLATFORM_ID == 0 // Core (0)
  #define pinLO(_pin) (PIN_MAP[_pin].gpio_peripheral->BRR = PIN_MAP[_pin].gpio_pin)
  #define pinHI(_pin) (PIN_MAP[_pin].gpio_peripheral->BSRR = PIN_MAP[_pin].gpio_pin)
#elif (PLATFORM_ID == 6) || (PLATFORM_ID == 8) || (PLATFORM_ID == 10) || (PLATFORM_ID == 88) // Photon (6), P1 (8), Electron (10) or Redbear Duo (88)
  STM32_Pin_Info* PIN_MAP2 = HAL_Pin_Map(); // Pointer required for highest access speed
 80a400e:	f000 ff9b 	bl	80a4f48 <HAL_Pin_Map>
 80a4012:	4b01      	ldr	r3, [pc, #4]	; (80a4018 <_GLOBAL__sub_I_PIN_MAP2+0x10>)
 80a4014:	6018      	str	r0, [r3, #0]
 80a4016:	bd08      	pop	{r3, pc}
 80a4018:	20001054 	.word	0x20001054

080a401c <_ZN12Adafruit_GFX8drawLineEsssst>:
}

// Bresenham's algorithm - thx wikpedia
void Adafruit_GFX::drawLine(int16_t x0, int16_t y0,
			    int16_t x1, int16_t y1,
			    uint16_t color) {
 80a401c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a4020:	461e      	mov	r6, r3
 80a4022:	b085      	sub	sp, #20
 80a4024:	f9bd 3038 	ldrsh.w	r3, [sp, #56]	; 0x38
 80a4028:	4615      	mov	r5, r2
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
 80a402a:	1a9a      	subs	r2, r3, r2
 80a402c:	2a00      	cmp	r2, #0
 80a402e:	bfb8      	it	lt
 80a4030:	4252      	neglt	r2, r2
 80a4032:	9200      	str	r2, [sp, #0]
 80a4034:	1a72      	subs	r2, r6, r1
 80a4036:	2a00      	cmp	r2, #0
 80a4038:	bfb8      	it	lt
 80a403a:	4252      	neglt	r2, r2
 80a403c:	9201      	str	r2, [sp, #4]
}

// Bresenham's algorithm - thx wikpedia
void Adafruit_GFX::drawLine(int16_t x0, int16_t y0,
			    int16_t x1, int16_t y1,
			    uint16_t color) {
 80a403e:	460c      	mov	r4, r1
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
 80a4040:	9a00      	ldr	r2, [sp, #0]
 80a4042:	9901      	ldr	r1, [sp, #4]
}

// Bresenham's algorithm - thx wikpedia
void Adafruit_GFX::drawLine(int16_t x0, int16_t y0,
			    int16_t x1, int16_t y1,
			    uint16_t color) {
 80a4044:	4681      	mov	r9, r0
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
 80a4046:	428a      	cmp	r2, r1
}

// Bresenham's algorithm - thx wikpedia
void Adafruit_GFX::drawLine(int16_t x0, int16_t y0,
			    int16_t x1, int16_t y1,
			    uint16_t color) {
 80a4048:	f8bd a03c 	ldrh.w	sl, [sp, #60]	; 0x3c
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
 80a404c:	dd05      	ble.n	80a405a <_ZN12Adafruit_GFX8drawLineEsssst+0x3e>
 80a404e:	4632      	mov	r2, r6
    swap(x0, y0);
    swap(x1, y1);
 80a4050:	461e      	mov	r6, r3
 80a4052:	4613      	mov	r3, r2
// Bresenham's algorithm - thx wikpedia
void Adafruit_GFX::drawLine(int16_t x0, int16_t y0,
			    int16_t x1, int16_t y1,
			    uint16_t color) {
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
  if (steep) {
 80a4054:	4622      	mov	r2, r4
    swap(x0, y0);
 80a4056:	462c      	mov	r4, r5
 80a4058:	4615      	mov	r5, r2
    swap(x1, y1);
  }

  if (x0 > x1) {
 80a405a:	42b4      	cmp	r4, r6
 80a405c:	dd05      	ble.n	80a406a <_ZN12Adafruit_GFX8drawLineEsssst+0x4e>
 80a405e:	462a      	mov	r2, r5
    swap(x0, x1);
    swap(y0, y1);
 80a4060:	461d      	mov	r5, r3
 80a4062:	4613      	mov	r3, r2
  if (steep) {
    swap(x0, y0);
    swap(x1, y1);
  }

  if (x0 > x1) {
 80a4064:	4622      	mov	r2, r4
 80a4066:	4634      	mov	r4, r6
 80a4068:	4616      	mov	r6, r2
    swap(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
  dy = abs(y1 - y0);
 80a406a:	1b5a      	subs	r2, r3, r5
 80a406c:	2a00      	cmp	r2, #0
    swap(x0, x1);
    swap(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
 80a406e:	ebc4 0806 	rsb	r8, r4, r6
  dy = abs(y1 - y0);
 80a4072:	bfb8      	it	lt
 80a4074:	4252      	neglt	r2, r2
    swap(x0, x1);
    swap(y0, y1);
  }

  int16_t dx, dy;
  dx = x1 - x0;
 80a4076:	fa1f f888 	uxth.w	r8, r8
  dy = abs(y1 - y0);
 80a407a:	9203      	str	r2, [sp, #12]

  int16_t err = dx / 2;
 80a407c:	fa0f f788 	sxth.w	r7, r8
 80a4080:	2202      	movs	r2, #2
  int16_t ystep;

  if (y0 < y1) {
    ystep = 1;
  } else {
    ystep = -1;
 80a4082:	429d      	cmp	r5, r3
 80a4084:	bfb4      	ite	lt
 80a4086:	2301      	movlt	r3, #1
 80a4088:	f04f 33ff 	movge.w	r3, #4294967295

  int16_t dx, dy;
  dx = x1 - x0;
  dy = abs(y1 - y0);

  int16_t err = dx / 2;
 80a408c:	fb97 f7f2 	sdiv	r7, r7, r2
  int16_t ystep;

  if (y0 < y1) {
    ystep = 1;
  } else {
    ystep = -1;
 80a4090:	9302      	str	r3, [sp, #8]
  }

  for (; x0<=x1; x0++) {
 80a4092:	42b4      	cmp	r4, r6
 80a4094:	dc1f      	bgt.n	80a40d6 <_ZN12Adafruit_GFX8drawLineEsssst+0xba>
    if (steep) {
 80a4096:	9a01      	ldr	r2, [sp, #4]
 80a4098:	9b00      	ldr	r3, [sp, #0]
      drawPixel(y0, x0, color);
    } else {
      drawPixel(x0, y0, color);
 80a409a:	4648      	mov	r0, r9
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
    if (steep) {
 80a409c:	4293      	cmp	r3, r2
 80a409e:	f8d9 3000 	ldr.w	r3, [r9]
      drawPixel(y0, x0, color);
 80a40a2:	bfc8      	it	gt
 80a40a4:	4622      	movgt	r2, r4
 80a40a6:	f8d3 b010 	ldr.w	fp, [r3, #16]
 80a40aa:	bfc8      	it	gt
 80a40ac:	4629      	movgt	r1, r5
 80a40ae:	4653      	mov	r3, sl
    } else {
      drawPixel(x0, y0, color);
 80a40b0:	bfdc      	itt	le
 80a40b2:	462a      	movle	r2, r5
 80a40b4:	4621      	movle	r1, r4
 80a40b6:	47d8      	blx	fp
    }
    err -= dy;
 80a40b8:	9b03      	ldr	r3, [sp, #12]
 80a40ba:	1aff      	subs	r7, r7, r3
 80a40bc:	b2bb      	uxth	r3, r7
 80a40be:	b21f      	sxth	r7, r3
    if (err < 0) {
 80a40c0:	2f00      	cmp	r7, #0
 80a40c2:	da05      	bge.n	80a40d0 <_ZN12Adafruit_GFX8drawLineEsssst+0xb4>
      y0 += ystep;
 80a40c4:	9a02      	ldr	r2, [sp, #8]
      err += dx;
 80a40c6:	eb08 0703 	add.w	r7, r8, r3
    } else {
      drawPixel(x0, y0, color);
    }
    err -= dy;
    if (err < 0) {
      y0 += ystep;
 80a40ca:	4415      	add	r5, r2
 80a40cc:	b22d      	sxth	r5, r5
      err += dx;
 80a40ce:	b23f      	sxth	r7, r7
 80a40d0:	3401      	adds	r4, #1
 80a40d2:	b224      	sxth	r4, r4
    ystep = 1;
  } else {
    ystep = -1;
  }

  for (; x0<=x1; x0++) {
 80a40d4:	e7dd      	b.n	80a4092 <_ZN12Adafruit_GFX8drawLineEsssst+0x76>
    if (err < 0) {
      y0 += ystep;
      err += dx;
    }
  }
}
 80a40d6:	b005      	add	sp, #20
 80a40d8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080a40dc <_ZN12Adafruit_GFX8drawRectEsssst>:

// Draw a rectangle
void Adafruit_GFX::drawRect(int16_t x, int16_t y,
			    int16_t w, int16_t h,
			    uint16_t color) {
 80a40dc:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 80a40e0:	4604      	mov	r4, r0
 80a40e2:	4691      	mov	r9, r2
 80a40e4:	460d      	mov	r5, r1
 80a40e6:	4698      	mov	r8, r3
 80a40e8:	f8bd 602c 	ldrh.w	r6, [sp, #44]	; 0x2c
  drawFastHLine(x, y, w, color);
 80a40ec:	6807      	ldr	r7, [r0, #0]
}

// Draw a rectangle
void Adafruit_GFX::drawRect(int16_t x, int16_t y,
			    int16_t w, int16_t h,
			    uint16_t color) {
 80a40ee:	f9bd a028 	ldrsh.w	sl, [sp, #40]	; 0x28
  drawFastHLine(x, y, w, color);
 80a40f2:	9600      	str	r6, [sp, #0]
 80a40f4:	69ff      	ldr	r7, [r7, #28]
 80a40f6:	47b8      	blx	r7
  drawFastHLine(x, y+h-1, w, color);
 80a40f8:	6823      	ldr	r3, [r4, #0]
 80a40fa:	f10a 32ff 	add.w	r2, sl, #4294967295
 80a40fe:	9600      	str	r6, [sp, #0]
 80a4100:	444a      	add	r2, r9
 80a4102:	69df      	ldr	r7, [r3, #28]
 80a4104:	4629      	mov	r1, r5
 80a4106:	4643      	mov	r3, r8
 80a4108:	4620      	mov	r0, r4
 80a410a:	b212      	sxth	r2, r2
 80a410c:	47b8      	blx	r7
  drawFastVLine(x, y, h, color);
 80a410e:	6823      	ldr	r3, [r4, #0]
 80a4110:	9600      	str	r6, [sp, #0]
 80a4112:	699f      	ldr	r7, [r3, #24]
 80a4114:	464a      	mov	r2, r9
 80a4116:	4653      	mov	r3, sl
 80a4118:	4629      	mov	r1, r5
 80a411a:	4620      	mov	r0, r4
 80a411c:	47b8      	blx	r7
  drawFastVLine(x+w-1, y, h, color);
 80a411e:	6823      	ldr	r3, [r4, #0]
 80a4120:	f108 31ff 	add.w	r1, r8, #4294967295
 80a4124:	960a      	str	r6, [sp, #40]	; 0x28
 80a4126:	4429      	add	r1, r5
 80a4128:	699d      	ldr	r5, [r3, #24]
 80a412a:	464a      	mov	r2, r9
 80a412c:	4653      	mov	r3, sl
 80a412e:	4620      	mov	r0, r4
 80a4130:	46ac      	mov	ip, r5
 80a4132:	b209      	sxth	r1, r1
}
 80a4134:	b002      	add	sp, #8
 80a4136:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
			    int16_t w, int16_t h,
			    uint16_t color) {
  drawFastHLine(x, y, w, color);
  drawFastHLine(x, y+h-1, w, color);
  drawFastVLine(x, y, h, color);
  drawFastVLine(x+w-1, y, h, color);
 80a413a:	4760      	bx	ip

080a413c <_ZN12Adafruit_GFX13drawFastVLineEssst>:
}

void Adafruit_GFX::drawFastVLine(int16_t x, int16_t y,
				 int16_t h, uint16_t color) {
 80a413c:	b537      	push	{r0, r1, r2, r4, r5, lr}
  // Update in subclasses if desired!
  drawLine(x, y, x, y+h-1, color);
 80a413e:	3b01      	subs	r3, #1
 80a4140:	f8bd 5018 	ldrh.w	r5, [sp, #24]
 80a4144:	4413      	add	r3, r2
 80a4146:	6804      	ldr	r4, [r0, #0]
 80a4148:	b21b      	sxth	r3, r3
 80a414a:	9300      	str	r3, [sp, #0]
 80a414c:	9501      	str	r5, [sp, #4]
 80a414e:	6964      	ldr	r4, [r4, #20]
 80a4150:	460b      	mov	r3, r1
 80a4152:	47a0      	blx	r4
}
 80a4154:	b003      	add	sp, #12
 80a4156:	bd30      	pop	{r4, r5, pc}

080a4158 <_ZN12Adafruit_GFX13drawFastHLineEssst>:

void Adafruit_GFX::drawFastHLine(int16_t x, int16_t y,
				 int16_t w, uint16_t color) {
 80a4158:	b537      	push	{r0, r1, r2, r4, r5, lr}
  // Update in subclasses if desired!
  drawLine(x, y, x+w-1, y, color);
 80a415a:	f8bd 5018 	ldrh.w	r5, [sp, #24]
 80a415e:	6804      	ldr	r4, [r0, #0]
 80a4160:	e88d 0024 	stmia.w	sp, {r2, r5}
 80a4164:	3b01      	subs	r3, #1
 80a4166:	440b      	add	r3, r1
 80a4168:	6964      	ldr	r4, [r4, #20]
 80a416a:	b21b      	sxth	r3, r3
 80a416c:	47a0      	blx	r4
}
 80a416e:	b003      	add	sp, #12
 80a4170:	bd30      	pop	{r4, r5, pc}

080a4172 <_ZN12Adafruit_GFX8fillRectEsssst>:

void Adafruit_GFX::fillRect(int16_t x, int16_t y, int16_t w, int16_t h,
			    uint16_t color) {
 80a4172:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 80a4176:	4605      	mov	r5, r0
 80a4178:	4617      	mov	r7, r2
  // Update in subclasses if desired!
  for (int16_t i=x; i<x+w; i++) {
 80a417a:	460c      	mov	r4, r1
  // Update in subclasses if desired!
  drawLine(x, y, x+w-1, y, color);
}

void Adafruit_GFX::fillRect(int16_t x, int16_t y, int16_t w, int16_t h,
			    uint16_t color) {
 80a417c:	f9bd 8028 	ldrsh.w	r8, [sp, #40]	; 0x28
 80a4180:	f8bd 902c 	ldrh.w	r9, [sp, #44]	; 0x2c
  // Update in subclasses if desired!
  for (int16_t i=x; i<x+w; i++) {
 80a4184:	eb01 0a03 	add.w	sl, r1, r3
 80a4188:	4554      	cmp	r4, sl
 80a418a:	da0b      	bge.n	80a41a4 <_ZN12Adafruit_GFX8fillRectEsssst+0x32>
    drawFastVLine(i, y, h, color);
 80a418c:	682b      	ldr	r3, [r5, #0]
 80a418e:	f8cd 9000 	str.w	r9, [sp]
 80a4192:	699e      	ldr	r6, [r3, #24]
 80a4194:	4621      	mov	r1, r4
 80a4196:	4643      	mov	r3, r8
 80a4198:	463a      	mov	r2, r7
 80a419a:	4628      	mov	r0, r5
 80a419c:	3401      	adds	r4, #1
 80a419e:	47b0      	blx	r6
 80a41a0:	b224      	sxth	r4, r4
}

void Adafruit_GFX::fillRect(int16_t x, int16_t y, int16_t w, int16_t h,
			    uint16_t color) {
  // Update in subclasses if desired!
  for (int16_t i=x; i<x+w; i++) {
 80a41a2:	e7f1      	b.n	80a4188 <_ZN12Adafruit_GFX8fillRectEsssst+0x16>
    drawFastVLine(i, y, h, color);
  }
}
 80a41a4:	b002      	add	sp, #8
 80a41a6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

080a41aa <_ZN12Adafruit_GFX10fillScreenEt>:

void Adafruit_GFX::fillScreen(uint16_t color) {
 80a41aa:	b513      	push	{r0, r1, r4, lr}
  fillRect(0, 0, _width, _height, color);
 80a41ac:	f9b0 200e 	ldrsh.w	r2, [r0, #14]
 80a41b0:	6804      	ldr	r4, [r0, #0]
 80a41b2:	9101      	str	r1, [sp, #4]
 80a41b4:	9200      	str	r2, [sp, #0]
 80a41b6:	2200      	movs	r2, #0
 80a41b8:	f9b0 300c 	ldrsh.w	r3, [r0, #12]
 80a41bc:	6a64      	ldr	r4, [r4, #36]	; 0x24
 80a41be:	4611      	mov	r1, r2
 80a41c0:	47a0      	blx	r4
}
 80a41c2:	b002      	add	sp, #8
 80a41c4:	bd10      	pop	{r4, pc}

080a41c6 <_ZN12Adafruit_GFX13invertDisplayEb>:
 
int16_t Adafruit_GFX::height(void) {
  return _height;
}

void Adafruit_GFX::invertDisplay(boolean i) {
 80a41c6:	4770      	bx	lr

080a41c8 <_ZN12Adafruit_GFX5writeEh>:
      }
    }
  }
}

size_t Adafruit_GFX::write(uint8_t c) {
 80a41c8:	b5f0      	push	{r4, r5, r6, r7, lr}
  
  if (c == '\n') {
 80a41ca:	290a      	cmp	r1, #10
      }
    }
  }
}

size_t Adafruit_GFX::write(uint8_t c) {
 80a41cc:	b085      	sub	sp, #20
 80a41ce:	4604      	mov	r4, r0
 80a41d0:	460d      	mov	r5, r1
  
  if (c == '\n') {
 80a41d2:	d107      	bne.n	80a41e4 <_ZN12Adafruit_GFX5writeEh+0x1c>
    cursor_y += textsize*fontDesc[0].height;	//all chars are same height so use height of space char
 80a41d4:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80a41d6:	7e02      	ldrb	r2, [r0, #24]
 80a41d8:	7859      	ldrb	r1, [r3, #1]
 80a41da:	8a43      	ldrh	r3, [r0, #18]
 80a41dc:	fb01 3302 	mla	r3, r1, r2, r3
 80a41e0:	8243      	strh	r3, [r0, #18]
 80a41e2:	e049      	b.n	80a4278 <_ZN12Adafruit_GFX5writeEh+0xb0>
    cursor_x  = 0;
  } else if (c == '\r') {
 80a41e4:	290d      	cmp	r1, #13
 80a41e6:	d049      	beq.n	80a427c <_ZN12Adafruit_GFX5writeEh+0xb4>
    // skip em
  } else {
    drawFastChar(cursor_x, cursor_y, c, textcolor, textbgcolor, textsize);
 80a41e8:	7e06      	ldrb	r6, [r0, #24]
 80a41ea:	6803      	ldr	r3, [r0, #0]
 80a41ec:	f9b0 2012 	ldrsh.w	r2, [r0, #18]
 80a41f0:	f9b0 1010 	ldrsh.w	r1, [r0, #16]
 80a41f4:	9602      	str	r6, [sp, #8]
 80a41f6:	8ac6      	ldrh	r6, [r0, #22]
 80a41f8:	9601      	str	r6, [sp, #4]
 80a41fa:	8a86      	ldrh	r6, [r0, #20]
 80a41fc:	9600      	str	r6, [sp, #0]
 80a41fe:	6b1e      	ldr	r6, [r3, #48]	; 0x30
 80a4200:	462b      	mov	r3, r5
 80a4202:	47b0      	blx	r6
	uint16_t w = fontDesc[c-fontStart].width;
 80a4204:	7ee3      	ldrb	r3, [r4, #27]
	uint16_t h = fontDesc[c-fontStart].height;
    if (fontKern > 0 && textcolor != textbgcolor) {
 80a4206:	f994 e01d 	ldrsb.w	lr, [r4, #29]
    cursor_x  = 0;
  } else if (c == '\r') {
    // skip em
  } else {
    drawFastChar(cursor_x, cursor_y, c, textcolor, textbgcolor, textsize);
	uint16_t w = fontDesc[c-fontStart].width;
 80a420a:	1aed      	subs	r5, r5, r3
 80a420c:	6a63      	ldr	r3, [r4, #36]	; 0x24
	uint16_t h = fontDesc[c-fontStart].height;
    if (fontKern > 0 && textcolor != textbgcolor) {
 80a420e:	f1be 0f00 	cmp.w	lr, #0
    cursor_x  = 0;
  } else if (c == '\r') {
    // skip em
  } else {
    drawFastChar(cursor_x, cursor_y, c, textcolor, textbgcolor, textsize);
	uint16_t w = fontDesc[c-fontStart].width;
 80a4212:	eb03 0285 	add.w	r2, r3, r5, lsl #2
 80a4216:	f813 6025 	ldrb.w	r6, [r3, r5, lsl #2]
	uint16_t h = fontDesc[c-fontStart].height;
 80a421a:	7855      	ldrb	r5, [r2, #1]
    if (fontKern > 0 && textcolor != textbgcolor) {
 80a421c:	dd15      	ble.n	80a424a <_ZN12Adafruit_GFX5writeEh+0x82>
 80a421e:	8ae0      	ldrh	r0, [r4, #22]
 80a4220:	8aa3      	ldrh	r3, [r4, #20]
 80a4222:	4283      	cmp	r3, r0
 80a4224:	d011      	beq.n	80a424a <_ZN12Adafruit_GFX5writeEh+0x82>
      fillRect(cursor_x+w*textsize,cursor_y,fontKern*textsize,h*textsize,textbgcolor);
 80a4226:	7e23      	ldrb	r3, [r4, #24]
 80a4228:	9001      	str	r0, [sp, #4]
 80a422a:	8a21      	ldrh	r1, [r4, #16]
 80a422c:	fb03 f005 	mul.w	r0, r3, r5
 80a4230:	fb06 1103 	mla	r1, r6, r3, r1
 80a4234:	b200      	sxth	r0, r0
 80a4236:	6827      	ldr	r7, [r4, #0]
 80a4238:	9000      	str	r0, [sp, #0]
 80a423a:	f9b4 2012 	ldrsh.w	r2, [r4, #18]
 80a423e:	6a7f      	ldr	r7, [r7, #36]	; 0x24
 80a4240:	fb0e f303 	mul.w	r3, lr, r3
 80a4244:	b209      	sxth	r1, r1
 80a4246:	4620      	mov	r0, r4
 80a4248:	47b8      	blx	r7
    }
    cursor_x += textsize*(w+fontKern);
 80a424a:	7e22      	ldrb	r2, [r4, #24]
 80a424c:	f994 301d 	ldrsb.w	r3, [r4, #29]
 80a4250:	8a20      	ldrh	r0, [r4, #16]
 80a4252:	b291      	uxth	r1, r2
 80a4254:	4433      	add	r3, r6
 80a4256:	fb03 0301 	mla	r3, r3, r1, r0
    if (wrap && (cursor_x > (_width - textsize*w))) {
 80a425a:	f894 0028 	ldrb.w	r0, [r4, #40]	; 0x28
	uint16_t w = fontDesc[c-fontStart].width;
	uint16_t h = fontDesc[c-fontStart].height;
    if (fontKern > 0 && textcolor != textbgcolor) {
      fillRect(cursor_x+w*textsize,cursor_y,fontKern*textsize,h*textsize,textbgcolor);
    }
    cursor_x += textsize*(w+fontKern);
 80a425e:	b21b      	sxth	r3, r3
 80a4260:	8223      	strh	r3, [r4, #16]
    if (wrap && (cursor_x > (_width - textsize*w))) {
 80a4262:	b158      	cbz	r0, 80a427c <_ZN12Adafruit_GFX5writeEh+0xb4>
 80a4264:	f9b4 000c 	ldrsh.w	r0, [r4, #12]
 80a4268:	fb06 0212 	mls	r2, r6, r2, r0
 80a426c:	4293      	cmp	r3, r2
 80a426e:	dd05      	ble.n	80a427c <_ZN12Adafruit_GFX5writeEh+0xb4>
      cursor_y += textsize*h;
 80a4270:	8a63      	ldrh	r3, [r4, #18]
 80a4272:	fb01 3505 	mla	r5, r1, r5, r3
 80a4276:	8265      	strh	r5, [r4, #18]
      cursor_x = 0;
 80a4278:	2300      	movs	r3, #0
 80a427a:	8223      	strh	r3, [r4, #16]
    }
  }
  return 1;
}
 80a427c:	2001      	movs	r0, #1
 80a427e:	b005      	add	sp, #20
 80a4280:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

080a4284 <_ZN12Adafruit_GFX7setFontEh>:
	  fontDesc = testDescriptors;
      fontKern = 1;
      break;
#endif
	default:
      font = GLCDFONT;
 80a4284:	2304      	movs	r3, #4
      fontData = glcdfontBitmaps;
	  fontDesc = glcdfontDescriptors;
 80a4286:	4a06      	ldr	r2, [pc, #24]	; (80a42a0 <_ZN12Adafruit_GFX7setFontEh+0x1c>)
	  fontDesc = testDescriptors;
      fontKern = 1;
      break;
#endif
	default:
      font = GLCDFONT;
 80a4288:	7683      	strb	r3, [r0, #26]
      fontData = glcdfontBitmaps;
 80a428a:	4b06      	ldr	r3, [pc, #24]	; (80a42a4 <_ZN12Adafruit_GFX7setFontEh+0x20>)
	  fontDesc = glcdfontDescriptors;
 80a428c:	6242      	str	r2, [r0, #36]	; 0x24
      fontKern = 1;
 80a428e:	2201      	movs	r2, #1
      fontKern = 1;
      break;
#endif
	default:
      font = GLCDFONT;
      fontData = glcdfontBitmaps;
 80a4290:	6203      	str	r3, [r0, #32]
	  fontDesc = glcdfontDescriptors;
      fontKern = 1;
 80a4292:	7742      	strb	r2, [r0, #29]
      break;
  }

  fontStart = pgm_read_byte(fontData+FONT_START);
 80a4294:	781a      	ldrb	r2, [r3, #0]
 80a4296:	76c2      	strb	r2, [r0, #27]
  fontEnd = pgm_read_byte(fontData+FONT_END);
 80a4298:	785b      	ldrb	r3, [r3, #1]
 80a429a:	7703      	strb	r3, [r0, #28]
 80a429c:	4770      	bx	lr
 80a429e:	bf00      	nop
 80a42a0:	080a8dfe 	.word	0x080a8dfe
 80a42a4:	080a8604 	.word	0x080a8604

080a42a8 <_ZN12Adafruit_GFXC1Ess>:




Adafruit_GFX::Adafruit_GFX(int16_t w, int16_t h):
  WIDTH(w), HEIGHT(h)
 80a42a8:	8142      	strh	r2, [r0, #10]
{
  _width    = WIDTH;
  _height   = HEIGHT;
 80a42aa:	81c2      	strh	r2, [r0, #14]
  rotation  = 0;
  cursor_y  = cursor_x    = 0;
  textsize  = 1;
  textcolor = textbgcolor = 0xFFFF;
 80a42ac:	f64f 72ff 	movw	r2, #65535	; 0xffff
#include "fonts.h"




Adafruit_GFX::Adafruit_GFX(int16_t w, int16_t h):
 80a42b0:	b538      	push	{r3, r4, r5, lr}
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
 80a42b2:	2300      	movs	r3, #0
  WIDTH(w), HEIGHT(h)
 80a42b4:	4d08      	ldr	r5, [pc, #32]	; (80a42d8 <_ZN12Adafruit_GFXC1Ess+0x30>)
 80a42b6:	6043      	str	r3, [r0, #4]
{
  _width    = WIDTH;
  _height   = HEIGHT;
  rotation  = 0;
 80a42b8:	7643      	strb	r3, [r0, #25]
  cursor_y  = cursor_x    = 0;
 80a42ba:	8203      	strh	r3, [r0, #16]
 80a42bc:	8243      	strh	r3, [r0, #18]
  textsize  = 1;
 80a42be:	2301      	movs	r3, #1




Adafruit_GFX::Adafruit_GFX(int16_t w, int16_t h):
  WIDTH(w), HEIGHT(h)
 80a42c0:	8101      	strh	r1, [r0, #8]
{
  _width    = WIDTH;
 80a42c2:	8181      	strh	r1, [r0, #12]




Adafruit_GFX::Adafruit_GFX(int16_t w, int16_t h):
  WIDTH(w), HEIGHT(h)
 80a42c4:	6005      	str	r5, [r0, #0]
{
  _width    = WIDTH;
  _height   = HEIGHT;
  rotation  = 0;
  cursor_y  = cursor_x    = 0;
  textsize  = 1;
 80a42c6:	7603      	strb	r3, [r0, #24]
  textcolor = textbgcolor = 0xFFFF;
 80a42c8:	82c2      	strh	r2, [r0, #22]
 80a42ca:	8282      	strh	r2, [r0, #20]
  wrap      = true;
 80a42cc:	f880 3028 	strb.w	r3, [r0, #40]	; 0x28
  // Default to GLCDFONT to be compatible with existing code
  setFont(GLCDFONT);		// May also be set to TIMESNR_8, CENTURY_8, COMICS_8 or TEST (for testing candidate fonts)
 80a42d0:	2104      	movs	r1, #4
 80a42d2:	f7ff ffd7 	bl	80a4284 <_ZN12Adafruit_GFX7setFontEh>
 }
 80a42d6:	bd38      	pop	{r3, r4, r5, pc}
 80a42d8:	080a85d0 	.word	0x080a85d0

080a42dc <_ZN12Adafruit_GFX8drawCharEsshtth>:
  drawChar(x,y,c,color,bg,size);
}

// Draw a character
void Adafruit_GFX::drawChar(int16_t x, int16_t y, unsigned char c,
			    uint16_t color, uint16_t bg, uint8_t size) {
 80a42dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a42e0:	b08b      	sub	sp, #44	; 0x2c
 80a42e2:	4692      	mov	sl, r2
 80a42e4:	f8bd 2050 	ldrh.w	r2, [sp, #80]	; 0x50
 80a42e8:	4604      	mov	r4, r0
 80a42ea:	9204      	str	r2, [sp, #16]
 80a42ec:	f8bd 2054 	ldrh.w	r2, [sp, #84]	; 0x54
 80a42f0:	460d      	mov	r5, r1
 80a42f2:	9205      	str	r2, [sp, #20]

  if (c < fontStart || c > fontEnd) {
 80a42f4:	7ec2      	ldrb	r2, [r0, #27]
  drawChar(x,y,c,color,bg,size);
}

// Draw a character
void Adafruit_GFX::drawChar(int16_t x, int16_t y, unsigned char c,
			    uint16_t color, uint16_t bg, uint8_t size) {
 80a42f6:	f89d 6058 	ldrb.w	r6, [sp, #88]	; 0x58

  if (c < fontStart || c > fontEnd) {
 80a42fa:	429a      	cmp	r2, r3
 80a42fc:	d805      	bhi.n	80a430a <_ZN12Adafruit_GFX8drawCharEsshtth+0x2e>
 80a42fe:	7f01      	ldrb	r1, [r0, #28]
 80a4300:	4299      	cmp	r1, r3
 80a4302:	d302      	bcc.n	80a430a <_ZN12Adafruit_GFX8drawCharEsshtth+0x2e>
    c = 0;
  }
  else {
    c -= fontStart;
 80a4304:	1a9b      	subs	r3, r3, r2
 80a4306:	b2db      	uxtb	r3, r3
 80a4308:	e000      	b.n	80a430c <_ZN12Adafruit_GFX8drawCharEsshtth+0x30>
// Draw a character
void Adafruit_GFX::drawChar(int16_t x, int16_t y, unsigned char c,
			    uint16_t color, uint16_t bg, uint8_t size) {

  if (c < fontStart || c > fontEnd) {
    c = 0;
 80a430a:	2300      	movs	r3, #0
  }
  else {
    c -= fontStart;
  }
 
  if((x >= _width)            || // Clip right
 80a430c:	f9b4 200c 	ldrsh.w	r2, [r4, #12]
 80a4310:	42aa      	cmp	r2, r5
 80a4312:	dd7b      	ble.n	80a440c <_ZN12Adafruit_GFX8drawCharEsshtth+0x130>
 80a4314:	f9b4 200e 	ldrsh.w	r2, [r4, #14]
 80a4318:	4552      	cmp	r2, sl
 80a431a:	dd77      	ble.n	80a440c <_ZN12Adafruit_GFX8drawCharEsshtth+0x130>
     (y >= _height)           || // Clip bottom
     ((x + (fontDesc[c].width * size) - 1) < 0) || // Clip left
 80a431c:	6a61      	ldr	r1, [r4, #36]	; 0x24
 80a431e:	009a      	lsls	r2, r3, #2
  else {
    c -= fontStart;
  }
 
  if((x >= _width)            || // Clip right
     (y >= _height)           || // Clip bottom
 80a4320:	f811 3023 	ldrb.w	r3, [r1, r3, lsl #2]
     ((x + (fontDesc[c].width * size) - 1) < 0) || // Clip left
 80a4324:	9207      	str	r2, [sp, #28]
  else {
    c -= fontStart;
  }
 
  if((x >= _width)            || // Clip right
     (y >= _height)           || // Clip bottom
 80a4326:	fb06 5303 	mla	r3, r6, r3, r5
 80a432a:	2b00      	cmp	r3, #0
     ((x + (fontDesc[c].width * size) - 1) < 0) || // Clip left
 80a432c:	440a      	add	r2, r1
  else {
    c -= fontStart;
  }
 
  if((x >= _width)            || // Clip right
     (y >= _height)           || // Clip bottom
 80a432e:	dd6d      	ble.n	80a440c <_ZN12Adafruit_GFX8drawCharEsshtth+0x130>
     ((x + (fontDesc[c].width * size) - 1) < 0) || // Clip left
 80a4330:	7853      	ldrb	r3, [r2, #1]
 80a4332:	fb06 a303 	mla	r3, r6, r3, sl
 80a4336:	2b00      	cmp	r3, #0
 80a4338:	dd68      	ble.n	80a440c <_ZN12Adafruit_GFX8drawCharEsshtth+0x130>
     ((y + (fontDesc[c].height * size) - 1) < 0))   // Clip top
    return;

	uint8_t bitCount=0;
  	uint16_t fontIndex = fontDesc[c].offset + 2; //((fontDesc + c)->offset) + 2;
 80a433a:	8853      	ldrh	r3, [r2, #2]
        } 
      } else if (bg != color) {
        if (size == 1) // default size
          drawPixel(x+j, y+i, bg);
        else {  // big size
          fillRect(x+j*size, y+i*size, size, size, bg);
 80a433c:	fa0f f886 	sxth.w	r8, r6
     ((x + (fontDesc[c].width * size) - 1) < 0) || // Clip left
     ((y + (fontDesc[c].height * size) - 1) < 0))   // Clip top
    return;

	uint8_t bitCount=0;
  	uint16_t fontIndex = fontDesc[c].offset + 2; //((fontDesc + c)->offset) + 2;
 80a4340:	3302      	adds	r3, #2
 80a4342:	b29b      	uxth	r3, r3
 80a4344:	9302      	str	r3, [sp, #8]
 80a4346:	2300      	movs	r3, #0
 80a4348:	9303      	str	r3, [sp, #12]
      if (line & 0x80) {
        if (size == 1) {// default sizeFast
          drawPixel(x+j, y+i, color);
          }
        else {  // big size
          fillRect(x+(j*size), y+(i*size), size, size, color);
 80a434a:	b2b3      	uxth	r3, r6
 80a434c:	9306      	str	r3, [sp, #24]
    return;

	uint8_t bitCount=0;
  	uint16_t fontIndex = fontDesc[c].offset + 2; //((fontDesc + c)->offset) + 2;
  
  for (int8_t i=0; i<fontDesc[c].height; i++ ) {	// i<fontHeight
 80a434e:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80a4350:	9907      	ldr	r1, [sp, #28]
 80a4352:	f99d 300c 	ldrsb.w	r3, [sp, #12]
 80a4356:	440a      	add	r2, r1
 80a4358:	7852      	ldrb	r2, [r2, #1]
 80a435a:	4293      	cmp	r3, r2
 80a435c:	da56      	bge.n	80a440c <_ZN12Adafruit_GFX8drawCharEsshtth+0x130>
      if (line & 0x80) {
        if (size == 1) {// default sizeFast
          drawPixel(x+j, y+i, color);
          }
        else {  // big size
          fillRect(x+(j*size), y+(i*size), size, size, color);
 80a435e:	9906      	ldr	r1, [sp, #24]
 80a4360:	b29b      	uxth	r3, r3
 80a4362:	fa1f f28a 	uxth.w	r2, sl
 80a4366:	fb03 2101 	mla	r1, r3, r1, r2
        } 
      } else if (bg != color) {
        if (size == 1) // default size
          drawPixel(x+j, y+i, bg);
 80a436a:	4413      	add	r3, r2
      if (line & 0x80) {
        if (size == 1) {// default sizeFast
          drawPixel(x+j, y+i, color);
          }
        else {  // big size
          fillRect(x+(j*size), y+(i*size), size, size, color);
 80a436c:	b209      	sxth	r1, r1
        } 
      } else if (bg != color) {
        if (size == 1) // default size
          drawPixel(x+j, y+i, bg);
 80a436e:	b21b      	sxth	r3, r3
      if (line & 0x80) {
        if (size == 1) {// default sizeFast
          drawPixel(x+j, y+i, color);
          }
        else {  // big size
          fillRect(x+(j*size), y+(i*size), size, size, color);
 80a4370:	9108      	str	r1, [sp, #32]
 80a4372:	f04f 0900 	mov.w	r9, #0
        } 
      } else if (bg != color) {
        if (size == 1) // default size
          drawPixel(x+j, y+i, bg);
 80a4376:	9309      	str	r3, [sp, #36]	; 0x24
	uint8_t bitCount=0;
  	uint16_t fontIndex = fontDesc[c].offset + 2; //((fontDesc + c)->offset) + 2;
  
  for (int8_t i=0; i<fontDesc[c].height; i++ ) {	// i<fontHeight
    uint8_t line;
    for (int8_t j = 0; j<fontDesc[c].width; j++) {			//j<fontWidth
 80a4378:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80a437a:	9807      	ldr	r0, [sp, #28]
 80a437c:	fa4f f189 	sxtb.w	r1, r9
 80a4380:	5c12      	ldrb	r2, [r2, r0]
 80a4382:	fa5f f389 	uxtb.w	r3, r9
 80a4386:	4291      	cmp	r1, r2
 80a4388:	da3c      	bge.n	80a4404 <_ZN12Adafruit_GFX8drawCharEsshtth+0x128>
      if (bitCount++%8 == 0) {
 80a438a:	075a      	lsls	r2, r3, #29
 80a438c:	d106      	bne.n	80a439c <_ZN12Adafruit_GFX8drawCharEsshtth+0xc0>
        line = pgm_read_byte(fontData+fontIndex++);
 80a438e:	9b02      	ldr	r3, [sp, #8]
 80a4390:	9802      	ldr	r0, [sp, #8]
 80a4392:	6a22      	ldr	r2, [r4, #32]
 80a4394:	3301      	adds	r3, #1
 80a4396:	b29b      	uxth	r3, r3
 80a4398:	5c17      	ldrb	r7, [r2, r0]
 80a439a:	9302      	str	r3, [sp, #8]
      }
      if (line & 0x80) {
 80a439c:	063b      	lsls	r3, r7, #24
 80a439e:	d50d      	bpl.n	80a43bc <_ZN12Adafruit_GFX8drawCharEsshtth+0xe0>
        if (size == 1) {// default sizeFast
 80a43a0:	2e01      	cmp	r6, #1
 80a43a2:	d105      	bne.n	80a43b0 <_ZN12Adafruit_GFX8drawCharEsshtth+0xd4>
          drawPixel(x+j, y+i, color);
 80a43a4:	6823      	ldr	r3, [r4, #0]
 80a43a6:	4429      	add	r1, r5
 80a43a8:	f8d3 b010 	ldr.w	fp, [r3, #16]
 80a43ac:	9b04      	ldr	r3, [sp, #16]
 80a43ae:	e010      	b.n	80a43d2 <_ZN12Adafruit_GFX8drawCharEsshtth+0xf6>
          }
        else {  // big size
          fillRect(x+(j*size), y+(i*size), size, size, color);
 80a43b0:	9b06      	ldr	r3, [sp, #24]
 80a43b2:	9a04      	ldr	r2, [sp, #16]
 80a43b4:	fb01 5103 	mla	r1, r1, r3, r5
 80a43b8:	6823      	ldr	r3, [r4, #0]
 80a43ba:	e014      	b.n	80a43e6 <_ZN12Adafruit_GFX8drawCharEsshtth+0x10a>
        } 
      } else if (bg != color) {
 80a43bc:	9b04      	ldr	r3, [sp, #16]
 80a43be:	9a05      	ldr	r2, [sp, #20]
 80a43c0:	4293      	cmp	r3, r2
 80a43c2:	d01a      	beq.n	80a43fa <_ZN12Adafruit_GFX8drawCharEsshtth+0x11e>
        if (size == 1) // default size
 80a43c4:	2e01      	cmp	r6, #1
 80a43c6:	d109      	bne.n	80a43dc <_ZN12Adafruit_GFX8drawCharEsshtth+0x100>
          drawPixel(x+j, y+i, bg);
 80a43c8:	6823      	ldr	r3, [r4, #0]
 80a43ca:	4429      	add	r1, r5
 80a43cc:	f8d3 b010 	ldr.w	fp, [r3, #16]
 80a43d0:	4613      	mov	r3, r2
 80a43d2:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80a43d4:	b209      	sxth	r1, r1
 80a43d6:	4620      	mov	r0, r4
 80a43d8:	47d8      	blx	fp
 80a43da:	e00e      	b.n	80a43fa <_ZN12Adafruit_GFX8drawCharEsshtth+0x11e>
        else {  // big size
          fillRect(x+j*size, y+i*size, size, size, bg);
 80a43dc:	9b06      	ldr	r3, [sp, #24]
 80a43de:	9a05      	ldr	r2, [sp, #20]
 80a43e0:	fb01 5103 	mla	r1, r1, r3, r5
 80a43e4:	6823      	ldr	r3, [r4, #0]
 80a43e6:	9201      	str	r2, [sp, #4]
 80a43e8:	f8cd 8000 	str.w	r8, [sp]
 80a43ec:	f8d3 b024 	ldr.w	fp, [r3, #36]	; 0x24
 80a43f0:	9a08      	ldr	r2, [sp, #32]
 80a43f2:	4643      	mov	r3, r8
 80a43f4:	b209      	sxth	r1, r1
 80a43f6:	4620      	mov	r0, r4
 80a43f8:	47d8      	blx	fp
        }
      }
      line <<= 1;
 80a43fa:	007f      	lsls	r7, r7, #1
 80a43fc:	b2ff      	uxtb	r7, r7
 80a43fe:	f109 0901 	add.w	r9, r9, #1
	uint8_t bitCount=0;
  	uint16_t fontIndex = fontDesc[c].offset + 2; //((fontDesc + c)->offset) + 2;
  
  for (int8_t i=0; i<fontDesc[c].height; i++ ) {	// i<fontHeight
    uint8_t line;
    for (int8_t j = 0; j<fontDesc[c].width; j++) {			//j<fontWidth
 80a4402:	e7b9      	b.n	80a4378 <_ZN12Adafruit_GFX8drawCharEsshtth+0x9c>
 80a4404:	9b03      	ldr	r3, [sp, #12]
 80a4406:	3301      	adds	r3, #1
 80a4408:	9303      	str	r3, [sp, #12]
    return;

	uint8_t bitCount=0;
  	uint16_t fontIndex = fontDesc[c].offset + 2; //((fontDesc + c)->offset) + 2;
  
  for (int8_t i=0; i<fontDesc[c].height; i++ ) {	// i<fontHeight
 80a440a:	e7a0      	b.n	80a434e <_ZN12Adafruit_GFX8drawCharEsshtth+0x72>
      }
      line <<= 1;
    }
    bitCount = 0;
  }
}
 80a440c:	b00b      	add	sp, #44	; 0x2c
 80a440e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080a4412 <_ZN12Adafruit_GFX12drawFastCharEsshtth>:
  }
  return 1;
}

void Adafruit_GFX::drawFastChar(int16_t x, int16_t y, unsigned char c,
                                    uint16_t color, uint16_t bg, uint8_t size) {
 80a4412:	b470      	push	{r4, r5, r6}
 80a4414:	f8bd 400c 	ldrh.w	r4, [sp, #12]
 80a4418:	f8bd 5010 	ldrh.w	r5, [sp, #16]
 80a441c:	f89d 6014 	ldrb.w	r6, [sp, #20]
  // Update in subclasses if desired!
  drawChar(x,y,c,color,bg,size);
 80a4420:	9504      	str	r5, [sp, #16]
 80a4422:	9605      	str	r6, [sp, #20]
 80a4424:	9403      	str	r4, [sp, #12]
}
 80a4426:	bc70      	pop	{r4, r5, r6}
}

void Adafruit_GFX::drawFastChar(int16_t x, int16_t y, unsigned char c,
                                    uint16_t color, uint16_t bg, uint8_t size) {
  // Update in subclasses if desired!
  drawChar(x,y,c,color,bg,size);
 80a4428:	f7ff bf58 	b.w	80a42dc <_ZN12Adafruit_GFX8drawCharEsshtth>

080a442c <_ZN12Adafruit_GFX9setCursorEss>:
    bitCount = 0;
  }
}

void Adafruit_GFX::setCursor(int16_t x, int16_t y) {
  cursor_x = x;
 80a442c:	8201      	strh	r1, [r0, #16]
  cursor_y = y;
 80a442e:	8242      	strh	r2, [r0, #18]
 80a4430:	4770      	bx	lr

080a4432 <_ZN12Adafruit_GFX11setTextSizeEh>:
}

void Adafruit_GFX::setTextSize(uint8_t s) {
  textsize = (s > 0) ? s : 1;
 80a4432:	2900      	cmp	r1, #0
 80a4434:	bf08      	it	eq
 80a4436:	2101      	moveq	r1, #1
 80a4438:	7601      	strb	r1, [r0, #24]
 80a443a:	4770      	bx	lr

080a443c <_GLOBAL__sub_I__ZN12Adafruit_GFXC2Ess>:
 80a443c:	f000 bd84 	b.w	80a4f48 <HAL_Pin_Map>

080a4440 <_GLOBAL__sub_I_glcdfontBitmaps>:
 80a4440:	f000 bd82 	b.w	80a4f48 <HAL_Pin_Map>

080a4444 <_ZN15Adafruit_LIS3DHD1Ev>:
  LIS3DH_INT1_SRC_YL = 0x04,
  LIS3DH_INT1_SRC_XH = 0x02,
  LIS3DH_INT1_SRC_XL = 0x01
} list3dh_ctrl_int2_src_t;

class Adafruit_LIS3DH : public Adafruit_Sensor {
 80a4444:	4770      	bx	lr
	...

080a4448 <_ZN15Adafruit_LIS3DH9getSensorEP8sensor_t>:
/**************************************************************************/
/*!
    @brief  Gets the sensor_t data
*/
/**************************************************************************/
void Adafruit_LIS3DH::getSensor(sensor_t *sensor) {
 80a4448:	b538      	push	{r3, r4, r5, lr}
 80a444a:	460c      	mov	r4, r1
 80a444c:	4605      	mov	r5, r0
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
 80a444e:	2228      	movs	r2, #40	; 0x28
 80a4450:	2100      	movs	r1, #0
 80a4452:	4620      	mov	r0, r4
 80a4454:	f003 fa01 	bl	80a785a <memset>

  /* Insert the sensor name in the fixed length char array */
  strncpy (sensor->name, "LIS3DH", sizeof(sensor->name) - 1);
 80a4458:	220b      	movs	r2, #11
 80a445a:	4908      	ldr	r1, [pc, #32]	; (80a447c <_ZN15Adafruit_LIS3DH9getSensorEP8sensor_t+0x34>)
 80a445c:	4620      	mov	r0, r4
 80a445e:	f003 fac1 	bl	80a79e4 <strncpy>
  sensor->name[sizeof(sensor->name)- 1] = 0;
 80a4462:	2300      	movs	r3, #0
  sensor->version     = 1;
 80a4464:	2201      	movs	r2, #1
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));

  /* Insert the sensor name in the fixed length char array */
  strncpy (sensor->name, "LIS3DH", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name)- 1] = 0;
 80a4466:	72e3      	strb	r3, [r4, #11]
  sensor->version     = 1;
 80a4468:	60e2      	str	r2, [r4, #12]
  sensor->sensor_id   = _sensorID;
 80a446a:	69a9      	ldr	r1, [r5, #24]
  sensor->type        = SENSOR_TYPE_ACCELEROMETER;
  sensor->min_delay   = 0;
 80a446c:	6263      	str	r3, [r4, #36]	; 0x24
  sensor->max_value   = 0;
 80a446e:	2300      	movs	r3, #0

  /* Insert the sensor name in the fixed length char array */
  strncpy (sensor->name, "LIS3DH", sizeof(sensor->name) - 1);
  sensor->name[sizeof(sensor->name)- 1] = 0;
  sensor->version     = 1;
  sensor->sensor_id   = _sensorID;
 80a4470:	6121      	str	r1, [r4, #16]
  sensor->type        = SENSOR_TYPE_ACCELEROMETER;
 80a4472:	6162      	str	r2, [r4, #20]
  sensor->min_delay   = 0;
  sensor->max_value   = 0;
 80a4474:	61a3      	str	r3, [r4, #24]
  sensor->min_value   = 0;
 80a4476:	61e3      	str	r3, [r4, #28]
  sensor->resolution  = 0;
 80a4478:	6223      	str	r3, [r4, #32]
 80a447a:	bd38      	pop	{r3, r4, r5, pc}
 80a447c:	080a91fe 	.word	0x080a91fe

080a4480 <_ZN15Adafruit_LIS3DHD0Ev>:
 80a4480:	b510      	push	{r4, lr}
 80a4482:	4604      	mov	r4, r0
 80a4484:	f7fb fe0d 	bl	80a00a2 <_ZdlPv>
 80a4488:	4620      	mov	r0, r4
 80a448a:	bd10      	pop	{r4, pc}

080a448c <_ZN7TwoWire5writeEi>:
  bool unlock();

  inline size_t write(unsigned long n) { return write((uint8_t)n); }
  inline size_t write(long n) { return write((uint8_t)n); }
  inline size_t write(unsigned int n) { return write((uint8_t)n); }
  inline size_t write(int n) { return write((uint8_t)n); }
 80a448c:	6803      	ldr	r3, [r0, #0]
 80a448e:	b2c9      	uxtb	r1, r1
 80a4490:	689b      	ldr	r3, [r3, #8]
 80a4492:	4718      	bx	r3

080a4494 <_ZN15Adafruit_LIS3DHC1Ev>:
    @brief  Instantiates a new LIS3DH class in I2C or SPI mode
*/
/**************************************************************************/
// I2C
Adafruit_LIS3DH::Adafruit_LIS3DH()
  : _cs(-1), _mosi(-1), _miso(-1), _sck(-1), _sensorID(-1)
 80a4494:	4a06      	ldr	r2, [pc, #24]	; (80a44b0 <_ZN15Adafruit_LIS3DHC1Ev+0x1c>)
 80a4496:	21ff      	movs	r1, #255	; 0xff
 80a4498:	6002      	str	r2, [r0, #0]
 80a449a:	f04f 32ff 	mov.w	r2, #4294967295
 80a449e:	6182      	str	r2, [r0, #24]
 80a44a0:	7742      	strb	r2, [r0, #29]
 80a44a2:	77c2      	strb	r2, [r0, #31]
 80a44a4:	f880 2020 	strb.w	r2, [r0, #32]
 80a44a8:	2211      	movs	r2, #17
 80a44aa:	7781      	strb	r1, [r0, #30]
 80a44ac:	6242      	str	r2, [r0, #36]	; 0x24
{
}
 80a44ae:	4770      	bx	lr
 80a44b0:	080a9210 	.word	0x080a9210

080a44b4 <_ZN15Adafruit_LIS3DH7spixferEh>:
/*!
    @brief  Low level SPI
*/
/**************************************************************************/

uint8_t Adafruit_LIS3DH::spixfer(uint8_t x) {
 80a44b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  #ifndef __AVR_ATtiny85__
  if (_sck == -1)
 80a44b8:	f990 3020 	ldrsb.w	r3, [r0, #32]
/*!
    @brief  Low level SPI
*/
/**************************************************************************/

uint8_t Adafruit_LIS3DH::spixfer(uint8_t x) {
 80a44bc:	4605      	mov	r5, r0
  #ifndef __AVR_ATtiny85__
  if (_sck == -1)
 80a44be:	3301      	adds	r3, #1
/*!
    @brief  Low level SPI
*/
/**************************************************************************/

uint8_t Adafruit_LIS3DH::spixfer(uint8_t x) {
 80a44c0:	460f      	mov	r7, r1
  #ifndef __AVR_ATtiny85__
  if (_sck == -1)
 80a44c2:	d104      	bne.n	80a44ce <_ZN15Adafruit_LIS3DH7spixferEh+0x1a>
    return SPI.transfer(x);
 80a44c4:	4816      	ldr	r0, [pc, #88]	; (80a4520 <_ZN15Adafruit_LIS3DH7spixferEh+0x6c>)
    if (digitalRead(_miso))
      reply |= 1;
  }
  return reply;
  #endif
}
 80a44c6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
/**************************************************************************/

uint8_t Adafruit_LIS3DH::spixfer(uint8_t x) {
  #ifndef __AVR_ATtiny85__
  if (_sck == -1)
    return SPI.transfer(x);
 80a44ca:	f001 b94d 	b.w	80a5768 <_ZN8SPIClass8transferEh>
 80a44ce:	2607      	movs	r6, #7
 80a44d0:	2400      	movs	r4, #0
  //Serial.println("Software SPI");
  uint8_t reply = 0;
  for (int i=7; i>=0; i--) {
    reply <<= 1;
    digitalWrite(_sck, LOW);
    digitalWrite(_mosi, x & (1<<i));
 80a44d2:	f04f 0801 	mov.w	r8, #1
  // software spi
  //Serial.println("Software SPI");
  uint8_t reply = 0;
  for (int i=7; i>=0; i--) {
    reply <<= 1;
    digitalWrite(_sck, LOW);
 80a44d6:	f995 0020 	ldrsb.w	r0, [r5, #32]
 80a44da:	2100      	movs	r1, #0
 80a44dc:	b280      	uxth	r0, r0
 80a44de:	f002 fbda 	bl	80a6c96 <digitalWrite>
    digitalWrite(_mosi, x & (1<<i));
 80a44e2:	f995 001e 	ldrsb.w	r0, [r5, #30]
 80a44e6:	fa08 f106 	lsl.w	r1, r8, r6
 80a44ea:	4039      	ands	r1, r7
 80a44ec:	b280      	uxth	r0, r0
 80a44ee:	f002 fbd2 	bl	80a6c96 <digitalWrite>
    digitalWrite(_sck, HIGH);
 80a44f2:	f995 0020 	ldrsb.w	r0, [r5, #32]
 80a44f6:	2101      	movs	r1, #1
 80a44f8:	b280      	uxth	r0, r0
 80a44fa:	f002 fbcc 	bl	80a6c96 <digitalWrite>
    if (digitalRead(_miso))
 80a44fe:	f995 001f 	ldrsb.w	r0, [r5, #31]

  // software spi
  //Serial.println("Software SPI");
  uint8_t reply = 0;
  for (int i=7; i>=0; i--) {
    reply <<= 1;
 80a4502:	0064      	lsls	r4, r4, #1
    digitalWrite(_sck, LOW);
    digitalWrite(_mosi, x & (1<<i));
    digitalWrite(_sck, HIGH);
    if (digitalRead(_miso))
 80a4504:	b280      	uxth	r0, r0

  // software spi
  //Serial.println("Software SPI");
  uint8_t reply = 0;
  for (int i=7; i>=0; i--) {
    reply <<= 1;
 80a4506:	b2e4      	uxtb	r4, r4
    digitalWrite(_sck, LOW);
    digitalWrite(_mosi, x & (1<<i));
    digitalWrite(_sck, HIGH);
    if (digitalRead(_miso))
 80a4508:	f002 fbde 	bl	80a6cc8 <digitalRead>
 80a450c:	b108      	cbz	r0, 80a4512 <_ZN15Adafruit_LIS3DH7spixferEh+0x5e>
      reply |= 1;
 80a450e:	f044 0401 	orr.w	r4, r4, #1
    return SPI.transfer(x);

  // software spi
  //Serial.println("Software SPI");
  uint8_t reply = 0;
  for (int i=7; i>=0; i--) {
 80a4512:	f116 36ff 	adds.w	r6, r6, #4294967295
 80a4516:	d2de      	bcs.n	80a44d6 <_ZN15Adafruit_LIS3DH7spixferEh+0x22>
    if (digitalRead(_miso))
      reply |= 1;
  }
  return reply;
  #endif
}
 80a4518:	4620      	mov	r0, r4
 80a451a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a451e:	bf00      	nop
 80a4520:	20001524 	.word	0x20001524

080a4524 <_ZN15Adafruit_LIS3DH16beginTransactionEv>:
  #endif
  return value;
}


void Adafruit_LIS3DH::beginTransaction() {
 80a4524:	b510      	push	{r4, lr}
#ifdef PARTICLE
    SPI.setBitOrder(MSBFIRST);
 80a4526:	4c08      	ldr	r4, [pc, #32]	; (80a4548 <_ZN15Adafruit_LIS3DH16beginTransactionEv+0x24>)
 80a4528:	2101      	movs	r1, #1
 80a452a:	4620      	mov	r0, r4
 80a452c:	f001 f849 	bl	80a55c2 <_ZN8SPIClass11setBitOrderEh>
    SPI.setClockSpeed(500000);
 80a4530:	4906      	ldr	r1, [pc, #24]	; (80a454c <_ZN15Adafruit_LIS3DH16beginTransactionEv+0x28>)
 80a4532:	4620      	mov	r0, r4
 80a4534:	2201      	movs	r2, #1
 80a4536:	f001 f8e1 	bl	80a56fc <_ZN8SPIClass13setClockSpeedEjj>
    SPI.setDataMode(SPI_MODE0);
 80a453a:	4620      	mov	r0, r4
#else
  SPI.beginTransaction(SPISettings(500000, MSBFIRST, SPI_MODE0));
#endif
}
 80a453c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

void Adafruit_LIS3DH::beginTransaction() {
#ifdef PARTICLE
    SPI.setBitOrder(MSBFIRST);
    SPI.setClockSpeed(500000);
    SPI.setDataMode(SPI_MODE0);
 80a4540:	2100      	movs	r1, #0
 80a4542:	f001 b841 	b.w	80a55c8 <_ZN8SPIClass11setDataModeEh>
 80a4546:	bf00      	nop
 80a4548:	20001524 	.word	0x20001524
 80a454c:	0007a120 	.word	0x0007a120

080a4550 <_ZN15Adafruit_LIS3DH14writeRegister8Ehh>:
/**************************************************************************/
/*!
    @brief  Writes 8-bits to the specified destination register
*/
/**************************************************************************/
void Adafruit_LIS3DH::writeRegister8(uint8_t reg, uint8_t value) {
 80a4550:	b570      	push	{r4, r5, r6, lr}
  if (_cs == -1) {
 80a4552:	f990 301d 	ldrsb.w	r3, [r0, #29]
/**************************************************************************/
/*!
    @brief  Writes 8-bits to the specified destination register
*/
/**************************************************************************/
void Adafruit_LIS3DH::writeRegister8(uint8_t reg, uint8_t value) {
 80a4556:	4604      	mov	r4, r0
  if (_cs == -1) {
 80a4558:	3301      	adds	r3, #1
/**************************************************************************/
/*!
    @brief  Writes 8-bits to the specified destination register
*/
/**************************************************************************/
void Adafruit_LIS3DH::writeRegister8(uint8_t reg, uint8_t value) {
 80a455a:	460e      	mov	r6, r1
 80a455c:	4615      	mov	r5, r2
  if (_cs == -1) {
 80a455e:	d116      	bne.n	80a458e <_ZN15Adafruit_LIS3DH14writeRegister8Ehh+0x3e>
    Wire.beginTransmission((uint8_t)_i2caddr);
 80a4560:	f002 fc00 	bl	80a6d64 <_Z19__fetch_global_Wirev>
 80a4564:	7f21      	ldrb	r1, [r4, #28]
 80a4566:	f002 fb39 	bl	80a6bdc <_ZN7TwoWire17beginTransmissionEh>
    Wire.write((uint8_t)reg);
 80a456a:	f002 fbfb 	bl	80a6d64 <_Z19__fetch_global_Wirev>
 80a456e:	6803      	ldr	r3, [r0, #0]
 80a4570:	4631      	mov	r1, r6
 80a4572:	689b      	ldr	r3, [r3, #8]
 80a4574:	4798      	blx	r3
    Wire.write((uint8_t)value);
 80a4576:	f002 fbf5 	bl	80a6d64 <_Z19__fetch_global_Wirev>
 80a457a:	6803      	ldr	r3, [r0, #0]
 80a457c:	4629      	mov	r1, r5
 80a457e:	689b      	ldr	r3, [r3, #8]
 80a4580:	4798      	blx	r3
    Wire.endTransmission();
 80a4582:	f002 fbef 	bl	80a6d64 <_Z19__fetch_global_Wirev>
    digitalWrite(_cs, HIGH);
    if (_sck == -1)
    	endTransaction();
  }
  #endif
}
 80a4586:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
void Adafruit_LIS3DH::writeRegister8(uint8_t reg, uint8_t value) {
  if (_cs == -1) {
    Wire.beginTransmission((uint8_t)_i2caddr);
    Wire.write((uint8_t)reg);
    Wire.write((uint8_t)value);
    Wire.endTransmission();
 80a458a:	f002 bb32 	b.w	80a6bf2 <_ZN7TwoWire15endTransmissionEv>
  }
  #ifndef __AVR_ATtiny85__
  else {
	if (_sck == -1)
 80a458e:	f990 3020 	ldrsb.w	r3, [r0, #32]
 80a4592:	3301      	adds	r3, #1
 80a4594:	d101      	bne.n	80a459a <_ZN15Adafruit_LIS3DH14writeRegister8Ehh+0x4a>
	  beginTransaction();
 80a4596:	f7ff ffc5 	bl	80a4524 <_ZN15Adafruit_LIS3DH16beginTransactionEv>

    digitalWrite(_cs, LOW);
 80a459a:	f994 001d 	ldrsb.w	r0, [r4, #29]
 80a459e:	2100      	movs	r1, #0
 80a45a0:	b280      	uxth	r0, r0
 80a45a2:	f002 fb78 	bl	80a6c96 <digitalWrite>
    spixfer(reg & ~0x80); // write, bit 7 low
 80a45a6:	f006 017f 	and.w	r1, r6, #127	; 0x7f
 80a45aa:	4620      	mov	r0, r4
 80a45ac:	f7ff ff82 	bl	80a44b4 <_ZN15Adafruit_LIS3DH7spixferEh>
    spixfer(value);
 80a45b0:	4629      	mov	r1, r5
 80a45b2:	4620      	mov	r0, r4
 80a45b4:	f7ff ff7e 	bl	80a44b4 <_ZN15Adafruit_LIS3DH7spixferEh>
    digitalWrite(_cs, HIGH);
 80a45b8:	f994 001d 	ldrsb.w	r0, [r4, #29]
 80a45bc:	2101      	movs	r1, #1
 80a45be:	b280      	uxth	r0, r0
    if (_sck == -1)
    	endTransaction();
  }
  #endif
}
 80a45c0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	  beginTransaction();

    digitalWrite(_cs, LOW);
    spixfer(reg & ~0x80); // write, bit 7 low
    spixfer(value);
    digitalWrite(_cs, HIGH);
 80a45c4:	f002 bb67 	b.w	80a6c96 <digitalWrite>

080a45c8 <_ZN15Adafruit_LIS3DH13readRegister8Eh>:
/**************************************************************************/
/*!
    @brief  Reads 8-bits from the specified register
*/
/**************************************************************************/
uint8_t Adafruit_LIS3DH::readRegister8(uint8_t reg) {
 80a45c8:	b538      	push	{r3, r4, r5, lr}
  uint8_t value;

  if (_cs == -1) {
 80a45ca:	f990 301d 	ldrsb.w	r3, [r0, #29]
/**************************************************************************/
/*!
    @brief  Reads 8-bits from the specified register
*/
/**************************************************************************/
uint8_t Adafruit_LIS3DH::readRegister8(uint8_t reg) {
 80a45ce:	4604      	mov	r4, r0
  uint8_t value;

  if (_cs == -1) {
 80a45d0:	3301      	adds	r3, #1
/**************************************************************************/
/*!
    @brief  Reads 8-bits from the specified register
*/
/**************************************************************************/
uint8_t Adafruit_LIS3DH::readRegister8(uint8_t reg) {
 80a45d2:	460d      	mov	r5, r1
  uint8_t value;

  if (_cs == -1) {
 80a45d4:	d11d      	bne.n	80a4612 <_ZN15Adafruit_LIS3DH13readRegister8Eh+0x4a>
    Wire.beginTransmission(_i2caddr);
 80a45d6:	f002 fbc5 	bl	80a6d64 <_Z19__fetch_global_Wirev>
 80a45da:	f994 101c 	ldrsb.w	r1, [r4, #28]
 80a45de:	f002 fb01 	bl	80a6be4 <_ZN7TwoWire17beginTransmissionEi>
    Wire.write((uint8_t)reg);
 80a45e2:	f002 fbbf 	bl	80a6d64 <_Z19__fetch_global_Wirev>
 80a45e6:	6803      	ldr	r3, [r0, #0]
 80a45e8:	4629      	mov	r1, r5
 80a45ea:	689b      	ldr	r3, [r3, #8]
 80a45ec:	4798      	blx	r3
    Wire.endTransmission();
 80a45ee:	f002 fbb9 	bl	80a6d64 <_Z19__fetch_global_Wirev>
 80a45f2:	f002 fafe 	bl	80a6bf2 <_ZN7TwoWire15endTransmissionEv>

    Wire.requestFrom(_i2caddr, 1);
 80a45f6:	f002 fbb5 	bl	80a6d64 <_Z19__fetch_global_Wirev>
 80a45fa:	2201      	movs	r2, #1
 80a45fc:	f994 101c 	ldrsb.w	r1, [r4, #28]
 80a4600:	f002 fae7 	bl	80a6bd2 <_ZN7TwoWire11requestFromEii>
    value = Wire.read();
 80a4604:	f002 fbae 	bl	80a6d64 <_Z19__fetch_global_Wirev>
 80a4608:	6803      	ldr	r3, [r0, #0]
 80a460a:	695b      	ldr	r3, [r3, #20]
 80a460c:	4798      	blx	r3
 80a460e:	b2c5      	uxtb	r5, r0
 80a4610:	e01b      	b.n	80a464a <_ZN15Adafruit_LIS3DH13readRegister8Eh+0x82>
  }
  #ifndef __AVR_ATtiny85__
  else {
	if (_sck == -1)
 80a4612:	f990 3020 	ldrsb.w	r3, [r0, #32]
 80a4616:	3301      	adds	r3, #1
 80a4618:	d101      	bne.n	80a461e <_ZN15Adafruit_LIS3DH13readRegister8Eh+0x56>
	  beginTransaction();
 80a461a:	f7ff ff83 	bl	80a4524 <_ZN15Adafruit_LIS3DH16beginTransactionEv>

	digitalWrite(_cs, LOW);
 80a461e:	f994 001d 	ldrsb.w	r0, [r4, #29]
 80a4622:	2100      	movs	r1, #0
 80a4624:	b280      	uxth	r0, r0
 80a4626:	f002 fb36 	bl	80a6c96 <digitalWrite>
    spixfer(reg | 0x80); // read, bit 7 high
 80a462a:	f045 0180 	orr.w	r1, r5, #128	; 0x80
 80a462e:	4620      	mov	r0, r4
 80a4630:	f7ff ff40 	bl	80a44b4 <_ZN15Adafruit_LIS3DH7spixferEh>
    value = spixfer(0);
 80a4634:	2100      	movs	r1, #0
 80a4636:	4620      	mov	r0, r4
 80a4638:	f7ff ff3c 	bl	80a44b4 <_ZN15Adafruit_LIS3DH7spixferEh>
 80a463c:	4605      	mov	r5, r0
    digitalWrite(_cs, HIGH);
 80a463e:	f994 001d 	ldrsb.w	r0, [r4, #29]
 80a4642:	2101      	movs	r1, #1
 80a4644:	b280      	uxth	r0, r0
 80a4646:	f002 fb26 	bl	80a6c96 <digitalWrite>
    if (_sck == -1)
    	endTransaction();
  }
  #endif
  return value;
}
 80a464a:	4628      	mov	r0, r5
 80a464c:	bd38      	pop	{r3, r4, r5, pc}

080a464e <_ZN15Adafruit_LIS3DH8setRangeE14lis3dh_range_t>:
/*!
    @brief  Sets the g range for the accelerometer
*/
/**************************************************************************/
void Adafruit_LIS3DH::setRange(lis3dh_range_t range)
{
 80a464e:	b538      	push	{r3, r4, r5, lr}
 80a4650:	460d      	mov	r5, r1
  uint8_t r = readRegister8(LIS3DH_REG_CTRL4);
 80a4652:	2123      	movs	r1, #35	; 0x23
/*!
    @brief  Sets the g range for the accelerometer
*/
/**************************************************************************/
void Adafruit_LIS3DH::setRange(lis3dh_range_t range)
{
 80a4654:	4604      	mov	r4, r0
  uint8_t r = readRegister8(LIS3DH_REG_CTRL4);
 80a4656:	f7ff ffb7 	bl	80a45c8 <_ZN15Adafruit_LIS3DH13readRegister8Eh>
  r &= ~(0x30);
  r |= range << 4;
 80a465a:	f020 0030 	bic.w	r0, r0, #48	; 0x30
 80a465e:	ea40 1205 	orr.w	r2, r0, r5, lsl #4
  writeRegister8(LIS3DH_REG_CTRL4, r);
 80a4662:	b2d2      	uxtb	r2, r2
 80a4664:	4620      	mov	r0, r4
}
 80a4666:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
void Adafruit_LIS3DH::setRange(lis3dh_range_t range)
{
  uint8_t r = readRegister8(LIS3DH_REG_CTRL4);
  r &= ~(0x30);
  r |= range << 4;
  writeRegister8(LIS3DH_REG_CTRL4, r);
 80a466a:	2123      	movs	r1, #35	; 0x23
 80a466c:	f7ff bf70 	b.w	80a4550 <_ZN15Adafruit_LIS3DH14writeRegister8Ehh>

080a4670 <_ZN15Adafruit_LIS3DH8getRangeEv>:
/*!
    @brief  Sets the g range for the accelerometer
*/
/**************************************************************************/
lis3dh_range_t Adafruit_LIS3DH::getRange(void)
{
 80a4670:	b508      	push	{r3, lr}
  /* Read the data format register to preserve bits */
  return (lis3dh_range_t)((readRegister8(LIS3DH_REG_CTRL4) >> 4) & 0x03);
 80a4672:	2123      	movs	r1, #35	; 0x23
 80a4674:	f7ff ffa8 	bl	80a45c8 <_ZN15Adafruit_LIS3DH13readRegister8Eh>
}
 80a4678:	f3c0 1001 	ubfx	r0, r0, #4, #2
 80a467c:	bd08      	pop	{r3, pc}

080a467e <_ZN15Adafruit_LIS3DH11setDataRateE17lis3dh_dataRate_t>:
/*!
    @brief  Sets the data rate for the LIS3DH (controls power consumption)
*/
/**************************************************************************/
void Adafruit_LIS3DH::setDataRate(lis3dh_dataRate_t dataRate)
{
 80a467e:	b538      	push	{r3, r4, r5, lr}
 80a4680:	460d      	mov	r5, r1
  uint8_t ctl1 = readRegister8(LIS3DH_REG_CTRL1);
 80a4682:	2120      	movs	r1, #32
/*!
    @brief  Sets the data rate for the LIS3DH (controls power consumption)
*/
/**************************************************************************/
void Adafruit_LIS3DH::setDataRate(lis3dh_dataRate_t dataRate)
{
 80a4684:	4604      	mov	r4, r0
  uint8_t ctl1 = readRegister8(LIS3DH_REG_CTRL1);
 80a4686:	f7ff ff9f 	bl	80a45c8 <_ZN15Adafruit_LIS3DH13readRegister8Eh>
  ctl1 &= ~(0xF0); // mask off bits
  ctl1 |= (dataRate << 4);
 80a468a:	f000 000f 	and.w	r0, r0, #15
 80a468e:	ea40 1205 	orr.w	r2, r0, r5, lsl #4
  writeRegister8(LIS3DH_REG_CTRL1, ctl1);
 80a4692:	b2d2      	uxtb	r2, r2
 80a4694:	4620      	mov	r0, r4
}
 80a4696:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
void Adafruit_LIS3DH::setDataRate(lis3dh_dataRate_t dataRate)
{
  uint8_t ctl1 = readRegister8(LIS3DH_REG_CTRL1);
  ctl1 &= ~(0xF0); // mask off bits
  ctl1 |= (dataRate << 4);
  writeRegister8(LIS3DH_REG_CTRL1, ctl1);
 80a469a:	2120      	movs	r1, #32
 80a469c:	f7ff bf58 	b.w	80a4550 <_ZN15Adafruit_LIS3DH14writeRegister8Ehh>

080a46a0 <_ZN15Adafruit_LIS3DH5beginEh>:
/**************************************************************************/
/*!
    @brief  Setups the HW (reads coefficients values, etc.)
*/
/**************************************************************************/
bool Adafruit_LIS3DH::begin(uint8_t i2caddr) {
 80a46a0:	b510      	push	{r4, lr}
 80a46a2:	4604      	mov	r4, r0
  _i2caddr = i2caddr;
 80a46a4:	7701      	strb	r1, [r0, #28]


  if (_cs == -1) {
 80a46a6:	f990 001d 	ldrsb.w	r0, [r0, #29]
 80a46aa:	1c42      	adds	r2, r0, #1
 80a46ac:	d104      	bne.n	80a46b8 <_ZN15Adafruit_LIS3DH5beginEh+0x18>
    // i2c
    Wire.begin();
 80a46ae:	f002 fb59 	bl	80a6d64 <_Z19__fetch_global_Wirev>
 80a46b2:	f002 fa7f 	bl	80a6bb4 <_ZN7TwoWire5beginEv>
 80a46b6:	e021      	b.n	80a46fc <_ZN15Adafruit_LIS3DH5beginEh+0x5c>
  } else {
    digitalWrite(_cs, HIGH);
 80a46b8:	2101      	movs	r1, #1
 80a46ba:	b280      	uxth	r0, r0
 80a46bc:	f002 faeb 	bl	80a6c96 <digitalWrite>
    pinMode(_cs, OUTPUT);
 80a46c0:	f994 001d 	ldrsb.w	r0, [r4, #29]
 80a46c4:	2101      	movs	r1, #1
 80a46c6:	b280      	uxth	r0, r0
 80a46c8:	f002 fad4 	bl	80a6c74 <pinMode>

#ifndef __AVR_ATtiny85__
    if (_sck == -1) {
 80a46cc:	f994 0020 	ldrsb.w	r0, [r4, #32]
 80a46d0:	1c43      	adds	r3, r0, #1
 80a46d2:	d103      	bne.n	80a46dc <_ZN15Adafruit_LIS3DH5beginEh+0x3c>
      // hardware SPI
      SPI.begin();
 80a46d4:	481a      	ldr	r0, [pc, #104]	; (80a4740 <_ZN15Adafruit_LIS3DH5beginEh+0xa0>)
 80a46d6:	f000 ff69 	bl	80a55ac <_ZN8SPIClass5beginEv>
 80a46da:	e00f      	b.n	80a46fc <_ZN15Adafruit_LIS3DH5beginEh+0x5c>
    } else {
      // software SPI
      pinMode(_sck, OUTPUT);
 80a46dc:	2101      	movs	r1, #1
 80a46de:	b280      	uxth	r0, r0
 80a46e0:	f002 fac8 	bl	80a6c74 <pinMode>
      pinMode(_mosi, OUTPUT);
 80a46e4:	f994 001e 	ldrsb.w	r0, [r4, #30]
 80a46e8:	2101      	movs	r1, #1
 80a46ea:	b280      	uxth	r0, r0
 80a46ec:	f002 fac2 	bl	80a6c74 <pinMode>
      pinMode(_miso, INPUT);
 80a46f0:	f994 001f 	ldrsb.w	r0, [r4, #31]
 80a46f4:	2100      	movs	r1, #0
 80a46f6:	b280      	uxth	r0, r0
 80a46f8:	f002 fabc 	bl	80a6c74 <pinMode>
    Serial.println(readRegister8(i), HEX);
  }
  */

  /* Check connection */
  uint8_t deviceid = readRegister8(LIS3DH_REG_WHOAMI);
 80a46fc:	210f      	movs	r1, #15
 80a46fe:	4620      	mov	r0, r4
 80a4700:	f7ff ff62 	bl	80a45c8 <_ZN15Adafruit_LIS3DH13readRegister8Eh>
  if (deviceid != 0x33)
 80a4704:	2833      	cmp	r0, #51	; 0x33
 80a4706:	d119      	bne.n	80a473c <_ZN15Adafruit_LIS3DH5beginEh+0x9c>
    //Serial.println(deviceid, HEX);
    return false;
  }

  // enable all axes, normal mode
  writeRegister8(LIS3DH_REG_CTRL1, 0x07);
 80a4708:	2207      	movs	r2, #7
 80a470a:	4620      	mov	r0, r4
 80a470c:	2120      	movs	r1, #32
 80a470e:	f7ff ff1f 	bl	80a4550 <_ZN15Adafruit_LIS3DH14writeRegister8Ehh>
  // 400Hz rate
  setDataRate(LIS3DH_DATARATE_400_HZ);
 80a4712:	4620      	mov	r0, r4
 80a4714:	2107      	movs	r1, #7
 80a4716:	f7ff ffb2 	bl	80a467e <_ZN15Adafruit_LIS3DH11setDataRateE17lis3dh_dataRate_t>

  // High res & BDU enabled
  writeRegister8(LIS3DH_REG_CTRL4, 0x88);
 80a471a:	4620      	mov	r0, r4
 80a471c:	2288      	movs	r2, #136	; 0x88
 80a471e:	2123      	movs	r1, #35	; 0x23
 80a4720:	f7ff ff16 	bl	80a4550 <_ZN15Adafruit_LIS3DH14writeRegister8Ehh>

  // DRDY on INT1
  writeRegister8(LIS3DH_REG_CTRL3, 0x10);
 80a4724:	4620      	mov	r0, r4
 80a4726:	2210      	movs	r2, #16
 80a4728:	2122      	movs	r1, #34	; 0x22
 80a472a:	f7ff ff11 	bl	80a4550 <_ZN15Adafruit_LIS3DH14writeRegister8Ehh>

  // Turn on orientation config
  //writeRegister8(LIS3DH_REG_PL_CFG, 0x40);

  // enable adcs
  writeRegister8(LIS3DH_REG_TEMPCFG, 0x80);
 80a472e:	4620      	mov	r0, r4
 80a4730:	2280      	movs	r2, #128	; 0x80
 80a4732:	211f      	movs	r1, #31
 80a4734:	f7ff ff0c 	bl	80a4550 <_ZN15Adafruit_LIS3DH14writeRegister8Ehh>
    Serial.print(i, HEX); Serial.print(" = 0x");
    Serial.println(readRegister8(i), HEX);
  }
  */

  return true;
 80a4738:	2001      	movs	r0, #1
 80a473a:	bd10      	pop	{r4, pc}
  uint8_t deviceid = readRegister8(LIS3DH_REG_WHOAMI);
  if (deviceid != 0x33)
  {
    /* No LIS3DH detected ... return false */
    //Serial.println(deviceid, HEX);
    return false;
 80a473c:	2000      	movs	r0, #0
    Serial.println(readRegister8(i), HEX);
  }
  */

  return true;
}
 80a473e:	bd10      	pop	{r4, pc}
 80a4740:	20001524 	.word	0x20001524

080a4744 <_ZN15Adafruit_LIS3DH4readEv>:


void Adafruit_LIS3DH::read(void) {
 80a4744:	b538      	push	{r3, r4, r5, lr}
  // read x y z at once

  if (_cs == -1) {
 80a4746:	f990 301d 	ldrsb.w	r3, [r0, #29]

  return true;
}


void Adafruit_LIS3DH::read(void) {
 80a474a:	4604      	mov	r4, r0
  // read x y z at once

  if (_cs == -1) {
 80a474c:	3301      	adds	r3, #1
 80a474e:	d143      	bne.n	80a47d8 <_ZN15Adafruit_LIS3DH4readEv+0x94>
    // i2c
    Wire.beginTransmission(_i2caddr);
 80a4750:	f002 fb08 	bl	80a6d64 <_Z19__fetch_global_Wirev>
 80a4754:	f994 101c 	ldrsb.w	r1, [r4, #28]
 80a4758:	f002 fa44 	bl	80a6be4 <_ZN7TwoWire17beginTransmissionEi>
    Wire.write(LIS3DH_REG_OUT_X_L | 0x80); // 0x80 for autoincrement
 80a475c:	f002 fb02 	bl	80a6d64 <_Z19__fetch_global_Wirev>
 80a4760:	21a8      	movs	r1, #168	; 0xa8
 80a4762:	f7ff fe93 	bl	80a448c <_ZN7TwoWire5writeEi>
    Wire.endTransmission();
 80a4766:	f002 fafd 	bl	80a6d64 <_Z19__fetch_global_Wirev>
 80a476a:	f002 fa42 	bl	80a6bf2 <_ZN7TwoWire15endTransmissionEv>

    Wire.requestFrom(_i2caddr, 6);
 80a476e:	f002 faf9 	bl	80a6d64 <_Z19__fetch_global_Wirev>
 80a4772:	2206      	movs	r2, #6
 80a4774:	f994 101c 	ldrsb.w	r1, [r4, #28]
 80a4778:	f002 fa2b 	bl	80a6bd2 <_ZN7TwoWire11requestFromEii>
    x = Wire.read(); x |= ((uint16_t)Wire.read()) << 8;
 80a477c:	f002 faf2 	bl	80a6d64 <_Z19__fetch_global_Wirev>
 80a4780:	6803      	ldr	r3, [r0, #0]
 80a4782:	695b      	ldr	r3, [r3, #20]
 80a4784:	4798      	blx	r3
 80a4786:	80e0      	strh	r0, [r4, #6]
 80a4788:	f002 faec 	bl	80a6d64 <_Z19__fetch_global_Wirev>
 80a478c:	6803      	ldr	r3, [r0, #0]
 80a478e:	695b      	ldr	r3, [r3, #20]
 80a4790:	4798      	blx	r3
 80a4792:	88e3      	ldrh	r3, [r4, #6]
 80a4794:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 80a4798:	80e0      	strh	r0, [r4, #6]
    y = Wire.read(); y |= ((uint16_t)Wire.read()) << 8;
 80a479a:	f002 fae3 	bl	80a6d64 <_Z19__fetch_global_Wirev>
 80a479e:	6803      	ldr	r3, [r0, #0]
 80a47a0:	695b      	ldr	r3, [r3, #20]
 80a47a2:	4798      	blx	r3
 80a47a4:	8120      	strh	r0, [r4, #8]
 80a47a6:	f002 fadd 	bl	80a6d64 <_Z19__fetch_global_Wirev>
 80a47aa:	6803      	ldr	r3, [r0, #0]
 80a47ac:	695b      	ldr	r3, [r3, #20]
 80a47ae:	4798      	blx	r3
 80a47b0:	8923      	ldrh	r3, [r4, #8]
 80a47b2:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 80a47b6:	8120      	strh	r0, [r4, #8]
    z = Wire.read(); z |= ((uint16_t)Wire.read()) << 8;
 80a47b8:	f002 fad4 	bl	80a6d64 <_Z19__fetch_global_Wirev>
 80a47bc:	6803      	ldr	r3, [r0, #0]
 80a47be:	695b      	ldr	r3, [r3, #20]
 80a47c0:	4798      	blx	r3
 80a47c2:	8160      	strh	r0, [r4, #10]
 80a47c4:	f002 face 	bl	80a6d64 <_Z19__fetch_global_Wirev>
 80a47c8:	6803      	ldr	r3, [r0, #0]
 80a47ca:	695b      	ldr	r3, [r3, #20]
 80a47cc:	4798      	blx	r3
 80a47ce:	8963      	ldrh	r3, [r4, #10]
 80a47d0:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 80a47d4:	8160      	strh	r0, [r4, #10]
 80a47d6:	e03c      	b.n	80a4852 <_ZN15Adafruit_LIS3DH4readEv+0x10e>
  }
  #ifndef __AVR_ATtiny85__
  else {
    if (_sck == -1)
 80a47d8:	f990 3020 	ldrsb.w	r3, [r0, #32]
 80a47dc:	3301      	adds	r3, #1
 80a47de:	d101      	bne.n	80a47e4 <_ZN15Adafruit_LIS3DH4readEv+0xa0>
      beginTransaction();
 80a47e0:	f7ff fea0 	bl	80a4524 <_ZN15Adafruit_LIS3DH16beginTransactionEv>

    digitalWrite(_cs, LOW);
 80a47e4:	f994 001d 	ldrsb.w	r0, [r4, #29]
 80a47e8:	2100      	movs	r1, #0
 80a47ea:	b280      	uxth	r0, r0
 80a47ec:	f002 fa53 	bl	80a6c96 <digitalWrite>
    spixfer(LIS3DH_REG_OUT_X_L | 0x80 | 0x40); // read multiple, bit 7&6 high
 80a47f0:	21e8      	movs	r1, #232	; 0xe8
 80a47f2:	4620      	mov	r0, r4
 80a47f4:	f7ff fe5e 	bl	80a44b4 <_ZN15Adafruit_LIS3DH7spixferEh>

    x = spixfer(); x |= ((uint16_t)spixfer()) << 8;
 80a47f8:	21ff      	movs	r1, #255	; 0xff
 80a47fa:	4620      	mov	r0, r4
 80a47fc:	f7ff fe5a 	bl	80a44b4 <_ZN15Adafruit_LIS3DH7spixferEh>
 80a4800:	21ff      	movs	r1, #255	; 0xff
 80a4802:	80e0      	strh	r0, [r4, #6]
 80a4804:	4620      	mov	r0, r4
 80a4806:	f7ff fe55 	bl	80a44b4 <_ZN15Adafruit_LIS3DH7spixferEh>
 80a480a:	88e3      	ldrh	r3, [r4, #6]
    y = spixfer(); y |= ((uint16_t)spixfer()) << 8;
 80a480c:	21ff      	movs	r1, #255	; 0xff
      beginTransaction();

    digitalWrite(_cs, LOW);
    spixfer(LIS3DH_REG_OUT_X_L | 0x80 | 0x40); // read multiple, bit 7&6 high

    x = spixfer(); x |= ((uint16_t)spixfer()) << 8;
 80a480e:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 80a4812:	80e0      	strh	r0, [r4, #6]
    y = spixfer(); y |= ((uint16_t)spixfer()) << 8;
 80a4814:	4620      	mov	r0, r4
 80a4816:	f7ff fe4d 	bl	80a44b4 <_ZN15Adafruit_LIS3DH7spixferEh>
 80a481a:	21ff      	movs	r1, #255	; 0xff
 80a481c:	8120      	strh	r0, [r4, #8]
 80a481e:	4620      	mov	r0, r4
 80a4820:	f7ff fe48 	bl	80a44b4 <_ZN15Adafruit_LIS3DH7spixferEh>
 80a4824:	8923      	ldrh	r3, [r4, #8]
    z = spixfer(); z |= ((uint16_t)spixfer()) << 8;
 80a4826:	21ff      	movs	r1, #255	; 0xff

    digitalWrite(_cs, LOW);
    spixfer(LIS3DH_REG_OUT_X_L | 0x80 | 0x40); // read multiple, bit 7&6 high

    x = spixfer(); x |= ((uint16_t)spixfer()) << 8;
    y = spixfer(); y |= ((uint16_t)spixfer()) << 8;
 80a4828:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 80a482c:	8120      	strh	r0, [r4, #8]
    z = spixfer(); z |= ((uint16_t)spixfer()) << 8;
 80a482e:	4620      	mov	r0, r4
 80a4830:	f7ff fe40 	bl	80a44b4 <_ZN15Adafruit_LIS3DH7spixferEh>
 80a4834:	21ff      	movs	r1, #255	; 0xff
 80a4836:	8160      	strh	r0, [r4, #10]
 80a4838:	4620      	mov	r0, r4
 80a483a:	f7ff fe3b 	bl	80a44b4 <_ZN15Adafruit_LIS3DH7spixferEh>
 80a483e:	8963      	ldrh	r3, [r4, #10]

    digitalWrite(_cs, HIGH);
 80a4840:	2101      	movs	r1, #1
    digitalWrite(_cs, LOW);
    spixfer(LIS3DH_REG_OUT_X_L | 0x80 | 0x40); // read multiple, bit 7&6 high

    x = spixfer(); x |= ((uint16_t)spixfer()) << 8;
    y = spixfer(); y |= ((uint16_t)spixfer()) << 8;
    z = spixfer(); z |= ((uint16_t)spixfer()) << 8;
 80a4842:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 80a4846:	8160      	strh	r0, [r4, #10]

    digitalWrite(_cs, HIGH);
 80a4848:	f994 001d 	ldrsb.w	r0, [r4, #29]
 80a484c:	b280      	uxth	r0, r0
 80a484e:	f002 fa22 	bl	80a6c96 <digitalWrite>
    if (_sck == -1)
    	endTransaction();

  }
  #endif
  uint8_t range = getRange();
 80a4852:	4620      	mov	r0, r4
 80a4854:	f7ff ff0c 	bl	80a4670 <_ZN15Adafruit_LIS3DH8getRangeEv>
  uint16_t divider = 1;
  if (range == LIS3DH_RANGE_16_G) divider = 2048;
 80a4858:	2803      	cmp	r0, #3
 80a485a:	d009      	beq.n	80a4870 <_ZN15Adafruit_LIS3DH4readEv+0x12c>
  if (range == LIS3DH_RANGE_8_G) divider = 4096;
 80a485c:	2802      	cmp	r0, #2
 80a485e:	d00a      	beq.n	80a4876 <_ZN15Adafruit_LIS3DH4readEv+0x132>
  if (range == LIS3DH_RANGE_4_G) divider = 8190;
 80a4860:	2801      	cmp	r0, #1
 80a4862:	d00b      	beq.n	80a487c <_ZN15Adafruit_LIS3DH4readEv+0x138>
  if (range == LIS3DH_RANGE_2_G) divider = 16380;
 80a4864:	2800      	cmp	r0, #0
 80a4866:	f643 70fc 	movw	r0, #16380	; 0x3ffc
 80a486a:	bf18      	it	ne
 80a486c:	2001      	movne	r0, #1
 80a486e:	e007      	b.n	80a4880 <_ZN15Adafruit_LIS3DH4readEv+0x13c>

  }
  #endif
  uint8_t range = getRange();
  uint16_t divider = 1;
  if (range == LIS3DH_RANGE_16_G) divider = 2048;
 80a4870:	f44f 6000 	mov.w	r0, #2048	; 0x800
 80a4874:	e004      	b.n	80a4880 <_ZN15Adafruit_LIS3DH4readEv+0x13c>
  if (range == LIS3DH_RANGE_8_G) divider = 4096;
 80a4876:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 80a487a:	e001      	b.n	80a4880 <_ZN15Adafruit_LIS3DH4readEv+0x13c>
  if (range == LIS3DH_RANGE_4_G) divider = 8190;
 80a487c:	f641 70fe 	movw	r0, #8190	; 0x1ffe
  if (range == LIS3DH_RANGE_2_G) divider = 16380;

  x_g = (float)x / divider;
 80a4880:	f002 fc9a 	bl	80a71b8 <__aeabi_i2f>
 80a4884:	4605      	mov	r5, r0
 80a4886:	f9b4 0006 	ldrsh.w	r0, [r4, #6]
 80a488a:	f002 fc95 	bl	80a71b8 <__aeabi_i2f>
 80a488e:	4629      	mov	r1, r5
 80a4890:	f002 fd9a 	bl	80a73c8 <__aeabi_fdiv>
 80a4894:	60e0      	str	r0, [r4, #12]
  y_g = (float)y / divider;
 80a4896:	f9b4 0008 	ldrsh.w	r0, [r4, #8]
 80a489a:	f002 fc8d 	bl	80a71b8 <__aeabi_i2f>
 80a489e:	4629      	mov	r1, r5
 80a48a0:	f002 fd92 	bl	80a73c8 <__aeabi_fdiv>
 80a48a4:	6120      	str	r0, [r4, #16]
  z_g = (float)z / divider;
 80a48a6:	f9b4 000a 	ldrsh.w	r0, [r4, #10]
 80a48aa:	f002 fc85 	bl	80a71b8 <__aeabi_i2f>
 80a48ae:	4629      	mov	r1, r5
 80a48b0:	f002 fd8a 	bl	80a73c8 <__aeabi_fdiv>
 80a48b4:	6160      	str	r0, [r4, #20]
 80a48b6:	bd38      	pop	{r3, r4, r5, pc}

080a48b8 <_ZN15Adafruit_LIS3DH8getEventEP15sensors_event_t>:
/**************************************************************************/
/*!
    @brief  Gets the most recent sensor event
*/
/**************************************************************************/
bool Adafruit_LIS3DH::getEvent(sensors_event_t *event) {
 80a48b8:	b570      	push	{r4, r5, r6, lr}
 80a48ba:	460c      	mov	r4, r1
 80a48bc:	4605      	mov	r5, r0
  /* Clear the event */
  memset(event, 0, sizeof(sensors_event_t));
 80a48be:	2624      	movs	r6, #36	; 0x24
 80a48c0:	4632      	mov	r2, r6
 80a48c2:	2100      	movs	r1, #0
 80a48c4:	4620      	mov	r0, r4
 80a48c6:	f002 ffc8 	bl	80a785a <memset>

  event->version   = sizeof(sensors_event_t);
 80a48ca:	6026      	str	r6, [r4, #0]
  event->sensor_id = _sensorID;
 80a48cc:	69ab      	ldr	r3, [r5, #24]
  event->type      = SENSOR_TYPE_ACCELEROMETER;
  event->timestamp = 0;

  read();
 80a48ce:	4628      	mov	r0, r5
bool Adafruit_LIS3DH::getEvent(sensors_event_t *event) {
  /* Clear the event */
  memset(event, 0, sizeof(sensors_event_t));

  event->version   = sizeof(sensors_event_t);
  event->sensor_id = _sensorID;
 80a48d0:	6063      	str	r3, [r4, #4]
  event->type      = SENSOR_TYPE_ACCELEROMETER;
 80a48d2:	2301      	movs	r3, #1
 80a48d4:	60a3      	str	r3, [r4, #8]
  event->timestamp = 0;
 80a48d6:	2300      	movs	r3, #0
 80a48d8:	6123      	str	r3, [r4, #16]

  read();
 80a48da:	f7ff ff33 	bl	80a4744 <_ZN15Adafruit_LIS3DH4readEv>

  event->acceleration.x = x_g;
 80a48de:	68eb      	ldr	r3, [r5, #12]
 80a48e0:	6163      	str	r3, [r4, #20]
  event->acceleration.y = y_g;
 80a48e2:	692b      	ldr	r3, [r5, #16]
 80a48e4:	61a3      	str	r3, [r4, #24]
  event->acceleration.z = z_g;
 80a48e6:	696b      	ldr	r3, [r5, #20]
 80a48e8:	61e3      	str	r3, [r4, #28]
}
 80a48ea:	bd70      	pop	{r4, r5, r6, pc}

080a48ec <_GLOBAL__sub_I__ZN15Adafruit_LIS3DHC2Ev>:
 80a48ec:	f000 bb2c 	b.w	80a4f48 <HAL_Pin_Map>

080a48f0 <_ZN8NexGaugeC1EhhPKcPv>:
* by BSpranger & ScruffR (Dec. 2015)
*/

#include "NexGauge.h"

NexGauge::NexGauge(uint8_t pid, uint8_t cid, const char *name, void *value)
 80a48f0:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a48f2:	4604      	mov	r4, r0
    :NexObject(pid, cid, name, value)
 80a48f4:	9d06      	ldr	r5, [sp, #24]
 80a48f6:	9500      	str	r5, [sp, #0]
 80a48f8:	f000 f836 	bl	80a4968 <_ZN9NexObjectC1EhhPKcPv>
{
}
 80a48fc:	4620      	mov	r0, r4
 80a48fe:	b003      	add	sp, #12
 80a4900:	bd30      	pop	{r4, r5, pc}

080a4902 <_GLOBAL__sub_I__ZN8NexGaugeC2EhhPKcPv>:
 80a4902:	f000 bb21 	b.w	80a4f48 <HAL_Pin_Map>

080a4906 <_GLOBAL__sub_I__Z14NexSendCommandPKcz>:
 80a4906:	f000 bb1f 	b.w	80a4f48 <HAL_Pin_Map>

080a490a <_ZN14NexProgressBarC1EhhPKcPv>:
* by BSpranger & ScruffR (Dec. 2015)
*/

#include "NexProgressBar.h"

NexProgressBar::NexProgressBar(uint8_t pid, uint8_t cid, const char *name, void *value)
 80a490a:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a490c:	4604      	mov	r4, r0
    :NexObject(pid, cid, name, value)
 80a490e:	9d06      	ldr	r5, [sp, #24]
 80a4910:	9500      	str	r5, [sp, #0]
 80a4912:	f000 f829 	bl	80a4968 <_ZN9NexObjectC1EhhPKcPv>
{
}
 80a4916:	4620      	mov	r0, r4
 80a4918:	b003      	add	sp, #12
 80a491a:	bd30      	pop	{r4, r5, pc}

080a491c <_ZN14NexProgressBar8setValueEm>:
  return NexObject::getValue("val", number);
}

bool NexProgressBar::setValue(uint32_t number)
{
  return NexObject::setValue("val", number);
 80a491c:	460a      	mov	r2, r1
 80a491e:	4901      	ldr	r1, [pc, #4]	; (80a4924 <_ZN14NexProgressBar8setValueEm+0x8>)
 80a4920:	f000 b835 	b.w	80a498e <_ZN9NexObject8setValueEPKcm>
 80a4924:	080a9224 	.word	0x080a9224

080a4928 <_GLOBAL__sub_I__ZN14NexProgressBarC2EhhPKcPv>:
 80a4928:	f000 bb0e 	b.w	80a4f48 <HAL_Pin_Map>

080a492c <_GLOBAL__sub_I__ZN11NexWaveformC2EhhPKcPv>:
 80a492c:	f000 bb0c 	b.w	80a4f48 <HAL_Pin_Map>

080a4930 <_ZN9NexButtonC1EhhPKcPv>:
* by BSpranger & ScruffR (Dec. 2015) 
*/

#include "NexButton.h"

NexButton::NexButton(uint8_t pid, uint8_t cid, const char *name, void *value)
 80a4930:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a4932:	4604      	mov	r4, r0
    :NexTouch(pid, cid, name, value)
 80a4934:	9d06      	ldr	r5, [sp, #24]
 80a4936:	9500      	str	r5, [sp, #0]
 80a4938:	f000 faa0 	bl	80a4e7c <_ZN8NexTouchC1EhhPKcPv>
{
}
 80a493c:	4620      	mov	r0, r4
 80a493e:	b003      	add	sp, #12
 80a4940:	bd30      	pop	{r4, r5, pc}

080a4942 <_GLOBAL__sub_I__ZN9NexButtonC2EhhPKcPv>:
 80a4942:	f000 bb01 	b.w	80a4f48 <HAL_Pin_Map>

080a4946 <_GLOBAL__sub_I__ZN8NexTimerC2EhhPKcPv>:
 80a4946:	f000 baff 	b.w	80a4f48 <HAL_Pin_Map>

080a494a <_GLOBAL__sub_I__ZN6NexVarC2EhhPKc>:
 80a494a:	f000 bafd 	b.w	80a4f48 <HAL_Pin_Map>

080a494e <_ZN9NexNumberC1EhhPKc>:
* by ScruffR (Dec. 2015)
*/

#include "NexNumber.h"

NexNumber::NexNumber(uint8_t pid, uint8_t cid, const char *name)
 80a494e:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a4950:	4604      	mov	r4, r0
    :NexTouch(pid, cid, name)
 80a4952:	2500      	movs	r5, #0
 80a4954:	9500      	str	r5, [sp, #0]
 80a4956:	f000 fa91 	bl	80a4e7c <_ZN8NexTouchC1EhhPKcPv>
{
}
 80a495a:	4620      	mov	r0, r4
 80a495c:	b003      	add	sp, #12
 80a495e:	bd30      	pop	{r4, r5, pc}

080a4960 <_GLOBAL__sub_I__ZN9NexNumberC2EhhPKc>:
 80a4960:	f000 baf2 	b.w	80a4f48 <HAL_Pin_Map>

080a4964 <_GLOBAL__sub_I_ITEADLIB_Nextion.cpp>:
 80a4964:	f000 baf0 	b.w	80a4f48 <HAL_Pin_Map>

080a4968 <_ZN9NexObjectC1EhhPKcPv>:
*/

#include "NexObject.h"
#include "NexHardware.h"

NexObject::NexObject(uint8_t pid, uint8_t cid, const char *name, void *value)
 80a4968:	b510      	push	{r4, lr}
{
    this->__pid = pid;
    this->__cid = cid;
    this->__name = name;
 80a496a:	6043      	str	r3, [r0, #4]
    this->__value = value;
 80a496c:	9b02      	ldr	r3, [sp, #8]
#include "NexObject.h"
#include "NexHardware.h"

NexObject::NexObject(uint8_t pid, uint8_t cid, const char *name, void *value)
{
    this->__pid = pid;
 80a496e:	7001      	strb	r1, [r0, #0]
    this->__cid = cid;
 80a4970:	7042      	strb	r2, [r0, #1]
    this->__name = name;
    this->__value = value;
 80a4972:	6083      	str	r3, [r0, #8]
}
 80a4974:	bd10      	pop	{r4, pc}

080a4976 <_ZN9NexObject11setObjValueEhPv>:

void NexObject::setObjValue(uint8_t type, void *value)
{
    if (__value)
 80a4976:	6883      	ldr	r3, [r0, #8]
 80a4978:	b11b      	cbz	r3, 80a4982 <_ZN9NexObject11setObjValueEhPv+0xc>
    {
        switch (type)
 80a497a:	2902      	cmp	r1, #2
        {
        case NEX_EVENT_VALUE:
           *((unsigned long *)__value) = (((uint8_t *)value)[0]) | (((unsigned long)((uint8_t *)value)[1]) << 8) | (((unsigned long)((uint8_t *)value)[2]) << 16) | (((unsigned long)((uint8_t *)value)[3]) << 24);
 80a497c:	bf04      	itt	eq
 80a497e:	6812      	ldreq	r2, [r2, #0]
 80a4980:	601a      	streq	r2, [r3, #0]
 80a4982:	4770      	bx	lr

080a4984 <_ZN9NexObject9getObjPidEv>:
}

uint8_t NexObject::getObjPid(void)
{
    return __pid;
}
 80a4984:	7800      	ldrb	r0, [r0, #0]
 80a4986:	4770      	bx	lr

080a4988 <_ZN9NexObject9getObjCidEv>:

uint8_t NexObject::getObjCid(void)
{
    return __cid;
}
 80a4988:	7840      	ldrb	r0, [r0, #1]
 80a498a:	4770      	bx	lr

080a498c <_ZN9NexObject12printObjInfoEv>:
{
    return __value;
}

void NexObject::printObjInfo(void)
{
 80a498c:	4770      	bx	lr

080a498e <_ZN9NexObject8setValueEPKcm>:
  return NexGetValue(getObjName(), valueType, value);
}

bool NexObject::setValue(const char* valueType, uint32_t value)
{
  return NexSetValue(getObjName(), valueType, value);
 80a498e:	6840      	ldr	r0, [r0, #4]
 80a4990:	f000 b9c0 	b.w	80a4d14 <_Z11NexSetValuePKcS0_m>

080a4994 <_ZN9NexObject9getStringEPKcPct>:
}

uint16_t NexObject::getString(const char* valueType, char* text, uint16_t len)
{
  return NexGetString(getObjName(), valueType, text, len);
 80a4994:	6840      	ldr	r0, [r0, #4]
 80a4996:	f000 b9e7 	b.w	80a4d68 <_Z12NexGetStringPKcS0_Pct>

080a499a <_ZN9NexObject9setStringEPKcS1_>:
}

bool NexObject::setString(const char* valueType, const char* text)
{
  return NexSetString(getObjName(), valueType, text);
 80a499a:	6840      	ldr	r0, [r0, #4]
 80a499c:	f000 ba12 	b.w	80a4dc4 <_Z12NexSetStringPKcS0_S0_>

080a49a0 <_GLOBAL__sub_I__ZN9NexObjectC2EhhPKcPv>:
 80a49a0:	f000 bad2 	b.w	80a4f48 <HAL_Pin_Map>

080a49a4 <_GLOBAL__sub_I__ZN11NexDSButtonC2EhhPKc>:
 80a49a4:	f000 bad0 	b.w	80a4f48 <HAL_Pin_Map>

080a49a8 <_GLOBAL__sub_I__Z11clearScreenm>:
 80a49a8:	f000 bace 	b.w	80a4f48 <HAL_Pin_Map>

080a49ac <_GLOBAL__sub_I__ZN7NexCropC2EhhPKcPv>:
 80a49ac:	f000 bacc 	b.w	80a4f48 <HAL_Pin_Map>

080a49b0 <_ZN9NexSliderC1EhhPKcPv>:
* by BSpranger & ScruffR (Dec. 2015)
*/

#include "NexSlider.h"

NexSlider::NexSlider(uint8_t pid, uint8_t cid, const char *name, void *value)
 80a49b0:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a49b2:	4604      	mov	r4, r0
    :NexTouch(pid, cid, name, value)
 80a49b4:	9d06      	ldr	r5, [sp, #24]
 80a49b6:	9500      	str	r5, [sp, #0]
 80a49b8:	f000 fa60 	bl	80a4e7c <_ZN8NexTouchC1EhhPKcPv>
{
}
 80a49bc:	4620      	mov	r0, r4
 80a49be:	b003      	add	sp, #12
 80a49c0:	bd30      	pop	{r4, r5, pc}

080a49c2 <_GLOBAL__sub_I__ZN9NexSliderC2EhhPKcPv>:
 80a49c2:	f000 bac1 	b.w	80a4f48 <HAL_Pin_Map>
	...

080a49c8 <_Z13recvRetStringPctm>:
 *
 * @return the length of string buffer.
 *
 */
uint16_t recvRetString(char *buffer, uint16_t len, uint32_t timeout)
{
 80a49c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a49cc:	b085      	sub	sp, #20
 80a49ce:	460d      	mov	r5, r1
 80a49d0:	9202      	str	r2, [sp, #8]
  uint16_t bufIdx = 0;
  //uint16_t tempIdx = 0;
  //char temp[len];
  //memset(temp, 0, len);

  if (!buffer || len == 0)
 80a49d2:	4681      	mov	r9, r0
 80a49d4:	2800      	cmp	r0, #0
 80a49d6:	d04d      	beq.n	80a4a74 <_Z13recvRetStringPctm+0xac>
 80a49d8:	2900      	cmp	r1, #0
 80a49da:	d04d      	beq.n	80a4a78 <_Z13recvRetStringPctm+0xb0>
  {
    goto __return;
  }
  memset(buffer, 0, len);
 80a49dc:	460a      	mov	r2, r1
 80a49de:	2100      	movs	r1, #0
  bool str_start_flag = false;
  uint8_t cnt_0xff = 0;
  uint8_t c = 0;
  uint32_t start;

  uint16_t bufIdx = 0;
 80a49e0:	f04f 0b00 	mov.w	fp, #0

  if (!buffer || len == 0)
  {
    goto __return;
  }
  memset(buffer, 0, len);
 80a49e4:	f002 ff39 	bl	80a785a <memset>
#endif

#include "timer_hal.h"
#include "delay_hal.h"

inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
 80a49e8:	f000 fb36 	bl	80a5058 <HAL_Timer_Get_Milli_Seconds>
 *
 */
uint16_t recvRetString(char *buffer, uint16_t len, uint32_t timeout)
{
  uint16_t ret = 0;
  bool str_start_flag = false;
 80a49ec:	46d8      	mov	r8, fp
  uint8_t cnt_0xff = 0;
 80a49ee:	465c      	mov	r4, fp
 80a49f0:	4f24      	ldr	r7, [pc, #144]	; (80a4a84 <_Z13recvRetStringPctm+0xbc>)
  while (cnt_0xff < 3 && millis() - start <= timeout)
  {
#if defined(SPARK)
    Particle.process();
#endif
    while (nexSerial.available())
 80a49f2:	f8df a094 	ldr.w	sl, [pc, #148]	; 80a4a88 <_Z13recvRetStringPctm+0xc0>
 80a49f6:	9001      	str	r0, [sp, #4]
 80a49f8:	f000 fb2e 	bl	80a5058 <HAL_Timer_Get_Milli_Seconds>
    goto __return;
  }
  memset(buffer, 0, len);

  start = millis();
  while (cnt_0xff < 3 && millis() - start <= timeout)
 80a49fc:	9b01      	ldr	r3, [sp, #4]
 80a49fe:	1ac0      	subs	r0, r0, r3
 80a4a00:	9b02      	ldr	r3, [sp, #8]
 80a4a02:	4283      	cmp	r3, r0
 80a4a04:	d339      	bcc.n	80a4a7a <_Z13recvRetStringPctm+0xb2>
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
 80a4a06:	f000 fb27 	bl	80a5058 <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
 80a4a0a:	6038      	str	r0, [r7, #0]
 80a4a0c:	f000 fd42 	bl	80a5494 <spark_process>
          if (cnt_0xff >= 3)
          {
            break;
          }
        }
        else if ((int)bufIdx < len - 1)
 80a4a10:	1e6b      	subs	r3, r5, #1
  while (cnt_0xff < 3 && millis() - start <= timeout)
  {
#if defined(SPARK)
    Particle.process();
#endif
    while (nexSerial.available())
 80a4a12:	f8da 6000 	ldr.w	r6, [sl]
          if (cnt_0xff >= 3)
          {
            break;
          }
        }
        else if ((int)bufIdx < len - 1)
 80a4a16:	9303      	str	r3, [sp, #12]
  while (cnt_0xff < 3 && millis() - start <= timeout)
  {
#if defined(SPARK)
    Particle.process();
#endif
    while (nexSerial.available())
 80a4a18:	6832      	ldr	r2, [r6, #0]
 80a4a1a:	4630      	mov	r0, r6
 80a4a1c:	6912      	ldr	r2, [r2, #16]
 80a4a1e:	4790      	blx	r2
 80a4a20:	b910      	cbnz	r0, 80a4a28 <_Z13recvRetStringPctm+0x60>
    goto __return;
  }
  memset(buffer, 0, len);

  start = millis();
  while (cnt_0xff < 3 && millis() - start <= timeout)
 80a4a22:	2c02      	cmp	r4, #2
 80a4a24:	d829      	bhi.n	80a4a7a <_Z13recvRetStringPctm+0xb2>
 80a4a26:	e7e7      	b.n	80a49f8 <_Z13recvRetStringPctm+0x30>
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
 80a4a28:	f000 fb16 	bl	80a5058 <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
 80a4a2c:	4b15      	ldr	r3, [pc, #84]	; (80a4a84 <_Z13recvRetStringPctm+0xbc>)
 80a4a2e:	6018      	str	r0, [r3, #0]
 80a4a30:	f000 fd30 	bl	80a5494 <spark_process>
    while (nexSerial.available())
    {
#if defined(SPARK)
      Particle.process();
#endif
      c = nexSerial.read();
 80a4a34:	6832      	ldr	r2, [r6, #0]
 80a4a36:	4630      	mov	r0, r6
 80a4a38:	6952      	ldr	r2, [r2, #20]
 80a4a3a:	4790      	blx	r2
 80a4a3c:	b2c0      	uxtb	r0, r0
      if (str_start_flag)
 80a4a3e:	f1b8 0f00 	cmp.w	r8, #0
 80a4a42:	d010      	beq.n	80a4a66 <_Z13recvRetStringPctm+0x9e>
      {
        if (0xFF == c)
 80a4a44:	28ff      	cmp	r0, #255	; 0xff
 80a4a46:	d104      	bne.n	80a4a52 <_Z13recvRetStringPctm+0x8a>
        {
          cnt_0xff++;
 80a4a48:	3401      	adds	r4, #1
 80a4a4a:	b2e4      	uxtb	r4, r4
          if (cnt_0xff >= 3)
 80a4a4c:	2c02      	cmp	r4, #2
 80a4a4e:	d9e3      	bls.n	80a4a18 <_Z13recvRetStringPctm+0x50>
 80a4a50:	e013      	b.n	80a4a7a <_Z13recvRetStringPctm+0xb2>
          {
            break;
          }
        }
        else if ((int)bufIdx < len - 1)
 80a4a52:	9b03      	ldr	r3, [sp, #12]
 80a4a54:	459b      	cmp	fp, r3
 80a4a56:	dadf      	bge.n	80a4a18 <_Z13recvRetStringPctm+0x50>
        {
          buffer[bufIdx++] = (char)c;
 80a4a58:	f10b 0201 	add.w	r2, fp, #1
 80a4a5c:	f809 000b 	strb.w	r0, [r9, fp]
 80a4a60:	fa1f fb82 	uxth.w	fp, r2
 80a4a64:	e7d8      	b.n	80a4a18 <_Z13recvRetStringPctm+0x50>
          //temp[tempIdx++] = (char)c;
          //temp[tempIdx] = '\0';  // memset makes sure of this already
        }
      }
      else if (NEX_RET_STRING_HEAD == c)
 80a4a66:	f1a0 0370 	sub.w	r3, r0, #112	; 0x70
 80a4a6a:	f1d3 0800 	rsbs	r8, r3, #0
 80a4a6e:	eb48 0803 	adc.w	r8, r8, r3
 80a4a72:	e7d1      	b.n	80a4a18 <_Z13recvRetStringPctm+0x50>
 * @return the length of string buffer.
 *
 */
uint16_t recvRetString(char *buffer, uint16_t len, uint32_t timeout)
{
  uint16_t ret = 0;
 80a4a74:	4683      	mov	fp, r0
 80a4a76:	e000      	b.n	80a4a7a <_Z13recvRetStringPctm+0xb2>
 80a4a78:	468b      	mov	fp, r1
  dbSerialPrint(",");
  dbSerialPrint(buffer);
  dbSerialPrintln("]");

  return ret;
}
 80a4a7a:	4658      	mov	r0, fp
 80a4a7c:	b005      	add	sp, #20
 80a4a7e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a4a82:	bf00      	nop
 80a4a84:	20001544 	.word	0x20001544
 80a4a88:	200004b8 	.word	0x200004b8

080a4a8c <_Z11sendCommandPKc>:
 * Send command to Nextion.
 *
 * @param cmd - the string of command.
 */
void sendCommand(const char* cmd)
{
 80a4a8c:	b538      	push	{r3, r4, r5, lr}
 80a4a8e:	4605      	mov	r5, r0
  while (nexSerial.read() >= 0);  // flush RX buffer only
 80a4a90:	4b08      	ldr	r3, [pc, #32]	; (80a4ab4 <_Z11sendCommandPKc+0x28>)
 80a4a92:	681c      	ldr	r4, [r3, #0]
 80a4a94:	6823      	ldr	r3, [r4, #0]
 80a4a96:	4620      	mov	r0, r4
 80a4a98:	695b      	ldr	r3, [r3, #20]
 80a4a9a:	4798      	blx	r3
 80a4a9c:	2800      	cmp	r0, #0
 80a4a9e:	daf9      	bge.n	80a4a94 <_Z11sendCommandPKc+0x8>
  nexSerial.print(cmd);
 80a4aa0:	4629      	mov	r1, r5
 80a4aa2:	4620      	mov	r0, r4
 80a4aa4:	f000 ff8a 	bl	80a59bc <_ZN5Print5printEPKc>
  nexSerial.print(NexCMDTERM);
 80a4aa8:	4620      	mov	r0, r4
  //nexSerial.write(0xFF);
  //nexSerial.write(0xFF);
  //nexSerial.write(0xFF);
}
 80a4aaa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 */
void sendCommand(const char* cmd)
{
  while (nexSerial.read() >= 0);  // flush RX buffer only
  nexSerial.print(cmd);
  nexSerial.print(NexCMDTERM);
 80a4aae:	4902      	ldr	r1, [pc, #8]	; (80a4ab8 <_Z11sendCommandPKc+0x2c>)
 80a4ab0:	f000 bf84 	b.w	80a59bc <_ZN5Print5printEPKc>
 80a4ab4:	200004b8 	.word	0x200004b8
 80a4ab8:	080a927f 	.word	0x080a927f

080a4abc <_Z22recvRetCommandFinishedm>:
 * @retval true - success.
 * @retval false - failed.
 *
 */
bool recvRetCommandFinished(uint32_t timeout)
{
 80a4abc:	b530      	push	{r4, r5, lr}
  bool ret = false;
  uint8_t temp[4] = "";

  nexSerial.setTimeout(timeout);
 80a4abe:	4b13      	ldr	r3, [pc, #76]	; (80a4b0c <_Z22recvRetCommandFinishedm+0x50>)
 * @retval true - success.
 * @retval false - failed.
 *
 */
bool recvRetCommandFinished(uint32_t timeout)
{
 80a4ac0:	b085      	sub	sp, #20
  bool ret = false;
  uint8_t temp[4] = "";

  nexSerial.setTimeout(timeout);
 80a4ac2:	681b      	ldr	r3, [r3, #0]
 *
 */
bool recvRetCommandFinished(uint32_t timeout)
{
  bool ret = false;
  uint8_t temp[4] = "";
 80a4ac4:	ad04      	add	r5, sp, #16
 80a4ac6:	2400      	movs	r4, #0

  nexSerial.setTimeout(timeout);
 80a4ac8:	4601      	mov	r1, r0
 *
 */
bool recvRetCommandFinished(uint32_t timeout)
{
  bool ret = false;
  uint8_t temp[4] = "";
 80a4aca:	f845 4d04 	str.w	r4, [r5, #-4]!

  nexSerial.setTimeout(timeout);
 80a4ace:	4618      	mov	r0, r3
 80a4ad0:	9301      	str	r3, [sp, #4]
 80a4ad2:	f001 f825 	bl	80a5b20 <_ZN6Stream10setTimeoutEm>
  if (sizeof(temp) != nexSerial.readBytes((char *)temp, sizeof(temp)))
 80a4ad6:	2204      	movs	r2, #4
 80a4ad8:	4629      	mov	r1, r5
 80a4ada:	9801      	ldr	r0, [sp, #4]
 80a4adc:	f001 f822 	bl	80a5b24 <_ZN6Stream9readBytesEPcj>
  {
    ret = false;
  }

  if (temp[0] == NEX_RET_CMD_FINISHED
 80a4ae0:	f89d 300c 	ldrb.w	r3, [sp, #12]
 80a4ae4:	2b01      	cmp	r3, #1
 80a4ae6:	d10e      	bne.n	80a4b06 <_Z22recvRetCommandFinishedm+0x4a>
    && temp[1] == 0xFF
 80a4ae8:	f89d 300d 	ldrb.w	r3, [sp, #13]
 80a4aec:	2bff      	cmp	r3, #255	; 0xff
 80a4aee:	d10a      	bne.n	80a4b06 <_Z22recvRetCommandFinishedm+0x4a>
    && temp[2] == 0xFF
 80a4af0:	f89d 300e 	ldrb.w	r3, [sp, #14]
 80a4af4:	2bff      	cmp	r3, #255	; 0xff
 80a4af6:	d106      	bne.n	80a4b06 <_Z22recvRetCommandFinishedm+0x4a>
    && temp[3] == 0xFF
 80a4af8:	f89d 400f 	ldrb.w	r4, [sp, #15]
 80a4afc:	f1a4 03ff 	sub.w	r3, r4, #255	; 0xff
 80a4b00:	4258      	negs	r0, r3
 80a4b02:	4158      	adcs	r0, r3
 80a4b04:	e000      	b.n	80a4b08 <_Z22recvRetCommandFinishedm+0x4c>
 80a4b06:	4620      	mov	r0, r4
  {
    dbSerialPrintln("recvRetCommandFinished err");
  }

  return ret;
}
 80a4b08:	b005      	add	sp, #20
 80a4b0a:	bd30      	pop	{r4, r5, pc}
 80a4b0c:	200004b8 	.word	0x200004b8

080a4b10 <_Z7nexInitm>:
bool nexInit(uint32_t baudrate)
{
  bool ret1 = false;
  bool ret2 = false;

  nexSerial.begin(baudrate);
 80a4b10:	4b0c      	ldr	r3, [pc, #48]	; (80a4b44 <_Z7nexInitm+0x34>)
  return ret;
}


bool nexInit(uint32_t baudrate)
{
 80a4b12:	b510      	push	{r4, lr}
  bool ret1 = false;
  bool ret2 = false;

  nexSerial.begin(baudrate);
 80a4b14:	4601      	mov	r1, r0
 80a4b16:	6818      	ldr	r0, [r3, #0]
 80a4b18:	f001 ffcc 	bl	80a6ab4 <_ZN11USARTSerial5beginEm>

  sendCommand("");
 80a4b1c:	480a      	ldr	r0, [pc, #40]	; (80a4b48 <_Z7nexInitm+0x38>)
 80a4b1e:	f7ff ffb5 	bl	80a4a8c <_Z11sendCommandPKc>
  sendCommand("bkcmd=1");  // only return success results
 80a4b22:	480a      	ldr	r0, [pc, #40]	; (80a4b4c <_Z7nexInitm+0x3c>)
 80a4b24:	f7ff ffb2 	bl	80a4a8c <_Z11sendCommandPKc>
  ret1 = recvRetCommandFinished();
 80a4b28:	2064      	movs	r0, #100	; 0x64
 80a4b2a:	f7ff ffc7 	bl	80a4abc <_Z22recvRetCommandFinishedm>
 80a4b2e:	4604      	mov	r4, r0
  sendCommand("page 0");   // show home page
 80a4b30:	4807      	ldr	r0, [pc, #28]	; (80a4b50 <_Z7nexInitm+0x40>)
 80a4b32:	f7ff ffab 	bl	80a4a8c <_Z11sendCommandPKc>
  ret2 = recvRetCommandFinished();
 80a4b36:	2064      	movs	r0, #100	; 0x64
 80a4b38:	f7ff ffc0 	bl	80a4abc <_Z22recvRetCommandFinishedm>
  return ret1 && ret2;
 80a4b3c:	2c00      	cmp	r4, #0
}
 80a4b3e:	bf08      	it	eq
 80a4b40:	2000      	moveq	r0, #0
 80a4b42:	bd10      	pop	{r4, pc}
 80a4b44:	200004b8 	.word	0x200004b8
 80a4b48:	080a92e8 	.word	0x080a92e8
 80a4b4c:	080a928f 	.word	0x080a928f
 80a4b50:	080a8166 	.word	0x080a8166

080a4b54 <_Z7nexLoopPP8NexTouch>:

void nexLoop(NexTouch *nex_listen_list[])
{
 80a4b54:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 80a4b58:	4607      	mov	r7, r0
  static uint8_t __buffer[20];

  uint16_t i;
  uint8_t c;

  while (nexSerial.available())
 80a4b5a:	4b4b      	ldr	r3, [pc, #300]	; (80a4c88 <_Z7nexLoopPP8NexTouch+0x134>)
    else if (NEX_RET_VALUE_HEAD == c)
    {
      dbSerialPrint("value cmd:");
      if (nexSerial.available() >= 10)
      {
        __buffer[0] = c;
 80a4b5c:	4c4b      	ldr	r4, [pc, #300]	; (80a4c8c <_Z7nexLoopPP8NexTouch+0x138>)
  static uint8_t __buffer[20];

  uint16_t i;
  uint8_t c;

  while (nexSerial.available())
 80a4b5e:	681d      	ldr	r5, [r3, #0]
 80a4b60:	f104 080c 	add.w	r8, r4, #12
 80a4b64:	682b      	ldr	r3, [r5, #0]
 80a4b66:	4628      	mov	r0, r5
 80a4b68:	691b      	ldr	r3, [r3, #16]
 80a4b6a:	4798      	blx	r3
 80a4b6c:	2800      	cmp	r0, #0
 80a4b6e:	f000 8088 	beq.w	80a4c82 <_Z7nexLoopPP8NexTouch+0x12e>
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
 80a4b72:	f000 fa71 	bl	80a5058 <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
 80a4b76:	4b46      	ldr	r3, [pc, #280]	; (80a4c90 <_Z7nexLoopPP8NexTouch+0x13c>)
 80a4b78:	6018      	str	r0, [r3, #0]
 80a4b7a:	f000 fc8b 	bl	80a5494 <spark_process>
  {
#if defined(SPARK)
    Particle.process();
#endif
    delay(10); 
 80a4b7e:	200a      	movs	r0, #10
 80a4b80:	f001 f8bc 	bl	80a5cfc <delay>

    c = nexSerial.read();
 80a4b84:	682b      	ldr	r3, [r5, #0]
 80a4b86:	4628      	mov	r0, r5
 80a4b88:	695b      	ldr	r3, [r3, #20]
 80a4b8a:	4798      	blx	r3
 80a4b8c:	b2c6      	uxtb	r6, r0

    if (NEX_RET_EVENT_TOUCH_HEAD == c)
 80a4b8e:	2e65      	cmp	r6, #101	; 0x65
 80a4b90:	d124      	bne.n	80a4bdc <_Z7nexLoopPP8NexTouch+0x88>
    {
      if (nexSerial.available() >= 6)
 80a4b92:	682b      	ldr	r3, [r5, #0]
 80a4b94:	4628      	mov	r0, r5
 80a4b96:	691b      	ldr	r3, [r3, #16]
 80a4b98:	4798      	blx	r3
 80a4b9a:	2805      	cmp	r0, #5
 80a4b9c:	dde2      	ble.n	80a4b64 <_Z7nexLoopPP8NexTouch+0x10>
      {
        __buffer[0] = c;
 80a4b9e:	7026      	strb	r6, [r4, #0]
 80a4ba0:	4e3c      	ldr	r6, [pc, #240]	; (80a4c94 <_Z7nexLoopPP8NexTouch+0x140>)
 80a4ba2:	f106 0a06 	add.w	sl, r6, #6
 80a4ba6:	f106 39ff 	add.w	r9, r6, #4294967295
        for (i = 1; i < 7; i++)
        {
          __buffer[i] = nexSerial.read();
 80a4baa:	682b      	ldr	r3, [r5, #0]
 80a4bac:	4628      	mov	r0, r5
 80a4bae:	695b      	ldr	r3, [r3, #20]
 80a4bb0:	4798      	blx	r3
 80a4bb2:	f806 0b01 	strb.w	r0, [r6], #1
    if (NEX_RET_EVENT_TOUCH_HEAD == c)
    {
      if (nexSerial.available() >= 6)
      {
        __buffer[0] = c;
        for (i = 1; i < 7; i++)
 80a4bb6:	45b2      	cmp	sl, r6
 80a4bb8:	d1f7      	bne.n	80a4baa <_Z7nexLoopPP8NexTouch+0x56>
        {
          __buffer[i] = nexSerial.read();
        }
        __buffer[i] = 0x00;

        if (0xFF == __buffer[4] && 0xFF == __buffer[5] && 0xFF == __buffer[6])
 80a4bba:	f899 3004 	ldrb.w	r3, [r9, #4]
        __buffer[0] = c;
        for (i = 1; i < 7; i++)
        {
          __buffer[i] = nexSerial.read();
        }
        __buffer[i] = 0x00;
 80a4bbe:	2000      	movs	r0, #0

        if (0xFF == __buffer[4] && 0xFF == __buffer[5] && 0xFF == __buffer[6])
 80a4bc0:	2bff      	cmp	r3, #255	; 0xff
        __buffer[0] = c;
        for (i = 1; i < 7; i++)
        {
          __buffer[i] = nexSerial.read();
        }
        __buffer[i] = 0x00;
 80a4bc2:	f889 0007 	strb.w	r0, [r9, #7]

        if (0xFF == __buffer[4] && 0xFF == __buffer[5] && 0xFF == __buffer[6])
 80a4bc6:	d1cd      	bne.n	80a4b64 <_Z7nexLoopPP8NexTouch+0x10>
 80a4bc8:	7963      	ldrb	r3, [r4, #5]
 80a4bca:	2bff      	cmp	r3, #255	; 0xff
 80a4bcc:	d1ca      	bne.n	80a4b64 <_Z7nexLoopPP8NexTouch+0x10>
 80a4bce:	79a3      	ldrb	r3, [r4, #6]
 80a4bd0:	2bff      	cmp	r3, #255	; 0xff
 80a4bd2:	d1c7      	bne.n	80a4b64 <_Z7nexLoopPP8NexTouch+0x10>
        {
          NexTouch::iterate(nex_listen_list, __buffer[1], __buffer[2], (int32_t)__buffer[3], NULL);
 80a4bd4:	78e3      	ldrb	r3, [r4, #3]
 80a4bd6:	78a2      	ldrb	r2, [r4, #2]
 80a4bd8:	7861      	ldrb	r1, [r4, #1]
 80a4bda:	e04d      	b.n	80a4c78 <_Z7nexLoopPP8NexTouch+0x124>
        }

      }
    }
    else if (NEX_RET_CURRENT_PAGE_ID_HEAD == c)
 80a4bdc:	2e66      	cmp	r6, #102	; 0x66
 80a4bde:	d124      	bne.n	80a4c2a <_Z7nexLoopPP8NexTouch+0xd6>
    {
      dbSerialPrint("page cmd:");
      if (nexSerial.available() >= 4)
 80a4be0:	682b      	ldr	r3, [r5, #0]
 80a4be2:	4628      	mov	r0, r5
 80a4be4:	691b      	ldr	r3, [r3, #16]
 80a4be6:	4798      	blx	r3
 80a4be8:	2803      	cmp	r0, #3
 80a4bea:	ddbb      	ble.n	80a4b64 <_Z7nexLoopPP8NexTouch+0x10>
      {
        __buffer[0] = c;
 80a4bec:	7026      	strb	r6, [r4, #0]
 80a4bee:	4e29      	ldr	r6, [pc, #164]	; (80a4c94 <_Z7nexLoopPP8NexTouch+0x140>)
 80a4bf0:	f106 0a04 	add.w	sl, r6, #4
 80a4bf4:	f106 39ff 	add.w	r9, r6, #4294967295
        for (i = 1; i < 5; i++)
        {
          __buffer[i] = nexSerial.read();
 80a4bf8:	682b      	ldr	r3, [r5, #0]
 80a4bfa:	4628      	mov	r0, r5
 80a4bfc:	695b      	ldr	r3, [r3, #20]
 80a4bfe:	4798      	blx	r3
 80a4c00:	f806 0b01 	strb.w	r0, [r6], #1
    {
      dbSerialPrint("page cmd:");
      if (nexSerial.available() >= 4)
      {
        __buffer[0] = c;
        for (i = 1; i < 5; i++)
 80a4c04:	45b2      	cmp	sl, r6
 80a4c06:	d1f7      	bne.n	80a4bf8 <_Z7nexLoopPP8NexTouch+0xa4>
        {
          __buffer[i] = nexSerial.read();
        }
        __buffer[i] = 0x00;

        if (0xFF == __buffer[2] && 0xFF == __buffer[3] && 0xFF == __buffer[4])
 80a4c08:	f899 3002 	ldrb.w	r3, [r9, #2]
        __buffer[0] = c;
        for (i = 1; i < 5; i++)
        {
          __buffer[i] = nexSerial.read();
        }
        __buffer[i] = 0x00;
 80a4c0c:	2200      	movs	r2, #0

        if (0xFF == __buffer[2] && 0xFF == __buffer[3] && 0xFF == __buffer[4])
 80a4c0e:	2bff      	cmp	r3, #255	; 0xff
        __buffer[0] = c;
        for (i = 1; i < 5; i++)
        {
          __buffer[i] = nexSerial.read();
        }
        __buffer[i] = 0x00;
 80a4c10:	f889 2005 	strb.w	r2, [r9, #5]

        if (0xFF == __buffer[2] && 0xFF == __buffer[3] && 0xFF == __buffer[4])
 80a4c14:	d1a6      	bne.n	80a4b64 <_Z7nexLoopPP8NexTouch+0x10>
 80a4c16:	78e3      	ldrb	r3, [r4, #3]
 80a4c18:	2bff      	cmp	r3, #255	; 0xff
 80a4c1a:	d1a3      	bne.n	80a4b64 <_Z7nexLoopPP8NexTouch+0x10>
 80a4c1c:	7923      	ldrb	r3, [r4, #4]
 80a4c1e:	2bff      	cmp	r3, #255	; 0xff
 80a4c20:	d1a0      	bne.n	80a4b64 <_Z7nexLoopPP8NexTouch+0x10>
        {
          dbSerialPrintln(__buffer[1]);
          NexTouch::iterate(nex_listen_list, __buffer[1], 0, (int32_t)NEX_EVENT_PUSH, NULL);
 80a4c22:	7861      	ldrb	r1, [r4, #1]
 80a4c24:	9200      	str	r2, [sp, #0]
 80a4c26:	2301      	movs	r3, #1
 80a4c28:	e027      	b.n	80a4c7a <_Z7nexLoopPP8NexTouch+0x126>
        }

      }
    }
    else if (NEX_RET_VALUE_HEAD == c)
 80a4c2a:	2e72      	cmp	r6, #114	; 0x72
 80a4c2c:	d19a      	bne.n	80a4b64 <_Z7nexLoopPP8NexTouch+0x10>
    {
      dbSerialPrint("value cmd:");
      if (nexSerial.available() >= 10)
 80a4c2e:	682b      	ldr	r3, [r5, #0]
 80a4c30:	4628      	mov	r0, r5
 80a4c32:	691b      	ldr	r3, [r3, #16]
 80a4c34:	4798      	blx	r3
 80a4c36:	2809      	cmp	r0, #9
 80a4c38:	dd94      	ble.n	80a4b64 <_Z7nexLoopPP8NexTouch+0x10>
      {
        __buffer[0] = c;
 80a4c3a:	7026      	strb	r6, [r4, #0]
 80a4c3c:	4e15      	ldr	r6, [pc, #84]	; (80a4c94 <_Z7nexLoopPP8NexTouch+0x140>)
 80a4c3e:	f106 39ff 	add.w	r9, r6, #4294967295
        for (i = 1; i < 12; i++)
        {
          __buffer[i] = nexSerial.read();
 80a4c42:	682b      	ldr	r3, [r5, #0]
 80a4c44:	4628      	mov	r0, r5
 80a4c46:	695b      	ldr	r3, [r3, #20]
 80a4c48:	4798      	blx	r3
 80a4c4a:	f806 0b01 	strb.w	r0, [r6], #1
    {
      dbSerialPrint("value cmd:");
      if (nexSerial.available() >= 10)
      {
        __buffer[0] = c;
        for (i = 1; i < 12; i++)
 80a4c4e:	45b0      	cmp	r8, r6
 80a4c50:	d1f7      	bne.n	80a4c42 <_Z7nexLoopPP8NexTouch+0xee>
        {
          __buffer[i] = nexSerial.read();
        }
        __buffer[i] = 0x00;
 80a4c52:	2300      	movs	r3, #0
 80a4c54:	f889 300c 	strb.w	r3, [r9, #12]

        if (0xFF == __buffer[i - 1] && 0xFF == __buffer[i - 2] && 0xFF == __buffer[i - 3])
 80a4c58:	f899 300b 	ldrb.w	r3, [r9, #11]
 80a4c5c:	2bff      	cmp	r3, #255	; 0xff
 80a4c5e:	d181      	bne.n	80a4b64 <_Z7nexLoopPP8NexTouch+0x10>
 80a4c60:	7aa3      	ldrb	r3, [r4, #10]
 80a4c62:	2bff      	cmp	r3, #255	; 0xff
 80a4c64:	f47f af7e 	bne.w	80a4b64 <_Z7nexLoopPP8NexTouch+0x10>
 80a4c68:	7a63      	ldrb	r3, [r4, #9]
 80a4c6a:	2bff      	cmp	r3, #255	; 0xff
 80a4c6c:	f47f af7a 	bne.w	80a4b64 <_Z7nexLoopPP8NexTouch+0x10>
          dbSerialPrint(" Component:");
          dbSerialPrint(__buffer[2]);
          dbSerialPrint(" Value:");
          i = __buffer[4] | (((unsigned long)__buffer[5]) << 8) | (((unsigned long)__buffer[6]) << 16) | (((unsigned long)__buffer[6]) << 24);
          dbSerialPrintln(i);
          NexTouch::iterate(nex_listen_list, __buffer[1], __buffer[2], (int32_t)__buffer[3], (void *)&(__buffer[4]));
 80a4c70:	78e3      	ldrb	r3, [r4, #3]
 80a4c72:	78a2      	ldrb	r2, [r4, #2]
 80a4c74:	7861      	ldrb	r1, [r4, #1]
 80a4c76:	4808      	ldr	r0, [pc, #32]	; (80a4c98 <_Z7nexLoopPP8NexTouch+0x144>)
 80a4c78:	9000      	str	r0, [sp, #0]
 80a4c7a:	4638      	mov	r0, r7
 80a4c7c:	f000 f92a 	bl	80a4ed4 <_ZN8NexTouch7iterateEPPS_hhlPv>
 80a4c80:	e770      	b.n	80a4b64 <_Z7nexLoopPP8NexTouch+0x10>
        }
      }
    }
  }
}
 80a4c82:	b002      	add	sp, #8
 80a4c84:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a4c88:	200004b8 	.word	0x200004b8
 80a4c8c:	20001058 	.word	0x20001058
 80a4c90:	20001544 	.word	0x20001544
 80a4c94:	20001059 	.word	0x20001059
 80a4c98:	2000105c 	.word	0x2000105c

080a4c9c <_Z11setBaudratem>:
*
* @retval true - success.
* @retval false - failed.
*/
bool setBaudrate(uint32_t baudrate)
{
 80a4c9c:	b530      	push	{r4, r5, lr}
  bool ret = false;
  char cmd[16] = "baud=";
 80a4c9e:	4b1a      	ldr	r3, [pc, #104]	; (80a4d08 <_Z11setBaudratem+0x6c>)
*
* @retval true - success.
* @retval false - failed.
*/
bool setBaudrate(uint32_t baudrate)
{
 80a4ca0:	4605      	mov	r5, r0
  bool ret = false;
  char cmd[16] = "baud=";
 80a4ca2:	f853 0f20 	ldr.w	r0, [r3, #32]!
*
* @retval true - success.
* @retval false - failed.
*/
bool setBaudrate(uint32_t baudrate)
{
 80a4ca6:	b085      	sub	sp, #20
  bool ret = false;
  char cmd[16] = "baud=";
 80a4ca8:	889b      	ldrh	r3, [r3, #4]
 80a4caa:	9000      	str	r0, [sp, #0]
 80a4cac:	f8ad 3004 	strh.w	r3, [sp, #4]

  utoa(baudrate, &cmd[strlen(cmd)], 10);
 80a4cb0:	4668      	mov	r0, sp
* @retval false - failed.
*/
bool setBaudrate(uint32_t baudrate)
{
  bool ret = false;
  char cmd[16] = "baud=";
 80a4cb2:	2300      	movs	r3, #0
 80a4cb4:	f8cd 3006 	str.w	r3, [sp, #6]
 80a4cb8:	f8cd 300a 	str.w	r3, [sp, #10]
 80a4cbc:	f8ad 300e 	strh.w	r3, [sp, #14]

  utoa(baudrate, &cmd[strlen(cmd)], 10);
 80a4cc0:	f002 fe73 	bl	80a79aa <strlen>
 80a4cc4:	220a      	movs	r2, #10
 80a4cc6:	eb0d 0100 	add.w	r1, sp, r0
 80a4cca:	4628      	mov	r0, r5
 80a4ccc:	f000 fdb7 	bl	80a583e <utoa>
  sendCommand(cmd);           // send in new baudrate using the current baudrate
 80a4cd0:	4668      	mov	r0, sp
 80a4cd2:	f7ff fedb 	bl	80a4a8c <_Z11sendCommandPKc>
  delay(10);
 80a4cd6:	200a      	movs	r0, #10
 80a4cd8:	f001 f810 	bl	80a5cfc <delay>

  nexSerial.flush();          // dump all returned data, since not usable with new baudrate
 80a4cdc:	4b0b      	ldr	r3, [pc, #44]	; (80a4d0c <_Z11setBaudratem+0x70>)
 80a4cde:	681c      	ldr	r4, [r3, #0]
 80a4ce0:	6823      	ldr	r3, [r4, #0]
 80a4ce2:	4620      	mov	r0, r4
 80a4ce4:	69db      	ldr	r3, [r3, #28]
 80a4ce6:	4798      	blx	r3
  nexSerial.end();            // close port (or pretend to ;-)
 80a4ce8:	4620      	mov	r0, r4
 80a4cea:	f001 fee6 	bl	80a6aba <_ZN11USARTSerial3endEv>
  nexSerial.begin(baudrate);  // activate new baudrate on MCU side too
 80a4cee:	4629      	mov	r1, r5
 80a4cf0:	4620      	mov	r0, r4
 80a4cf2:	f001 fedf 	bl	80a6ab4 <_ZN11USARTSerial5beginEm>
  sendCommand("");            // trigger test transmission
 80a4cf6:	4806      	ldr	r0, [pc, #24]	; (80a4d10 <_Z11setBaudratem+0x74>)
 80a4cf8:	f7ff fec8 	bl	80a4a8c <_Z11sendCommandPKc>

  if (recvRetCommandFinished())
 80a4cfc:	2064      	movs	r0, #100	; 0x64
 80a4cfe:	f7ff fedd 	bl	80a4abc <_Z22recvRetCommandFinishedm>
  {
    dbSerialPrintln("setBaudrate err ");
  }

  return ret;
}
 80a4d02:	b005      	add	sp, #20
 80a4d04:	bd30      	pop	{r4, r5, pc}
 80a4d06:	bf00      	nop
 80a4d08:	080a9228 	.word	0x080a9228
 80a4d0c:	200004b8 	.word	0x200004b8
 80a4d10:	080a92e8 	.word	0x080a92e8

080a4d14 <_Z11NexSetValuePKcS0_m>:
  sendCommand(cmd);
  return recvRetNumber(value);
}

bool NexSetValue(const char* objName, const char* valueType, uint32_t value)
{
 80a4d14:	b530      	push	{r4, r5, lr}
 80a4d16:	460d      	mov	r5, r1
 80a4d18:	b089      	sub	sp, #36	; 0x24
  char cmd[32];
  //snprintf(cmd, sizeof(cmd), "%s.%s=%d", objName, valueType, value);
  strcpy(cmd, objName);
 80a4d1a:	4601      	mov	r1, r0
 80a4d1c:	4668      	mov	r0, sp
  sendCommand(cmd);
  return recvRetNumber(value);
}

bool NexSetValue(const char* objName, const char* valueType, uint32_t value)
{
 80a4d1e:	4614      	mov	r4, r2
  char cmd[32];
  //snprintf(cmd, sizeof(cmd), "%s.%s=%d", objName, valueType, value);
  strcpy(cmd, objName);
 80a4d20:	f002 fe1f 	bl	80a7962 <strcpy>
  strcat(cmd, ".");
 80a4d24:	490e      	ldr	r1, [pc, #56]	; (80a4d60 <_Z11NexSetValuePKcS0_m+0x4c>)
 80a4d26:	4668      	mov	r0, sp
 80a4d28:	f002 fe02 	bl	80a7930 <strcat>
  strcat(cmd, valueType);
 80a4d2c:	4629      	mov	r1, r5
 80a4d2e:	4668      	mov	r0, sp
 80a4d30:	f002 fdfe 	bl	80a7930 <strcat>
  strcat(cmd, "=");
 80a4d34:	490b      	ldr	r1, [pc, #44]	; (80a4d64 <_Z11NexSetValuePKcS0_m+0x50>)
 80a4d36:	4668      	mov	r0, sp
 80a4d38:	f002 fdfa 	bl	80a7930 <strcat>
  utoa(value, &cmd[strlen(cmd)], 10);
 80a4d3c:	4668      	mov	r0, sp
 80a4d3e:	f002 fe34 	bl	80a79aa <strlen>
 80a4d42:	220a      	movs	r2, #10
 80a4d44:	eb0d 0100 	add.w	r1, sp, r0
 80a4d48:	4620      	mov	r0, r4
 80a4d4a:	f000 fd78 	bl	80a583e <utoa>
  sendCommand(cmd);
 80a4d4e:	4668      	mov	r0, sp
 80a4d50:	f7ff fe9c 	bl	80a4a8c <_Z11sendCommandPKc>
  return recvRetCommandFinished();
 80a4d54:	2064      	movs	r0, #100	; 0x64
 80a4d56:	f7ff feb1 	bl	80a4abc <_Z22recvRetCommandFinishedm>
}
 80a4d5a:	b009      	add	sp, #36	; 0x24
 80a4d5c:	bd30      	pop	{r4, r5, pc}
 80a4d5e:	bf00      	nop
 80a4d60:	080a82c2 	.word	0x080a82c2
 80a4d64:	080a92a2 	.word	0x080a92a2

080a4d68 <_Z12NexGetStringPKcS0_Pct>:

uint16_t NexGetString(const char* objName, const char* valueType, char* text, uint16_t len)
{
 80a4d68:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a4d6a:	4607      	mov	r7, r0
 80a4d6c:	460e      	mov	r6, r1
 80a4d6e:	4614      	mov	r4, r2
 80a4d70:	461d      	mov	r5, r3
  //char cmd[32];
  //snprintf(cmd, sizeof(cmd), "get %s.%s", objName, valueType);
  char cmd[32] = "get ";
 80a4d72:	4a12      	ldr	r2, [pc, #72]	; (80a4dbc <_Z12NexGetStringPKcS0_Pct+0x54>)
  sendCommand(cmd);
  return recvRetCommandFinished();
}

uint16_t NexGetString(const char* objName, const char* valueType, char* text, uint16_t len)
{
 80a4d74:	b089      	sub	sp, #36	; 0x24
  //char cmd[32];
  //snprintf(cmd, sizeof(cmd), "get %s.%s", objName, valueType);
  char cmd[32] = "get ";
 80a4d76:	f852 0f30 	ldr.w	r0, [r2, #48]!
 80a4d7a:	2100      	movs	r1, #0
 80a4d7c:	7913      	ldrb	r3, [r2, #4]
 80a4d7e:	9000      	str	r0, [sp, #0]
 80a4d80:	221b      	movs	r2, #27
 80a4d82:	f10d 0005 	add.w	r0, sp, #5
 80a4d86:	f88d 3004 	strb.w	r3, [sp, #4]
 80a4d8a:	f002 fd66 	bl	80a785a <memset>
  strcat(cmd, objName);
 80a4d8e:	4639      	mov	r1, r7
 80a4d90:	4668      	mov	r0, sp
 80a4d92:	f002 fdcd 	bl	80a7930 <strcat>
  strcat(cmd, ".");
 80a4d96:	490a      	ldr	r1, [pc, #40]	; (80a4dc0 <_Z12NexGetStringPKcS0_Pct+0x58>)
 80a4d98:	4668      	mov	r0, sp
 80a4d9a:	f002 fdc9 	bl	80a7930 <strcat>
  strcat(cmd, valueType);
 80a4d9e:	4631      	mov	r1, r6
 80a4da0:	4668      	mov	r0, sp
 80a4da2:	f002 fdc5 	bl	80a7930 <strcat>
  sendCommand(cmd);
 80a4da6:	4668      	mov	r0, sp
 80a4da8:	f7ff fe70 	bl	80a4a8c <_Z11sendCommandPKc>
  return recvRetString(text, len);
 80a4dac:	2264      	movs	r2, #100	; 0x64
 80a4dae:	4629      	mov	r1, r5
 80a4db0:	4620      	mov	r0, r4
 80a4db2:	f7ff fe09 	bl	80a49c8 <_Z13recvRetStringPctm>
}
 80a4db6:	b009      	add	sp, #36	; 0x24
 80a4db8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a4dba:	bf00      	nop
 80a4dbc:	080a9228 	.word	0x080a9228
 80a4dc0:	080a82c2 	.word	0x080a82c2

080a4dc4 <_Z12NexSetStringPKcS0_S0_>:

bool NexSetString(const char* objName, const char* valueType, const char* text)
{
 80a4dc4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a4dc6:	4606      	mov	r6, r0
 80a4dc8:	af00      	add	r7, sp, #0
  char cmd[strlen(text) + 32];
 80a4dca:	4610      	mov	r0, r2
  sendCommand(cmd);
  return recvRetString(text, len);
}

bool NexSetString(const char* objName, const char* valueType, const char* text)
{
 80a4dcc:	460d      	mov	r5, r1
 80a4dce:	4614      	mov	r4, r2
  char cmd[strlen(text) + 32];
 80a4dd0:	f002 fdeb 	bl	80a79aa <strlen>
 80a4dd4:	f100 0327 	add.w	r3, r0, #39	; 0x27
 80a4dd8:	f023 0307 	bic.w	r3, r3, #7
 80a4ddc:	ebad 0d03 	sub.w	sp, sp, r3
  memset(cmd, 0, sizeof(cmd));
 80a4de0:	f100 0220 	add.w	r2, r0, #32
 80a4de4:	2100      	movs	r1, #0
 80a4de6:	4668      	mov	r0, sp
 80a4de8:	f002 fd37 	bl	80a785a <memset>
  //snprintf(cmd, sizeof(cmd), "%s.%s=\"%s\"", objName, valueType, text);
  strcpy(cmd, objName);
 80a4dec:	4631      	mov	r1, r6
 80a4dee:	4668      	mov	r0, sp
 80a4df0:	f002 fdb7 	bl	80a7962 <strcpy>
  strcat(cmd, ".");
 80a4df4:	490d      	ldr	r1, [pc, #52]	; (80a4e2c <_Z12NexSetStringPKcS0_S0_+0x68>)
 80a4df6:	4668      	mov	r0, sp
 80a4df8:	f002 fd9a 	bl	80a7930 <strcat>
  strcat(cmd, valueType);
 80a4dfc:	4629      	mov	r1, r5
 80a4dfe:	4668      	mov	r0, sp
 80a4e00:	f002 fd96 	bl	80a7930 <strcat>
  strcat(cmd, "=\"");
 80a4e04:	490a      	ldr	r1, [pc, #40]	; (80a4e30 <_Z12NexSetStringPKcS0_S0_+0x6c>)
 80a4e06:	4668      	mov	r0, sp
 80a4e08:	f002 fd92 	bl	80a7930 <strcat>
  strcat(cmd, text);
 80a4e0c:	4621      	mov	r1, r4
 80a4e0e:	4668      	mov	r0, sp
 80a4e10:	f002 fd8e 	bl	80a7930 <strcat>
  strcat(cmd, "\"");
 80a4e14:	4907      	ldr	r1, [pc, #28]	; (80a4e34 <_Z12NexSetStringPKcS0_S0_+0x70>)
 80a4e16:	4668      	mov	r0, sp
 80a4e18:	f002 fd8a 	bl	80a7930 <strcat>
  sendCommand(cmd);
 80a4e1c:	4668      	mov	r0, sp
 80a4e1e:	f7ff fe35 	bl	80a4a8c <_Z11sendCommandPKc>
  return recvRetCommandFinished();
 80a4e22:	2064      	movs	r0, #100	; 0x64
 80a4e24:	f7ff fe4a 	bl	80a4abc <_Z22recvRetCommandFinishedm>
}
 80a4e28:	46bd      	mov	sp, r7
 80a4e2a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a4e2c:	080a82c2 	.word	0x080a82c2
 80a4e30:	080a92aa 	.word	0x080a92aa
 80a4e34:	080a92ab 	.word	0x080a92ab

080a4e38 <_GLOBAL__sub_I_bkCmd>:
 80a4e38:	f000 b886 	b.w	80a4f48 <HAL_Pin_Map>

080a4e3c <_GLOBAL__sub_I__ZN10NexHotspotC2EhhPKcPv>:
 80a4e3c:	f000 b884 	b.w	80a4f48 <HAL_Pin_Map>

080a4e40 <_GLOBAL__sub_I__ZN7NexPageC2EhhPKcPv>:
 80a4e40:	f000 b882 	b.w	80a4f48 <HAL_Pin_Map>

080a4e44 <_ZN7NexTextC1EhhPKcPv>:
* by BSpranger & ScruffR (Dec. 2015)
*/

#include "NexText.h"

NexText::NexText(uint8_t pid, uint8_t cid, const char *name, void *value)
 80a4e44:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a4e46:	4604      	mov	r4, r0
    :NexTouch(pid, cid, name, value)
 80a4e48:	9d06      	ldr	r5, [sp, #24]
 80a4e4a:	9500      	str	r5, [sp, #0]
 80a4e4c:	f000 f816 	bl	80a4e7c <_ZN8NexTouchC1EhhPKcPv>
{
}
 80a4e50:	4620      	mov	r0, r4
 80a4e52:	b003      	add	sp, #12
 80a4e54:	bd30      	pop	{r4, r5, pc}
	...

080a4e58 <_ZN7NexText7getTextEPct>:

uint16_t NexText::getText(char *buffer, uint16_t len)
{
  return NexObject::getString(NexTEXT, buffer, len);
 80a4e58:	4613      	mov	r3, r2
 80a4e5a:	460a      	mov	r2, r1
 80a4e5c:	4901      	ldr	r1, [pc, #4]	; (80a4e64 <_ZN7NexText7getTextEPct+0xc>)
 80a4e5e:	f7ff bd99 	b.w	80a4994 <_ZN9NexObject9getStringEPKcPct>
 80a4e62:	bf00      	nop
 80a4e64:	080a92ad 	.word	0x080a92ad

080a4e68 <_ZN7NexText7setTextEPKc>:
  //return recvRetString(text, len);
}

bool NexText::setText(const char *buffer)
{
  return NexObject::setString(NexTEXT, buffer);
 80a4e68:	460a      	mov	r2, r1
 80a4e6a:	4901      	ldr	r1, [pc, #4]	; (80a4e70 <_ZN7NexText7setTextEPKc+0x8>)
 80a4e6c:	f7ff bd95 	b.w	80a499a <_ZN9NexObject9setStringEPKcS1_>
 80a4e70:	080a92ad 	.word	0x080a92ad

080a4e74 <_GLOBAL__sub_I__ZN7NexTextC2EhhPKcPv>:
 80a4e74:	f000 b868 	b.w	80a4f48 <HAL_Pin_Map>

080a4e78 <_GLOBAL__sub_I__ZN10NexPictureC2EhhPKcPv>:
 80a4e78:	f000 b866 	b.w	80a4f48 <HAL_Pin_Map>

080a4e7c <_ZN8NexTouchC1EhhPKcPv>:
*/

#include "NexTouch.h"


NexTouch::NexTouch(uint8_t pid, uint8_t cid, const char *name, void *value)
 80a4e7c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a4e7e:	4604      	mov	r4, r0
    :NexObject(pid, cid, name, value)
 80a4e80:	9d06      	ldr	r5, [sp, #24]
 80a4e82:	9500      	str	r5, [sp, #0]
 80a4e84:	f7ff fd70 	bl	80a4968 <_ZN9NexObjectC1EhhPKcPv>
    this->__cb_pop = NULL;
    this->__cb_value = NULL;
    this->__cbpop_ptr = NULL;
    this->__cbpush_ptr = NULL;
    this->__cbvalue_ptr = NULL;
}
 80a4e88:	4620      	mov	r0, r4


NexTouch::NexTouch(uint8_t pid, uint8_t cid, const char *name, void *value)
    :NexObject(pid, cid, name, value)
{
    this->__cb_push = NULL;
 80a4e8a:	2300      	movs	r3, #0
 80a4e8c:	60e3      	str	r3, [r4, #12]
    this->__cb_pop = NULL;
 80a4e8e:	6163      	str	r3, [r4, #20]
    this->__cb_value = NULL;
 80a4e90:	61e3      	str	r3, [r4, #28]
    this->__cbpop_ptr = NULL;
 80a4e92:	61a3      	str	r3, [r4, #24]
    this->__cbpush_ptr = NULL;
 80a4e94:	6123      	str	r3, [r4, #16]
    this->__cbvalue_ptr = NULL;
 80a4e96:	6223      	str	r3, [r4, #32]
}
 80a4e98:	b003      	add	sp, #12
 80a4e9a:	bd30      	pop	{r4, r5, pc}

080a4e9c <_ZN8NexTouch10attachPushEPFvPvES0_>:

void NexTouch::attachPush(NexTouchEventCb push, void *ptr)
{
    this->__cb_push = push;
 80a4e9c:	60c1      	str	r1, [r0, #12]
    this->__cbpush_ptr = ptr;
 80a4e9e:	6102      	str	r2, [r0, #16]
 80a4ea0:	4770      	bx	lr

080a4ea2 <_ZN8NexTouch9attachPopEPFvPvES0_>:
    this->__cbpush_ptr = NULL;
}

void NexTouch::attachPop(NexTouchEventCb pop, void *ptr)
{
    this->__cb_pop = pop;
 80a4ea2:	6141      	str	r1, [r0, #20]
    this->__cbpop_ptr = ptr;
 80a4ea4:	6182      	str	r2, [r0, #24]
 80a4ea6:	4770      	bx	lr

080a4ea8 <_ZN8NexTouch4pushEv>:
    this->__cbvalue_ptr = NULL;
}

void NexTouch::push(void)
{
    if (__cb_push)
 80a4ea8:	68c3      	ldr	r3, [r0, #12]
 80a4eaa:	b10b      	cbz	r3, 80a4eb0 <_ZN8NexTouch4pushEv+0x8>
    {
        __cb_push(__cbpush_ptr);
 80a4eac:	6900      	ldr	r0, [r0, #16]
 80a4eae:	4718      	bx	r3
 80a4eb0:	4770      	bx	lr

080a4eb2 <_ZN8NexTouch3popEv>:
    }
}

void NexTouch::pop(void)
{
    if (__cb_pop)
 80a4eb2:	6943      	ldr	r3, [r0, #20]
 80a4eb4:	b10b      	cbz	r3, 80a4eba <_ZN8NexTouch3popEv+0x8>
    {
        __cb_pop(__cbpop_ptr);
 80a4eb6:	6980      	ldr	r0, [r0, #24]
 80a4eb8:	4718      	bx	r3
 80a4eba:	4770      	bx	lr

080a4ebc <_ZN8NexTouch5valueEhPv>:
    }
}

void NexTouch::value(uint8_t type, void *value)
{
 80a4ebc:	b510      	push	{r4, lr}
 80a4ebe:	4604      	mov	r4, r0
    ((NexObject *)__cbvalue_ptr)->setObjValue(type, value);
 80a4ec0:	6a00      	ldr	r0, [r0, #32]
 80a4ec2:	f7ff fd58 	bl	80a4976 <_ZN9NexObject11setObjValueEhPv>

    if (__cb_value)
 80a4ec6:	69e3      	ldr	r3, [r4, #28]
 80a4ec8:	b11b      	cbz	r3, 80a4ed2 <_ZN8NexTouch5valueEhPv+0x16>
    {
        __cb_value(__cbvalue_ptr);
 80a4eca:	6a20      	ldr	r0, [r4, #32]
    }
}
 80a4ecc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
{
    ((NexObject *)__cbvalue_ptr)->setObjValue(type, value);

    if (__cb_value)
    {
        __cb_value(__cbvalue_ptr);
 80a4ed0:	4718      	bx	r3
 80a4ed2:	bd10      	pop	{r4, pc}

080a4ed4 <_ZN8NexTouch7iterateEPPS_hhlPv>:
    }
}
void NexTouch::iterate(NexTouch **list, uint8_t pid, uint8_t cid, int32_t event, void *value)
{
 80a4ed4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80a4ed8:	f8dd 8020 	ldr.w	r8, [sp, #32]
 80a4edc:	4689      	mov	r9, r1
 80a4ede:	4692      	mov	sl, r2
 80a4ee0:	461d      	mov	r5, r3
    NexTouch *e = NULL;
    uint16_t i = 0;

    if (NULL == list)
 80a4ee2:	4607      	mov	r7, r0
 80a4ee4:	b358      	cbz	r0, 80a4f3e <_ZN8NexTouch7iterateEPPS_hhlPv+0x6a>
 80a4ee6:	2600      	movs	r6, #0
    {
        return;
    }
    
    for(i = 0; (e = list[i]) != NULL; i++)
 80a4ee8:	b2b3      	uxth	r3, r6
 80a4eea:	f857 4023 	ldr.w	r4, [r7, r3, lsl #2]
 80a4eee:	b334      	cbz	r4, 80a4f3e <_ZN8NexTouch7iterateEPPS_hhlPv+0x6a>
    {
        if (e->getObjPid() == pid && e->getObjCid() == cid)
 80a4ef0:	4620      	mov	r0, r4
 80a4ef2:	f7ff fd47 	bl	80a4984 <_ZN9NexObject9getObjPidEv>
 80a4ef6:	4548      	cmp	r0, r9
 80a4ef8:	d11f      	bne.n	80a4f3a <_ZN8NexTouch7iterateEPPS_hhlPv+0x66>
 80a4efa:	4620      	mov	r0, r4
 80a4efc:	f7ff fd44 	bl	80a4988 <_ZN9NexObject9getObjCidEv>
 80a4f00:	4550      	cmp	r0, sl
 80a4f02:	d11a      	bne.n	80a4f3a <_ZN8NexTouch7iterateEPPS_hhlPv+0x66>
        {
            e->printObjInfo();
 80a4f04:	4620      	mov	r0, r4
 80a4f06:	f7ff fd41 	bl	80a498c <_ZN9NexObject12printObjInfoEv>
            if (NEX_EVENT_PUSH == event)
 80a4f0a:	2d01      	cmp	r5, #1
 80a4f0c:	d104      	bne.n	80a4f18 <_ZN8NexTouch7iterateEPPS_hhlPv+0x44>
            {
                e->push();
 80a4f0e:	4620      	mov	r0, r4
            }
            
            break;
        }
    }
}
 80a4f10:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        if (e->getObjPid() == pid && e->getObjCid() == cid)
        {
            e->printObjInfo();
            if (NEX_EVENT_PUSH == event)
            {
                e->push();
 80a4f14:	f7ff bfc8 	b.w	80a4ea8 <_ZN8NexTouch4pushEv>
            }
            else if (NEX_EVENT_POP == event)
 80a4f18:	b925      	cbnz	r5, 80a4f24 <_ZN8NexTouch7iterateEPPS_hhlPv+0x50>
            {
                e->pop();
 80a4f1a:	4620      	mov	r0, r4
            }
            
            break;
        }
    }
}
 80a4f1c:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
            {
                e->push();
            }
            else if (NEX_EVENT_POP == event)
            {
                e->pop();
 80a4f20:	f7ff bfc7 	b.w	80a4eb2 <_ZN8NexTouch3popEv>
            }
            else if (NEX_EVENT_VALUE == event)
 80a4f24:	2d02      	cmp	r5, #2
 80a4f26:	d001      	beq.n	80a4f2c <_ZN8NexTouch7iterateEPPS_hhlPv+0x58>
            {
                e->value(NEX_EVENT_VALUE, value);
            }
            else if (NEX_EVENT_STRING == event)
 80a4f28:	2d03      	cmp	r5, #3
 80a4f2a:	d108      	bne.n	80a4f3e <_ZN8NexTouch7iterateEPPS_hhlPv+0x6a>
            {
                e->value(NEX_EVENT_STRING, value);
 80a4f2c:	4642      	mov	r2, r8
 80a4f2e:	4629      	mov	r1, r5
 80a4f30:	4620      	mov	r0, r4
            }
            
            break;
        }
    }
}
 80a4f32:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
            {
                e->value(NEX_EVENT_VALUE, value);
            }
            else if (NEX_EVENT_STRING == event)
            {
                e->value(NEX_EVENT_STRING, value);
 80a4f36:	f7ff bfc1 	b.w	80a4ebc <_ZN8NexTouch5valueEhPv>
 80a4f3a:	3601      	adds	r6, #1
    if (NULL == list)
    {
        return;
    }
    
    for(i = 0; (e = list[i]) != NULL; i++)
 80a4f3c:	e7d4      	b.n	80a4ee8 <_ZN8NexTouch7iterateEPPS_hhlPv+0x14>
 80a4f3e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

080a4f42 <_GLOBAL__sub_I__ZN8NexTouchC2EhhPKcPv>:
 80a4f42:	f000 b801 	b.w	80a4f48 <HAL_Pin_Map>
	...

080a4f48 <HAL_Pin_Map>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_gpio)

DYNALIB_FN(0, hal_gpio, HAL_Pin_Map, STM32_Pin_Info*(void))
 80a4f48:	b508      	push	{r3, lr}
 80a4f4a:	4b02      	ldr	r3, [pc, #8]	; (80a4f54 <HAL_Pin_Map+0xc>)
 80a4f4c:	681b      	ldr	r3, [r3, #0]
 80a4f4e:	681b      	ldr	r3, [r3, #0]
 80a4f50:	9301      	str	r3, [sp, #4]
 80a4f52:	bd08      	pop	{r3, pc}
 80a4f54:	080601b0 	.word	0x080601b0

080a4f58 <HAL_Pin_Mode>:
DYNALIB_FN(1, hal_gpio, HAL_Validate_Pin_Function, PinFunction(pin_t, PinFunction))
DYNALIB_FN(2, hal_gpio, HAL_Pin_Mode, void(pin_t, PinMode))
 80a4f58:	b508      	push	{r3, lr}
 80a4f5a:	4b02      	ldr	r3, [pc, #8]	; (80a4f64 <HAL_Pin_Mode+0xc>)
 80a4f5c:	681b      	ldr	r3, [r3, #0]
 80a4f5e:	689b      	ldr	r3, [r3, #8]
 80a4f60:	9301      	str	r3, [sp, #4]
 80a4f62:	bd08      	pop	{r3, pc}
 80a4f64:	080601b0 	.word	0x080601b0

080a4f68 <HAL_Get_Pin_Mode>:
DYNALIB_FN(3, hal_gpio, HAL_Get_Pin_Mode, PinMode(pin_t))
 80a4f68:	b508      	push	{r3, lr}
 80a4f6a:	4b02      	ldr	r3, [pc, #8]	; (80a4f74 <HAL_Get_Pin_Mode+0xc>)
 80a4f6c:	681b      	ldr	r3, [r3, #0]
 80a4f6e:	68db      	ldr	r3, [r3, #12]
 80a4f70:	9301      	str	r3, [sp, #4]
 80a4f72:	bd08      	pop	{r3, pc}
 80a4f74:	080601b0 	.word	0x080601b0

080a4f78 <HAL_GPIO_Write>:
DYNALIB_FN(4, hal_gpio, HAL_GPIO_Write, void(pin_t, uint8_t))
 80a4f78:	b508      	push	{r3, lr}
 80a4f7a:	4b02      	ldr	r3, [pc, #8]	; (80a4f84 <HAL_GPIO_Write+0xc>)
 80a4f7c:	681b      	ldr	r3, [r3, #0]
 80a4f7e:	691b      	ldr	r3, [r3, #16]
 80a4f80:	9301      	str	r3, [sp, #4]
 80a4f82:	bd08      	pop	{r3, pc}
 80a4f84:	080601b0 	.word	0x080601b0

080a4f88 <HAL_GPIO_Read>:
DYNALIB_FN(5, hal_gpio, HAL_GPIO_Read, int32_t(pin_t))
 80a4f88:	b508      	push	{r3, lr}
 80a4f8a:	4b02      	ldr	r3, [pc, #8]	; (80a4f94 <HAL_GPIO_Read+0xc>)
 80a4f8c:	681b      	ldr	r3, [r3, #0]
 80a4f8e:	695b      	ldr	r3, [r3, #20]
 80a4f90:	9301      	str	r3, [sp, #4]
 80a4f92:	bd08      	pop	{r3, pc}
 80a4f94:	080601b0 	.word	0x080601b0

080a4f98 <HAL_SPI_Begin>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_spi)

DYNALIB_FN(0, hal_spi, HAL_SPI_Begin, void(HAL_SPI_Interface, uint16_t))
 80a4f98:	b508      	push	{r3, lr}
 80a4f9a:	4b02      	ldr	r3, [pc, #8]	; (80a4fa4 <HAL_SPI_Begin+0xc>)
 80a4f9c:	681b      	ldr	r3, [r3, #0]
 80a4f9e:	681b      	ldr	r3, [r3, #0]
 80a4fa0:	9301      	str	r3, [sp, #4]
 80a4fa2:	bd08      	pop	{r3, pc}
 80a4fa4:	080601b4 	.word	0x080601b4

080a4fa8 <HAL_SPI_Set_Bit_Order>:
DYNALIB_FN(1, hal_spi, HAL_SPI_End, void(HAL_SPI_Interface))
DYNALIB_FN(2, hal_spi, HAL_SPI_Set_Bit_Order, void(HAL_SPI_Interface, uint8_t))
 80a4fa8:	b508      	push	{r3, lr}
 80a4faa:	4b02      	ldr	r3, [pc, #8]	; (80a4fb4 <HAL_SPI_Set_Bit_Order+0xc>)
 80a4fac:	681b      	ldr	r3, [r3, #0]
 80a4fae:	689b      	ldr	r3, [r3, #8]
 80a4fb0:	9301      	str	r3, [sp, #4]
 80a4fb2:	bd08      	pop	{r3, pc}
 80a4fb4:	080601b4 	.word	0x080601b4

080a4fb8 <HAL_SPI_Set_Data_Mode>:
DYNALIB_FN(3, hal_spi, HAL_SPI_Set_Data_Mode, void(HAL_SPI_Interface, uint8_t))
 80a4fb8:	b508      	push	{r3, lr}
 80a4fba:	4b02      	ldr	r3, [pc, #8]	; (80a4fc4 <HAL_SPI_Set_Data_Mode+0xc>)
 80a4fbc:	681b      	ldr	r3, [r3, #0]
 80a4fbe:	68db      	ldr	r3, [r3, #12]
 80a4fc0:	9301      	str	r3, [sp, #4]
 80a4fc2:	bd08      	pop	{r3, pc}
 80a4fc4:	080601b4 	.word	0x080601b4

080a4fc8 <HAL_SPI_Set_Clock_Divider>:
DYNALIB_FN(4, hal_spi, HAL_SPI_Set_Clock_Divider, void(HAL_SPI_Interface, uint8_t))
 80a4fc8:	b508      	push	{r3, lr}
 80a4fca:	4b02      	ldr	r3, [pc, #8]	; (80a4fd4 <HAL_SPI_Set_Clock_Divider+0xc>)
 80a4fcc:	681b      	ldr	r3, [r3, #0]
 80a4fce:	691b      	ldr	r3, [r3, #16]
 80a4fd0:	9301      	str	r3, [sp, #4]
 80a4fd2:	bd08      	pop	{r3, pc}
 80a4fd4:	080601b4 	.word	0x080601b4

080a4fd8 <HAL_SPI_Send_Receive_Data>:
DYNALIB_FN(5, hal_spi, HAL_SPI_Send_Receive_Data, uint16_t(HAL_SPI_Interface, uint16_t))
 80a4fd8:	b508      	push	{r3, lr}
 80a4fda:	4b02      	ldr	r3, [pc, #8]	; (80a4fe4 <HAL_SPI_Send_Receive_Data+0xc>)
 80a4fdc:	681b      	ldr	r3, [r3, #0]
 80a4fde:	695b      	ldr	r3, [r3, #20]
 80a4fe0:	9301      	str	r3, [sp, #4]
 80a4fe2:	bd08      	pop	{r3, pc}
 80a4fe4:	080601b4 	.word	0x080601b4

080a4fe8 <HAL_SPI_Init>:
DYNALIB_FN(6, hal_spi, HAL_SPI_Is_Enabled_Old, bool(void))
DYNALIB_FN(7, hal_spi, HAL_SPI_Init, void(HAL_SPI_Interface))
 80a4fe8:	b508      	push	{r3, lr}
 80a4fea:	4b02      	ldr	r3, [pc, #8]	; (80a4ff4 <HAL_SPI_Init+0xc>)
 80a4fec:	681b      	ldr	r3, [r3, #0]
 80a4fee:	69db      	ldr	r3, [r3, #28]
 80a4ff0:	9301      	str	r3, [sp, #4]
 80a4ff2:	bd08      	pop	{r3, pc}
 80a4ff4:	080601b4 	.word	0x080601b4

080a4ff8 <HAL_SPI_Is_Enabled>:
DYNALIB_FN(8, hal_spi, HAL_SPI_Is_Enabled, bool(HAL_SPI_Interface))
 80a4ff8:	b508      	push	{r3, lr}
 80a4ffa:	4b02      	ldr	r3, [pc, #8]	; (80a5004 <HAL_SPI_Is_Enabled+0xc>)
 80a4ffc:	681b      	ldr	r3, [r3, #0]
 80a4ffe:	6a1b      	ldr	r3, [r3, #32]
 80a5000:	9301      	str	r3, [sp, #4]
 80a5002:	bd08      	pop	{r3, pc}
 80a5004:	080601b4 	.word	0x080601b4

080a5008 <HAL_SPI_Info>:
DYNALIB_FN(9, hal_spi, HAL_SPI_Info, void(HAL_SPI_Interface, hal_spi_info_t*, void*))
 80a5008:	b508      	push	{r3, lr}
 80a500a:	4b02      	ldr	r3, [pc, #8]	; (80a5014 <HAL_SPI_Info+0xc>)
 80a500c:	681b      	ldr	r3, [r3, #0]
 80a500e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a5010:	9301      	str	r3, [sp, #4]
 80a5012:	bd08      	pop	{r3, pc}
 80a5014:	080601b4 	.word	0x080601b4

080a5018 <HAL_SPI_Set_Settings>:
DYNALIB_FN(10, hal_spi, HAL_SPI_DMA_Transfer, void(HAL_SPI_Interface, void*, void*, uint32_t, HAL_SPI_DMA_UserCallback))
DYNALIB_FN(11, hal_spi, HAL_SPI_Begin_Ext, void(HAL_SPI_Interface, SPI_Mode, uint16_t, void*))
DYNALIB_FN(12, hal_spi, HAL_SPI_Set_Callback_On_Select, void(HAL_SPI_Interface, HAL_SPI_Select_UserCallback, void*))
DYNALIB_FN(13, hal_spi, HAL_SPI_DMA_Transfer_Cancel, void(HAL_SPI_Interface))
DYNALIB_FN(14, hal_spi, HAL_SPI_DMA_Transfer_Status, int32_t(HAL_SPI_Interface, HAL_SPI_TransferStatus*))
DYNALIB_FN(15, hal_spi, HAL_SPI_Set_Settings, int32_t(HAL_SPI_Interface, uint8_t, uint8_t, uint8_t, uint8_t, void*))
 80a5018:	b508      	push	{r3, lr}
 80a501a:	4b02      	ldr	r3, [pc, #8]	; (80a5024 <HAL_SPI_Set_Settings+0xc>)
 80a501c:	681b      	ldr	r3, [r3, #0]
 80a501e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80a5020:	9301      	str	r3, [sp, #4]
 80a5022:	bd08      	pop	{r3, pc}
 80a5024:	080601b4 	.word	0x080601b4

080a5028 <HAL_RNG_GetRandomNumber>:

DYNALIB_BEGIN(hal)

#if PLATFORM_ID > 3
DYNALIB_FN(0, hal, HAL_RNG_Configuration, void(void))
DYNALIB_FN(1, hal, HAL_RNG_GetRandomNumber, uint32_t(void))
 80a5028:	b508      	push	{r3, lr}
 80a502a:	4b02      	ldr	r3, [pc, #8]	; (80a5034 <HAL_RNG_GetRandomNumber+0xc>)
 80a502c:	681b      	ldr	r3, [r3, #0]
 80a502e:	685b      	ldr	r3, [r3, #4]
 80a5030:	9301      	str	r3, [sp, #4]
 80a5032:	bd08      	pop	{r3, pc}
 80a5034:	0806019c 	.word	0x0806019c

080a5038 <HAL_Delay_Microseconds>:
#else
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal, HAL_Delay_Milliseconds, void(uint32_t))
DYNALIB_FN(BASE_IDX + 1, hal, HAL_Delay_Microseconds, void(uint32_t))
 80a5038:	b508      	push	{r3, lr}
 80a503a:	4b02      	ldr	r3, [pc, #8]	; (80a5044 <HAL_Delay_Microseconds+0xc>)
 80a503c:	681b      	ldr	r3, [r3, #0]
 80a503e:	68db      	ldr	r3, [r3, #12]
 80a5040:	9301      	str	r3, [sp, #4]
 80a5042:	bd08      	pop	{r3, pc}
 80a5044:	0806019c 	.word	0x0806019c

080a5048 <HAL_Timer_Get_Micro_Seconds>:
DYNALIB_FN(BASE_IDX + 2, hal, HAL_Timer_Get_Micro_Seconds, system_tick_t(void))
 80a5048:	b508      	push	{r3, lr}
 80a504a:	4b02      	ldr	r3, [pc, #8]	; (80a5054 <HAL_Timer_Get_Micro_Seconds+0xc>)
 80a504c:	681b      	ldr	r3, [r3, #0]
 80a504e:	691b      	ldr	r3, [r3, #16]
 80a5050:	9301      	str	r3, [sp, #4]
 80a5052:	bd08      	pop	{r3, pc}
 80a5054:	0806019c 	.word	0x0806019c

080a5058 <HAL_Timer_Get_Milli_Seconds>:
DYNALIB_FN(BASE_IDX + 3, hal, HAL_Timer_Get_Milli_Seconds, system_tick_t(void))
 80a5058:	b508      	push	{r3, lr}
 80a505a:	4b02      	ldr	r3, [pc, #8]	; (80a5064 <HAL_Timer_Get_Milli_Seconds+0xc>)
 80a505c:	681b      	ldr	r3, [r3, #0]
 80a505e:	695b      	ldr	r3, [r3, #20]
 80a5060:	9301      	str	r3, [sp, #4]
 80a5062:	bd08      	pop	{r3, pc}
 80a5064:	0806019c 	.word	0x0806019c

080a5068 <HAL_RTC_Get_UnixTime>:

DYNALIB_FN(BASE_IDX + 4, hal, HAL_RTC_Configuration, void(void))
DYNALIB_FN(BASE_IDX + 5, hal, HAL_RTC_Get_UnixTime, time_t(void))
 80a5068:	b508      	push	{r3, lr}
 80a506a:	4b02      	ldr	r3, [pc, #8]	; (80a5074 <HAL_RTC_Get_UnixTime+0xc>)
 80a506c:	681b      	ldr	r3, [r3, #0]
 80a506e:	69db      	ldr	r3, [r3, #28]
 80a5070:	9301      	str	r3, [sp, #4]
 80a5072:	bd08      	pop	{r3, pc}
 80a5074:	0806019c 	.word	0x0806019c

080a5078 <HAL_RTC_Time_Is_Valid>:
DYNALIB_FN(BASE_IDX + 15, hal,HAL_EEPROM_Get, void(uint32_t, void *, size_t))
DYNALIB_FN(BASE_IDX + 16, hal,HAL_EEPROM_Put, void(uint32_t, const void *, size_t))
DYNALIB_FN(BASE_IDX + 17, hal,HAL_EEPROM_Clear, void(void))
DYNALIB_FN(BASE_IDX + 18, hal,HAL_EEPROM_Has_Pending_Erase, bool(void))
DYNALIB_FN(BASE_IDX + 19, hal,HAL_EEPROM_Perform_Pending_Erase, void(void))
DYNALIB_FN(BASE_IDX + 20, hal, HAL_RTC_Time_Is_Valid, uint8_t(void*))
 80a5078:	b508      	push	{r3, lr}
 80a507a:	4b02      	ldr	r3, [pc, #8]	; (80a5084 <HAL_RTC_Time_Is_Valid+0xc>)
 80a507c:	681b      	ldr	r3, [r3, #0]
 80a507e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80a5080:	9301      	str	r3, [sp, #4]
 80a5082:	bd08      	pop	{r3, pc}
 80a5084:	0806019c 	.word	0x0806019c

080a5088 <HAL_Core_System_Reset_Ex>:
DYNALIB_FN(21, hal_core, HAL_Core_Runtime_Info, uint32_t(runtime_info_t*, void*))
DYNALIB_FN(22, hal_core, HAL_Set_System_Config, int(hal_system_config_t, const void*, unsigned))
DYNALIB_FN(23, hal_core, HAL_Core_Enter_Safe_Mode, void(void*))
DYNALIB_FN(24, hal_core, HAL_Feature_Get, bool(HAL_Feature))
DYNALIB_FN(25, hal_core, HAL_Feature_Set, int(HAL_Feature, bool))
DYNALIB_FN(26, hal_core, HAL_Core_System_Reset_Ex, void(int, uint32_t, void*))
 80a5088:	b508      	push	{r3, lr}
 80a508a:	4b02      	ldr	r3, [pc, #8]	; (80a5094 <HAL_Core_System_Reset_Ex+0xc>)
 80a508c:	681b      	ldr	r3, [r3, #0]
 80a508e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80a5090:	9301      	str	r3, [sp, #4]
 80a5092:	bd08      	pop	{r3, pc}
 80a5094:	080601b8 	.word	0x080601b8

080a5098 <HAL_Core_Get_Last_Reset_Info>:
DYNALIB_FN(27, hal_core, HAL_Core_Get_Last_Reset_Info, int(int*, uint32_t*, void*))
 80a5098:	b508      	push	{r3, lr}
 80a509a:	4b02      	ldr	r3, [pc, #8]	; (80a50a4 <HAL_Core_Get_Last_Reset_Info+0xc>)
 80a509c:	681b      	ldr	r3, [r3, #0]
 80a509e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80a50a0:	9301      	str	r3, [sp, #4]
 80a50a2:	bd08      	pop	{r3, pc}
 80a50a4:	080601b8 	.word	0x080601b8

080a50a8 <os_thread_yield>:

#if PLATFORM_THREADING
DYNALIB_FN(0, hal_concurrent, __gthread_equal, bool(__gthread_t, __gthread_t))
DYNALIB_FN(1, hal_concurrent, os_thread_create, os_result_t(os_thread_t*, const char*, os_thread_prio_t, os_thread_fn_t, void*, size_t))
DYNALIB_FN(2, hal_concurrent, os_thread_is_current, bool(os_thread_t))
DYNALIB_FN(3, hal_concurrent, os_thread_yield, os_result_t(void))
 80a50a8:	b508      	push	{r3, lr}
 80a50aa:	4b02      	ldr	r3, [pc, #8]	; (80a50b4 <os_thread_yield+0xc>)
 80a50ac:	681b      	ldr	r3, [r3, #0]
 80a50ae:	68db      	ldr	r3, [r3, #12]
 80a50b0:	9301      	str	r3, [sp, #4]
 80a50b2:	bd08      	pop	{r3, pc}
 80a50b4:	080601d0 	.word	0x080601d0

080a50b8 <os_timer_create>:
DYNALIB_FN(4, hal_concurrent, os_thread_join, os_result_t(os_thread_t))
DYNALIB_FN(5, hal_concurrent, os_thread_cleanup, os_result_t(os_thread_t))
DYNALIB_FN(6, hal_concurrent, os_thread_delay_until, os_result_t(system_tick_t*, system_tick_t))
DYNALIB_FN(7, hal_concurrent, os_thread_scheduling, void(bool, void*))

DYNALIB_FN(8, hal_concurrent, os_timer_create, int(os_timer_t*, unsigned, void(*)(os_timer_t), void*, bool, void*))
 80a50b8:	b508      	push	{r3, lr}
 80a50ba:	4b02      	ldr	r3, [pc, #8]	; (80a50c4 <os_timer_create+0xc>)
 80a50bc:	681b      	ldr	r3, [r3, #0]
 80a50be:	6a1b      	ldr	r3, [r3, #32]
 80a50c0:	9301      	str	r3, [sp, #4]
 80a50c2:	bd08      	pop	{r3, pc}
 80a50c4:	080601d0 	.word	0x080601d0

080a50c8 <os_timer_destroy>:
DYNALIB_FN(9, hal_concurrent, os_timer_destroy, int(os_timer_t, void*))
 80a50c8:	b508      	push	{r3, lr}
 80a50ca:	4b02      	ldr	r3, [pc, #8]	; (80a50d4 <os_timer_destroy+0xc>)
 80a50cc:	681b      	ldr	r3, [r3, #0]
 80a50ce:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a50d0:	9301      	str	r3, [sp, #4]
 80a50d2:	bd08      	pop	{r3, pc}
 80a50d4:	080601d0 	.word	0x080601d0

080a50d8 <os_timer_get_id>:
DYNALIB_FN(10, hal_concurrent, os_timer_get_id, int(os_timer_t, void**))
 80a50d8:	b508      	push	{r3, lr}
 80a50da:	4b02      	ldr	r3, [pc, #8]	; (80a50e4 <os_timer_get_id+0xc>)
 80a50dc:	681b      	ldr	r3, [r3, #0]
 80a50de:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a50e0:	9301      	str	r3, [sp, #4]
 80a50e2:	bd08      	pop	{r3, pc}
 80a50e4:	080601d0 	.word	0x080601d0

080a50e8 <os_timer_change>:
DYNALIB_FN(11, hal_concurrent, os_timer_change, int(os_timer_t, os_timer_change_t, bool, unsigned, unsigned, void*))
 80a50e8:	b508      	push	{r3, lr}
 80a50ea:	4b02      	ldr	r3, [pc, #8]	; (80a50f4 <os_timer_change+0xc>)
 80a50ec:	681b      	ldr	r3, [r3, #0]
 80a50ee:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a50f0:	9301      	str	r3, [sp, #4]
 80a50f2:	bd08      	pop	{r3, pc}
 80a50f4:	080601d0 	.word	0x080601d0

080a50f8 <os_mutex_create>:

DYNALIB_FN(12, hal_concurrent, os_mutex_create, int(os_mutex_t*))
 80a50f8:	b508      	push	{r3, lr}
 80a50fa:	4b02      	ldr	r3, [pc, #8]	; (80a5104 <os_mutex_create+0xc>)
 80a50fc:	681b      	ldr	r3, [r3, #0]
 80a50fe:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a5100:	9301      	str	r3, [sp, #4]
 80a5102:	bd08      	pop	{r3, pc}
 80a5104:	080601d0 	.word	0x080601d0

080a5108 <os_mutex_lock>:
DYNALIB_FN(13, hal_concurrent, os_mutex_destroy, int(os_mutex_t))
DYNALIB_FN(14, hal_concurrent, os_mutex_lock, int(os_mutex_t))
 80a5108:	b508      	push	{r3, lr}
 80a510a:	4b02      	ldr	r3, [pc, #8]	; (80a5114 <os_mutex_lock+0xc>)
 80a510c:	681b      	ldr	r3, [r3, #0]
 80a510e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80a5110:	9301      	str	r3, [sp, #4]
 80a5112:	bd08      	pop	{r3, pc}
 80a5114:	080601d0 	.word	0x080601d0

080a5118 <os_mutex_unlock>:
DYNALIB_FN(15, hal_concurrent, os_mutex_trylock, int(os_mutex_t))
DYNALIB_FN(16, hal_concurrent, os_mutex_unlock, int(os_mutex_t))
 80a5118:	b508      	push	{r3, lr}
 80a511a:	4b02      	ldr	r3, [pc, #8]	; (80a5124 <os_mutex_unlock+0xc>)
 80a511c:	681b      	ldr	r3, [r3, #0]
 80a511e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80a5120:	9301      	str	r3, [sp, #4]
 80a5122:	bd08      	pop	{r3, pc}
 80a5124:	080601d0 	.word	0x080601d0

080a5128 <HAL_USART_Init>:
#define BASE_IDX 6 // Base index for all subsequent functions
#else
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal_usart, HAL_USART_Init, void(HAL_USART_Serial, Ring_Buffer*, Ring_Buffer*))
 80a5128:	b508      	push	{r3, lr}
 80a512a:	4b02      	ldr	r3, [pc, #8]	; (80a5134 <HAL_USART_Init+0xc>)
 80a512c:	681b      	ldr	r3, [r3, #0]
 80a512e:	699b      	ldr	r3, [r3, #24]
 80a5130:	9301      	str	r3, [sp, #4]
 80a5132:	bd08      	pop	{r3, pc}
 80a5134:	080601c4 	.word	0x080601c4

080a5138 <HAL_USART_End>:
DYNALIB_FN(BASE_IDX + 1, hal_usart, HAL_USART_Begin, void(HAL_USART_Serial, uint32_t))
DYNALIB_FN(BASE_IDX + 2, hal_usart, HAL_USART_End, void(HAL_USART_Serial))
 80a5138:	b508      	push	{r3, lr}
 80a513a:	4b02      	ldr	r3, [pc, #8]	; (80a5144 <HAL_USART_End+0xc>)
 80a513c:	681b      	ldr	r3, [r3, #0]
 80a513e:	6a1b      	ldr	r3, [r3, #32]
 80a5140:	9301      	str	r3, [sp, #4]
 80a5142:	bd08      	pop	{r3, pc}
 80a5144:	080601c4 	.word	0x080601c4

080a5148 <HAL_USART_Write_Data>:
DYNALIB_FN(BASE_IDX + 3, hal_usart, HAL_USART_Write_Data, uint32_t(HAL_USART_Serial, uint8_t))
 80a5148:	b508      	push	{r3, lr}
 80a514a:	4b02      	ldr	r3, [pc, #8]	; (80a5154 <HAL_USART_Write_Data+0xc>)
 80a514c:	681b      	ldr	r3, [r3, #0]
 80a514e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a5150:	9301      	str	r3, [sp, #4]
 80a5152:	bd08      	pop	{r3, pc}
 80a5154:	080601c4 	.word	0x080601c4

080a5158 <HAL_USART_Available_Data>:
DYNALIB_FN(BASE_IDX + 4, hal_usart, HAL_USART_Available_Data, int32_t(HAL_USART_Serial))
 80a5158:	b508      	push	{r3, lr}
 80a515a:	4b02      	ldr	r3, [pc, #8]	; (80a5164 <HAL_USART_Available_Data+0xc>)
 80a515c:	681b      	ldr	r3, [r3, #0]
 80a515e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a5160:	9301      	str	r3, [sp, #4]
 80a5162:	bd08      	pop	{r3, pc}
 80a5164:	080601c4 	.word	0x080601c4

080a5168 <HAL_USART_Read_Data>:
DYNALIB_FN(BASE_IDX + 5, hal_usart, HAL_USART_Read_Data, int32_t(HAL_USART_Serial))
 80a5168:	b508      	push	{r3, lr}
 80a516a:	4b02      	ldr	r3, [pc, #8]	; (80a5174 <HAL_USART_Read_Data+0xc>)
 80a516c:	681b      	ldr	r3, [r3, #0]
 80a516e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a5170:	9301      	str	r3, [sp, #4]
 80a5172:	bd08      	pop	{r3, pc}
 80a5174:	080601c4 	.word	0x080601c4

080a5178 <HAL_USART_Peek_Data>:
DYNALIB_FN(BASE_IDX + 6, hal_usart, HAL_USART_Peek_Data, int32_t(HAL_USART_Serial))
 80a5178:	b508      	push	{r3, lr}
 80a517a:	4b02      	ldr	r3, [pc, #8]	; (80a5184 <HAL_USART_Peek_Data+0xc>)
 80a517c:	681b      	ldr	r3, [r3, #0]
 80a517e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a5180:	9301      	str	r3, [sp, #4]
 80a5182:	bd08      	pop	{r3, pc}
 80a5184:	080601c4 	.word	0x080601c4

080a5188 <HAL_USART_Flush_Data>:
DYNALIB_FN(BASE_IDX + 7, hal_usart, HAL_USART_Flush_Data, void(HAL_USART_Serial))
 80a5188:	b508      	push	{r3, lr}
 80a518a:	4b02      	ldr	r3, [pc, #8]	; (80a5194 <HAL_USART_Flush_Data+0xc>)
 80a518c:	681b      	ldr	r3, [r3, #0]
 80a518e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a5190:	9301      	str	r3, [sp, #4]
 80a5192:	bd08      	pop	{r3, pc}
 80a5194:	080601c4 	.word	0x080601c4

080a5198 <HAL_USART_Is_Enabled>:
DYNALIB_FN(BASE_IDX + 8, hal_usart, HAL_USART_Is_Enabled, bool(HAL_USART_Serial))
 80a5198:	b508      	push	{r3, lr}
 80a519a:	4b02      	ldr	r3, [pc, #8]	; (80a51a4 <HAL_USART_Is_Enabled+0xc>)
 80a519c:	681b      	ldr	r3, [r3, #0]
 80a519e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80a51a0:	9301      	str	r3, [sp, #4]
 80a51a2:	bd08      	pop	{r3, pc}
 80a51a4:	080601c4 	.word	0x080601c4

080a51a8 <HAL_USART_Available_Data_For_Write>:
DYNALIB_FN(BASE_IDX + 9, hal_usart, HAL_USART_Half_Duplex, void(HAL_USART_Serial, bool))
DYNALIB_FN(BASE_IDX + 10, hal_usart, HAL_USART_Available_Data_For_Write, int32_t(HAL_USART_Serial))
 80a51a8:	b508      	push	{r3, lr}
 80a51aa:	4b02      	ldr	r3, [pc, #8]	; (80a51b4 <HAL_USART_Available_Data_For_Write+0xc>)
 80a51ac:	681b      	ldr	r3, [r3, #0]
 80a51ae:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80a51b0:	9301      	str	r3, [sp, #4]
 80a51b2:	bd08      	pop	{r3, pc}
 80a51b4:	080601c4 	.word	0x080601c4

080a51b8 <HAL_USART_BeginConfig>:
#define BASE_IDX2 (BASE_IDX+13)
#else
#define BASE_IDX2 (BASE_IDX+11)
#endif

DYNALIB_FN(BASE_IDX2 + 0, hal_usart, HAL_USART_BeginConfig, void(HAL_USART_Serial serial, uint32_t baud, uint32_t config, void *ptr))
 80a51b8:	b508      	push	{r3, lr}
 80a51ba:	4b02      	ldr	r3, [pc, #8]	; (80a51c4 <HAL_USART_BeginConfig+0xc>)
 80a51bc:	681b      	ldr	r3, [r3, #0]
 80a51be:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80a51c0:	9301      	str	r3, [sp, #4]
 80a51c2:	bd08      	pop	{r3, pc}
 80a51c4:	080601c4 	.word	0x080601c4

080a51c8 <HAL_I2C_Begin>:
#endif

DYNALIB_FN(BASE_IDX + 0, hal_i2c, HAL_I2C_Set_Speed, void(HAL_I2C_Interface, uint32_t, void*))
DYNALIB_FN(BASE_IDX + 1, hal_i2c, HAL_I2C_Enable_DMA_Mode, void(HAL_I2C_Interface, bool, void*))
DYNALIB_FN(BASE_IDX + 2, hal_i2c, HAL_I2C_Stretch_Clock, void(HAL_I2C_Interface, bool, void*))
DYNALIB_FN(BASE_IDX + 3, hal_i2c, HAL_I2C_Begin, void(HAL_I2C_Interface, I2C_Mode, uint8_t, void*))
 80a51c8:	b508      	push	{r3, lr}
 80a51ca:	4b02      	ldr	r3, [pc, #8]	; (80a51d4 <HAL_I2C_Begin+0xc>)
 80a51cc:	681b      	ldr	r3, [r3, #0]
 80a51ce:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80a51d0:	9301      	str	r3, [sp, #4]
 80a51d2:	bd08      	pop	{r3, pc}
 80a51d4:	080601ac 	.word	0x080601ac

080a51d8 <HAL_I2C_Request_Data>:
DYNALIB_FN(BASE_IDX + 4, hal_i2c, HAL_I2C_End, void(HAL_I2C_Interface, void*))
DYNALIB_FN(BASE_IDX + 5, hal_i2c, HAL_I2C_Request_Data, uint32_t(HAL_I2C_Interface, uint8_t, uint8_t, uint8_t, void*))
 80a51d8:	b508      	push	{r3, lr}
 80a51da:	4b02      	ldr	r3, [pc, #8]	; (80a51e4 <HAL_I2C_Request_Data+0xc>)
 80a51dc:	681b      	ldr	r3, [r3, #0]
 80a51de:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80a51e0:	9301      	str	r3, [sp, #4]
 80a51e2:	bd08      	pop	{r3, pc}
 80a51e4:	080601ac 	.word	0x080601ac

080a51e8 <HAL_I2C_Begin_Transmission>:
DYNALIB_FN(BASE_IDX + 6, hal_i2c, HAL_I2C_Begin_Transmission, void(HAL_I2C_Interface, uint8_t, void*))
 80a51e8:	b508      	push	{r3, lr}
 80a51ea:	4b02      	ldr	r3, [pc, #8]	; (80a51f4 <HAL_I2C_Begin_Transmission+0xc>)
 80a51ec:	681b      	ldr	r3, [r3, #0]
 80a51ee:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80a51f0:	9301      	str	r3, [sp, #4]
 80a51f2:	bd08      	pop	{r3, pc}
 80a51f4:	080601ac 	.word	0x080601ac

080a51f8 <HAL_I2C_End_Transmission>:
DYNALIB_FN(BASE_IDX + 7, hal_i2c, HAL_I2C_End_Transmission, uint8_t(HAL_I2C_Interface, uint8_t, void*))
 80a51f8:	b508      	push	{r3, lr}
 80a51fa:	4b02      	ldr	r3, [pc, #8]	; (80a5204 <HAL_I2C_End_Transmission+0xc>)
 80a51fc:	681b      	ldr	r3, [r3, #0]
 80a51fe:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80a5200:	9301      	str	r3, [sp, #4]
 80a5202:	bd08      	pop	{r3, pc}
 80a5204:	080601ac 	.word	0x080601ac

080a5208 <HAL_I2C_Write_Data>:
DYNALIB_FN(BASE_IDX + 8, hal_i2c, HAL_I2C_Write_Data, uint32_t(HAL_I2C_Interface, uint8_t, void*))
 80a5208:	b508      	push	{r3, lr}
 80a520a:	4b02      	ldr	r3, [pc, #8]	; (80a5214 <HAL_I2C_Write_Data+0xc>)
 80a520c:	681b      	ldr	r3, [r3, #0]
 80a520e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80a5210:	9301      	str	r3, [sp, #4]
 80a5212:	bd08      	pop	{r3, pc}
 80a5214:	080601ac 	.word	0x080601ac

080a5218 <HAL_I2C_Available_Data>:
DYNALIB_FN(BASE_IDX + 9, hal_i2c, HAL_I2C_Available_Data, int32_t(HAL_I2C_Interface, void*))
 80a5218:	b508      	push	{r3, lr}
 80a521a:	4b02      	ldr	r3, [pc, #8]	; (80a5224 <HAL_I2C_Available_Data+0xc>)
 80a521c:	681b      	ldr	r3, [r3, #0]
 80a521e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80a5220:	9301      	str	r3, [sp, #4]
 80a5222:	bd08      	pop	{r3, pc}
 80a5224:	080601ac 	.word	0x080601ac

080a5228 <HAL_I2C_Read_Data>:
DYNALIB_FN(BASE_IDX + 10, hal_i2c, HAL_I2C_Read_Data, int32_t(HAL_I2C_Interface, void*))
 80a5228:	b508      	push	{r3, lr}
 80a522a:	4b02      	ldr	r3, [pc, #8]	; (80a5234 <HAL_I2C_Read_Data+0xc>)
 80a522c:	681b      	ldr	r3, [r3, #0]
 80a522e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80a5230:	9301      	str	r3, [sp, #4]
 80a5232:	bd08      	pop	{r3, pc}
 80a5234:	080601ac 	.word	0x080601ac

080a5238 <HAL_I2C_Peek_Data>:
DYNALIB_FN(BASE_IDX + 11, hal_i2c, HAL_I2C_Peek_Data, int32_t(HAL_I2C_Interface, void*))
 80a5238:	b508      	push	{r3, lr}
 80a523a:	4b02      	ldr	r3, [pc, #8]	; (80a5244 <HAL_I2C_Peek_Data+0xc>)
 80a523c:	681b      	ldr	r3, [r3, #0]
 80a523e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80a5240:	9301      	str	r3, [sp, #4]
 80a5242:	bd08      	pop	{r3, pc}
 80a5244:	080601ac 	.word	0x080601ac

080a5248 <HAL_I2C_Flush_Data>:
DYNALIB_FN(BASE_IDX + 12, hal_i2c, HAL_I2C_Flush_Data, void(HAL_I2C_Interface, void*))
 80a5248:	b508      	push	{r3, lr}
 80a524a:	4b02      	ldr	r3, [pc, #8]	; (80a5254 <HAL_I2C_Flush_Data+0xc>)
 80a524c:	681b      	ldr	r3, [r3, #0]
 80a524e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80a5250:	9301      	str	r3, [sp, #4]
 80a5252:	bd08      	pop	{r3, pc}
 80a5254:	080601ac 	.word	0x080601ac

080a5258 <HAL_I2C_Is_Enabled>:
DYNALIB_FN(BASE_IDX + 13, hal_i2c, HAL_I2C_Is_Enabled, bool(HAL_I2C_Interface, void*))
 80a5258:	b508      	push	{r3, lr}
 80a525a:	4b02      	ldr	r3, [pc, #8]	; (80a5264 <HAL_I2C_Is_Enabled+0xc>)
 80a525c:	681b      	ldr	r3, [r3, #0]
 80a525e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80a5260:	9301      	str	r3, [sp, #4]
 80a5262:	bd08      	pop	{r3, pc}
 80a5264:	080601ac 	.word	0x080601ac

080a5268 <HAL_I2C_Init>:
DYNALIB_FN(BASE_IDX + 14, hal_i2c, HAL_I2C_Set_Callback_On_Receive, void(HAL_I2C_Interface, void(*)(int), void*))
DYNALIB_FN(BASE_IDX + 15, hal_i2c, HAL_I2C_Set_Callback_On_Request, void(HAL_I2C_Interface, void(*)(void), void*))
DYNALIB_FN(BASE_IDX + 16, hal_i2c, HAL_I2C_Init, void(HAL_I2C_Interface, void*))
 80a5268:	b508      	push	{r3, lr}
 80a526a:	4b03      	ldr	r3, [pc, #12]	; (80a5278 <HAL_I2C_Init+0x10>)
 80a526c:	681b      	ldr	r3, [r3, #0]
 80a526e:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80a5272:	9301      	str	r3, [sp, #4]
 80a5274:	bd08      	pop	{r3, pc}
 80a5276:	0000      	.short	0x0000
 80a5278:	080601ac 	.word	0x080601ac

080a527c <socket_handle_valid>:
// GNINRAW

DYNALIB_BEGIN(hal_socket)

DYNALIB_FN(0, hal_socket, socket_active_status, uint8_t(sock_handle_t))
DYNALIB_FN(1, hal_socket, socket_handle_valid, uint8_t(sock_handle_t))
 80a527c:	b508      	push	{r3, lr}
 80a527e:	4b02      	ldr	r3, [pc, #8]	; (80a5288 <socket_handle_valid+0xc>)
 80a5280:	681b      	ldr	r3, [r3, #0]
 80a5282:	685b      	ldr	r3, [r3, #4]
 80a5284:	9301      	str	r3, [sp, #4]
 80a5286:	bd08      	pop	{r3, pc}
 80a5288:	080601bc 	.word	0x080601bc

080a528c <socket_create>:
DYNALIB_FN(2, hal_socket, socket_create, sock_handle_t(uint8_t, uint8_t, uint8_t, uint16_t, network_interface_t))
 80a528c:	b508      	push	{r3, lr}
 80a528e:	4b02      	ldr	r3, [pc, #8]	; (80a5298 <socket_create+0xc>)
 80a5290:	681b      	ldr	r3, [r3, #0]
 80a5292:	689b      	ldr	r3, [r3, #8]
 80a5294:	9301      	str	r3, [sp, #4]
 80a5296:	bd08      	pop	{r3, pc}
 80a5298:	080601bc 	.word	0x080601bc

080a529c <socket_receivefrom>:
DYNALIB_FN(3, hal_socket, socket_connect, int32_t(sock_handle_t, const sockaddr_t*, long))
DYNALIB_FN(4, hal_socket, socket_receive, sock_result_t(sock_handle_t, void*, socklen_t, system_tick_t))
DYNALIB_FN(5, hal_socket, socket_receivefrom, sock_result_t(sock_handle_t, void*, socklen_t, uint32_t, sockaddr_t*, socklen_t*))
 80a529c:	b508      	push	{r3, lr}
 80a529e:	4b02      	ldr	r3, [pc, #8]	; (80a52a8 <socket_receivefrom+0xc>)
 80a52a0:	681b      	ldr	r3, [r3, #0]
 80a52a2:	695b      	ldr	r3, [r3, #20]
 80a52a4:	9301      	str	r3, [sp, #4]
 80a52a6:	bd08      	pop	{r3, pc}
 80a52a8:	080601bc 	.word	0x080601bc

080a52ac <socket_sendto>:
DYNALIB_FN(6, hal_socket, socket_send, sock_result_t(sock_handle_t, const void*, socklen_t))
DYNALIB_FN(7, hal_socket, socket_sendto, sock_result_t(sock_handle_t, const void*, socklen_t, uint32_t, sockaddr_t*, socklen_t))
 80a52ac:	b508      	push	{r3, lr}
 80a52ae:	4b02      	ldr	r3, [pc, #8]	; (80a52b8 <socket_sendto+0xc>)
 80a52b0:	681b      	ldr	r3, [r3, #0]
 80a52b2:	69db      	ldr	r3, [r3, #28]
 80a52b4:	9301      	str	r3, [sp, #4]
 80a52b6:	bd08      	pop	{r3, pc}
 80a52b8:	080601bc 	.word	0x080601bc

080a52bc <socket_close>:
DYNALIB_FN(8, hal_socket, socket_close, sock_result_t(sock_handle_t))
 80a52bc:	b508      	push	{r3, lr}
 80a52be:	4b02      	ldr	r3, [pc, #8]	; (80a52c8 <socket_close+0xc>)
 80a52c0:	681b      	ldr	r3, [r3, #0]
 80a52c2:	6a1b      	ldr	r3, [r3, #32]
 80a52c4:	9301      	str	r3, [sp, #4]
 80a52c6:	bd08      	pop	{r3, pc}
 80a52c8:	080601bc 	.word	0x080601bc

080a52cc <socket_handle_invalid>:
DYNALIB_FN(9, hal_socket, socket_reset_blocking_call, sock_result_t(void))
DYNALIB_FN(10, hal_socket, socket_create_tcp_server, sock_result_t(uint16_t, network_interface_t))
DYNALIB_FN(11, hal_socket, socket_accept, sock_result_t(sock_handle_t))
DYNALIB_FN(12, hal_socket, socket_handle_invalid, sock_handle_t(void))
 80a52cc:	b508      	push	{r3, lr}
 80a52ce:	4b02      	ldr	r3, [pc, #8]	; (80a52d8 <socket_handle_invalid+0xc>)
 80a52d0:	681b      	ldr	r3, [r3, #0]
 80a52d2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a52d4:	9301      	str	r3, [sp, #4]
 80a52d6:	bd08      	pop	{r3, pc}
 80a52d8:	080601bc 	.word	0x080601bc

080a52dc <HAL_USB_USART_Init>:
#endif

DYNALIB_BEGIN(hal_usb)

#ifdef USB_CDC_ENABLE
DYNALIB_FN(0, hal_usb, HAL_USB_USART_Init, void(HAL_USB_USART_Serial, const HAL_USB_USART_Config*))
 80a52dc:	b508      	push	{r3, lr}
 80a52de:	4b02      	ldr	r3, [pc, #8]	; (80a52e8 <HAL_USB_USART_Init+0xc>)
 80a52e0:	681b      	ldr	r3, [r3, #0]
 80a52e2:	681b      	ldr	r3, [r3, #0]
 80a52e4:	9301      	str	r3, [sp, #4]
 80a52e6:	bd08      	pop	{r3, pc}
 80a52e8:	080601d8 	.word	0x080601d8

080a52ec <HAL_USB_USART_Available_Data>:
DYNALIB_FN(1, hal_usb, HAL_USB_USART_Begin, void(HAL_USB_USART_Serial, uint32_t, void *))
DYNALIB_FN(2, hal_usb, HAL_USB_USART_End, void(HAL_USB_USART_Serial))
DYNALIB_FN(3, hal_usb, HAL_USB_USART_Baud_Rate, unsigned int(HAL_USB_USART_Serial))
DYNALIB_FN(4, hal_usb, HAL_USB_USART_Available_Data, int32_t(HAL_USB_USART_Serial))
 80a52ec:	b508      	push	{r3, lr}
 80a52ee:	4b02      	ldr	r3, [pc, #8]	; (80a52f8 <HAL_USB_USART_Available_Data+0xc>)
 80a52f0:	681b      	ldr	r3, [r3, #0]
 80a52f2:	691b      	ldr	r3, [r3, #16]
 80a52f4:	9301      	str	r3, [sp, #4]
 80a52f6:	bd08      	pop	{r3, pc}
 80a52f8:	080601d8 	.word	0x080601d8

080a52fc <HAL_USB_USART_Available_Data_For_Write>:
DYNALIB_FN(5, hal_usb, HAL_USB_USART_Available_Data_For_Write, int32_t(HAL_USB_USART_Serial))
 80a52fc:	b508      	push	{r3, lr}
 80a52fe:	4b02      	ldr	r3, [pc, #8]	; (80a5308 <HAL_USB_USART_Available_Data_For_Write+0xc>)
 80a5300:	681b      	ldr	r3, [r3, #0]
 80a5302:	695b      	ldr	r3, [r3, #20]
 80a5304:	9301      	str	r3, [sp, #4]
 80a5306:	bd08      	pop	{r3, pc}
 80a5308:	080601d8 	.word	0x080601d8

080a530c <HAL_USB_USART_Receive_Data>:
DYNALIB_FN(6, hal_usb, HAL_USB_USART_Receive_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
 80a530c:	b508      	push	{r3, lr}
 80a530e:	4b02      	ldr	r3, [pc, #8]	; (80a5318 <HAL_USB_USART_Receive_Data+0xc>)
 80a5310:	681b      	ldr	r3, [r3, #0]
 80a5312:	699b      	ldr	r3, [r3, #24]
 80a5314:	9301      	str	r3, [sp, #4]
 80a5316:	bd08      	pop	{r3, pc}
 80a5318:	080601d8 	.word	0x080601d8

080a531c <HAL_USB_USART_Send_Data>:
DYNALIB_FN(7, hal_usb, HAL_USB_USART_Send_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
 80a531c:	b508      	push	{r3, lr}
 80a531e:	4b02      	ldr	r3, [pc, #8]	; (80a5328 <HAL_USB_USART_Send_Data+0xc>)
 80a5320:	681b      	ldr	r3, [r3, #0]
 80a5322:	69db      	ldr	r3, [r3, #28]
 80a5324:	9301      	str	r3, [sp, #4]
 80a5326:	bd08      	pop	{r3, pc}
 80a5328:	080601d8 	.word	0x080601d8

080a532c <HAL_USB_USART_Flush_Data>:
DYNALIB_FN(8, hal_usb, HAL_USB_USART_Flush_Data, void(HAL_USB_USART_Serial))
 80a532c:	b508      	push	{r3, lr}
 80a532e:	4b02      	ldr	r3, [pc, #8]	; (80a5338 <HAL_USB_USART_Flush_Data+0xc>)
 80a5330:	681b      	ldr	r3, [r3, #0]
 80a5332:	6a1b      	ldr	r3, [r3, #32]
 80a5334:	9301      	str	r3, [sp, #4]
 80a5336:	bd08      	pop	{r3, pc}
 80a5338:	080601d8 	.word	0x080601d8

080a533c <inet_gethostbyname>:
DYNALIB_FN(14, hal_wlan, wlan_set_error_count, void(uint32_t))
DYNALIB_FN(15, hal_wlan, wlan_fetch_ipconfig, void(WLanConfig*))
DYNALIB_FN(16, hal_wlan, wlan_setup, void(void))

DYNALIB_FN(17, hal_wlan, HAL_NET_SetNetWatchDog, uint32_t(uint32_t))
DYNALIB_FN(18, hal_wlan, inet_gethostbyname, int(const char*, uint16_t, HAL_IPAddress*, network_interface_t, void*))
 80a533c:	b508      	push	{r3, lr}
 80a533e:	4b02      	ldr	r3, [pc, #8]	; (80a5348 <inet_gethostbyname+0xc>)
 80a5340:	681b      	ldr	r3, [r3, #0]
 80a5342:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80a5344:	9301      	str	r3, [sp, #4]
 80a5346:	bd08      	pop	{r3, pc}
 80a5348:	080601c0 	.word	0x080601c0

080a534c <LED_SetSignalingColor>:
#endif // defined(DYNALIB_EXPORT)

DYNALIB_BEGIN(services)

DYNALIB_FN(0, services, LED_SetRGBColor, void(uint32_t))
DYNALIB_FN(1, services, LED_SetSignalingColor, void(uint32_t))
 80a534c:	b508      	push	{r3, lr}
 80a534e:	4b02      	ldr	r3, [pc, #8]	; (80a5358 <LED_SetSignalingColor+0xc>)
 80a5350:	681b      	ldr	r3, [r3, #0]
 80a5352:	685b      	ldr	r3, [r3, #4]
 80a5354:	9301      	str	r3, [sp, #4]
 80a5356:	bd08      	pop	{r3, pc}
 80a5358:	080201a8 	.word	0x080201a8

080a535c <LED_Signaling_Start>:
DYNALIB_FN(2, services, LED_Signaling_Start, void(void))
 80a535c:	b508      	push	{r3, lr}
 80a535e:	4b02      	ldr	r3, [pc, #8]	; (80a5368 <LED_Signaling_Start+0xc>)
 80a5360:	681b      	ldr	r3, [r3, #0]
 80a5362:	689b      	ldr	r3, [r3, #8]
 80a5364:	9301      	str	r3, [sp, #4]
 80a5366:	bd08      	pop	{r3, pc}
 80a5368:	080201a8 	.word	0x080201a8

080a536c <LED_Signaling_Stop>:
DYNALIB_FN(3, services, LED_Signaling_Stop, void(void))
 80a536c:	b508      	push	{r3, lr}
 80a536e:	4b02      	ldr	r3, [pc, #8]	; (80a5378 <LED_Signaling_Stop+0xc>)
 80a5370:	681b      	ldr	r3, [r3, #0]
 80a5372:	68db      	ldr	r3, [r3, #12]
 80a5374:	9301      	str	r3, [sp, #4]
 80a5376:	bd08      	pop	{r3, pc}
 80a5378:	080201a8 	.word	0x080201a8

080a537c <LED_SetBrightness>:
DYNALIB_FN(4, services, LED_SetBrightness, void(uint8_t))
 80a537c:	b508      	push	{r3, lr}
 80a537e:	4b02      	ldr	r3, [pc, #8]	; (80a5388 <LED_SetBrightness+0xc>)
 80a5380:	681b      	ldr	r3, [r3, #0]
 80a5382:	691b      	ldr	r3, [r3, #16]
 80a5384:	9301      	str	r3, [sp, #4]
 80a5386:	bd08      	pop	{r3, pc}
 80a5388:	080201a8 	.word	0x080201a8

080a538c <LED_RGB_IsOverRidden>:
DYNALIB_FN(5, services, LED_RGB_Get, void(uint8_t*))
DYNALIB_FN(6, services, LED_RGB_IsOverRidden, bool(void))
 80a538c:	b508      	push	{r3, lr}
 80a538e:	4b02      	ldr	r3, [pc, #8]	; (80a5398 <LED_RGB_IsOverRidden+0xc>)
 80a5390:	681b      	ldr	r3, [r3, #0]
 80a5392:	699b      	ldr	r3, [r3, #24]
 80a5394:	9301      	str	r3, [sp, #4]
 80a5396:	bd08      	pop	{r3, pc}
 80a5398:	080201a8 	.word	0x080201a8

080a539c <LED_On>:
DYNALIB_FN(7, services, LED_On, void(Led_TypeDef))
 80a539c:	b508      	push	{r3, lr}
 80a539e:	4b02      	ldr	r3, [pc, #8]	; (80a53a8 <LED_On+0xc>)
 80a53a0:	681b      	ldr	r3, [r3, #0]
 80a53a2:	69db      	ldr	r3, [r3, #28]
 80a53a4:	9301      	str	r3, [sp, #4]
 80a53a6:	bd08      	pop	{r3, pc}
 80a53a8:	080201a8 	.word	0x080201a8

080a53ac <panic_>:
DYNALIB_FN(9, services, LED_Toggle, void(Led_TypeDef))
DYNALIB_FN(10, services, LED_Fade, void(Led_TypeDef))
DYNALIB_FN(11, services, Get_LED_Brightness, uint8_t(void))

DYNALIB_FN(12, services, set_logger_output, void(debug_output_fn, LoggerOutputLevel)) // Deprecated
DYNALIB_FN(13, services, panic_, void(ePanicCode, void*, void(*)(uint32_t)))
 80a53ac:	b508      	push	{r3, lr}
 80a53ae:	4b02      	ldr	r3, [pc, #8]	; (80a53b8 <panic_+0xc>)
 80a53b0:	681b      	ldr	r3, [r3, #0]
 80a53b2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a53b4:	9301      	str	r3, [sp, #4]
 80a53b6:	bd08      	pop	{r3, pc}
 80a53b8:	080201a8 	.word	0x080201a8

080a53bc <system_mode>:
#include "system_setup.h"
#endif

DYNALIB_BEGIN(system)

DYNALIB_FN(0, system, system_mode, System_Mode_TypeDef(void))
 80a53bc:	b508      	push	{r3, lr}
 80a53be:	4b02      	ldr	r3, [pc, #8]	; (80a53c8 <system_mode+0xc>)
 80a53c0:	681b      	ldr	r3, [r3, #0]
 80a53c2:	681b      	ldr	r3, [r3, #0]
 80a53c4:	9301      	str	r3, [sp, #4]
 80a53c6:	bd08      	pop	{r3, pc}
 80a53c8:	080601a4 	.word	0x080601a4

080a53cc <set_system_mode>:
DYNALIB_FN(1, system, set_system_mode, void(System_Mode_TypeDef))
 80a53cc:	b508      	push	{r3, lr}
 80a53ce:	4b02      	ldr	r3, [pc, #8]	; (80a53d8 <set_system_mode+0xc>)
 80a53d0:	681b      	ldr	r3, [r3, #0]
 80a53d2:	685b      	ldr	r3, [r3, #4]
 80a53d4:	9301      	str	r3, [sp, #4]
 80a53d6:	bd08      	pop	{r3, pc}
 80a53d8:	080601a4 	.word	0x080601a4

080a53dc <system_delay_ms>:

DYNALIB_FN(2, system, set_ymodem_serial_flash_update_handler, void(ymodem_serial_flash_update_handler))
DYNALIB_FN(3, system, system_firmwareUpdate, bool(Stream*, void*))
DYNALIB_FN(4, system, system_fileTransfer, bool(system_file_transfer_t*, void*))

DYNALIB_FN(5, system, system_delay_ms, void(unsigned long, bool))
 80a53dc:	b508      	push	{r3, lr}
 80a53de:	4b02      	ldr	r3, [pc, #8]	; (80a53e8 <system_delay_ms+0xc>)
 80a53e0:	681b      	ldr	r3, [r3, #0]
 80a53e2:	695b      	ldr	r3, [r3, #20]
 80a53e4:	9301      	str	r3, [sp, #4]
 80a53e6:	bd08      	pop	{r3, pc}
 80a53e8:	080601a4 	.word	0x080601a4

080a53ec <application_thread_current>:
DYNALIB_FN(15, system, system_get_flag, int(system_flag_t, uint8_t*, void*))
DYNALIB_FN(16, system, Spark_Prepare_For_Firmware_Update, int(FileTransfer::Descriptor&, uint32_t, void*))
DYNALIB_FN(17, system, Spark_Save_Firmware_Chunk, int(FileTransfer::Descriptor&, const uint8_t*, void*))
DYNALIB_FN(18, system, Spark_Finish_Firmware_Update, int(FileTransfer::Descriptor&, uint32_t, void*))

DYNALIB_FN(19, system, application_thread_current, uint8_t(void*))
 80a53ec:	b508      	push	{r3, lr}
 80a53ee:	4b02      	ldr	r3, [pc, #8]	; (80a53f8 <application_thread_current+0xc>)
 80a53f0:	681b      	ldr	r3, [r3, #0]
 80a53f2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80a53f4:	9301      	str	r3, [sp, #4]
 80a53f6:	bd08      	pop	{r3, pc}
 80a53f8:	080601a4 	.word	0x080601a4

080a53fc <application_thread_invoke>:
DYNALIB_FN(20, system, system_thread_current, uint8_t(void*))
DYNALIB_FN(21, system, application_thread_invoke, uint8_t(void(*)(void*), void*, void*))
 80a53fc:	b508      	push	{r3, lr}
 80a53fe:	4b02      	ldr	r3, [pc, #8]	; (80a5408 <application_thread_invoke+0xc>)
 80a5400:	681b      	ldr	r3, [r3, #0]
 80a5402:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80a5404:	9301      	str	r3, [sp, #4]
 80a5406:	bd08      	pop	{r3, pc}
 80a5408:	080601a4 	.word	0x080601a4

080a540c <system_thread_get_state>:
DYNALIB_FN(22, system, system_thread_get_state, spark::feature::State(void*))
 80a540c:	b508      	push	{r3, lr}
 80a540e:	4b02      	ldr	r3, [pc, #8]	; (80a5418 <system_thread_get_state+0xc>)
 80a5410:	681b      	ldr	r3, [r3, #0]
 80a5412:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80a5414:	9301      	str	r3, [sp, #4]
 80a5416:	bd08      	pop	{r3, pc}
 80a5418:	080601a4 	.word	0x080601a4

080a541c <system_ctrl_set_app_request_handler>:
DYNALIB_FN(BASE_IDX + 6, system, led_pattern_period, uint16_t(int, int, void*))
DYNALIB_FN(BASE_IDX + 7, system, system_set_tester_handlers, int(system_tester_handlers_t*, void*))
DYNALIB_FN(BASE_IDX + 8, system, system_format_diag_data, int(const uint16_t*, size_t, unsigned, appender_fn, void*, void*))

// Control requests
DYNALIB_FN(BASE_IDX + 9, system, system_ctrl_set_app_request_handler, int(ctrl_request_handler_fn, void*))
 80a541c:	b508      	push	{r3, lr}
 80a541e:	4b03      	ldr	r3, [pc, #12]	; (80a542c <system_ctrl_set_app_request_handler+0x10>)
 80a5420:	681b      	ldr	r3, [r3, #0]
 80a5422:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80a5426:	9301      	str	r3, [sp, #4]
 80a5428:	bd08      	pop	{r3, pc}
 80a542a:	0000      	.short	0x0000
 80a542c:	080601a4 	.word	0x080601a4

080a5430 <system_ctrl_set_result>:
DYNALIB_FN(BASE_IDX + 10, system, system_ctrl_alloc_reply_data, int(ctrl_request*, size_t, void*))
DYNALIB_FN(BASE_IDX + 11, system, system_ctrl_free_request_data, void(ctrl_request*, void*))
DYNALIB_FN(BASE_IDX + 12, system, system_ctrl_set_result, void(ctrl_request*, int, ctrl_completion_handler_fn, void*, void*))
 80a5430:	b508      	push	{r3, lr}
 80a5432:	4b03      	ldr	r3, [pc, #12]	; (80a5440 <system_ctrl_set_result+0x10>)
 80a5434:	681b      	ldr	r3, [r3, #0]
 80a5436:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 80a543a:	9301      	str	r3, [sp, #4]
 80a543c:	bd08      	pop	{r3, pc}
 80a543e:	0000      	.short	0x0000
 80a5440:	080601a4 	.word	0x080601a4

080a5444 <network_disconnect>:
DYNALIB_BEGIN(system_net)

DYNALIB_FN(0, system_net, network_config, const void*(network_handle_t, uint32_t, void*))
DYNALIB_FN(1, system_net, network_connect, void(network_handle_t, uint32_t, uint32_t, void*))
DYNALIB_FN(2, system_net, network_connecting, bool(network_handle_t, uint32_t, void*))
DYNALIB_FN(3, system_net, network_disconnect, void(network_handle_t, uint32_t, void*))
 80a5444:	b508      	push	{r3, lr}
 80a5446:	4b02      	ldr	r3, [pc, #8]	; (80a5450 <network_disconnect+0xc>)
 80a5448:	681b      	ldr	r3, [r3, #0]
 80a544a:	68db      	ldr	r3, [r3, #12]
 80a544c:	9301      	str	r3, [sp, #4]
 80a544e:	bd08      	pop	{r3, pc}
 80a5450:	080601c8 	.word	0x080601c8

080a5454 <network_ready>:
DYNALIB_FN(4, system_net, network_ready, bool(network_handle_t, uint32_t, void*))
 80a5454:	b508      	push	{r3, lr}
 80a5456:	4b02      	ldr	r3, [pc, #8]	; (80a5460 <network_ready+0xc>)
 80a5458:	681b      	ldr	r3, [r3, #0]
 80a545a:	691b      	ldr	r3, [r3, #16]
 80a545c:	9301      	str	r3, [sp, #4]
 80a545e:	bd08      	pop	{r3, pc}
 80a5460:	080601c8 	.word	0x080601c8

080a5464 <network_on>:
DYNALIB_FN(5, system_net, network_on, void(network_handle_t, uint32_t, uint32_t, void*))
 80a5464:	b508      	push	{r3, lr}
 80a5466:	4b02      	ldr	r3, [pc, #8]	; (80a5470 <network_on+0xc>)
 80a5468:	681b      	ldr	r3, [r3, #0]
 80a546a:	695b      	ldr	r3, [r3, #20]
 80a546c:	9301      	str	r3, [sp, #4]
 80a546e:	bd08      	pop	{r3, pc}
 80a5470:	080601c8 	.word	0x080601c8

080a5474 <network_off>:
DYNALIB_FN(6, system_net, network_off, void(network_handle_t, uint32_t, uint32_t, void*))
 80a5474:	b508      	push	{r3, lr}
 80a5476:	4b02      	ldr	r3, [pc, #8]	; (80a5480 <network_off+0xc>)
 80a5478:	681b      	ldr	r3, [r3, #0]
 80a547a:	699b      	ldr	r3, [r3, #24]
 80a547c:	9301      	str	r3, [sp, #4]
 80a547e:	bd08      	pop	{r3, pc}
 80a5480:	080601c8 	.word	0x080601c8

080a5484 <network_listen>:
DYNALIB_FN(7, system_net, network_listen, void(network_handle_t, uint32_t, void*))
 80a5484:	b508      	push	{r3, lr}
 80a5486:	4b02      	ldr	r3, [pc, #8]	; (80a5490 <network_listen+0xc>)
 80a5488:	681b      	ldr	r3, [r3, #0]
 80a548a:	69db      	ldr	r3, [r3, #28]
 80a548c:	9301      	str	r3, [sp, #4]
 80a548e:	bd08      	pop	{r3, pc}
 80a5490:	080601c8 	.word	0x080601c8

080a5494 <spark_process>:

DYNALIB_BEGIN(system_cloud)

DYNALIB_FN(0, system_cloud, spark_variable, bool(const char*, const void*, Spark_Data_TypeDef, spark_variable_t*))
DYNALIB_FN(1, system_cloud, spark_function, bool(const char*, p_user_function_int_str_t, void*))
DYNALIB_FN(2, system_cloud, spark_process, void(void))
 80a5494:	b508      	push	{r3, lr}
 80a5496:	4b02      	ldr	r3, [pc, #8]	; (80a54a0 <spark_process+0xc>)
 80a5498:	681b      	ldr	r3, [r3, #0]
 80a549a:	689b      	ldr	r3, [r3, #8]
 80a549c:	9301      	str	r3, [sp, #4]
 80a549e:	bd08      	pop	{r3, pc}
 80a54a0:	080601cc 	.word	0x080601cc

080a54a4 <spark_cloud_flag_connect>:
DYNALIB_FN(3, system_cloud, spark_cloud_flag_connect, void(void))
 80a54a4:	b508      	push	{r3, lr}
 80a54a6:	4b02      	ldr	r3, [pc, #8]	; (80a54b0 <spark_cloud_flag_connect+0xc>)
 80a54a8:	681b      	ldr	r3, [r3, #0]
 80a54aa:	68db      	ldr	r3, [r3, #12]
 80a54ac:	9301      	str	r3, [sp, #4]
 80a54ae:	bd08      	pop	{r3, pc}
 80a54b0:	080601cc 	.word	0x080601cc

080a54b4 <spark_cloud_flag_connected>:
DYNALIB_FN(4, system_cloud, spark_cloud_flag_disconnect, void(void))
DYNALIB_FN(5, system_cloud, spark_cloud_flag_connected, bool(void))
 80a54b4:	b508      	push	{r3, lr}
 80a54b6:	4b02      	ldr	r3, [pc, #8]	; (80a54c0 <spark_cloud_flag_connected+0xc>)
 80a54b8:	681b      	ldr	r3, [r3, #0]
 80a54ba:	695b      	ldr	r3, [r3, #20]
 80a54bc:	9301      	str	r3, [sp, #4]
 80a54be:	bd08      	pop	{r3, pc}
 80a54c0:	080601cc 	.word	0x080601cc

080a54c4 <spark_send_event>:
DYNALIB_FN(6, system_cloud, system_cloud_protocol_instance, ProtocolFacade*(void))
DYNALIB_FN(7, system_cloud, spark_deviceID, String(void))
DYNALIB_FN(8, system_cloud, spark_send_event, bool(const char*, const char*, int, uint32_t, void*))
 80a54c4:	b508      	push	{r3, lr}
 80a54c6:	4b02      	ldr	r3, [pc, #8]	; (80a54d0 <spark_send_event+0xc>)
 80a54c8:	681b      	ldr	r3, [r3, #0]
 80a54ca:	6a1b      	ldr	r3, [r3, #32]
 80a54cc:	9301      	str	r3, [sp, #4]
 80a54ce:	bd08      	pop	{r3, pc}
 80a54d0:	080601cc 	.word	0x080601cc

080a54d4 <spark_subscribe>:
DYNALIB_FN(9, system_cloud, spark_subscribe, bool(const char*, EventHandler, void*, Spark_Subscription_Scope_TypeDef, const char*, void*))
 80a54d4:	b508      	push	{r3, lr}
 80a54d6:	4b02      	ldr	r3, [pc, #8]	; (80a54e0 <spark_subscribe+0xc>)
 80a54d8:	681b      	ldr	r3, [r3, #0]
 80a54da:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a54dc:	9301      	str	r3, [sp, #4]
 80a54de:	bd08      	pop	{r3, pc}
 80a54e0:	080601cc 	.word	0x080601cc

080a54e4 <spark_sync_time_pending>:
DYNALIB_FN(10, system_cloud, spark_unsubscribe, void(void*))
DYNALIB_FN(11, system_cloud, spark_sync_time, bool(void*))
DYNALIB_FN(12, system_cloud, spark_sync_time_pending, bool(void*))
 80a54e4:	b508      	push	{r3, lr}
 80a54e6:	4b02      	ldr	r3, [pc, #8]	; (80a54f0 <spark_sync_time_pending+0xc>)
 80a54e8:	681b      	ldr	r3, [r3, #0]
 80a54ea:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a54ec:	9301      	str	r3, [sp, #4]
 80a54ee:	bd08      	pop	{r3, pc}
 80a54f0:	080601cc 	.word	0x080601cc

080a54f4 <spark_set_random_seed_from_cloud_handler>:
DYNALIB_FN(13, system_cloud, spark_sync_time_last, system_tick_t(time_t*, void*))
DYNALIB_FN(14, system_cloud, spark_set_connection_property, int(unsigned, unsigned, particle::protocol::connection_properties_t*, void*))
DYNALIB_FN(15, system_cloud, spark_set_random_seed_from_cloud_handler, int(void (*handler)(unsigned int), void*))
 80a54f4:	b508      	push	{r3, lr}
 80a54f6:	4b02      	ldr	r3, [pc, #8]	; (80a5500 <spark_set_random_seed_from_cloud_handler+0xc>)
 80a54f8:	681b      	ldr	r3, [r3, #0]
 80a54fa:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80a54fc:	9301      	str	r3, [sp, #4]
 80a54fe:	bd08      	pop	{r3, pc}
 80a5500:	080601cc 	.word	0x080601cc

080a5504 <malloc>:

#include "dynalib.h"

DYNALIB_BEGIN(rt)

DYNALIB_FN(0, rt, malloc, void*(size_t))
 80a5504:	b508      	push	{r3, lr}
 80a5506:	4b02      	ldr	r3, [pc, #8]	; (80a5510 <malloc+0xc>)
 80a5508:	681b      	ldr	r3, [r3, #0]
 80a550a:	681b      	ldr	r3, [r3, #0]
 80a550c:	9301      	str	r3, [sp, #4]
 80a550e:	bd08      	pop	{r3, pc}
 80a5510:	080601a0 	.word	0x080601a0

080a5514 <free>:
DYNALIB_FN(1, rt, free, void(void*))
 80a5514:	b508      	push	{r3, lr}
 80a5516:	4b02      	ldr	r3, [pc, #8]	; (80a5520 <free+0xc>)
 80a5518:	681b      	ldr	r3, [r3, #0]
 80a551a:	685b      	ldr	r3, [r3, #4]
 80a551c:	9301      	str	r3, [sp, #4]
 80a551e:	bd08      	pop	{r3, pc}
 80a5520:	080601a0 	.word	0x080601a0

080a5524 <realloc>:
DYNALIB_FN(2, rt, realloc, void*(void*, size_t))
 80a5524:	b508      	push	{r3, lr}
 80a5526:	4b02      	ldr	r3, [pc, #8]	; (80a5530 <realloc+0xc>)
 80a5528:	681b      	ldr	r3, [r3, #0]
 80a552a:	689b      	ldr	r3, [r3, #8]
 80a552c:	9301      	str	r3, [sp, #4]
 80a552e:	bd08      	pop	{r3, pc}
 80a5530:	080601a0 	.word	0x080601a0

080a5534 <siscanf>:
DYNALIB_FN(3, rt, sprintf, int(char*, const char*, ...))
DYNALIB_FN(4, rt, siprintf, int(char*, const char*, ...))
DYNALIB_FN(5, rt, sscanf, int(const char*, const char*, ...))
DYNALIB_FN(6, rt, siscanf, int(const char*, const char*, ...))
 80a5534:	b508      	push	{r3, lr}
 80a5536:	4b02      	ldr	r3, [pc, #8]	; (80a5540 <siscanf+0xc>)
 80a5538:	681b      	ldr	r3, [r3, #0]
 80a553a:	699b      	ldr	r3, [r3, #24]
 80a553c:	9301      	str	r3, [sp, #4]
 80a553e:	bd08      	pop	{r3, pc}
 80a5540:	080601a0 	.word	0x080601a0

080a5544 <vsnprintf>:
DYNALIB_FN(7, rt, snprintf, int(char*, size_t, const char*, ...))
DYNALIB_FN(8, rt, sniprintf, int(char*, size_t, const char*, ...))
DYNALIB_FN(9, rt, vsnprintf, int(char*, size_t, const char*, va_list))
 80a5544:	b508      	push	{r3, lr}
 80a5546:	4b02      	ldr	r3, [pc, #8]	; (80a5550 <vsnprintf+0xc>)
 80a5548:	681b      	ldr	r3, [r3, #0]
 80a554a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a554c:	9301      	str	r3, [sp, #4]
 80a554e:	bd08      	pop	{r3, pc}
 80a5550:	080601a0 	.word	0x080601a0

080a5554 <abort>:
DYNALIB_FN(10, rt, vsniprintf, int(char*, size_t, const char*, va_list))
DYNALIB_FN(11, rt, abort, void(void))
 80a5554:	b508      	push	{r3, lr}
 80a5556:	4b02      	ldr	r3, [pc, #8]	; (80a5560 <abort+0xc>)
 80a5558:	681b      	ldr	r3, [r3, #0]
 80a555a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a555c:	9301      	str	r3, [sp, #4]
 80a555e:	bd08      	pop	{r3, pc}
 80a5560:	080601a0 	.word	0x080601a0

080a5564 <_malloc_r>:
DYNALIB_FN(12, rt, _malloc_r, void*(struct _reent*, size_t))
 80a5564:	b508      	push	{r3, lr}
 80a5566:	4b02      	ldr	r3, [pc, #8]	; (80a5570 <_malloc_r+0xc>)
 80a5568:	681b      	ldr	r3, [r3, #0]
 80a556a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a556c:	9301      	str	r3, [sp, #4]
 80a556e:	bd08      	pop	{r3, pc}
 80a5570:	080601a0 	.word	0x080601a0

080a5574 <_ZN8SPIClassD1Ev>:
  Mutex mutex_;
#endif

public:
  SPIClass(HAL_SPI_Interface spi);
  virtual ~SPIClass() {};
 80a5574:	4770      	bx	lr

080a5576 <_ZN8SPIClassD0Ev>:
 80a5576:	b510      	push	{r4, lr}
 80a5578:	4604      	mov	r4, r0
 80a557a:	f7fa fd92 	bl	80a00a2 <_ZdlPv>
 80a557e:	4620      	mov	r0, r4
 80a5580:	bd10      	pop	{r4, pc}
	...

080a5584 <_ZN8SPIClassC1E17HAL_SPI_Interface>:
  if (!info->enabled || info->default_settings)
    return particle::__SPISettings();
  return particle::__SPISettings(info->clock, info->bit_order, info->data_mode);
}

SPIClass::SPIClass(HAL_SPI_Interface spi)
 80a5584:	b570      	push	{r4, r5, r6, lr}
 80a5586:	4604      	mov	r4, r0
 80a5588:	460e      	mov	r6, r1
 80a558a:	4b07      	ldr	r3, [pc, #28]	; (80a55a8 <_ZN8SPIClassC1E17HAL_SPI_Interface+0x24>)
    Mutex(os_mutex_t handle) : handle_(handle) {}

    /**
     * Creates a new mutex.
     */
    Mutex() : handle_(nullptr)
 80a558c:	2500      	movs	r5, #0
 80a558e:	6003      	str	r3, [r0, #0]
 80a5590:	f840 5f0c 	str.w	r5, [r0, #12]!
    {
        os_mutex_create(&handle_);
 80a5594:	f7ff fdb0 	bl	80a50f8 <os_mutex_create>
{
  _spi = spi;
  HAL_SPI_Init(_spi);
 80a5598:	4630      	mov	r0, r6
  return particle::__SPISettings(info->clock, info->bit_order, info->data_mode);
}

SPIClass::SPIClass(HAL_SPI_Interface spi)
{
  _spi = spi;
 80a559a:	7126      	strb	r6, [r4, #4]
  HAL_SPI_Init(_spi);
 80a559c:	f7ff fd24 	bl	80a4fe8 <HAL_SPI_Init>
  dividerReference = SPI_CLK_SYSTEM;     // 0 indicates the system clock
 80a55a0:	60a5      	str	r5, [r4, #8]
}
 80a55a2:	4620      	mov	r0, r4
 80a55a4:	bd70      	pop	{r4, r5, r6, pc}
 80a55a6:	bf00      	nop
 80a55a8:	080a92c4 	.word	0x080a92c4

080a55ac <_ZN8SPIClass5beginEv>:

void SPIClass::begin()
{
    // todo - fetch default pin from HAL
  HAL_SPI_Begin(_spi, SPI_DEFAULT_SS);
 80a55ac:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80a55b0:	7900      	ldrb	r0, [r0, #4]
 80a55b2:	f7ff bcf1 	b.w	80a4f98 <HAL_SPI_Begin>

080a55b6 <_ZN8SPIClass5beginEt>:
}

void SPIClass::begin(uint16_t ss_pin)
{
  if (ss_pin >= TOTAL_PINS)
 80a55b6:	2917      	cmp	r1, #23
 80a55b8:	d802      	bhi.n	80a55c0 <_ZN8SPIClass5beginEt+0xa>
  {
    return;
  }

  HAL_SPI_Begin(_spi, ss_pin);
 80a55ba:	7900      	ldrb	r0, [r0, #4]
 80a55bc:	f7ff bcec 	b.w	80a4f98 <HAL_SPI_Begin>
 80a55c0:	4770      	bx	lr

080a55c2 <_ZN8SPIClass11setBitOrderEh>:
  HAL_SPI_End(_spi);
}

void SPIClass::setBitOrder(uint8_t bitOrder)
{
  HAL_SPI_Set_Bit_Order(_spi, bitOrder);
 80a55c2:	7900      	ldrb	r0, [r0, #4]
 80a55c4:	f7ff bcf0 	b.w	80a4fa8 <HAL_SPI_Set_Bit_Order>

080a55c8 <_ZN8SPIClass11setDataModeEh>:
}

void SPIClass::setDataMode(uint8_t mode)
{
  HAL_SPI_Set_Data_Mode(_spi, mode);
 80a55c8:	7900      	ldrb	r0, [r0, #4]
 80a55ca:	f7ff bcf5 	b.w	80a4fb8 <HAL_SPI_Set_Data_Mode>

080a55ce <_ZN8SPIClass14endTransactionEv>:
        }
    }

    void lock() { os_mutex_lock(handle_); }
    bool trylock() { return os_mutex_trylock(handle_)==0; }
    void unlock() { os_mutex_unlock(handle_); }
 80a55ce:	68c0      	ldr	r0, [r0, #12]
 80a55d0:	f7ff bda2 	b.w	80a5118 <os_mutex_unlock>

080a55d4 <_Z17divisorShiftScaleh>:
uint8_t divisorShiftScale(uint8_t divider)
{
    unsigned result = 0;
    for (; result<arraySize(clock_divisors); result++)
    {
        if (clock_divisors[result]==divider)
 80a55d4:	4a05      	ldr	r2, [pc, #20]	; (80a55ec <_Z17divisorShiftScaleh+0x18>)
    SPI_CLOCK_DIV256
};

uint8_t divisorShiftScale(uint8_t divider)
{
    unsigned result = 0;
 80a55d6:	2300      	movs	r3, #0
    for (; result<arraySize(clock_divisors); result++)
    {
        if (clock_divisors[result]==divider)
 80a55d8:	5c99      	ldrb	r1, [r3, r2]
 80a55da:	4281      	cmp	r1, r0
 80a55dc:	d002      	beq.n	80a55e4 <_Z17divisorShiftScaleh+0x10>
};

uint8_t divisorShiftScale(uint8_t divider)
{
    unsigned result = 0;
    for (; result<arraySize(clock_divisors); result++)
 80a55de:	3301      	adds	r3, #1
 80a55e0:	2b08      	cmp	r3, #8
 80a55e2:	d1f9      	bne.n	80a55d8 <_Z17divisorShiftScaleh+0x4>
    {
        if (clock_divisors[result]==divider)
            break;
    }
    return result+1;
 80a55e4:	1c58      	adds	r0, r3, #1
}
 80a55e6:	b2c0      	uxtb	r0, r0
 80a55e8:	4770      	bx	lr
 80a55ea:	bf00      	nop
 80a55ec:	080a92cc 	.word	0x080a92cc

080a55f0 <_ZN8SPIClass19computeClockDividerEjjRhRj>:

void SPIClass::computeClockDivider(unsigned reference, unsigned targetSpeed, uint8_t& divider, unsigned& clock)
{
    clock = reference;
    uint8_t scale = 0;
    clock >>= 1;        // div2 is the first
 80a55f0:	0840      	lsrs	r0, r0, #1
        HAL_SPI_Set_Clock_Divider(_spi, rate);
    }
}

void SPIClass::computeClockDivider(unsigned reference, unsigned targetSpeed, uint8_t& divider, unsigned& clock)
{
 80a55f2:	b530      	push	{r4, r5, lr}
    clock = reference;
    uint8_t scale = 0;
    clock >>= 1;        // div2 is the first
 80a55f4:	6018      	str	r0, [r3, #0]
 80a55f6:	2400      	movs	r4, #0
    while (clock > targetSpeed && scale<7) {
 80a55f8:	6818      	ldr	r0, [r3, #0]
 80a55fa:	b2e5      	uxtb	r5, r4
 80a55fc:	4288      	cmp	r0, r1
 80a55fe:	d906      	bls.n	80a560e <_ZN8SPIClass19computeClockDividerEjjRhRj+0x1e>
 80a5600:	3401      	adds	r4, #1
 80a5602:	2c08      	cmp	r4, #8
 80a5604:	d002      	beq.n	80a560c <_ZN8SPIClass19computeClockDividerEjjRhRj+0x1c>
        clock >>= 1;
 80a5606:	0840      	lsrs	r0, r0, #1
 80a5608:	6018      	str	r0, [r3, #0]
void SPIClass::computeClockDivider(unsigned reference, unsigned targetSpeed, uint8_t& divider, unsigned& clock)
{
    clock = reference;
    uint8_t scale = 0;
    clock >>= 1;        // div2 is the first
    while (clock > targetSpeed && scale<7) {
 80a560a:	e7f5      	b.n	80a55f8 <_ZN8SPIClass19computeClockDividerEjjRhRj+0x8>
 80a560c:	2507      	movs	r5, #7
        clock >>= 1;
        scale++;
    }
    divider = clock_divisors[scale];
 80a560e:	4b02      	ldr	r3, [pc, #8]	; (80a5618 <_ZN8SPIClass19computeClockDividerEjjRhRj+0x28>)
 80a5610:	5d5b      	ldrb	r3, [r3, r5]
 80a5612:	7013      	strb	r3, [r2, #0]
 80a5614:	bd30      	pop	{r4, r5, pc}
 80a5616:	bf00      	nop
 80a5618:	080a92cc 	.word	0x080a92cc

080a561c <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE>:
  lock();
  return 0;
}

int32_t SPIClass::beginTransaction(const particle::__SPISettings& settings)
{
 80a561c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a5620:	4680      	mov	r8, r0
 80a5622:	b08f      	sub	sp, #60	; 0x3c
            os_mutex_destroy(handle_);
            handle_ = nullptr;
        }
    }

    void lock() { os_mutex_lock(handle_); }
 80a5624:	68c0      	ldr	r0, [r0, #12]
 80a5626:	460f      	mov	r7, r1
 80a5628:	f7ff fd6e 	bl	80a5108 <os_mutex_lock>
  lock();
  // Get Current SPISettings
  hal_spi_info_t info;
  querySpiInfo(_spi, &info);
 80a562c:	f898 4004 	ldrb.w	r4, [r8, #4]
#include "core_hal.h"
#include "spark_macros.h"

static void querySpiInfo(HAL_SPI_Interface spi, hal_spi_info_t* info)
{
  memset(info, 0, sizeof(hal_spi_info_t));
 80a5630:	2214      	movs	r2, #20
 80a5632:	2100      	movs	r1, #0
 80a5634:	a809      	add	r0, sp, #36	; 0x24
 80a5636:	f002 f910 	bl	80a785a <memset>
  info->version = HAL_SPI_INFO_VERSION_1;
 80a563a:	230b      	movs	r3, #11
  HAL_SPI_Info(spi, info, nullptr);
 80a563c:	4620      	mov	r0, r4
 80a563e:	2200      	movs	r2, #0
 80a5640:	a909      	add	r1, sp, #36	; 0x24
#include "spark_macros.h"

static void querySpiInfo(HAL_SPI_Interface spi, hal_spi_info_t* info)
{
  memset(info, 0, sizeof(hal_spi_info_t));
  info->version = HAL_SPI_INFO_VERSION_1;
 80a5642:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
  HAL_SPI_Info(spi, info, nullptr);
 80a5646:	f7ff fcdf 	bl	80a5008 <HAL_SPI_Info>
}

static particle::__SPISettings spiSettingsFromSpiInfo(hal_spi_info_t* info)
{
  if (!info->enabled || info->default_settings)
 80a564a:	f89d 402d 	ldrb.w	r4, [sp, #45]	; 0x2d
 80a564e:	b14c      	cbz	r4, 80a5664 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x48>
 80a5650:	f89d 502c 	ldrb.w	r5, [sp, #44]	; 0x2c
 80a5654:	b92d      	cbnz	r5, 80a5662 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x46>
    return particle::__SPISettings();
  return particle::__SPISettings(info->clock, info->bit_order, info->data_mode);
 80a5656:	9e0c      	ldr	r6, [sp, #48]	; 0x30
 80a5658:	f89d 9034 	ldrb.w	r9, [sp, #52]	; 0x34
 80a565c:	f89d 4035 	ldrb.w	r4, [sp, #53]	; 0x35
 80a5660:	e003      	b.n	80a566a <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x4e>
      dataMode_{dataMode}
  {
  }

  __SPISettings()
  {
 80a5662:	2400      	movs	r4, #0
 80a5664:	46a1      	mov	r9, r4
 80a5666:	4626      	mov	r6, r4
 80a5668:	2501      	movs	r5, #1
 80a566a:	793b      	ldrb	r3, [r7, #4]
  }

  bool operator==(const __SPISettings& other) const
  {
    if (default_ && other.default_)
 80a566c:	b10d      	cbz	r5, 80a5672 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x56>
 80a566e:	2b00      	cmp	r3, #0
 80a5670:	d140      	bne.n	80a56f4 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0xd8>
      return true;

    if (default_ == other.default_ &&
 80a5672:	429d      	cmp	r5, r3
 80a5674:	d10b      	bne.n	80a568e <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x72>
 80a5676:	68ba      	ldr	r2, [r7, #8]
 80a5678:	42b2      	cmp	r2, r6
 80a567a:	d108      	bne.n	80a568e <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x72>
        clock_ == other.clock_ &&
        bitOrder_ == other.bitOrder_ &&
 80a567c:	f88d 9020 	strb.w	r9, [sp, #32]
 80a5680:	f88d 4021 	strb.w	r4, [sp, #33]	; 0x21
 80a5684:	f8bd 1020 	ldrh.w	r1, [sp, #32]
 80a5688:	89ba      	ldrh	r2, [r7, #12]
 80a568a:	4291      	cmp	r1, r2
 80a568c:	d032      	beq.n	80a56f4 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0xd8>
  querySpiInfo(_spi, &info);
  particle::__SPISettings current = spiSettingsFromSpiInfo(&info);
  // If they differ, reconfigure SPI peripheral
  if (settings != current)
  {
    if (!settings.default_) {
 80a568e:	bb23      	cbnz	r3, 80a56da <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0xbe>
      uint8_t divisor = 0;
 80a5690:	f88d 300f 	strb.w	r3, [sp, #15]
      unsigned int clock;
      computeClockDivider((unsigned int)info.system_clock, settings.clock_, divisor, clock);
 80a5694:	f10d 020f 	add.w	r2, sp, #15
 80a5698:	ab04      	add	r3, sp, #16
 80a569a:	68b9      	ldr	r1, [r7, #8]
 80a569c:	980a      	ldr	r0, [sp, #40]	; 0x28
 80a569e:	f7ff ffa7 	bl	80a55f0 <_ZN8SPIClass19computeClockDividerEjjRhRj>
 80a56a2:	793b      	ldrb	r3, [r7, #4]
    return false;
  }

  bool operator<=(const __SPISettings& other) const
  {
    if (default_ && other.default_)
 80a56a4:	b105      	cbz	r5, 80a56a8 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x8c>
 80a56a6:	bb13      	cbnz	r3, 80a56ee <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0xd2>
      return true;

    if (default_ == other.default_ &&
 80a56a8:	42ab      	cmp	r3, r5
 80a56aa:	d009      	beq.n	80a56c0 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0xa4>

      if (!(current <= settings && clock == current.clock_)) {
        HAL_SPI_Set_Settings(_spi, 0, divisor, settings.bitOrder_, settings.dataMode_, nullptr);
 80a56ac:	2100      	movs	r1, #0
 80a56ae:	7b3b      	ldrb	r3, [r7, #12]
 80a56b0:	9101      	str	r1, [sp, #4]
 80a56b2:	7b7c      	ldrb	r4, [r7, #13]
 80a56b4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80a56b8:	f898 0004 	ldrb.w	r0, [r8, #4]
 80a56bc:	9400      	str	r4, [sp, #0]
 80a56be:	e013      	b.n	80a56e8 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0xcc>
 80a56c0:	68bb      	ldr	r3, [r7, #8]
 80a56c2:	42b3      	cmp	r3, r6
 80a56c4:	d3f2      	bcc.n	80a56ac <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x90>
        clock_ <= other.clock_ &&
        bitOrder_ == other.bitOrder_ &&
 80a56c6:	f88d 9020 	strb.w	r9, [sp, #32]
 80a56ca:	f88d 4021 	strb.w	r4, [sp, #33]	; 0x21
 80a56ce:	f8bd 2020 	ldrh.w	r2, [sp, #32]
 80a56d2:	89bb      	ldrh	r3, [r7, #12]
 80a56d4:	429a      	cmp	r2, r3
 80a56d6:	d1e9      	bne.n	80a56ac <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x90>
 80a56d8:	e009      	b.n	80a56ee <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0xd2>
      }
    } else {
      HAL_SPI_Set_Settings(_spi, 1, 0, 0, 0, nullptr);
 80a56da:	2300      	movs	r3, #0
 80a56dc:	461a      	mov	r2, r3
 80a56de:	f898 0004 	ldrb.w	r0, [r8, #4]
 80a56e2:	9301      	str	r3, [sp, #4]
 80a56e4:	9300      	str	r3, [sp, #0]
 80a56e6:	2101      	movs	r1, #1
 80a56e8:	f7ff fc96 	bl	80a5018 <HAL_SPI_Set_Settings>
 80a56ec:	e002      	b.n	80a56f4 <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0xd8>
    if (!settings.default_) {
      uint8_t divisor = 0;
      unsigned int clock;
      computeClockDivider((unsigned int)info.system_clock, settings.clock_, divisor, clock);

      if (!(current <= settings && clock == current.clock_)) {
 80a56ee:	9b04      	ldr	r3, [sp, #16]
 80a56f0:	42b3      	cmp	r3, r6
 80a56f2:	d1db      	bne.n	80a56ac <_ZN8SPIClass16beginTransactionERKN8particle13__SPISettingsE+0x90>
      HAL_SPI_Set_Settings(_spi, 1, 0, 0, 0, nullptr);
    }
  }

  return 0;
}
 80a56f4:	2000      	movs	r0, #0
 80a56f6:	b00f      	add	sp, #60	; 0x3c
 80a56f8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

080a56fc <_ZN8SPIClass13setClockSpeedEjj>:
    }
    divider = clock_divisors[scale];
}

unsigned SPIClass::setClockSpeed(unsigned value, unsigned value_scale)
{
 80a56fc:	b570      	push	{r4, r5, r6, lr}
 80a56fe:	4604      	mov	r4, r0
    // actual speed is the system clock divided by some scalar
    unsigned targetSpeed = value*value_scale;
 80a5700:	fb02 f501 	mul.w	r5, r2, r1
    }
    divider = clock_divisors[scale];
}

unsigned SPIClass::setClockSpeed(unsigned value, unsigned value_scale)
{
 80a5704:	b088      	sub	sp, #32
    // actual speed is the system clock divided by some scalar
    unsigned targetSpeed = value*value_scale;
    hal_spi_info_t info;
    querySpiInfo(_spi, &info);
 80a5706:	7906      	ldrb	r6, [r0, #4]
#include "core_hal.h"
#include "spark_macros.h"

static void querySpiInfo(HAL_SPI_Interface spi, hal_spi_info_t* info)
{
  memset(info, 0, sizeof(hal_spi_info_t));
 80a5708:	2214      	movs	r2, #20
 80a570a:	2100      	movs	r1, #0
 80a570c:	a803      	add	r0, sp, #12
 80a570e:	f002 f8a4 	bl	80a785a <memset>
  info->version = HAL_SPI_INFO_VERSION_1;
 80a5712:	230b      	movs	r3, #11
  HAL_SPI_Info(spi, info, nullptr);
 80a5714:	a903      	add	r1, sp, #12
 80a5716:	4630      	mov	r0, r6
 80a5718:	2200      	movs	r2, #0
#include "spark_macros.h"

static void querySpiInfo(HAL_SPI_Interface spi, hal_spi_info_t* info)
{
  memset(info, 0, sizeof(hal_spi_info_t));
  info->version = HAL_SPI_INFO_VERSION_1;
 80a571a:	f8ad 300c 	strh.w	r3, [sp, #12]
  HAL_SPI_Info(spi, info, nullptr);
 80a571e:	f7ff fc73 	bl	80a5008 <HAL_SPI_Info>
    unsigned targetSpeed = value*value_scale;
    hal_spi_info_t info;
    querySpiInfo(_spi, &info);
    uint8_t rate;
    unsigned clock;
    computeClockDivider(info.system_clock, targetSpeed, rate, clock);
 80a5722:	ab02      	add	r3, sp, #8
 80a5724:	f10d 0207 	add.w	r2, sp, #7
 80a5728:	4629      	mov	r1, r5
 80a572a:	9804      	ldr	r0, [sp, #16]
 80a572c:	f7ff ff60 	bl	80a55f0 <_ZN8SPIClass19computeClockDividerEjjRhRj>
    HAL_SPI_Set_Clock_Divider(_spi, rate);
 80a5730:	7920      	ldrb	r0, [r4, #4]
 80a5732:	f89d 1007 	ldrb.w	r1, [sp, #7]
 80a5736:	f7ff fc47 	bl	80a4fc8 <HAL_SPI_Set_Clock_Divider>
    return clock;
}
 80a573a:	9802      	ldr	r0, [sp, #8]
 80a573c:	b008      	add	sp, #32
 80a573e:	bd70      	pop	{r4, r5, r6, pc}

080a5740 <_ZN8SPIClass15setClockDividerEh>:
    }
    return result+1;
}

void SPIClass::setClockDivider(uint8_t rate)
{
 80a5740:	b538      	push	{r3, r4, r5, lr}
 80a5742:	4604      	mov	r4, r0
    if (dividerReference)
 80a5744:	68a5      	ldr	r5, [r4, #8]
    }
    return result+1;
}

void SPIClass::setClockDivider(uint8_t rate)
{
 80a5746:	4608      	mov	r0, r1
    if (dividerReference)
 80a5748:	b14d      	cbz	r5, 80a575e <_ZN8SPIClass15setClockDividerEh+0x1e>
    {
        // determine the clock speed
        uint8_t scale = divisorShiftScale(rate);
 80a574a:	f7ff ff43 	bl	80a55d4 <_Z17divisorShiftScaleh>
        unsigned targetSpeed = dividerReference>>scale;
        setClockSpeed(targetSpeed);
 80a574e:	2201      	movs	r2, #1
 80a5750:	fa25 f100 	lsr.w	r1, r5, r0
 80a5754:	4620      	mov	r0, r4
    }
    else
    {
        HAL_SPI_Set_Clock_Divider(_spi, rate);
    }
}
 80a5756:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    if (dividerReference)
    {
        // determine the clock speed
        uint8_t scale = divisorShiftScale(rate);
        unsigned targetSpeed = dividerReference>>scale;
        setClockSpeed(targetSpeed);
 80a575a:	f7ff bfcf 	b.w	80a56fc <_ZN8SPIClass13setClockSpeedEjj>
    }
    else
    {
        HAL_SPI_Set_Clock_Divider(_spi, rate);
 80a575e:	7920      	ldrb	r0, [r4, #4]
    }
}
 80a5760:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        unsigned targetSpeed = dividerReference>>scale;
        setClockSpeed(targetSpeed);
    }
    else
    {
        HAL_SPI_Set_Clock_Divider(_spi, rate);
 80a5764:	f7ff bc30 	b.w	80a4fc8 <HAL_SPI_Set_Clock_Divider>

080a5768 <_ZN8SPIClass8transferEh>:
    HAL_SPI_Set_Clock_Divider(_spi, rate);
    return clock;
}

byte SPIClass::transfer(byte _data)
{
 80a5768:	b508      	push	{r3, lr}
  return HAL_SPI_Send_Receive_Data(_spi, _data);
 80a576a:	7900      	ldrb	r0, [r0, #4]
 80a576c:	f7ff fc34 	bl	80a4fd8 <HAL_SPI_Send_Receive_Data>
}
 80a5770:	b2c0      	uxtb	r0, r0
 80a5772:	bd08      	pop	{r3, pc}

080a5774 <_ZN8SPIClass9isEnabledEv>:
  //To Do
}

bool SPIClass::isEnabled()
{
  return HAL_SPI_Is_Enabled(_spi);
 80a5774:	7900      	ldrb	r0, [r0, #4]
 80a5776:	f7ff bc3f 	b.w	80a4ff8 <HAL_SPI_Is_Enabled>

080a577a <_ZN11SystemClass5resetEm>:
    reset(0);
}

void SystemClass::reset(uint32_t data)
{
    HAL_Core_System_Reset_Ex(RESET_REASON_USER, data, nullptr);
 80a577a:	4601      	mov	r1, r0
 80a577c:	2200      	movs	r2, #0
 80a577e:	208c      	movs	r0, #140	; 0x8c
 80a5780:	f7ff bc82 	b.w	80a5088 <HAL_Core_System_Reset_Ex>

080a5784 <_ZN11SystemClass5resetEv>:
    HAL_Core_Enter_Bootloader(persist);
}

void SystemClass::reset(void)
{
    reset(0);
 80a5784:	2000      	movs	r0, #0
 80a5786:	f7ff bff8 	b.w	80a577a <_ZN11SystemClass5resetEm>
	...

080a578c <_GLOBAL__sub_I_System>:
    WAKEUP_REASON_RTC = 2,
    WAKEUP_REASON_PIN_OR_RTC = 3
};

struct SleepResult {
    SleepResult() {}
 80a578c:	f64f 739c 	movw	r3, #65436	; 0xff9c
    return wokenUpByRtc();
}

system_error_t SleepResult::error() const {
    return err_;
}
 80a5790:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a5792:	4c0d      	ldr	r4, [pc, #52]	; (80a57c8 <_GLOBAL__sub_I_System+0x3c>)
 80a5794:	2500      	movs	r5, #0
 80a5796:	8063      	strh	r3, [r4, #2]
 80a5798:	f64f 73ff 	movw	r3, #65535	; 0xffff

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
 80a579c:	4628      	mov	r0, r5
    WAKEUP_REASON_RTC = 2,
    WAKEUP_REASON_PIN_OR_RTC = 3
};

struct SleepResult {
    SleepResult() {}
 80a579e:	80a3      	strh	r3, [r4, #4]
 80a57a0:	7025      	strb	r5, [r4, #0]

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
 80a57a2:	f7ff fe13 	bl	80a53cc <set_system_mode>
        return get_flag(flag) != 0;
    }

    inline int resetReason() const
    {
        int reason = RESET_REASON_NONE;
 80a57a6:	a802      	add	r0, sp, #8
 80a57a8:	f840 5d04 	str.w	r5, [r0, #-4]!
        HAL_Core_Get_Last_Reset_Info(&reason, nullptr, nullptr);
 80a57ac:	462a      	mov	r2, r5
 80a57ae:	4629      	mov	r1, r5
 80a57b0:	f7ff fc72 	bl	80a5098 <HAL_Core_Get_Last_Reset_Info>
        return reason;
 80a57b4:	9b01      	ldr	r3, [sp, #4]
class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
        if (resetReason() == RESET_REASON_POWER_MANAGEMENT) {
 80a57b6:	2b1e      	cmp	r3, #30
 80a57b8:	d104      	bne.n	80a57c4 <_GLOBAL__sub_I_System+0x38>
            // Woken up from standby mode
            sleepResult_ = SleepResult(WAKEUP_REASON_PIN_OR_RTC, SYSTEM_ERROR_NONE, WKP);
 80a57ba:	2303      	movs	r3, #3
 80a57bc:	7023      	strb	r3, [r4, #0]
 80a57be:	2311      	movs	r3, #17
 80a57c0:	8065      	strh	r5, [r4, #2]
 80a57c2:	80a3      	strh	r3, [r4, #4]
 80a57c4:	b003      	add	sp, #12
 80a57c6:	bd30      	pop	{r4, r5, pc}
 80a57c8:	2000106c 	.word	0x2000106c

080a57cc <_Z11str_reversePc>:

//------------------------------------------------------------------------------------------
#define BUFSIZE (sizeof(long) * 8 + 1)

//utility function used by ultoa()
__attribute__((weak)) void str_reverse(char* buffer){
 80a57cc:	b510      	push	{r4, lr}
 80a57ce:	4604      	mov	r4, r0
	char *i, *j;
	char c;
	i=buffer;
	j=buffer + strlen(buffer)-1;
 80a57d0:	f002 f8eb 	bl	80a79aa <strlen>
 80a57d4:	3801      	subs	r0, #1
 80a57d6:	1823      	adds	r3, r4, r0
 80a57d8:	4620      	mov	r0, r4
	while(i<j){
 80a57da:	4298      	cmp	r0, r3
 80a57dc:	d206      	bcs.n	80a57ec <_Z11str_reversePc+0x20>
		c = *i;
 80a57de:	7802      	ldrb	r2, [r0, #0]
		*i = *j;
 80a57e0:	7819      	ldrb	r1, [r3, #0]
 80a57e2:	f800 1b01 	strb.w	r1, [r0], #1
		*j = c;
 80a57e6:	f803 2901 	strb.w	r2, [r3], #-1
__attribute__((weak)) void str_reverse(char* buffer){
	char *i, *j;
	char c;
	i=buffer;
	j=buffer + strlen(buffer)-1;
	while(i<j){
 80a57ea:	e7f6      	b.n	80a57da <_Z11str_reversePc+0xe>
 80a57ec:	bd10      	pop	{r4, pc}

080a57ee <ultoa>:
      memcpy(head, ++tail, i);
      return str;
}

//convert unsigned long to string
__attribute__((weak)) char* ultoa(unsigned long a, char* buffer, int radix, char pad){
 80a57ee:	b570      	push	{r4, r5, r6, lr}
 80a57f0:	460c      	mov	r4, r1
	if(radix<2 || radix>36){
 80a57f2:	1e91      	subs	r1, r2, #2
 80a57f4:	2922      	cmp	r1, #34	; 0x22
 80a57f6:	d820      	bhi.n	80a583a <ultoa+0x4c>
 80a57f8:	4625      	mov	r5, r4
 80a57fa:	4629      	mov	r1, r5
		return NULL;
	}
	char* ptr=buffer;

	div_t result;
	while(a){
 80a57fc:	b910      	cbnz	r0, 80a5804 <ultoa+0x16>
                *ptr += 'a'-10;
            }
            ++ptr;
            a = result.quot;
	}
        while (ptr < buffer+pad)
 80a57fe:	4423      	add	r3, r4
            *ptr++ = '0';
 80a5800:	2230      	movs	r2, #48	; 0x30
 80a5802:	e00e      	b.n	80a5822 <ultoa+0x34>
	div_t result;
	while(a){
            /* toolchain bug??
            result = div(a, radix);
            */
            result.quot = a/radix;
 80a5804:	fbb0 f6f2 	udiv	r6, r0, r2
            result.rem = a%radix;
 80a5808:	fb02 0016 	mls	r0, r2, r6, r0
            *ptr = result.rem;
 80a580c:	b2c1      	uxtb	r1, r0
            if(result.rem<10){
 80a580e:	2809      	cmp	r0, #9
            /* toolchain bug??
            result = div(a, radix);
            */
            result.quot = a/radix;
            result.rem = a%radix;
            *ptr = result.rem;
 80a5810:	f805 1b01 	strb.w	r1, [r5], #1
            if(result.rem<10){
                *ptr += '0';
 80a5814:	bf94      	ite	ls
 80a5816:	3130      	addls	r1, #48	; 0x30
            }else{
                *ptr += 'a'-10;
 80a5818:	3157      	addhi	r1, #87	; 0x57
 80a581a:	f805 1c01 	strb.w	r1, [r5, #-1]
            }
            ++ptr;
            a = result.quot;
 80a581e:	4630      	mov	r0, r6
		return NULL;
	}
	char* ptr=buffer;

	div_t result;
	while(a){
 80a5820:	e7eb      	b.n	80a57fa <ultoa+0xc>
                *ptr += 'a'-10;
            }
            ++ptr;
            a = result.quot;
	}
        while (ptr < buffer+pad)
 80a5822:	4299      	cmp	r1, r3
 80a5824:	d202      	bcs.n	80a582c <ultoa+0x3e>
            *ptr++ = '0';
 80a5826:	f801 2b01 	strb.w	r2, [r1], #1
                *ptr += 'a'-10;
            }
            ++ptr;
            a = result.quot;
	}
        while (ptr < buffer+pad)
 80a582a:	e7fa      	b.n	80a5822 <ultoa+0x34>
            *ptr++ = '0';

	*ptr = '\0';
 80a582c:	2300      	movs	r3, #0
	str_reverse(buffer);
 80a582e:	4620      	mov	r0, r4
            a = result.quot;
	}
        while (ptr < buffer+pad)
            *ptr++ = '0';

	*ptr = '\0';
 80a5830:	700b      	strb	r3, [r1, #0]
	str_reverse(buffer);
 80a5832:	f7ff ffcb 	bl	80a57cc <_Z11str_reversePc>
	return buffer;
 80a5836:	4620      	mov	r0, r4
 80a5838:	bd70      	pop	{r4, r5, r6, pc}
}

//convert unsigned long to string
__attribute__((weak)) char* ultoa(unsigned long a, char* buffer, int radix, char pad){
	if(radix<2 || radix>36){
		return NULL;
 80a583a:	2000      	movs	r0, #0
            *ptr++ = '0';

	*ptr = '\0';
	str_reverse(buffer);
	return buffer;
}
 80a583c:	bd70      	pop	{r4, r5, r6, pc}

080a583e <utoa>:
		ultoa(a, buffer, radix);
	}
	return buffer;
}

__attribute__((weak)) char* utoa(unsigned a, char* buffer, int radix) {
 80a583e:	b508      	push	{r3, lr}
    return ultoa(a, buffer, radix);
 80a5840:	2301      	movs	r3, #1
 80a5842:	f7ff ffd4 	bl	80a57ee <ultoa>
}
 80a5846:	bd08      	pop	{r3, pc}

080a5848 <_ZN6StringD1Ev>:
	init();
	char buf[33];
	dtoa(value, decimalPlaces, buf);
        *this = buf;
}
String::~String()
 80a5848:	b510      	push	{r4, lr}
 80a584a:	4604      	mov	r4, r0
{
	free(buffer);
 80a584c:	6800      	ldr	r0, [r0, #0]
 80a584e:	f7ff fe61 	bl	80a5514 <free>
}
 80a5852:	4620      	mov	r0, r4
 80a5854:	bd10      	pop	{r4, pc}

080a5856 <_ZN6String10invalidateEv>:
	len = 0;
	flags = 0;
}

void String::invalidate(void)
{
 80a5856:	b510      	push	{r4, lr}
 80a5858:	4604      	mov	r4, r0
	if (buffer) free(buffer);
 80a585a:	6800      	ldr	r0, [r0, #0]
 80a585c:	b108      	cbz	r0, 80a5862 <_ZN6String10invalidateEv+0xc>
 80a585e:	f7ff fe59 	bl	80a5514 <free>
	buffer = NULL;
 80a5862:	2300      	movs	r3, #0
 80a5864:	6023      	str	r3, [r4, #0]
	capacity = len = 0;
 80a5866:	60a3      	str	r3, [r4, #8]
 80a5868:	6063      	str	r3, [r4, #4]
 80a586a:	bd10      	pop	{r4, pc}

080a586c <_ZN6String12changeBufferEj>:
	}
	return 0;
}

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
 80a586c:	b538      	push	{r3, r4, r5, lr}
 80a586e:	4604      	mov	r4, r0
 80a5870:	460d      	mov	r5, r1
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
 80a5872:	6800      	ldr	r0, [r0, #0]
 80a5874:	3101      	adds	r1, #1
 80a5876:	f7ff fe55 	bl	80a5524 <realloc>
	if (newbuffer) {
 80a587a:	b110      	cbz	r0, 80a5882 <_ZN6String12changeBufferEj+0x16>
		buffer = newbuffer;
		capacity = maxStrLen;
 80a587c:	e884 0021 	stmia.w	r4, {r0, r5}
		return 1;
 80a5880:	2001      	movs	r0, #1
	}
	return 0;
}
 80a5882:	bd38      	pop	{r3, r4, r5, pc}

080a5884 <_ZN6String7reserveEj>:
	buffer = NULL;
	capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
 80a5884:	b510      	push	{r4, lr}
	if (buffer && capacity >= size) return 1;
 80a5886:	6803      	ldr	r3, [r0, #0]
	buffer = NULL;
	capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
 80a5888:	4604      	mov	r4, r0
	if (buffer && capacity >= size) return 1;
 80a588a:	b113      	cbz	r3, 80a5892 <_ZN6String7reserveEj+0xe>
 80a588c:	6843      	ldr	r3, [r0, #4]
 80a588e:	428b      	cmp	r3, r1
 80a5890:	d207      	bcs.n	80a58a2 <_ZN6String7reserveEj+0x1e>
	if (changeBuffer(size)) {
 80a5892:	4620      	mov	r0, r4
 80a5894:	f7ff ffea 	bl	80a586c <_ZN6String12changeBufferEj>
 80a5898:	b120      	cbz	r0, 80a58a4 <_ZN6String7reserveEj+0x20>
		if (len == 0) buffer[0] = 0;
 80a589a:	68a3      	ldr	r3, [r4, #8]
 80a589c:	b90b      	cbnz	r3, 80a58a2 <_ZN6String7reserveEj+0x1e>
 80a589e:	6822      	ldr	r2, [r4, #0]
 80a58a0:	7013      	strb	r3, [r2, #0]
 80a58a2:	2001      	movs	r0, #1
		return 1;
	}
	return 0;
}
 80a58a4:	bd10      	pop	{r4, pc}

080a58a6 <_ZN6String4copyEPKcj>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
 80a58a6:	b570      	push	{r4, r5, r6, lr}
 80a58a8:	460e      	mov	r6, r1
	if (!reserve(length)) {
 80a58aa:	4611      	mov	r1, r2
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
 80a58ac:	4604      	mov	r4, r0
 80a58ae:	4615      	mov	r5, r2
	if (!reserve(length)) {
 80a58b0:	f7ff ffe8 	bl	80a5884 <_ZN6String7reserveEj>
 80a58b4:	b918      	cbnz	r0, 80a58be <_ZN6String4copyEPKcj+0x18>
		invalidate();
 80a58b6:	4620      	mov	r0, r4
 80a58b8:	f7ff ffcd 	bl	80a5856 <_ZN6String10invalidateEv>
		return *this;
 80a58bc:	e009      	b.n	80a58d2 <_ZN6String4copyEPKcj+0x2c>
	}
	len = length;
	memcpy(buffer, cstr, length);
 80a58be:	462a      	mov	r2, r5
 80a58c0:	4631      	mov	r1, r6
{
	if (!reserve(length)) {
		invalidate();
		return *this;
	}
	len = length;
 80a58c2:	60a5      	str	r5, [r4, #8]
	memcpy(buffer, cstr, length);
 80a58c4:	6820      	ldr	r0, [r4, #0]
 80a58c6:	f001 ffbd 	bl	80a7844 <memcpy>
	buffer[len] = 0;
 80a58ca:	6822      	ldr	r2, [r4, #0]
 80a58cc:	68a3      	ldr	r3, [r4, #8]
 80a58ce:	2100      	movs	r1, #0
 80a58d0:	54d1      	strb	r1, [r2, r3]
	return *this;
}
 80a58d2:	4620      	mov	r0, r4
 80a58d4:	bd70      	pop	{r4, r5, r6, pc}

080a58d6 <_ZN6StringC1EPK19__FlashStringHelper>:
{
	init();
	*this = value;
}

String::String(const __FlashStringHelper *pstr)
 80a58d6:	b538      	push	{r3, r4, r5, lr}
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a58d8:	2300      	movs	r3, #0
{
	init();
	*this = value;
}

String::String(const __FlashStringHelper *pstr)
 80a58da:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a58dc:	6003      	str	r3, [r0, #0]
	capacity = 0;
 80a58de:	6043      	str	r3, [r0, #4]
	len = 0;
 80a58e0:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a58e2:	7303      	strb	r3, [r0, #12]

String::String(const __FlashStringHelper *pstr)
{
	init();
	const char* cstr = reinterpret_cast<const char*>(pstr);
	if (cstr) copy(cstr, strlen(cstr));
 80a58e4:	460d      	mov	r5, r1
 80a58e6:	b139      	cbz	r1, 80a58f8 <_ZN6StringC1EPK19__FlashStringHelper+0x22>
 80a58e8:	4608      	mov	r0, r1
 80a58ea:	f002 f85e 	bl	80a79aa <strlen>
 80a58ee:	4629      	mov	r1, r5
 80a58f0:	4602      	mov	r2, r0
 80a58f2:	4620      	mov	r0, r4
 80a58f4:	f7ff ffd7 	bl	80a58a6 <_ZN6String4copyEPKcj>
}
 80a58f8:	4620      	mov	r0, r4
 80a58fa:	bd38      	pop	{r3, r4, r5, pc}

080a58fc <_ZN6StringaSERKS_>:
}
#endif

String & String::operator = (const String &rhs)
{
	if (this == &rhs) return *this;
 80a58fc:	4288      	cmp	r0, r1
	rhs.len = 0;
}
#endif

String & String::operator = (const String &rhs)
{
 80a58fe:	b510      	push	{r4, lr}
 80a5900:	460b      	mov	r3, r1
 80a5902:	4604      	mov	r4, r0
	if (this == &rhs) return *this;
 80a5904:	d007      	beq.n	80a5916 <_ZN6StringaSERKS_+0x1a>

	if (rhs.buffer) copy(rhs.buffer, rhs.len);
 80a5906:	6809      	ldr	r1, [r1, #0]
 80a5908:	b119      	cbz	r1, 80a5912 <_ZN6StringaSERKS_+0x16>
 80a590a:	689a      	ldr	r2, [r3, #8]
 80a590c:	f7ff ffcb 	bl	80a58a6 <_ZN6String4copyEPKcj>
 80a5910:	e001      	b.n	80a5916 <_ZN6StringaSERKS_+0x1a>
	else invalidate();
 80a5912:	f7ff ffa0 	bl	80a5856 <_ZN6String10invalidateEv>

	return *this;
}
 80a5916:	4620      	mov	r0, r4
 80a5918:	bd10      	pop	{r4, pc}

080a591a <_ZN6StringC1ERKS_>:
{
	init();
	if (cstr) copy(cstr, length);
}

String::String(const String &value)
 80a591a:	b510      	push	{r4, lr}
 80a591c:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a591e:	2300      	movs	r3, #0
 80a5920:	6003      	str	r3, [r0, #0]
	capacity = 0;
 80a5922:	6043      	str	r3, [r0, #4]
	len = 0;
 80a5924:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a5926:	7303      	strb	r3, [r0, #12]
}

String::String(const String &value)
{
	init();
	*this = value;
 80a5928:	f7ff ffe8 	bl	80a58fc <_ZN6StringaSERKS_>
}
 80a592c:	4620      	mov	r0, r4
 80a592e:	bd10      	pop	{r4, pc}

080a5930 <_ZNK6String6equalsEPKc>:
{
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
 80a5930:	b508      	push	{r3, lr}
	if (len == 0) return (cstr == NULL || *cstr == 0);
 80a5932:	6882      	ldr	r2, [r0, #8]
{
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
 80a5934:	460b      	mov	r3, r1
	if (len == 0) return (cstr == NULL || *cstr == 0);
 80a5936:	b912      	cbnz	r2, 80a593e <_ZNK6String6equalsEPKc+0xe>
 80a5938:	b919      	cbnz	r1, 80a5942 <_ZNK6String6equalsEPKc+0x12>
 80a593a:	2001      	movs	r0, #1
 80a593c:	bd08      	pop	{r3, pc}
	if (cstr == NULL) return buffer[0] == 0;
 80a593e:	b911      	cbnz	r1, 80a5946 <_ZNK6String6equalsEPKc+0x16>
 80a5940:	6803      	ldr	r3, [r0, #0]
 80a5942:	7818      	ldrb	r0, [r3, #0]
 80a5944:	e002      	b.n	80a594c <_ZNK6String6equalsEPKc+0x1c>
	return strcmp(buffer, cstr) == 0;
 80a5946:	6800      	ldr	r0, [r0, #0]
 80a5948:	f002 f801 	bl	80a794e <strcmp>
 80a594c:	fab0 f080 	clz	r0, r0
 80a5950:	0940      	lsrs	r0, r0, #5
}
 80a5952:	bd08      	pop	{r3, pc}

080a5954 <_ZN6StringixEj>:
}

char & String::operator[](unsigned int index)
{
	static char dummy_writable_char;
	if (index >= len || !buffer) {
 80a5954:	6883      	ldr	r3, [r0, #8]
 80a5956:	428b      	cmp	r3, r1
 80a5958:	d901      	bls.n	80a595e <_ZN6StringixEj+0xa>
 80a595a:	6800      	ldr	r0, [r0, #0]
 80a595c:	b918      	cbnz	r0, 80a5966 <_ZN6StringixEj+0x12>
		dummy_writable_char = 0;
 80a595e:	4803      	ldr	r0, [pc, #12]	; (80a596c <_ZN6StringixEj+0x18>)
 80a5960:	2300      	movs	r3, #0
 80a5962:	7003      	strb	r3, [r0, #0]
		return dummy_writable_char;
 80a5964:	4770      	bx	lr
	}
	return buffer[index];
 80a5966:	4408      	add	r0, r1
}
 80a5968:	4770      	bx	lr
 80a596a:	bf00      	nop
 80a596c:	20001072 	.word	0x20001072

080a5970 <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 80a5970:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a5972:	4606      	mov	r6, r0
 80a5974:	460d      	mov	r5, r1
 80a5976:	188f      	adds	r7, r1, r2
  size_t n = 0;
 80a5978:	2400      	movs	r4, #0
  while (size--) {
 80a597a:	42bd      	cmp	r5, r7
 80a597c:	d00c      	beq.n	80a5998 <_ZN5Print5writeEPKhj+0x28>
     int chunk = write(*buffer++);
 80a597e:	6833      	ldr	r3, [r6, #0]
 80a5980:	f815 1b01 	ldrb.w	r1, [r5], #1
 80a5984:	689b      	ldr	r3, [r3, #8]
 80a5986:	4630      	mov	r0, r6
 80a5988:	4798      	blx	r3
     if (chunk>=0)
 80a598a:	2800      	cmp	r0, #0
 80a598c:	db01      	blt.n	80a5992 <_ZN5Print5writeEPKhj+0x22>
         n += chunk;
 80a598e:	4404      	add	r4, r0

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  size_t n = 0;
  while (size--) {
 80a5990:	e7f3      	b.n	80a597a <_ZN5Print5writeEPKhj+0xa>
     int chunk = write(*buffer++);
 80a5992:	2c00      	cmp	r4, #0
 80a5994:	bf08      	it	eq
 80a5996:	4604      	moveq	r4, r0
             n = chunk;
         break;
     }
  }
  return n;
}
 80a5998:	4620      	mov	r0, r4
 80a599a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a599c <_ZN5Print5writeEPKc>:

    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
 80a599c:	b570      	push	{r4, r5, r6, lr}
 80a599e:	4605      	mov	r5, r0
      if (str == NULL) return 0;
 80a59a0:	460c      	mov	r4, r1
      return write((const uint8_t *)str, strlen(str));
    }
 80a59a2:	4608      	mov	r0, r1
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
 80a59a4:	b149      	cbz	r1, 80a59ba <_ZN5Print5writeEPKc+0x1e>
      return write((const uint8_t *)str, strlen(str));
 80a59a6:	f002 f800 	bl	80a79aa <strlen>
 80a59aa:	682b      	ldr	r3, [r5, #0]
 80a59ac:	4602      	mov	r2, r0
 80a59ae:	4621      	mov	r1, r4
 80a59b0:	4628      	mov	r0, r5
    }
 80a59b2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
 80a59b6:	68db      	ldr	r3, [r3, #12]
 80a59b8:	4718      	bx	r3
    }
 80a59ba:	bd70      	pop	{r4, r5, r6, pc}

080a59bc <_ZN5Print5printEPKc>:
 80a59bc:	b508      	push	{r3, lr}
 80a59be:	f7ff ffed 	bl	80a599c <_ZN5Print5writeEPKc>
 80a59c2:	bd08      	pop	{r3, pc}

080a59c4 <_ZN5Print5printEc>:
  return write(str);
}

size_t Print::print(char c)
{
  return write(c);
 80a59c4:	6803      	ldr	r3, [r0, #0]
 80a59c6:	689b      	ldr	r3, [r3, #8]
 80a59c8:	4718      	bx	r3

080a59ca <_ZN5Print7printlnEv>:
{
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
 80a59ca:	b538      	push	{r3, r4, r5, lr}
  size_t n = print('\r');
 80a59cc:	210d      	movs	r1, #13
{
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
 80a59ce:	4605      	mov	r5, r0
  size_t n = print('\r');
 80a59d0:	f7ff fff8 	bl	80a59c4 <_ZN5Print5printEc>
  n += print('\n');
 80a59d4:	210a      	movs	r1, #10
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
  size_t n = print('\r');
 80a59d6:	4604      	mov	r4, r0
  n += print('\n');
 80a59d8:	4628      	mov	r0, r5
 80a59da:	f7ff fff3 	bl	80a59c4 <_ZN5Print5printEc>
  return n;
}
 80a59de:	4420      	add	r0, r4
 80a59e0:	bd38      	pop	{r3, r4, r5, pc}

080a59e2 <_ZN5Print11printNumberEmh>:
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
 80a59e2:	2a01      	cmp	r2, #1
 80a59e4:	bf98      	it	ls
 80a59e6:	220a      	movls	r2, #10
  return println(reinterpret_cast<const char*>(str));
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base) {
 80a59e8:	b530      	push	{r4, r5, lr}
 80a59ea:	460b      	mov	r3, r1
 80a59ec:	b08b      	sub	sp, #44	; 0x2c
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
 80a59ee:	2100      	movs	r1, #0
 80a59f0:	f88d 1024 	strb.w	r1, [sp, #36]	; 0x24
 80a59f4:	f10d 0423 	add.w	r4, sp, #35	; 0x23
  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
    unsigned long m = n;
    n /= base;
 80a59f8:	fbb3 f5f2 	udiv	r5, r3, r2
    char c = m - base * n;
 80a59fc:	fb05 3312 	mls	r3, r5, r2, r3
 80a5a00:	b2db      	uxtb	r3, r3
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
 80a5a02:	2b09      	cmp	r3, #9
 80a5a04:	bf94      	ite	ls
 80a5a06:	3330      	addls	r3, #48	; 0x30
 80a5a08:	3337      	addhi	r3, #55	; 0x37
 80a5a0a:	b2db      	uxtb	r3, r3
 80a5a0c:	4621      	mov	r1, r4
 80a5a0e:	f804 3901 	strb.w	r3, [r4], #-1
 80a5a12:	462b      	mov	r3, r5
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
 80a5a14:	2d00      	cmp	r5, #0
 80a5a16:	d1ef      	bne.n	80a59f8 <_ZN5Print11printNumberEmh+0x16>
    n /= base;
    char c = m - base * n;
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
 80a5a18:	f7ff ffc0 	bl	80a599c <_ZN5Print5writeEPKc>
}
 80a5a1c:	b00b      	add	sp, #44	; 0x2c
 80a5a1e:	bd30      	pop	{r4, r5, pc}

080a5a20 <_ZN5Print5printEmi>:
    return printNumber(n, base);
  }
}

size_t Print::print(unsigned long n, int base)
{
 80a5a20:	b410      	push	{r4}
  if (base == 0) return write(n);
 80a5a22:	b922      	cbnz	r2, 80a5a2e <_ZN5Print5printEmi+0xe>
 80a5a24:	6803      	ldr	r3, [r0, #0]
 80a5a26:	b2c9      	uxtb	r1, r1
 80a5a28:	689b      	ldr	r3, [r3, #8]
  else return printNumber(n, base);
}
 80a5a2a:	bc10      	pop	{r4}
  }
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
 80a5a2c:	4718      	bx	r3
  else return printNumber(n, base);
 80a5a2e:	b2d2      	uxtb	r2, r2
}
 80a5a30:	bc10      	pop	{r4}
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
 80a5a32:	f7ff bfd6 	b.w	80a59e2 <_ZN5Print11printNumberEmh>

080a5a36 <_ZN5Print5printEhi>:
  return write(c);
}

size_t Print::print(unsigned char b, int base)
{
  return print((unsigned long) b, base);
 80a5a36:	f7ff bff3 	b.w	80a5a20 <_ZN5Print5printEmi>

080a5a3a <_ZN5Print5printEli>:
{
  return print((unsigned long) n, base);
}

size_t Print::print(long n, int base)
{
 80a5a3a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a5a3e:	4607      	mov	r7, r0
 80a5a40:	460e      	mov	r6, r1
  if (base == 0) {
 80a5a42:	4615      	mov	r5, r2
 80a5a44:	b92a      	cbnz	r2, 80a5a52 <_ZN5Print5printEli+0x18>
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
  }
}
 80a5a46:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
}

size_t Print::print(long n, int base)
{
  if (base == 0) {
    return write(n);
 80a5a4a:	6803      	ldr	r3, [r0, #0]
 80a5a4c:	b2c9      	uxtb	r1, r1
 80a5a4e:	689b      	ldr	r3, [r3, #8]
 80a5a50:	4718      	bx	r3
  } else if (base == 10) {
 80a5a52:	2a0a      	cmp	r2, #10
 80a5a54:	d102      	bne.n	80a5a5c <_ZN5Print5printEli+0x22>
    if (n < 0) {
 80a5a56:	2900      	cmp	r1, #0
 80a5a58:	da01      	bge.n	80a5a5e <_ZN5Print5printEli+0x24>
 80a5a5a:	e004      	b.n	80a5a66 <_ZN5Print5printEli+0x2c>
      n = -n;
      return printNumber(n, 10) + t;
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
 80a5a5c:	b2d2      	uxtb	r2, r2
  }
}
 80a5a5e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
      n = -n;
      return printNumber(n, 10) + t;
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
 80a5a62:	f7ff bfbe 	b.w	80a59e2 <_ZN5Print11printNumberEmh>
{
  if (base == 0) {
    return write(n);
  } else if (base == 10) {
    if (n < 0) {
      int t = print('-');
 80a5a66:	212d      	movs	r1, #45	; 0x2d
 80a5a68:	f7ff ffac 	bl	80a59c4 <_ZN5Print5printEc>
      n = -n;
      return printNumber(n, 10) + t;
 80a5a6c:	462a      	mov	r2, r5
{
  if (base == 0) {
    return write(n);
  } else if (base == 10) {
    if (n < 0) {
      int t = print('-');
 80a5a6e:	4604      	mov	r4, r0
      n = -n;
      return printNumber(n, 10) + t;
 80a5a70:	4271      	negs	r1, r6
 80a5a72:	4638      	mov	r0, r7
 80a5a74:	f7ff ffb5 	bl	80a59e2 <_ZN5Print11printNumberEmh>
 80a5a78:	4420      	add	r0, r4
    }
    return printNumber(n, 10);
  } else {
    return printNumber(n, base);
  }
}
 80a5a7a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080a5a7e <_ZN5Print5printEii>:
  return print((unsigned long) b, base);
}

size_t Print::print(int n, int base)
{
  return print((long) n, base);
 80a5a7e:	f7ff bfdc 	b.w	80a5a3a <_ZN5Print5printEli>

080a5a82 <_ZN5Print11printf_implEbPKcz>:

  return n;
}

size_t Print::printf_impl(bool newline, const char* format, ...)
{
 80a5a82:	b40c      	push	{r2, r3}
 80a5a84:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a5a88:	b087      	sub	sp, #28
 80a5a8a:	af00      	add	r7, sp, #0
 80a5a8c:	f107 0438 	add.w	r4, r7, #56	; 0x38
 80a5a90:	f854 9b04 	ldr.w	r9, [r4], #4
 80a5a94:	4605      	mov	r5, r0
 80a5a96:	460e      	mov	r6, r1
    const int bufsize = 20;
    char test[bufsize];
    va_list marker;
    va_start(marker, format);
    size_t n = vsnprintf(test, bufsize, format, marker);
 80a5a98:	4623      	mov	r3, r4
 80a5a9a:	464a      	mov	r2, r9
 80a5a9c:	2114      	movs	r1, #20
 80a5a9e:	1d38      	adds	r0, r7, #4
size_t Print::printf_impl(bool newline, const char* format, ...)
{
    const int bufsize = 20;
    char test[bufsize];
    va_list marker;
    va_start(marker, format);
 80a5aa0:	603c      	str	r4, [r7, #0]
    size_t n = vsnprintf(test, bufsize, format, marker);
 80a5aa2:	f7ff fd4f 	bl	80a5544 <vsnprintf>
    va_end(marker);

    if (n<bufsize)
 80a5aa6:	2813      	cmp	r0, #19
 80a5aa8:	d805      	bhi.n	80a5ab6 <_ZN5Print11printf_implEbPKcz+0x34>
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a5aaa:	1d39      	adds	r1, r7, #4
 80a5aac:	4628      	mov	r0, r5
 80a5aae:	f7ff ff75 	bl	80a599c <_ZN5Print5writeEPKc>
 80a5ab2:	4604      	mov	r4, r0
 80a5ab4:	e013      	b.n	80a5ade <_ZN5Print11printf_implEbPKcz+0x5c>
    {
        n = print(test);
    }
    else
    {
        char bigger[n+1];
 80a5ab6:	f100 0308 	add.w	r3, r0, #8
 80a5aba:	f023 0307 	bic.w	r3, r3, #7
        va_start(marker, format);
        n = vsnprintf(bigger, n+1, format, marker);
        va_end(marker);
        n = print(bigger);
 80a5abe:	46e8      	mov	r8, sp
    {
        n = print(test);
    }
    else
    {
        char bigger[n+1];
 80a5ac0:	ebad 0d03 	sub.w	sp, sp, r3
        va_start(marker, format);
        n = vsnprintf(bigger, n+1, format, marker);
 80a5ac4:	1c41      	adds	r1, r0, #1
 80a5ac6:	4623      	mov	r3, r4
 80a5ac8:	464a      	mov	r2, r9
 80a5aca:	4668      	mov	r0, sp
        n = print(test);
    }
    else
    {
        char bigger[n+1];
        va_start(marker, format);
 80a5acc:	603c      	str	r4, [r7, #0]
        n = vsnprintf(bigger, n+1, format, marker);
 80a5ace:	f7ff fd39 	bl	80a5544 <vsnprintf>
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a5ad2:	4669      	mov	r1, sp
 80a5ad4:	4628      	mov	r0, r5
 80a5ad6:	f7ff ff61 	bl	80a599c <_ZN5Print5writeEPKc>
 80a5ada:	4604      	mov	r4, r0
 80a5adc:	46c5      	mov	sp, r8
        va_start(marker, format);
        n = vsnprintf(bigger, n+1, format, marker);
        va_end(marker);
        n = print(bigger);
    }
    if (newline)
 80a5ade:	b11e      	cbz	r6, 80a5ae8 <_ZN5Print11printf_implEbPKcz+0x66>
        n += println();
 80a5ae0:	4628      	mov	r0, r5
 80a5ae2:	f7ff ff72 	bl	80a59ca <_ZN5Print7printlnEv>
 80a5ae6:	4404      	add	r4, r0
    return n;
}
 80a5ae8:	4620      	mov	r0, r4
 80a5aea:	371c      	adds	r7, #28
 80a5aec:	46bd      	mov	sp, r7
 80a5aee:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a5af2:	b002      	add	sp, #8
 80a5af4:	4770      	bx	lr

080a5af6 <_ZN6Stream9timedReadEv>:
#define PARSE_TIMEOUT 1000  // default number of milli-seconds to wait
#define NO_SKIP_CHAR  1  // a magic char not found in a valid ASCII numeric field

// private method to read stream with timeout
int Stream::timedRead()
{
 80a5af6:	b510      	push	{r4, lr}
 80a5af8:	4604      	mov	r4, r0
#endif

#include "timer_hal.h"
#include "delay_hal.h"

inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
 80a5afa:	f7ff faad 	bl	80a5058 <HAL_Timer_Get_Milli_Seconds>
  int c;
  _startMillis = millis();
 80a5afe:	60e0      	str	r0, [r4, #12]
  do {
    c = read();
 80a5b00:	6823      	ldr	r3, [r4, #0]
 80a5b02:	4620      	mov	r0, r4
 80a5b04:	695b      	ldr	r3, [r3, #20]
 80a5b06:	4798      	blx	r3
    if (c >= 0) return c;
 80a5b08:	2800      	cmp	r0, #0
 80a5b0a:	da08      	bge.n	80a5b1e <_ZN6Stream9timedReadEv+0x28>
 80a5b0c:	f7ff faa4 	bl	80a5058 <HAL_Timer_Get_Milli_Seconds>
// private method to read stream with timeout
int Stream::timedRead()
{
  int c;
  _startMillis = millis();
  do {
 80a5b10:	68e3      	ldr	r3, [r4, #12]
 80a5b12:	1ac0      	subs	r0, r0, r3
 80a5b14:	68a3      	ldr	r3, [r4, #8]
 80a5b16:	4298      	cmp	r0, r3
 80a5b18:	d3f2      	bcc.n	80a5b00 <_ZN6Stream9timedReadEv+0xa>
    c = read();
    if (c >= 0) return c;
  } while(millis() - _startMillis < _timeout);
  return -1;     // -1 indicates timeout
 80a5b1a:	f04f 30ff 	mov.w	r0, #4294967295
}
 80a5b1e:	bd10      	pop	{r4, pc}

080a5b20 <_ZN6Stream10setTimeoutEm>:
// Public Methods
//////////////////////////////////////////////////////////////

void Stream::setTimeout(system_tick_t timeout)  // sets the maximum number of milliseconds to wait
{
  _timeout = timeout;
 80a5b20:	6081      	str	r1, [r0, #8]
 80a5b22:	4770      	bx	lr

080a5b24 <_ZN6Stream9readBytesEPcj>:
// terminates if length characters have been read, or timeout (see setTimeout)
// returns the number of characters placed in the buffer
// the buffer is NOT null terminated.
//
size_t Stream::readBytes(char *buffer, size_t length)
{
 80a5b24:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a5b28:	4680      	mov	r8, r0
 80a5b2a:	460d      	mov	r5, r1
 80a5b2c:	460c      	mov	r4, r1
 80a5b2e:	188f      	adds	r7, r1, r2
  size_t count = 0;
  while (count < length) {
 80a5b30:	42bc      	cmp	r4, r7
 80a5b32:	eba4 0605 	sub.w	r6, r4, r5
 80a5b36:	d007      	beq.n	80a5b48 <_ZN6Stream9readBytesEPcj+0x24>
    int c = timedRead();
 80a5b38:	4640      	mov	r0, r8
 80a5b3a:	f7ff ffdc 	bl	80a5af6 <_ZN6Stream9timedReadEv>
    if (c < 0) break;
 80a5b3e:	2800      	cmp	r0, #0
 80a5b40:	db02      	blt.n	80a5b48 <_ZN6Stream9readBytesEPcj+0x24>
    *buffer++ = (char)c;
 80a5b42:	f804 0b01 	strb.w	r0, [r4], #1
// the buffer is NOT null terminated.
//
size_t Stream::readBytes(char *buffer, size_t length)
{
  size_t count = 0;
  while (count < length) {
 80a5b46:	e7f3      	b.n	80a5b30 <_ZN6Stream9readBytesEPcj+0xc>
    if (c < 0) break;
    *buffer++ = (char)c;
    count++;
  }
  return count;
}
 80a5b48:	4630      	mov	r0, r6
 80a5b4a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080a5b4e <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>:
	if (_M_pi != nullptr)
	  _M_pi->_M_release();
      }

      __shared_count(const __shared_count& __r) noexcept
      : _M_pi(__r._M_pi)
 80a5b4e:	680b      	ldr	r3, [r1, #0]
 80a5b50:	6003      	str	r3, [r0, #0]
      {
	if (_M_pi != 0)
 80a5b52:	b113      	cbz	r3, 80a5b5a <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_+0xc>
    }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }
 80a5b54:	685a      	ldr	r2, [r3, #4]
 80a5b56:	3201      	adds	r2, #1
 80a5b58:	605a      	str	r2, [r3, #4]
      __shared_count(const __shared_count& __r) noexcept
      : _M_pi(__r._M_pi)
      {
	if (_M_pi != 0)
	  _M_pi->_M_add_ref_copy();
      }
 80a5b5a:	4770      	bx	lr

080a5b5c <_GLOBAL__sub_I__ZN5spark3LogE>:
    // This handler doesn't support direct logging
}

// spark::Logger
inline spark::Logger::Logger(const char *name) :
        name_(name) {
 80a5b5c:	4a01      	ldr	r2, [pc, #4]	; (80a5b64 <_GLOBAL__sub_I__ZN5spark3LogE+0x8>)
 80a5b5e:	4b02      	ldr	r3, [pc, #8]	; (80a5b68 <_GLOBAL__sub_I__ZN5spark3LogE+0xc>)
 80a5b60:	601a      	str	r2, [r3, #0]
 80a5b62:	4770      	bx	lr
 80a5b64:	080a938d 	.word	0x080a938d
 80a5b68:	20001074 	.word	0x20001074

080a5b6c <_ZL22Refresh_UnixTime_Cachel>:
}
*/

/* Refresh Unix/RTC time cache */
static void Refresh_UnixTime_Cache(time_t unix_time)
{
 80a5b6c:	b5f0      	push	{r4, r5, r6, r7, lr}
    unix_time += time_zone_cache;
 80a5b6e:	4b14      	ldr	r3, [pc, #80]	; (80a5bc0 <_ZL22Refresh_UnixTime_Cachel+0x54>)
    unix_time += dst_current_cache;
    if(unix_time != unix_time_cache)
 80a5b70:	4f14      	ldr	r7, [pc, #80]	; (80a5bc4 <_ZL22Refresh_UnixTime_Cachel+0x58>)
*/

/* Refresh Unix/RTC time cache */
static void Refresh_UnixTime_Cache(time_t unix_time)
{
    unix_time += time_zone_cache;
 80a5b72:	681e      	ldr	r6, [r3, #0]
    unix_time += dst_current_cache;
 80a5b74:	4b14      	ldr	r3, [pc, #80]	; (80a5bc8 <_ZL22Refresh_UnixTime_Cachel+0x5c>)
*/

/* Refresh Unix/RTC time cache */
static void Refresh_UnixTime_Cache(time_t unix_time)
{
    unix_time += time_zone_cache;
 80a5b76:	4406      	add	r6, r0
    unix_time += dst_current_cache;
 80a5b78:	6818      	ldr	r0, [r3, #0]
    if(unix_time != unix_time_cache)
 80a5b7a:	683b      	ldr	r3, [r7, #0]

/* Refresh Unix/RTC time cache */
static void Refresh_UnixTime_Cache(time_t unix_time)
{
    unix_time += time_zone_cache;
    unix_time += dst_current_cache;
 80a5b7c:	4406      	add	r6, r0
    if(unix_time != unix_time_cache)
 80a5b7e:	429e      	cmp	r6, r3
}
*/

/* Refresh Unix/RTC time cache */
static void Refresh_UnixTime_Cache(time_t unix_time)
{
 80a5b80:	b08b      	sub	sp, #44	; 0x2c
    unix_time += time_zone_cache;
    unix_time += dst_current_cache;
    if(unix_time != unix_time_cache)
 80a5b82:	d01b      	beq.n	80a5bbc <_ZL22Refresh_UnixTime_Cachel+0x50>
 80a5b84:	a80a      	add	r0, sp, #40	; 0x28
 80a5b86:	f840 6d28 	str.w	r6, [r0, #-40]!

/* Convert Unix/RTC time to Calendar time */
static struct tm Convert_UnixTime_To_CalendarTime(time_t unix_time)
{
	struct tm *calendar_time;
	calendar_time = localtime(&unix_time);
 80a5b8a:	f001 fd63 	bl	80a7654 <localtime>
	calendar_time->tm_year += 1900;
	return *calendar_time;
 80a5b8e:	4604      	mov	r4, r0
/* Convert Unix/RTC time to Calendar time */
static struct tm Convert_UnixTime_To_CalendarTime(time_t unix_time)
{
	struct tm *calendar_time;
	calendar_time = localtime(&unix_time);
	calendar_time->tm_year += 1900;
 80a5b90:	6943      	ldr	r3, [r0, #20]
	return *calendar_time;
 80a5b92:	ad01      	add	r5, sp, #4
/* Convert Unix/RTC time to Calendar time */
static struct tm Convert_UnixTime_To_CalendarTime(time_t unix_time)
{
	struct tm *calendar_time;
	calendar_time = localtime(&unix_time);
	calendar_time->tm_year += 1900;
 80a5b94:	f203 736c 	addw	r3, r3, #1900	; 0x76c
 80a5b98:	6143      	str	r3, [r0, #20]
	return *calendar_time;
 80a5b9a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80a5b9c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80a5b9e:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80a5ba0:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80a5ba2:	f8d4 e000 	ldr.w	lr, [r4]
{
    unix_time += time_zone_cache;
    unix_time += dst_current_cache;
    if(unix_time != unix_time_cache)
    {
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
 80a5ba6:	4c09      	ldr	r4, [pc, #36]	; (80a5bcc <_ZL22Refresh_UnixTime_Cachel+0x60>)
static struct tm Convert_UnixTime_To_CalendarTime(time_t unix_time)
{
	struct tm *calendar_time;
	calendar_time = localtime(&unix_time);
	calendar_time->tm_year += 1900;
	return *calendar_time;
 80a5ba8:	f8c5 e000 	str.w	lr, [r5]
{
    unix_time += time_zone_cache;
    unix_time += dst_current_cache;
    if(unix_time != unix_time_cache)
    {
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
 80a5bac:	ad01      	add	r5, sp, #4
 80a5bae:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80a5bb0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80a5bb2:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80a5bb4:	c40f      	stmia	r4!, {r0, r1, r2, r3}
            unix_time_cache = unix_time;
 80a5bb6:	603e      	str	r6, [r7, #0]
{
    unix_time += time_zone_cache;
    unix_time += dst_current_cache;
    if(unix_time != unix_time_cache)
    {
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
 80a5bb8:	f8c4 e000 	str.w	lr, [r4]
            unix_time_cache = unix_time;
    }
}
 80a5bbc:	b00b      	add	sp, #44	; 0x2c
 80a5bbe:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a5bc0:	200010a8 	.word	0x200010a8
 80a5bc4:	200010a4 	.word	0x200010a4
 80a5bc8:	200010a0 	.word	0x200010a0
 80a5bcc:	20001078 	.word	0x20001078

080a5bd0 <_ZN10CloudClass12syncTimeDoneEv.isra.1>:
    bool syncTimePending(void)
    {
        return connected() && CLOUD_FN(spark_sync_time_pending(nullptr), false);
    }

    bool syncTimeDone(void)
 80a5bd0:	b508      	push	{r3, lr}
    {
        return !CLOUD_FN(spark_sync_time_pending(nullptr), false) || disconnected();
 80a5bd2:	2000      	movs	r0, #0
 80a5bd4:	f7ff fc86 	bl	80a54e4 <spark_sync_time_pending>
 80a5bd8:	b128      	cbz	r0, 80a5be6 <_ZN10CloudClass12syncTimeDoneEv.isra.1+0x16>
    static void sleep(Spark_Sleep_TypeDef sleepMode, long seconds=0) __attribute__ ((deprecated("Please use System.sleep() instead.")))
    { SystemClass::sleep(sleepMode, seconds); }
    static void sleep(uint16_t wakeUpPin, InterruptMode edgeTriggerMode, long seconds=0) __attribute__ ((deprecated("Please use System.sleep() instead.")))
    { SystemClass::sleep(wakeUpPin, edgeTriggerMode, seconds); }

    static bool connected(void) { return spark_cloud_flag_connected(); }
 80a5bda:	f7ff fc6b 	bl	80a54b4 <spark_cloud_flag_connected>
        return connected() && CLOUD_FN(spark_sync_time_pending(nullptr), false);
    }

    bool syncTimeDone(void)
    {
        return !CLOUD_FN(spark_sync_time_pending(nullptr), false) || disconnected();
 80a5bde:	f080 0001 	eor.w	r0, r0, #1
 80a5be2:	b2c0      	uxtb	r0, r0
 80a5be4:	bd08      	pop	{r3, pc}
 80a5be6:	2001      	movs	r0, #1
    }
 80a5be8:	bd08      	pop	{r3, pc}
	...

080a5bec <_ZN9TimeClass5monthEl>:
	return month(now());
}

/* the month for the given time */
int TimeClass::month(time_t t)
{
 80a5bec:	b508      	push	{r3, lr}
	Refresh_UnixTime_Cache(t);
 80a5bee:	f7ff ffbd 	bl	80a5b6c <_ZL22Refresh_UnixTime_Cachel>
	return (calendar_time_cache.tm_mon + 1);//Arduino's month representation
 80a5bf2:	4b02      	ldr	r3, [pc, #8]	; (80a5bfc <_ZN9TimeClass5monthEl+0x10>)
 80a5bf4:	6918      	ldr	r0, [r3, #16]
}
 80a5bf6:	3001      	adds	r0, #1
 80a5bf8:	bd08      	pop	{r3, pc}
 80a5bfa:	bf00      	nop
 80a5bfc:	20001078 	.word	0x20001078

080a5c00 <_ZN9TimeClass4zoneEf>:
	return HAL_RTC_Get_UnixTime()+time_zone_cache+dst_current_cache;
}

/* set the time zone (+/-) offset from GMT */
void TimeClass::zone(float GMT_Offset)
{
 80a5c00:	b510      	push	{r4, lr}
	if(GMT_Offset < -12 || GMT_Offset > 14)
 80a5c02:	4909      	ldr	r1, [pc, #36]	; (80a5c28 <_ZN9TimeClass4zoneEf+0x28>)
	return HAL_RTC_Get_UnixTime()+time_zone_cache+dst_current_cache;
}

/* set the time zone (+/-) offset from GMT */
void TimeClass::zone(float GMT_Offset)
{
 80a5c04:	4604      	mov	r4, r0
	if(GMT_Offset < -12 || GMT_Offset > 14)
 80a5c06:	f001 fcc9 	bl	80a759c <__aeabi_fcmplt>
 80a5c0a:	b960      	cbnz	r0, 80a5c26 <_ZN9TimeClass4zoneEf+0x26>
 80a5c0c:	4907      	ldr	r1, [pc, #28]	; (80a5c2c <_ZN9TimeClass4zoneEf+0x2c>)
 80a5c0e:	4620      	mov	r0, r4
 80a5c10:	f001 fce2 	bl	80a75d8 <__aeabi_fcmpgt>
 80a5c14:	b938      	cbnz	r0, 80a5c26 <_ZN9TimeClass4zoneEf+0x26>
	{
		return;
	}
	time_zone_cache = GMT_Offset * 3600;
 80a5c16:	4906      	ldr	r1, [pc, #24]	; (80a5c30 <_ZN9TimeClass4zoneEf+0x30>)
 80a5c18:	4620      	mov	r0, r4
 80a5c1a:	f001 fb21 	bl	80a7260 <__aeabi_fmul>
 80a5c1e:	f001 fce5 	bl	80a75ec <__aeabi_f2iz>
 80a5c22:	4b04      	ldr	r3, [pc, #16]	; (80a5c34 <_ZN9TimeClass4zoneEf+0x34>)
 80a5c24:	6018      	str	r0, [r3, #0]
 80a5c26:	bd10      	pop	{r4, pc}
 80a5c28:	c1400000 	.word	0xc1400000
 80a5c2c:	41600000 	.word	0x41600000
 80a5c30:	45610000 	.word	0x45610000
 80a5c34:	200010a8 	.word	0x200010a8

080a5c38 <_ZN9TimeClass7isValidEv>:
    strftime(buf, 50, format_str, calendar_time);
    return String(buf);
}

bool TimeClass::isValid()
{
 80a5c38:	b510      	push	{r4, lr}
    bool rtcstate = HAL_RTC_Time_Is_Valid(nullptr);
 80a5c3a:	2000      	movs	r0, #0
 80a5c3c:	f7ff fa1c 	bl	80a5078 <HAL_RTC_Time_Is_Valid>
    if (rtcstate)
 80a5c40:	4604      	mov	r4, r0
 80a5c42:	b968      	cbnz	r0, 80a5c60 <_ZN9TimeClass7isValidEv+0x28>
        }
    }

    static System_Mode_TypeDef mode(void) {
        return system_mode();
 80a5c44:	f7ff fbba 	bl	80a53bc <system_mode>
        return rtcstate;
    if (System.mode() == AUTOMATIC && system_thread_get_state(nullptr) == spark::feature::DISABLED)
 80a5c48:	2801      	cmp	r0, #1
 80a5c4a:	d10b      	bne.n	80a5c64 <_ZN9TimeClass7isValidEv+0x2c>
 80a5c4c:	4620      	mov	r0, r4
 80a5c4e:	f7ff fbdd 	bl	80a540c <system_thread_get_state>
 80a5c52:	b938      	cbnz	r0, 80a5c64 <_ZN9TimeClass7isValidEv+0x2c>
    {
        waitUntil(Particle.syncTimeDone);
 80a5c54:	f7ff ffbc 	bl	80a5bd0 <_ZN10CloudClass12syncTimeDoneEv.isra.1>


    static uint32_t freeMemory();

    template<typename Condition, typename While> static bool waitConditionWhile(Condition _condition, While _while) {
        while (_while() && !_condition()) {
 80a5c58:	b930      	cbnz	r0, 80a5c68 <_ZN9TimeClass7isValidEv+0x30>
            spark_process();
 80a5c5a:	f7ff fc1b 	bl	80a5494 <spark_process>
 80a5c5e:	e7f9      	b.n	80a5c54 <_ZN9TimeClass7isValidEv+0x1c>

bool TimeClass::isValid()
{
    bool rtcstate = HAL_RTC_Time_Is_Valid(nullptr);
    if (rtcstate)
        return rtcstate;
 80a5c60:	2001      	movs	r0, #1
 80a5c62:	bd10      	pop	{r4, pc}
    if (System.mode() == AUTOMATIC && system_thread_get_state(nullptr) == spark::feature::DISABLED)
    {
        waitUntil(Particle.syncTimeDone);
        return HAL_RTC_Time_Is_Valid(nullptr);
    }
    return rtcstate;
 80a5c64:	2000      	movs	r0, #0
 80a5c66:	bd10      	pop	{r4, pc}
    bool rtcstate = HAL_RTC_Time_Is_Valid(nullptr);
    if (rtcstate)
        return rtcstate;
    if (System.mode() == AUTOMATIC && system_thread_get_state(nullptr) == spark::feature::DISABLED)
    {
        waitUntil(Particle.syncTimeDone);
 80a5c68:	f7ff ffb2 	bl	80a5bd0 <_ZN10CloudClass12syncTimeDoneEv.isra.1>
        return HAL_RTC_Time_Is_Valid(nullptr);
 80a5c6c:	2000      	movs	r0, #0
 80a5c6e:	f7ff fa03 	bl	80a5078 <HAL_RTC_Time_Is_Valid>
 80a5c72:	3000      	adds	r0, #0
 80a5c74:	bf18      	it	ne
 80a5c76:	2001      	movne	r0, #1
    }
    return rtcstate;
}
 80a5c78:	bd10      	pop	{r4, pc}

080a5c7a <_ZN9TimeClass3nowEv>:
	return calendar_time_cache.tm_year;
}

/* return the current time as seconds since Jan 1 1970 */
time_t TimeClass::now()
{
 80a5c7a:	b508      	push	{r3, lr}
    (void)isValid();
 80a5c7c:	f7ff ffdc 	bl	80a5c38 <_ZN9TimeClass7isValidEv>
	return HAL_RTC_Get_UnixTime();
}
 80a5c80:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

/* return the current time as seconds since Jan 1 1970 */
time_t TimeClass::now()
{
    (void)isValid();
	return HAL_RTC_Get_UnixTime();
 80a5c84:	f7ff b9f0 	b.w	80a5068 <HAL_RTC_Get_UnixTime>

080a5c88 <_ZN9TimeClass4hourEv>:

const char* TimeClass::format_spec = TIME_FORMAT_DEFAULT;

/* current hour */
int TimeClass::hour()
{
 80a5c88:	b508      	push	{r3, lr}
	return hour(now());
 80a5c8a:	f7ff fff6 	bl	80a5c7a <_ZN9TimeClass3nowEv>
}

/* the hour for the given time */
int TimeClass::hour(time_t t)
{
	Refresh_UnixTime_Cache(t);
 80a5c8e:	f7ff ff6d 	bl	80a5b6c <_ZL22Refresh_UnixTime_Cachel>

/* current hour */
int TimeClass::hour()
{
	return hour(now());
}
 80a5c92:	4b01      	ldr	r3, [pc, #4]	; (80a5c98 <_ZN9TimeClass4hourEv+0x10>)
 80a5c94:	6898      	ldr	r0, [r3, #8]
 80a5c96:	bd08      	pop	{r3, pc}
 80a5c98:	20001078 	.word	0x20001078

080a5c9c <_ZN9TimeClass6minuteEv>:
	return (hour(t) >= 12);
}

/* current minute */
int TimeClass::minute()
{
 80a5c9c:	b508      	push	{r3, lr}
	return minute(now());
 80a5c9e:	f7ff ffec 	bl	80a5c7a <_ZN9TimeClass3nowEv>
}

/* the minute for the given time */
int TimeClass::minute(time_t t)
{
	Refresh_UnixTime_Cache(t);
 80a5ca2:	f7ff ff63 	bl	80a5b6c <_ZL22Refresh_UnixTime_Cachel>

/* current minute */
int TimeClass::minute()
{
	return minute(now());
}
 80a5ca6:	4b01      	ldr	r3, [pc, #4]	; (80a5cac <_ZN9TimeClass6minuteEv+0x10>)
 80a5ca8:	6858      	ldr	r0, [r3, #4]
 80a5caa:	bd08      	pop	{r3, pc}
 80a5cac:	20001078 	.word	0x20001078

080a5cb0 <_ZN9TimeClass3dayEv>:
	return calendar_time_cache.tm_sec;
}

/* current day */
int TimeClass::day()
{
 80a5cb0:	b508      	push	{r3, lr}
	return day(now());
 80a5cb2:	f7ff ffe2 	bl	80a5c7a <_ZN9TimeClass3nowEv>
}

/* the day for the given time */
int TimeClass::day(time_t t)
{
	Refresh_UnixTime_Cache(t);
 80a5cb6:	f7ff ff59 	bl	80a5b6c <_ZL22Refresh_UnixTime_Cachel>

/* current day */
int TimeClass::day()
{
	return day(now());
}
 80a5cba:	4b01      	ldr	r3, [pc, #4]	; (80a5cc0 <_ZN9TimeClass3dayEv+0x10>)
 80a5cbc:	68d8      	ldr	r0, [r3, #12]
 80a5cbe:	bd08      	pop	{r3, pc}
 80a5cc0:	20001078 	.word	0x20001078

080a5cc4 <_ZN9TimeClass5monthEv>:
	return (calendar_time_cache.tm_wday + 1);//Arduino's weekday representation
}

/* current month */
int TimeClass::month()
{
 80a5cc4:	b508      	push	{r3, lr}
	return month(now());
 80a5cc6:	f7ff ffd8 	bl	80a5c7a <_ZN9TimeClass3nowEv>
}
 80a5cca:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
}

/* current month */
int TimeClass::month()
{
	return month(now());
 80a5cce:	f7ff bf8d 	b.w	80a5bec <_ZN9TimeClass5monthEl>
	...

080a5cd4 <_ZN9TimeClass4yearEv>:
	return (calendar_time_cache.tm_mon + 1);//Arduino's month representation
}

/* current four digit year */
int TimeClass::year()
{
 80a5cd4:	b508      	push	{r3, lr}
	return year(now());
 80a5cd6:	f7ff ffd0 	bl	80a5c7a <_ZN9TimeClass3nowEv>
}

/* the year for the given time */
int TimeClass::year(time_t t)
{
	Refresh_UnixTime_Cache(t);
 80a5cda:	f7ff ff47 	bl	80a5b6c <_ZL22Refresh_UnixTime_Cachel>

/* current four digit year */
int TimeClass::year()
{
	return year(now());
}
 80a5cde:	4b01      	ldr	r3, [pc, #4]	; (80a5ce4 <_ZN9TimeClass4yearEv+0x10>)
 80a5ce0:	6958      	ldr	r0, [r3, #20]
 80a5ce2:	bd08      	pop	{r3, pc}
 80a5ce4:	20001078 	.word	0x20001078

080a5ce8 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT>:
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
            unix_time_cache = unix_time;
    }
}

const char* TimeClass::format_spec = TIME_FORMAT_DEFAULT;
 80a5ce8:	4b02      	ldr	r3, [pc, #8]	; (80a5cf4 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0xc>)
 80a5cea:	681a      	ldr	r2, [r3, #0]
 80a5cec:	4b02      	ldr	r3, [pc, #8]	; (80a5cf8 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0x10>)
 80a5cee:	601a      	str	r2, [r3, #0]
 80a5cf0:	4770      	bx	lr
 80a5cf2:	bf00      	nop
 80a5cf4:	20000304 	.word	0x20000304
 80a5cf8:	2000109c 	.word	0x2000109c

080a5cfc <delay>:
    return (value - fromStart) * (toEnd - toStart) / (fromEnd - fromStart) + toStart;
}

void delay(unsigned long ms)
{
    system_delay_ms(ms, false);
 80a5cfc:	2100      	movs	r1, #0
 80a5cfe:	f7ff bb6d 	b.w	80a53dc <system_delay_ms>

080a5d02 <_ZN3UDP13receivePacketEPcj>:
         * @param buffer        The buffer to read data to
         * @param buf_size      The buffer size
         * @return The number of bytes written to the buffer, or a negative value on error.
         */
        virtual int receivePacket(uint8_t* buffer, size_t buf_size);
        virtual int receivePacket(char* buffer, size_t buf_size) { return receivePacket((uint8_t*)buffer, buf_size); }
 80a5d02:	6803      	ldr	r3, [r0, #0]
 80a5d04:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a5d06:	4718      	bx	r3

080a5d08 <_ZN3UDP4readEPcj>:
         * @return
         */
	virtual int read();
	virtual int read(unsigned char* buffer, size_t len);

	virtual int read(char* buffer, size_t len) { return read((unsigned char*)buffer, len); };
 80a5d08:	6803      	ldr	r3, [r0, #0]
 80a5d0a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80a5d0c:	4718      	bx	r3

080a5d0e <_ZN3UDP10remotePortEv>:
     */
    void flush_buffer();


	virtual IPAddress remoteIP() { return _remoteIP; };
	virtual uint16_t remotePort() { return _remotePort; };
 80a5d0e:	8e80      	ldrh	r0, [r0, #52]	; 0x34
 80a5d10:	4770      	bx	lr

080a5d12 <_ZN3UDP9availableEv>:
    return bound;
}

int UDP::available()
{
    return _total - _offset;
 80a5d12:	8f02      	ldrh	r2, [r0, #56]	; 0x38
 80a5d14:	8ec0      	ldrh	r0, [r0, #54]	; 0x36
}
 80a5d16:	1a10      	subs	r0, r2, r0
 80a5d18:	4770      	bx	lr

080a5d1a <_ZN3UDP5writeEh>:
    DEBUG("sendto(buffer=%lx, size=%d)=%d",buffer, buffer_size , rv);
    return rv;
}

size_t UDP::write(uint8_t byte)
{
 80a5d1a:	b513      	push	{r0, r1, r4, lr}
 80a5d1c:	ab02      	add	r3, sp, #8
    return write(&byte, 1);
 80a5d1e:	6802      	ldr	r2, [r0, #0]
    DEBUG("sendto(buffer=%lx, size=%d)=%d",buffer, buffer_size , rv);
    return rv;
}

size_t UDP::write(uint8_t byte)
{
 80a5d20:	f803 1d01 	strb.w	r1, [r3, #-1]!
    return write(&byte, 1);
 80a5d24:	68d4      	ldr	r4, [r2, #12]
 80a5d26:	4619      	mov	r1, r3
 80a5d28:	2201      	movs	r2, #1
 80a5d2a:	47a0      	blx	r4
}
 80a5d2c:	b002      	add	sp, #8
 80a5d2e:	bd10      	pop	{r4, pc}

080a5d30 <_ZN3UDP4readEv>:
    }
    return ret;
}

int UDP::read()
{
 80a5d30:	b510      	push	{r4, lr}
  return available() ? _buffer[_offset++] : -1;
 80a5d32:	6803      	ldr	r3, [r0, #0]
    }
    return ret;
}

int UDP::read()
{
 80a5d34:	4604      	mov	r4, r0
  return available() ? _buffer[_offset++] : -1;
 80a5d36:	691b      	ldr	r3, [r3, #16]
 80a5d38:	4798      	blx	r3
 80a5d3a:	b128      	cbz	r0, 80a5d48 <_ZN3UDP4readEv+0x18>
 80a5d3c:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 80a5d3e:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 80a5d40:	1c59      	adds	r1, r3, #1
 80a5d42:	86e1      	strh	r1, [r4, #54]	; 0x36
 80a5d44:	5cd0      	ldrb	r0, [r2, r3]
 80a5d46:	bd10      	pop	{r4, pc}
 80a5d48:	f04f 30ff 	mov.w	r0, #4294967295
}
 80a5d4c:	bd10      	pop	{r4, pc}

080a5d4e <_ZN3UDP4peekEv>:
    }
    return read;
}

int UDP::peek()
{
 80a5d4e:	b510      	push	{r4, lr}
    return available() ? _buffer[_offset] : -1;
 80a5d50:	6803      	ldr	r3, [r0, #0]
    }
    return read;
}

int UDP::peek()
{
 80a5d52:	4604      	mov	r4, r0
    return available() ? _buffer[_offset] : -1;
 80a5d54:	691b      	ldr	r3, [r3, #16]
 80a5d56:	4798      	blx	r3
 80a5d58:	b118      	cbz	r0, 80a5d62 <_ZN3UDP4peekEv+0x14>
 80a5d5a:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 80a5d5c:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 80a5d5e:	5cd0      	ldrb	r0, [r2, r3]
 80a5d60:	bd10      	pop	{r4, pc}
 80a5d62:	f04f 30ff 	mov.w	r0, #4294967295
}
 80a5d66:	bd10      	pop	{r4, pc}

080a5d68 <_ZN3UDP5flushEv>:

void UDP::flush()
{
 80a5d68:	4770      	bx	lr

080a5d6a <_ZNK3UDP7printToER5Print>:
  _offset = 0;
  _total = 0;
}

size_t UDP::printTo(Print& p) const
{
 80a5d6a:	4603      	mov	r3, r0
 80a5d6c:	4608      	mov	r0, r1
 80a5d6e:	b410      	push	{r4}
    // can't use available() since this is a `const` method, and available is part of the Stream interface, and is non-const.
    int size = _total - _offset;
 80a5d70:	8ed9      	ldrh	r1, [r3, #54]	; 0x36
    return p.write(_buffer+_offset, size);
 80a5d72:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
 80a5d74:	8f1a      	ldrh	r2, [r3, #56]	; 0x38
 80a5d76:	6803      	ldr	r3, [r0, #0]
 80a5d78:	1a52      	subs	r2, r2, r1
 80a5d7a:	68db      	ldr	r3, [r3, #12]
 80a5d7c:	4421      	add	r1, r4
}
 80a5d7e:	bc10      	pop	{r4}

size_t UDP::printTo(Print& p) const
{
    // can't use available() since this is a `const` method, and available is part of the Stream interface, and is non-const.
    int size = _total - _offset;
    return p.write(_buffer+_offset, size);
 80a5d80:	4718      	bx	r3

080a5d82 <_ZThn16_NK3UDP7printToER5Print>:
        /**
         * Prints the current read parsed packet to the given output.
         * @param p
         * @return
         */
        virtual size_t printTo(Print& p) const;
 80a5d82:	f1a0 0010 	sub.w	r0, r0, #16
 80a5d86:	f7ff bff0 	b.w	80a5d6a <_ZNK3UDP7printToER5Print>
	...

080a5d8c <_ZN3UDP5beginEtm>:
    _buffer_size = 0;
    flush_buffer(); // clear buffer
}

uint8_t UDP::begin(uint16_t port, network_interface_t nif)
{
 80a5d8c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    }


    static NetworkClass& from(network_interface_t nif) {
        // hard-code for now until multiple-networks are implemented.
        return Network;
 80a5d8e:	4b11      	ldr	r3, [pc, #68]	; (80a5dd4 <_ZN3UDP5beginEtm+0x48>)
 80a5d90:	4605      	mov	r5, r0
 80a5d92:	6818      	ldr	r0, [r3, #0]
 80a5d94:	460f      	mov	r7, r1
    bool bound = 0;
    if(Network.from(nif).ready())
 80a5d96:	6803      	ldr	r3, [r0, #0]
    _buffer_size = 0;
    flush_buffer(); // clear buffer
}

uint8_t UDP::begin(uint16_t port, network_interface_t nif)
{
 80a5d98:	4616      	mov	r6, r2
    bool bound = 0;
    if(Network.from(nif).ready())
 80a5d9a:	681b      	ldr	r3, [r3, #0]
 80a5d9c:	4798      	blx	r3
 80a5d9e:	b1b8      	cbz	r0, 80a5dd0 <_ZN3UDP5beginEtm+0x44>
    {
       _sock = socket_create(AF_INET, SOCK_DGRAM, IPPROTO_UDP, port, nif);
 80a5da0:	2102      	movs	r1, #2
 80a5da2:	463b      	mov	r3, r7
 80a5da4:	2211      	movs	r2, #17
 80a5da6:	4608      	mov	r0, r1
 80a5da8:	9600      	str	r6, [sp, #0]
 80a5daa:	f7ff fa6f 	bl	80a528c <socket_create>
 80a5dae:	6168      	str	r0, [r5, #20]
        DEBUG("socket=%d",_sock);
        if (socket_handle_valid(_sock))
 80a5db0:	f7ff fa64 	bl	80a527c <socket_handle_valid>
 80a5db4:	4604      	mov	r4, r0
 80a5db6:	b130      	cbz	r0, 80a5dc6 <_ZN3UDP5beginEtm+0x3a>
{
}

void UDP::flush_buffer()
{
  _offset = 0;
 80a5db8:	2300      	movs	r3, #0
 80a5dba:	86eb      	strh	r3, [r5, #54]	; 0x36
  _total = 0;
 80a5dbc:	872b      	strh	r3, [r5, #56]	; 0x38
       _sock = socket_create(AF_INET, SOCK_DGRAM, IPPROTO_UDP, port, nif);
        DEBUG("socket=%d",_sock);
        if (socket_handle_valid(_sock))
        {
            flush_buffer(); // clear buffer
            _port = port;
 80a5dbe:	832f      	strh	r7, [r5, #24]
            _nif = nif;
 80a5dc0:	646e      	str	r6, [r5, #68]	; 0x44
            bound = true;
 80a5dc2:	2001      	movs	r0, #1
 80a5dc4:	e004      	b.n	80a5dd0 <_ZN3UDP5beginEtm+0x44>
        }
        else {
            stop();
 80a5dc6:	682b      	ldr	r3, [r5, #0]
 80a5dc8:	4628      	mov	r0, r5
 80a5dca:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a5dcc:	4798      	blx	r3
            bound = false;
 80a5dce:	4620      	mov	r0, r4
        }
    }
    return bound;
}
 80a5dd0:	b003      	add	sp, #12
 80a5dd2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a5dd4:	080a9514 	.word	0x080a9514

080a5dd8 <_ZN3UDP4stopEv>:
{
    return _total - _offset;
}

void UDP::stop()
{
 80a5dd8:	b538      	push	{r3, r4, r5, lr}
 80a5dda:	4604      	mov	r4, r0
    DEBUG("_sock %d closesocket", _sock);
    if (isOpen(_sock))
 80a5ddc:	6945      	ldr	r5, [r0, #20]

using namespace spark;

static bool inline isOpen(sock_handle_t sd)
{
   return sd != socket_handle_invalid();
 80a5dde:	f7ff fa75 	bl	80a52cc <socket_handle_invalid>
}

void UDP::stop()
{
    DEBUG("_sock %d closesocket", _sock);
    if (isOpen(_sock))
 80a5de2:	4285      	cmp	r5, r0
 80a5de4:	d002      	beq.n	80a5dec <_ZN3UDP4stopEv+0x14>
    {
        socket_close(_sock);
 80a5de6:	6960      	ldr	r0, [r4, #20]
 80a5de8:	f7ff fa68 	bl	80a52bc <socket_close>
    }
    _sock = socket_handle_invalid();
 80a5dec:	f7ff fa6e 	bl	80a52cc <socket_handle_invalid>
{
}

void UDP::flush_buffer()
{
  _offset = 0;
 80a5df0:	2300      	movs	r3, #0
    DEBUG("_sock %d closesocket", _sock);
    if (isOpen(_sock))
    {
        socket_close(_sock);
    }
    _sock = socket_handle_invalid();
 80a5df2:	6160      	str	r0, [r4, #20]
{
}

void UDP::flush_buffer()
{
  _offset = 0;
 80a5df4:	86e3      	strh	r3, [r4, #54]	; 0x36
  _total = 0;
 80a5df6:	8723      	strh	r3, [r4, #56]	; 0x38
 80a5df8:	bd38      	pop	{r3, r4, r5, pc}

080a5dfa <_ZN3UDP10sendPacketEPKhj9IPAddresst>:
    flush(); // wait for send to complete
    return result;
}

int UDP::sendPacket(const uint8_t* buffer, size_t buffer_size, IPAddress remoteIP, uint16_t port)
{
 80a5dfa:	b530      	push	{r4, r5, lr}
 80a5dfc:	b087      	sub	sp, #28
 80a5dfe:	f8bd 4028 	ldrh.w	r4, [sp, #40]	; 0x28
    sockaddr_t remoteSockAddr;
    remoteSockAddr.sa_family = AF_INET;
 80a5e02:	2502      	movs	r5, #2
 80a5e04:	f8ad 5008 	strh.w	r5, [sp, #8]

    remoteSockAddr.sa_data[0] = (port & 0xFF00) >> 8;
    remoteSockAddr.sa_data[1] = (port & 0x00FF);
 80a5e08:	f88d 400b 	strb.w	r4, [sp, #11]
int UDP::sendPacket(const uint8_t* buffer, size_t buffer_size, IPAddress remoteIP, uint16_t port)
{
    sockaddr_t remoteSockAddr;
    remoteSockAddr.sa_family = AF_INET;

    remoteSockAddr.sa_data[0] = (port & 0xFF00) >> 8;
 80a5e0c:	0a25      	lsrs	r5, r4, #8
    remoteSockAddr.sa_data[1] = (port & 0x00FF);

    remoteSockAddr.sa_data[2] = remoteIP[0];
 80a5e0e:	79dc      	ldrb	r4, [r3, #7]
int UDP::sendPacket(const uint8_t* buffer, size_t buffer_size, IPAddress remoteIP, uint16_t port)
{
    sockaddr_t remoteSockAddr;
    remoteSockAddr.sa_family = AF_INET;

    remoteSockAddr.sa_data[0] = (port & 0xFF00) >> 8;
 80a5e10:	f88d 500a 	strb.w	r5, [sp, #10]
    remoteSockAddr.sa_data[1] = (port & 0x00FF);

    remoteSockAddr.sa_data[2] = remoteIP[0];
 80a5e14:	f88d 400c 	strb.w	r4, [sp, #12]
    remoteSockAddr.sa_data[3] = remoteIP[1];
 80a5e18:	799c      	ldrb	r4, [r3, #6]
 80a5e1a:	f88d 400d 	strb.w	r4, [sp, #13]
    remoteSockAddr.sa_data[4] = remoteIP[2];
 80a5e1e:	795c      	ldrb	r4, [r3, #5]
    remoteSockAddr.sa_data[5] = remoteIP[3];
 80a5e20:	791b      	ldrb	r3, [r3, #4]
    remoteSockAddr.sa_data[0] = (port & 0xFF00) >> 8;
    remoteSockAddr.sa_data[1] = (port & 0x00FF);

    remoteSockAddr.sa_data[2] = remoteIP[0];
    remoteSockAddr.sa_data[3] = remoteIP[1];
    remoteSockAddr.sa_data[4] = remoteIP[2];
 80a5e22:	f88d 400e 	strb.w	r4, [sp, #14]
    remoteSockAddr.sa_data[5] = remoteIP[3];
 80a5e26:	f88d 300f 	strb.w	r3, [sp, #15]

    int rv = socket_sendto(_sock, buffer, buffer_size, 0, &remoteSockAddr, sizeof(remoteSockAddr));
 80a5e2a:	2310      	movs	r3, #16
 80a5e2c:	9301      	str	r3, [sp, #4]
 80a5e2e:	ab02      	add	r3, sp, #8
 80a5e30:	9300      	str	r3, [sp, #0]
 80a5e32:	6940      	ldr	r0, [r0, #20]
 80a5e34:	2300      	movs	r3, #0
 80a5e36:	f7ff fa39 	bl	80a52ac <socket_sendto>
    DEBUG("sendto(buffer=%lx, size=%d)=%d",buffer, buffer_size , rv);
    return rv;
}
 80a5e3a:	b007      	add	sp, #28
 80a5e3c:	bd30      	pop	{r4, r5, pc}

080a5e3e <_ZN3UDP5writeEPKhj>:
{
    return write(&byte, 1);
}

size_t UDP::write(const uint8_t *buffer, size_t size)
{
 80a5e3e:	b538      	push	{r3, r4, r5, lr}
    size_t available = _buffer ? _buffer_size - _offset : 0;
 80a5e40:	6bc3      	ldr	r3, [r0, #60]	; 0x3c
{
    return write(&byte, 1);
}

size_t UDP::write(const uint8_t *buffer, size_t size)
{
 80a5e42:	4605      	mov	r5, r0
 80a5e44:	8ec0      	ldrh	r0, [r0, #54]	; 0x36
    size_t available = _buffer ? _buffer_size - _offset : 0;
 80a5e46:	b113      	cbz	r3, 80a5e4e <_ZN3UDP5writeEPKhj+0x10>
 80a5e48:	6c2c      	ldr	r4, [r5, #64]	; 0x40
 80a5e4a:	1a24      	subs	r4, r4, r0
 80a5e4c:	e000      	b.n	80a5e50 <_ZN3UDP5writeEPKhj+0x12>
 80a5e4e:	461c      	mov	r4, r3
 80a5e50:	4294      	cmp	r4, r2
 80a5e52:	bf28      	it	cs
 80a5e54:	4614      	movcs	r4, r2
    if (size>available)
        size = available;
    memcpy(_buffer+_offset, buffer, size);
 80a5e56:	4418      	add	r0, r3
 80a5e58:	4622      	mov	r2, r4
 80a5e5a:	f001 fcf3 	bl	80a7844 <memcpy>
    _offset += size;
 80a5e5e:	8eeb      	ldrh	r3, [r5, #54]	; 0x36
    return size;
}
 80a5e60:	4620      	mov	r0, r4
{
    size_t available = _buffer ? _buffer_size - _offset : 0;
    if (size>available)
        size = available;
    memcpy(_buffer+_offset, buffer, size);
    _offset += size;
 80a5e62:	4423      	add	r3, r4
 80a5e64:	86eb      	strh	r3, [r5, #54]	; 0x36
    return size;
}
 80a5e66:	bd38      	pop	{r3, r4, r5, pc}

080a5e68 <_ZN3UDP4readEPhj>:
{
  return available() ? _buffer[_offset++] : -1;
}

int UDP::read(unsigned char* buffer, size_t len)
{
 80a5e68:	b570      	push	{r4, r5, r6, lr}
    int read = -1;
    if (available())
 80a5e6a:	6803      	ldr	r3, [r0, #0]
{
  return available() ? _buffer[_offset++] : -1;
}

int UDP::read(unsigned char* buffer, size_t len)
{
 80a5e6c:	4604      	mov	r4, r0
    int read = -1;
    if (available())
 80a5e6e:	691b      	ldr	r3, [r3, #16]
{
  return available() ? _buffer[_offset++] : -1;
}

int UDP::read(unsigned char* buffer, size_t len)
{
 80a5e70:	460e      	mov	r6, r1
 80a5e72:	4615      	mov	r5, r2
    int read = -1;
    if (available())
 80a5e74:	4798      	blx	r3
 80a5e76:	b188      	cbz	r0, 80a5e9c <_ZN3UDP4readEPhj+0x34>
    {
    read = min(int(len), available());
 80a5e78:	6823      	ldr	r3, [r4, #0]
 80a5e7a:	4620      	mov	r0, r4
 80a5e7c:	691b      	ldr	r3, [r3, #16]
 80a5e7e:	4798      	blx	r3
 80a5e80:	4285      	cmp	r5, r0
 80a5e82:	bfa8      	it	ge
 80a5e84:	4605      	movge	r5, r0
      memcpy(buffer, &_buffer[_offset], read);
 80a5e86:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 80a5e88:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 80a5e8a:	462a      	mov	r2, r5
 80a5e8c:	4419      	add	r1, r3
 80a5e8e:	4630      	mov	r0, r6
 80a5e90:	f001 fcd8 	bl	80a7844 <memcpy>
      _offset += read;
 80a5e94:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 80a5e96:	442b      	add	r3, r5
 80a5e98:	86e3      	strh	r3, [r4, #54]	; 0x36
 80a5e9a:	e001      	b.n	80a5ea0 <_ZN3UDP4readEPhj+0x38>
  return available() ? _buffer[_offset++] : -1;
}

int UDP::read(unsigned char* buffer, size_t len)
{
    int read = -1;
 80a5e9c:	f04f 35ff 	mov.w	r5, #4294967295
    read = min(int(len), available());
      memcpy(buffer, &_buffer[_offset], read);
      _offset += read;
    }
    return read;
}
 80a5ea0:	4628      	mov	r0, r5
 80a5ea2:	bd70      	pop	{r4, r5, r6, pc}

080a5ea4 <_ZN3UDP13receivePacketEPhj>:
    };
    return available();
}

int UDP::receivePacket(uint8_t* buffer, size_t size)
{
 80a5ea4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a5ea6:	4b19      	ldr	r3, [pc, #100]	; (80a5f0c <_ZN3UDP13receivePacketEPhj+0x68>)
 80a5ea8:	4604      	mov	r4, r0
 80a5eaa:	6818      	ldr	r0, [r3, #0]
 80a5eac:	b089      	sub	sp, #36	; 0x24
    int ret = -1;
    if(Network.from(_nif).ready() && isOpen(_sock) && buffer)
 80a5eae:	6803      	ldr	r3, [r0, #0]
    };
    return available();
}

int UDP::receivePacket(uint8_t* buffer, size_t size)
{
 80a5eb0:	460d      	mov	r5, r1
    int ret = -1;
    if(Network.from(_nif).ready() && isOpen(_sock) && buffer)
 80a5eb2:	681b      	ldr	r3, [r3, #0]
    };
    return available();
}

int UDP::receivePacket(uint8_t* buffer, size_t size)
{
 80a5eb4:	4616      	mov	r6, r2
    int ret = -1;
    if(Network.from(_nif).ready() && isOpen(_sock) && buffer)
 80a5eb6:	4798      	blx	r3
 80a5eb8:	b310      	cbz	r0, 80a5f00 <_ZN3UDP13receivePacketEPhj+0x5c>
 80a5eba:	6967      	ldr	r7, [r4, #20]

using namespace spark;

static bool inline isOpen(sock_handle_t sd)
{
   return sd != socket_handle_invalid();
 80a5ebc:	f7ff fa06 	bl	80a52cc <socket_handle_invalid>
}

int UDP::receivePacket(uint8_t* buffer, size_t size)
{
    int ret = -1;
    if(Network.from(_nif).ready() && isOpen(_sock) && buffer)
 80a5ec0:	4287      	cmp	r7, r0
 80a5ec2:	d01d      	beq.n	80a5f00 <_ZN3UDP13receivePacketEPhj+0x5c>
 80a5ec4:	b1e5      	cbz	r5, 80a5f00 <_ZN3UDP13receivePacketEPhj+0x5c>
    {
        sockaddr_t remoteSockAddr;
        socklen_t remoteSockAddrLen = sizeof(remoteSockAddr);
 80a5ec6:	ab08      	add	r3, sp, #32
 80a5ec8:	2210      	movs	r2, #16
 80a5eca:	f843 2d14 	str.w	r2, [r3, #-20]!

        ret = socket_receivefrom(_sock, buffer, size, 0, &remoteSockAddr, &remoteSockAddrLen);
 80a5ece:	9301      	str	r3, [sp, #4]
 80a5ed0:	eb0d 0302 	add.w	r3, sp, r2
 80a5ed4:	9300      	str	r3, [sp, #0]
 80a5ed6:	4629      	mov	r1, r5
 80a5ed8:	2300      	movs	r3, #0
 80a5eda:	4632      	mov	r2, r6
 80a5edc:	6960      	ldr	r0, [r4, #20]
 80a5ede:	f7ff f9dd 	bl	80a529c <socket_receivefrom>
        if (ret >= 0)
 80a5ee2:	1e05      	subs	r5, r0, #0
 80a5ee4:	db0e      	blt.n	80a5f04 <_ZN3UDP13receivePacketEPhj+0x60>
        {
            _remotePort = remoteSockAddr.sa_data[0] << 8 | remoteSockAddr.sa_data[1];
 80a5ee6:	f89d 2012 	ldrb.w	r2, [sp, #18]
 80a5eea:	f89d 3013 	ldrb.w	r3, [sp, #19]
            _remoteIP = &remoteSockAddr.sa_data[2];
 80a5eee:	a905      	add	r1, sp, #20
        socklen_t remoteSockAddrLen = sizeof(remoteSockAddr);

        ret = socket_receivefrom(_sock, buffer, size, 0, &remoteSockAddr, &remoteSockAddrLen);
        if (ret >= 0)
        {
            _remotePort = remoteSockAddr.sa_data[0] << 8 | remoteSockAddr.sa_data[1];
 80a5ef0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80a5ef4:	86a3      	strh	r3, [r4, #52]	; 0x34
            _remoteIP = &remoteSockAddr.sa_data[2];
 80a5ef6:	f104 001c 	add.w	r0, r4, #28
 80a5efa:	f000 fcd5 	bl	80a68a8 <_ZN9IPAddressaSEPKh>
 80a5efe:	e001      	b.n	80a5f04 <_ZN3UDP13receivePacketEPhj+0x60>
    return available();
}

int UDP::receivePacket(uint8_t* buffer, size_t size)
{
    int ret = -1;
 80a5f00:	f04f 35ff 	mov.w	r5, #4294967295
            _remotePort = remoteSockAddr.sa_data[0] << 8 | remoteSockAddr.sa_data[1];
            _remoteIP = &remoteSockAddr.sa_data[2];
        }
    }
    return ret;
}
 80a5f04:	4628      	mov	r0, r5
 80a5f06:	b009      	add	sp, #36	; 0x24
 80a5f08:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a5f0a:	bf00      	nop
 80a5f0c:	080a9514 	.word	0x080a9514

080a5f10 <_ZN3UDP11beginPacketEPKct>:

    flush_buffer(); // clear buffer
}

int UDP::beginPacket(const char *host, uint16_t port)
{
 80a5f10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a5f14:	4b16      	ldr	r3, [pc, #88]	; (80a5f70 <_ZN3UDP11beginPacketEPKct+0x60>)
 80a5f16:	4606      	mov	r6, r0
 80a5f18:	6818      	ldr	r0, [r3, #0]
 80a5f1a:	b094      	sub	sp, #80	; 0x50
    if(Network.from(_nif).ready())
 80a5f1c:	6803      	ldr	r3, [r0, #0]

    flush_buffer(); // clear buffer
}

int UDP::beginPacket(const char *host, uint16_t port)
{
 80a5f1e:	460d      	mov	r5, r1
    if(Network.from(_nif).ready())
 80a5f20:	681b      	ldr	r3, [r3, #0]

    flush_buffer(); // clear buffer
}

int UDP::beginPacket(const char *host, uint16_t port)
{
 80a5f22:	4617      	mov	r7, r2
    if(Network.from(_nif).ready())
 80a5f24:	4798      	blx	r3
 80a5f26:	b300      	cbz	r0, 80a5f6a <_ZN3UDP11beginPacketEPKct+0x5a>
    {
        HAL_IPAddress ip_addr;

        if(inet_gethostbyname((char*)host, strlen(host), &ip_addr, _nif, NULL) == 0)
 80a5f28:	4628      	mov	r0, r5
 80a5f2a:	f001 fd3e 	bl	80a79aa <strlen>
 80a5f2e:	2400      	movs	r4, #0
 80a5f30:	b281      	uxth	r1, r0
 80a5f32:	9400      	str	r4, [sp, #0]
 80a5f34:	6c73      	ldr	r3, [r6, #68]	; 0x44
 80a5f36:	aa03      	add	r2, sp, #12
 80a5f38:	4628      	mov	r0, r5
 80a5f3a:	f7ff f9ff 	bl	80a533c <inet_gethostbyname>
 80a5f3e:	b998      	cbnz	r0, 80a5f68 <_ZN3UDP11beginPacketEPKct+0x58>
        {
            IPAddress remote_addr(ip_addr);
 80a5f40:	a903      	add	r1, sp, #12
 80a5f42:	a808      	add	r0, sp, #32
 80a5f44:	f000 fc84 	bl	80a6850 <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>
            return beginPacket(remote_addr, port);
 80a5f48:	6833      	ldr	r3, [r6, #0]

/**
 * The IP address stored in host order.
 *
 */
class IPAddress : public Printable {
 80a5f4a:	ac0f      	add	r4, sp, #60	; 0x3c
 80a5f4c:	f8d3 8038 	ldr.w	r8, [r3, #56]	; 0x38
 80a5f50:	4b08      	ldr	r3, [pc, #32]	; (80a5f74 <_ZN3UDP11beginPacketEPKct+0x64>)
 80a5f52:	ad09      	add	r5, sp, #36	; 0x24
 80a5f54:	930e      	str	r3, [sp, #56]	; 0x38
 80a5f56:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80a5f58:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80a5f5a:	682b      	ldr	r3, [r5, #0]
 80a5f5c:	463a      	mov	r2, r7
 80a5f5e:	7023      	strb	r3, [r4, #0]
 80a5f60:	a90e      	add	r1, sp, #56	; 0x38
 80a5f62:	4630      	mov	r0, r6
 80a5f64:	47c0      	blx	r8
 80a5f66:	e000      	b.n	80a5f6a <_ZN3UDP11beginPacketEPKct+0x5a>
        }
    }
    return 0;
 80a5f68:	4620      	mov	r0, r4
}
 80a5f6a:	b014      	add	sp, #80	; 0x50
 80a5f6c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a5f70:	080a9514 	.word	0x080a9514
 80a5f74:	080a9474 	.word	0x080a9474

080a5f78 <_ZN3UDP8remoteIPEv>:
     * Discards the currently read packet.
     */
    void flush_buffer();


	virtual IPAddress remoteIP() { return _remoteIP; };
 80a5f78:	b570      	push	{r4, r5, r6, lr}
 80a5f7a:	4604      	mov	r4, r0
 80a5f7c:	4606      	mov	r6, r0
 80a5f7e:	4b05      	ldr	r3, [pc, #20]	; (80a5f94 <_ZN3UDP8remoteIPEv+0x1c>)
 80a5f80:	f101 0520 	add.w	r5, r1, #32
 80a5f84:	f844 3b04 	str.w	r3, [r4], #4
 80a5f88:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80a5f8a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80a5f8c:	682b      	ldr	r3, [r5, #0]
 80a5f8e:	4630      	mov	r0, r6
 80a5f90:	7023      	strb	r3, [r4, #0]
 80a5f92:	bd70      	pop	{r4, r5, r6, pc}
 80a5f94:	080a9474 	.word	0x080a9474

080a5f98 <_ZN3UDP10sendPacketEPKcj9IPAddresst>:
         * @param ip
         * @param port
         * @return
         */
        virtual int sendPacket(const uint8_t* buffer, size_t buffer_size, IPAddress destination, uint16_t port);
        virtual int sendPacket(const char* buffer, size_t buffer_size, IPAddress destination, uint16_t port) {
 80a5f98:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a5f9a:	4694      	mov	ip, r2
 80a5f9c:	468e      	mov	lr, r1
 80a5f9e:	4606      	mov	r6, r0
            return sendPacket((uint8_t*)buffer, buffer_size, destination, port);
 80a5fa0:	6802      	ldr	r2, [r0, #0]
         * @param ip
         * @param port
         * @return
         */
        virtual int sendPacket(const uint8_t* buffer, size_t buffer_size, IPAddress destination, uint16_t port);
        virtual int sendPacket(const char* buffer, size_t buffer_size, IPAddress destination, uint16_t port) {
 80a5fa2:	b089      	sub	sp, #36	; 0x24
            return sendPacket((uint8_t*)buffer, buffer_size, destination, port);
 80a5fa4:	6a97      	ldr	r7, [r2, #40]	; 0x28
 80a5fa6:	4a09      	ldr	r2, [pc, #36]	; (80a5fcc <_ZN3UDP10sendPacketEPKcj9IPAddresst+0x34>)
 80a5fa8:	ac03      	add	r4, sp, #12
 80a5faa:	1d1d      	adds	r5, r3, #4
 80a5fac:	9202      	str	r2, [sp, #8]
 80a5fae:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80a5fb0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80a5fb2:	682b      	ldr	r3, [r5, #0]
 80a5fb4:	4662      	mov	r2, ip
 80a5fb6:	7023      	strb	r3, [r4, #0]
 80a5fb8:	f8bd 3038 	ldrh.w	r3, [sp, #56]	; 0x38
 80a5fbc:	4671      	mov	r1, lr
 80a5fbe:	9300      	str	r3, [sp, #0]
 80a5fc0:	4630      	mov	r0, r6
 80a5fc2:	ab02      	add	r3, sp, #8
 80a5fc4:	47b8      	blx	r7
        }
 80a5fc6:	b009      	add	sp, #36	; 0x24
 80a5fc8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a5fca:	bf00      	nop
 80a5fcc:	080a9474 	.word	0x080a9474

080a5fd0 <_ZN3UDP9endPacketEv>:
    flush_buffer(); // clear buffer
    return _buffer_size;
}

int UDP::endPacket()
{
 80a5fd0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a5fd2:	4604      	mov	r4, r0
    int result = sendPacket(_buffer, _offset, _remoteIP, _remotePort);
 80a5fd4:	6803      	ldr	r3, [r0, #0]
    flush_buffer(); // clear buffer
    return _buffer_size;
}

int UDP::endPacket()
{
 80a5fd6:	b089      	sub	sp, #36	; 0x24
    int result = sendPacket(_buffer, _offset, _remoteIP, _remotePort);
 80a5fd8:	6a9f      	ldr	r7, [r3, #40]	; 0x28
 80a5fda:	4b0d      	ldr	r3, [pc, #52]	; (80a6010 <_ZN3UDP9endPacketEv+0x40>)
 80a5fdc:	ad03      	add	r5, sp, #12
 80a5fde:	f100 0620 	add.w	r6, r0, #32
 80a5fe2:	f8b0 e036 	ldrh.w	lr, [r0, #54]	; 0x36
 80a5fe6:	9302      	str	r3, [sp, #8]
 80a5fe8:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80a5fea:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80a5fec:	6833      	ldr	r3, [r6, #0]
 80a5fee:	4672      	mov	r2, lr
 80a5ff0:	702b      	strb	r3, [r5, #0]
 80a5ff2:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
 80a5ff4:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 80a5ff6:	9300      	str	r3, [sp, #0]
 80a5ff8:	4620      	mov	r0, r4
 80a5ffa:	ab02      	add	r3, sp, #8
 80a5ffc:	47b8      	blx	r7
 80a5ffe:	4605      	mov	r5, r0
    flush(); // wait for send to complete
 80a6000:	6823      	ldr	r3, [r4, #0]
 80a6002:	4620      	mov	r0, r4
 80a6004:	69db      	ldr	r3, [r3, #28]
 80a6006:	4798      	blx	r3
    return result;
}
 80a6008:	4628      	mov	r0, r5
 80a600a:	b009      	add	sp, #36	; 0x24
 80a600c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a600e:	bf00      	nop
 80a6010:	080a9474 	.word	0x080a9474

080a6014 <_ZN3UDPC1Ev>:
static bool inline isOpen(sock_handle_t sd)
{
   return sd != socket_handle_invalid();
}

UDP::UDP() : _sock(socket_handle_invalid()), _offset(0), _total(0), _buffer(0), _buffer_size(512)
 80a6014:	b538      	push	{r3, r4, r5, lr}
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
 80a6016:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a601a:	6083      	str	r3, [r0, #8]
 80a601c:	4b0b      	ldr	r3, [pc, #44]	; (80a604c <_ZN3UDPC1Ev+0x38>)
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
 80a601e:	2500      	movs	r5, #0
 80a6020:	f103 0208 	add.w	r2, r3, #8
 80a6024:	336c      	adds	r3, #108	; 0x6c
 80a6026:	6002      	str	r2, [r0, #0]
 80a6028:	6103      	str	r3, [r0, #16]
 80a602a:	6045      	str	r5, [r0, #4]
 80a602c:	4604      	mov	r4, r0
 80a602e:	f7ff f94d 	bl	80a52cc <socket_handle_invalid>
 80a6032:	6160      	str	r0, [r4, #20]
 80a6034:	f104 001c 	add.w	r0, r4, #28
 80a6038:	f000 fbfc 	bl	80a6834 <_ZN9IPAddressC1Ev>
 80a603c:	f44f 7300 	mov.w	r3, #512	; 0x200
 80a6040:	86e5      	strh	r5, [r4, #54]	; 0x36
 80a6042:	8725      	strh	r5, [r4, #56]	; 0x38
 80a6044:	63e5      	str	r5, [r4, #60]	; 0x3c
 80a6046:	6423      	str	r3, [r4, #64]	; 0x40
{
}
 80a6048:	4620      	mov	r0, r4
 80a604a:	bd38      	pop	{r3, r4, r5, pc}
 80a604c:	080a93e0 	.word	0x080a93e0

080a6050 <_ZN3UDP13releaseBufferEv>:
    }
    return _buffer_size;
}

void UDP::releaseBuffer()
{
 80a6050:	b510      	push	{r4, lr}
    if (_buffer_allocated && _buffer) {
 80a6052:	f890 3048 	ldrb.w	r3, [r0, #72]	; 0x48
    }
    return _buffer_size;
}

void UDP::releaseBuffer()
{
 80a6056:	4604      	mov	r4, r0
    if (_buffer_allocated && _buffer) {
 80a6058:	b11b      	cbz	r3, 80a6062 <_ZN3UDP13releaseBufferEv+0x12>
 80a605a:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
 80a605c:	b108      	cbz	r0, 80a6062 <_ZN3UDP13releaseBufferEv+0x12>
        delete _buffer;
 80a605e:	f7fa f820 	bl	80a00a2 <_ZdlPv>
    }
    _buffer = NULL;
 80a6062:	2300      	movs	r3, #0
 80a6064:	63e3      	str	r3, [r4, #60]	; 0x3c
    _buffer_allocated = false;
 80a6066:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
    _buffer_size = 0;
 80a606a:	6423      	str	r3, [r4, #64]	; 0x40
{
}

void UDP::flush_buffer()
{
  _offset = 0;
 80a606c:	86e3      	strh	r3, [r4, #54]	; 0x36
  _total = 0;
 80a606e:	8723      	strh	r3, [r4, #56]	; 0x38
 80a6070:	bd10      	pop	{r4, pc}

080a6072 <_ZN3UDP9setBufferEjPh>:
UDP::UDP() : _sock(socket_handle_invalid()), _offset(0), _total(0), _buffer(0), _buffer_size(512)
{
}

bool UDP::setBuffer(size_t buf_size, uint8_t* buffer)
{
 80a6072:	b570      	push	{r4, r5, r6, lr}
 80a6074:	4604      	mov	r4, r0
 80a6076:	4616      	mov	r6, r2
 80a6078:	460d      	mov	r5, r1
    releaseBuffer();
 80a607a:	f7ff ffe9 	bl	80a6050 <_ZN3UDP13releaseBufferEv>

    _buffer = buffer;
    _buffer_size = 0;
 80a607e:	2300      	movs	r3, #0

bool UDP::setBuffer(size_t buf_size, uint8_t* buffer)
{
    releaseBuffer();

    _buffer = buffer;
 80a6080:	63e6      	str	r6, [r4, #60]	; 0x3c
    _buffer_size = 0;
 80a6082:	6423      	str	r3, [r4, #64]	; 0x40
    if (!_buffer && buf_size) {         // requested allocation
 80a6084:	b93e      	cbnz	r6, 80a6096 <_ZN3UDP9setBufferEjPh+0x24>
 80a6086:	b135      	cbz	r5, 80a6096 <_ZN3UDP9setBufferEjPh+0x24>
        _buffer = new uint8_t[buf_size];
 80a6088:	4628      	mov	r0, r5
 80a608a:	f7fa f808 	bl	80a009e <_Znaj>
        _buffer_allocated = true;
 80a608e:	2301      	movs	r3, #1
    releaseBuffer();

    _buffer = buffer;
    _buffer_size = 0;
    if (!_buffer && buf_size) {         // requested allocation
        _buffer = new uint8_t[buf_size];
 80a6090:	63e0      	str	r0, [r4, #60]	; 0x3c
        _buffer_allocated = true;
 80a6092:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
    }
    if (_buffer) {
 80a6096:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80a6098:	b103      	cbz	r3, 80a609c <_ZN3UDP9setBufferEjPh+0x2a>
        _buffer_size = buf_size;
 80a609a:	6425      	str	r5, [r4, #64]	; 0x40
    }
    return _buffer_size;
 80a609c:	6c20      	ldr	r0, [r4, #64]	; 0x40
}
 80a609e:	3000      	adds	r0, #0
 80a60a0:	bf18      	it	ne
 80a60a2:	2001      	movne	r0, #1
 80a60a4:	bd70      	pop	{r4, r5, r6, pc}

080a60a6 <_ZN3UDP11beginPacketE9IPAddresst>:
    }
    return 0;
}

int UDP::beginPacket(IPAddress ip, uint16_t port)
{
 80a60a6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a60a8:	4617      	mov	r7, r2
    // default behavior previously was to use a 512 byte buffer, so instantiate that if not already done
    if (!_buffer && _buffer_size) {
 80a60aa:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
    }
    return 0;
}

int UDP::beginPacket(IPAddress ip, uint16_t port)
{
 80a60ac:	4605      	mov	r5, r0
 80a60ae:	460c      	mov	r4, r1
    // default behavior previously was to use a 512 byte buffer, so instantiate that if not already done
    if (!_buffer && _buffer_size) {
 80a60b0:	b91a      	cbnz	r2, 80a60ba <_ZN3UDP11beginPacketE9IPAddresst+0x14>
 80a60b2:	6c01      	ldr	r1, [r0, #64]	; 0x40
 80a60b4:	b109      	cbz	r1, 80a60ba <_ZN3UDP11beginPacketE9IPAddresst+0x14>
        setBuffer(_buffer_size);
 80a60b6:	f7ff ffdc 	bl	80a6072 <_ZN3UDP9setBufferEjPh>
 80a60ba:	f105 0620 	add.w	r6, r5, #32
 80a60be:	3404      	adds	r4, #4
 80a60c0:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80a60c2:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 80a60c4:	6823      	ldr	r3, [r4, #0]
 80a60c6:	7033      	strb	r3, [r6, #0]
{
}

void UDP::flush_buffer()
{
  _offset = 0;
 80a60c8:	2300      	movs	r3, #0
    if (!_buffer && _buffer_size) {
        setBuffer(_buffer_size);
    }

    _remoteIP = ip;
    _remotePort = port;
 80a60ca:	86af      	strh	r7, [r5, #52]	; 0x34
{
}

void UDP::flush_buffer()
{
  _offset = 0;
 80a60cc:	86eb      	strh	r3, [r5, #54]	; 0x36
  _total = 0;
 80a60ce:	872b      	strh	r3, [r5, #56]	; 0x38

    _remoteIP = ip;
    _remotePort = port;
    flush_buffer(); // clear buffer
    return _buffer_size;
}
 80a60d0:	6c28      	ldr	r0, [r5, #64]	; 0x40
 80a60d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a60d4 <_ZN3UDP11parsePacketEv>:
    _offset += size;
    return size;
}

int UDP::parsePacket()
{
 80a60d4:	b510      	push	{r4, lr}
    if (!_buffer && _buffer_size) {
 80a60d6:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
    _offset += size;
    return size;
}

int UDP::parsePacket()
{
 80a60d8:	4604      	mov	r4, r0
    if (!_buffer && _buffer_size) {
 80a60da:	b91a      	cbnz	r2, 80a60e4 <_ZN3UDP11parsePacketEv+0x10>
 80a60dc:	6c01      	ldr	r1, [r0, #64]	; 0x40
 80a60de:	b109      	cbz	r1, 80a60e4 <_ZN3UDP11parsePacketEv+0x10>
        setBuffer(_buffer_size);
 80a60e0:	f7ff ffc7 	bl	80a6072 <_ZN3UDP9setBufferEjPh>
    }

    flush_buffer();         // start a new read - discard the old data
    if (_buffer && _buffer_size) {
 80a60e4:	6be1      	ldr	r1, [r4, #60]	; 0x3c
{
}

void UDP::flush_buffer()
{
  _offset = 0;
 80a60e6:	2300      	movs	r3, #0
 80a60e8:	86e3      	strh	r3, [r4, #54]	; 0x36
  _total = 0;
 80a60ea:	8723      	strh	r3, [r4, #56]	; 0x38
    if (!_buffer && _buffer_size) {
        setBuffer(_buffer_size);
    }

    flush_buffer();         // start a new read - discard the old data
    if (_buffer && _buffer_size) {
 80a60ec:	b141      	cbz	r1, 80a6100 <_ZN3UDP11parsePacketEv+0x2c>
 80a60ee:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80a60f0:	b132      	cbz	r2, 80a6100 <_ZN3UDP11parsePacketEv+0x2c>
        int result = receivePacket(_buffer, _buffer_size);
 80a60f2:	6823      	ldr	r3, [r4, #0]
 80a60f4:	4620      	mov	r0, r4
 80a60f6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a60f8:	4798      	blx	r3
        if (result>0) {
 80a60fa:	2800      	cmp	r0, #0
            _total = result;
 80a60fc:	bfc8      	it	gt
 80a60fe:	8720      	strhgt	r0, [r4, #56]	; 0x38
        }
    };
    return available();
 80a6100:	6823      	ldr	r3, [r4, #0]
 80a6102:	4620      	mov	r0, r4
}
 80a6104:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        int result = receivePacket(_buffer, _buffer_size);
        if (result>0) {
            _total = result;
        }
    };
    return available();
 80a6108:	691b      	ldr	r3, [r3, #16]
 80a610a:	4718      	bx	r3

080a610c <_ZN8RGBClassD1Ev>:
#include "rgbled.h"

typedef void (raw_rgb_change_handler_t)(uint8_t, uint8_t, uint8_t);
typedef std::function<raw_rgb_change_handler_t> wiring_rgb_change_handler_t;

class RGBClass {
 80a610c:	b510      	push	{r4, lr}
 80a610e:	4604      	mov	r4, r0
 80a6110:	f7fa fcac 	bl	80a0a6c <_ZNSt14_Function_baseD1Ev>
 80a6114:	4620      	mov	r0, r4
 80a6116:	bd10      	pop	{r4, pc}

080a6118 <_ZN8RGBClass7controlEb>:
{
    return LED_RGB_IsOverRidden();
}

void RGBClass::control(bool override)
{
 80a6118:	b510      	push	{r4, lr}
 80a611a:	4604      	mov	r4, r0

RGBClass RGB;

bool RGBClass::controlled(void)
{
    return LED_RGB_IsOverRidden();
 80a611c:	f7ff f936 	bl	80a538c <LED_RGB_IsOverRidden>
}

void RGBClass::control(bool override)
{
    if (override == controlled()) {
 80a6120:	4284      	cmp	r4, r0
 80a6122:	d008      	beq.n	80a6136 <_ZN8RGBClass7controlEb+0x1e>
        return;
    } else if (override) {
 80a6124:	b11c      	cbz	r4, 80a612e <_ZN8RGBClass7controlEb+0x16>
        LED_Signaling_Start();
    } else {
        LED_Signaling_Stop();
    }
}
 80a6126:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
void RGBClass::control(bool override)
{
    if (override == controlled()) {
        return;
    } else if (override) {
        LED_Signaling_Start();
 80a612a:	f7ff b917 	b.w	80a535c <LED_Signaling_Start>
    } else {
        LED_Signaling_Stop();
    }
}
 80a612e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    if (override == controlled()) {
        return;
    } else if (override) {
        LED_Signaling_Start();
    } else {
        LED_Signaling_Stop();
 80a6132:	f7ff b91b 	b.w	80a536c <LED_Signaling_Stop>
 80a6136:	bd10      	pop	{r4, pc}

080a6138 <_ZN8RGBClass5colorEiii>:
void RGBClass::color(uint32_t rgb) {
    color((rgb>>16)&0xFF, (rgb>>8)&0xFF, (rgb)&0xFF);
}

void RGBClass::color(int red, int green, int blue)
{
 80a6138:	b570      	push	{r4, r5, r6, lr}
 80a613a:	4605      	mov	r5, r0
 80a613c:	460e      	mov	r6, r1
 80a613e:	4614      	mov	r4, r2

RGBClass RGB;

bool RGBClass::controlled(void)
{
    return LED_RGB_IsOverRidden();
 80a6140:	f7ff f924 	bl	80a538c <LED_RGB_IsOverRidden>
    color((rgb>>16)&0xFF, (rgb>>8)&0xFF, (rgb)&0xFF);
}

void RGBClass::color(int red, int green, int blue)
{
    if (!controlled()) {
 80a6144:	b150      	cbz	r0, 80a615c <_ZN8RGBClass5colorEiii+0x24>
        return;
    }
    LED_SetSignalingColor(red << 16 | green << 8 | blue);
 80a6146:	ea44 2006 	orr.w	r0, r4, r6, lsl #8
 80a614a:	ea40 4005 	orr.w	r0, r0, r5, lsl #16
 80a614e:	f7ff f8fd 	bl	80a534c <LED_SetSignalingColor>
    LED_On(LED_RGB);
}
 80a6152:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
{
    if (!controlled()) {
        return;
    }
    LED_SetSignalingColor(red << 16 | green << 8 | blue);
    LED_On(LED_RGB);
 80a6156:	20e7      	movs	r0, #231	; 0xe7
 80a6158:	f7ff b920 	b.w	80a539c <LED_On>
 80a615c:	bd70      	pop	{r4, r5, r6, pc}

080a615e <_ZN8RGBClass10brightnessEhb>:
}

void RGBClass::brightness(uint8_t brightness, bool update)
{
 80a615e:	b510      	push	{r4, lr}
 80a6160:	460c      	mov	r4, r1
    LED_SetBrightness(brightness);
 80a6162:	f7ff f90b 	bl	80a537c <LED_SetBrightness>

RGBClass RGB;

bool RGBClass::controlled(void)
{
    return LED_RGB_IsOverRidden();
 80a6166:	f7ff f911 	bl	80a538c <LED_RGB_IsOverRidden>
}

void RGBClass::brightness(uint8_t brightness, bool update)
{
    LED_SetBrightness(brightness);
    if (controlled() && update) {
 80a616a:	b128      	cbz	r0, 80a6178 <_ZN8RGBClass10brightnessEhb+0x1a>
 80a616c:	b124      	cbz	r4, 80a6178 <_ZN8RGBClass10brightnessEhb+0x1a>
        LED_On(LED_RGB);
    }
}
 80a616e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

void RGBClass::brightness(uint8_t brightness, bool update)
{
    LED_SetBrightness(brightness);
    if (controlled() && update) {
        LED_On(LED_RGB);
 80a6172:	20e7      	movs	r0, #231	; 0xe7
 80a6174:	f7ff b912 	b.w	80a539c <LED_On>
 80a6178:	bd10      	pop	{r4, pc}

080a617a <_ZSt4swapISt9_Any_dataEvRT_S2_>:
   *  @param  __b  Another thing of arbitrary type.
   *  @return   Nothing.
  */
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)
 80a617a:	b513      	push	{r0, r1, r4, lr}
 80a617c:	460b      	mov	r3, r1
 80a617e:	4604      	mov	r4, r0
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a6180:	c803      	ldmia	r0, {r0, r1}
 80a6182:	e88d 0003 	stmia.w	sp, {r0, r1}
      __a = _GLIBCXX_MOVE(__b);
 80a6186:	e893 0003 	ldmia.w	r3, {r0, r1}
 80a618a:	e884 0003 	stmia.w	r4, {r0, r1}
      __b = _GLIBCXX_MOVE(__tmp);
 80a618e:	e89d 0003 	ldmia.w	sp, {r0, r1}
 80a6192:	e883 0003 	stmia.w	r3, {r0, r1}
    }
 80a6196:	b002      	add	sp, #8
 80a6198:	bd10      	pop	{r4, pc}
	...

080a619c <_GLOBAL__sub_I_RGB>:
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a619c:	4803      	ldr	r0, [pc, #12]	; (80a61ac <_GLOBAL__sub_I_RGB+0x10>)
 80a619e:	2300      	movs	r3, #0
 80a61a0:	6083      	str	r3, [r0, #8]
#include "spark_wiring_rgb.h"
#include "spark_wiring_interrupts.h"

#include "core_hal.h"

RGBClass RGB;
 80a61a2:	4a03      	ldr	r2, [pc, #12]	; (80a61b0 <_GLOBAL__sub_I_RGB+0x14>)
 80a61a4:	4903      	ldr	r1, [pc, #12]	; (80a61b4 <_GLOBAL__sub_I_RGB+0x18>)
 80a61a6:	f000 bdfd 	b.w	80a6da4 <__aeabi_atexit>
 80a61aa:	bf00      	nop
 80a61ac:	200010ac 	.word	0x200010ac
 80a61b0:	200003bc 	.word	0x200003bc
 80a61b4:	080a610d 	.word	0x080a610d

080a61b8 <serialEventRun>:

/**
 * Provides background processing of serial data.
 */
void serialEventRun()
{
 80a61b8:	b508      	push	{r3, lr}
    if (serialEvent && Serial.available()>0)
 80a61ba:	4b14      	ldr	r3, [pc, #80]	; (80a620c <serialEventRun+0x54>)
 80a61bc:	b133      	cbz	r3, 80a61cc <serialEventRun+0x14>
 80a61be:	f000 fbd3 	bl	80a6968 <_Z16_fetch_usbserialv>
 80a61c2:	6803      	ldr	r3, [r0, #0]
 80a61c4:	691b      	ldr	r3, [r3, #16]
 80a61c6:	4798      	blx	r3
 80a61c8:	2800      	cmp	r0, #0
 80a61ca:	dc16      	bgt.n	80a61fa <serialEventRun+0x42>
        serialEvent();

    if (serialEvent1 && Serial1.available()>0)
 80a61cc:	4b10      	ldr	r3, [pc, #64]	; (80a6210 <serialEventRun+0x58>)
 80a61ce:	b133      	cbz	r3, 80a61de <serialEventRun+0x26>
 80a61d0:	f000 fc7a 	bl	80a6ac8 <_Z22__fetch_global_Serial1v>
 80a61d4:	6803      	ldr	r3, [r0, #0]
 80a61d6:	691b      	ldr	r3, [r3, #16]
 80a61d8:	4798      	blx	r3
 80a61da:	2800      	cmp	r0, #0
 80a61dc:	dc10      	bgt.n	80a6200 <serialEventRun+0x48>
        serialEvent1();

#if Wiring_Serial2
    if (serialEventRun2) serialEventRun2();
 80a61de:	4b0d      	ldr	r3, [pc, #52]	; (80a6214 <serialEventRun+0x5c>)
 80a61e0:	b10b      	cbz	r3, 80a61e6 <serialEventRun+0x2e>
 80a61e2:	f3af 8000 	nop.w
#if Wiring_Serial5
    if (serialEventRun5) serialEventRun5();
#endif

#if Wiring_USBSerial1
    if (usbSerialEvent1 && USBSerial1.available()>0)
 80a61e6:	4b0c      	ldr	r3, [pc, #48]	; (80a6218 <serialEventRun+0x60>)
 80a61e8:	b17b      	cbz	r3, 80a620a <serialEventRun+0x52>
 80a61ea:	f000 fbf9 	bl	80a69e0 <_Z17_fetch_usbserial1v>
 80a61ee:	6803      	ldr	r3, [r0, #0]
 80a61f0:	691b      	ldr	r3, [r3, #16]
 80a61f2:	4798      	blx	r3
 80a61f4:	2800      	cmp	r0, #0
 80a61f6:	dc06      	bgt.n	80a6206 <serialEventRun+0x4e>
 80a61f8:	bd08      	pop	{r3, pc}
 * Provides background processing of serial data.
 */
void serialEventRun()
{
    if (serialEvent && Serial.available()>0)
        serialEvent();
 80a61fa:	f3af 8000 	nop.w
 80a61fe:	e7e5      	b.n	80a61cc <serialEventRun+0x14>

    if (serialEvent1 && Serial1.available()>0)
        serialEvent1();
 80a6200:	f3af 8000 	nop.w
 80a6204:	e7eb      	b.n	80a61de <serialEventRun+0x26>
    if (serialEventRun5) serialEventRun5();
#endif

#if Wiring_USBSerial1
    if (usbSerialEvent1 && USBSerial1.available()>0)
        usbSerialEvent1();
 80a6206:	f3af 8000 	nop.w
 80a620a:	bd08      	pop	{r3, pc}
	...

080a621c <_post_loop>:
#if Wiring_Serial5
void serialEvent5() __attribute__((weak));
#endif

void _post_loop()
{
 80a621c:	b508      	push	{r3, lr}
	serialEventRun();
 80a621e:	f7ff ffcb 	bl	80a61b8 <serialEventRun>
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
 80a6222:	f7fe ff19 	bl	80a5058 <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
 80a6226:	4b01      	ldr	r3, [pc, #4]	; (80a622c <_post_loop+0x10>)
 80a6228:	6018      	str	r0, [r3, #0]
 80a622a:	bd08      	pop	{r3, pc}
 80a622c:	20001544 	.word	0x20001544

080a6230 <_Z33system_initialize_user_backup_ramv>:
 * the dynamically linked application module.
 */
void system_initialize_user_backup_ram()
{
    size_t len = &link_global_retained_end-&link_global_retained_start;
    memcpy(&link_global_retained_start, &link_global_retained_initial_values, len);
 80a6230:	4802      	ldr	r0, [pc, #8]	; (80a623c <_Z33system_initialize_user_backup_ramv+0xc>)
 80a6232:	4a03      	ldr	r2, [pc, #12]	; (80a6240 <_Z33system_initialize_user_backup_ramv+0x10>)
 80a6234:	4903      	ldr	r1, [pc, #12]	; (80a6244 <_Z33system_initialize_user_backup_ramv+0x14>)
 80a6236:	1a12      	subs	r2, r2, r0
 80a6238:	f001 bb04 	b.w	80a7844 <memcpy>
 80a623c:	40024000 	.word	0x40024000
 80a6240:	40024004 	.word	0x40024004
 80a6244:	080a97e0 	.word	0x080a97e0

080a6248 <_Z27ctrl_request_custom_handlerP12ctrl_request>:
bool __backup_ram_was_valid() { return false; }

#endif

// Default handler for CTRL_REQUEST_APP_CUSTOM requests
void __attribute((weak)) ctrl_request_custom_handler(ctrl_request* req) {
 80a6248:	b507      	push	{r0, r1, r2, lr}
    system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
 80a624a:	2300      	movs	r3, #0
 80a624c:	9300      	str	r3, [sp, #0]
 80a624e:	461a      	mov	r2, r3
 80a6250:	f06f 0177 	mvn.w	r1, #119	; 0x77
 80a6254:	f7ff f8ec 	bl	80a5430 <system_ctrl_set_result>
}
 80a6258:	b003      	add	sp, #12
 80a625a:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080a6260 <_ZL20ctrl_request_handlerP12ctrl_request>:
// Callback invoked to process a logging configuration request
void(*log_process_ctrl_request_callback)(ctrl_request* req) = nullptr;
#endif

// Application handler for control requests
static void ctrl_request_handler(ctrl_request* req) {
 80a6260:	b507      	push	{r0, r1, r2, lr}
    switch (req->type) {
 80a6262:	8843      	ldrh	r3, [r0, #2]
 80a6264:	2b0a      	cmp	r3, #10
 80a6266:	d008      	beq.n	80a627a <_ZL20ctrl_request_handlerP12ctrl_request+0x1a>
 80a6268:	2b50      	cmp	r3, #80	; 0x50
 80a626a:	d109      	bne.n	80a6280 <_ZL20ctrl_request_handlerP12ctrl_request+0x20>
#if Wiring_LogConfig
    case CTRL_REQUEST_LOG_CONFIG: {
        if (log_process_ctrl_request_callback) {
 80a626c:	4b09      	ldr	r3, [pc, #36]	; (80a6294 <_ZL20ctrl_request_handlerP12ctrl_request+0x34>)
 80a626e:	681b      	ldr	r3, [r3, #0]
 80a6270:	b13b      	cbz	r3, 80a6282 <_ZL20ctrl_request_handlerP12ctrl_request+0x22>
    }
    default:
        system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
        break;
    }
}
 80a6272:	b003      	add	sp, #12
 80a6274:	f85d eb04 	ldr.w	lr, [sp], #4
static void ctrl_request_handler(ctrl_request* req) {
    switch (req->type) {
#if Wiring_LogConfig
    case CTRL_REQUEST_LOG_CONFIG: {
        if (log_process_ctrl_request_callback) {
            log_process_ctrl_request_callback(req);
 80a6278:	4718      	bx	r3
        }
        break;
    }
#endif
    case CTRL_REQUEST_APP_CUSTOM: {
        ctrl_request_custom_handler(req);
 80a627a:	f7ff ffe5 	bl	80a6248 <_Z27ctrl_request_custom_handlerP12ctrl_request>
        break;
 80a627e:	e006      	b.n	80a628e <_ZL20ctrl_request_handlerP12ctrl_request+0x2e>
    }
    default:
        system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
 80a6280:	2300      	movs	r3, #0
 80a6282:	9300      	str	r3, [sp, #0]
 80a6284:	461a      	mov	r2, r3
 80a6286:	f06f 0177 	mvn.w	r1, #119	; 0x77
 80a628a:	f7ff f8d1 	bl	80a5430 <system_ctrl_set_result>
        break;
    }
}
 80a628e:	b003      	add	sp, #12
 80a6290:	f85d fb04 	ldr.w	pc, [sp], #4
 80a6294:	200010bc 	.word	0x200010bc

080a6298 <module_user_init_hook>:

void module_user_init_hook()
{
 80a6298:	b538      	push	{r3, r4, r5, lr}
#if PLATFORM_BACKUP_RAM
    backup_ram_was_valid_ =  __backup_sram_signature==signature;
 80a629a:	4c10      	ldr	r4, [pc, #64]	; (80a62dc <module_user_init_hook+0x44>)
 80a629c:	4d10      	ldr	r5, [pc, #64]	; (80a62e0 <module_user_init_hook+0x48>)
 80a629e:	6823      	ldr	r3, [r4, #0]
 80a62a0:	42ab      	cmp	r3, r5
 80a62a2:	4b10      	ldr	r3, [pc, #64]	; (80a62e4 <module_user_init_hook+0x4c>)
 80a62a4:	bf0c      	ite	eq
 80a62a6:	2201      	moveq	r2, #1
 80a62a8:	2200      	movne	r2, #0
 80a62aa:	701a      	strb	r2, [r3, #0]
    if (!backup_ram_was_valid_) {
 80a62ac:	d002      	beq.n	80a62b4 <module_user_init_hook+0x1c>
        system_initialize_user_backup_ram();
 80a62ae:	f7ff ffbf 	bl	80a6230 <_Z33system_initialize_user_backup_ramv>
        __backup_sram_signature = signature;
 80a62b2:	6025      	str	r5, [r4, #0]
#endif

    // todo - add a RNG define for that capability
#if defined(STM32F2XX)
    // Initialize the default stdlib PRNG using hardware RNG as a seed
    srand(HAL_RNG_GetRandomNumber());
 80a62b4:	f7fe feb8 	bl	80a5028 <HAL_RNG_GetRandomNumber>
 80a62b8:	f001 fad8 	bl	80a786c <srand>

    // If the user defines random_seed_from_cloud, call it with a seed value
    // generated by a hardware RNG as well.
    if (random_seed_from_cloud) {
 80a62bc:	4b0a      	ldr	r3, [pc, #40]	; (80a62e8 <module_user_init_hook+0x50>)
 80a62be:	b11b      	cbz	r3, 80a62c8 <module_user_init_hook+0x30>
        uint32_t seed = HAL_RNG_GetRandomNumber();
 80a62c0:	f7fe feb2 	bl	80a5028 <HAL_RNG_GetRandomNumber>
        random_seed_from_cloud(seed);
 80a62c4:	f3af 8000 	nop.w
    }
#endif
    // Register the random_seed_from_cloud handler
    spark_set_random_seed_from_cloud_handler(&random_seed_from_cloud, nullptr);
 80a62c8:	2100      	movs	r1, #0
 80a62ca:	4807      	ldr	r0, [pc, #28]	; (80a62e8 <module_user_init_hook+0x50>)
 80a62cc:	f7ff f912 	bl	80a54f4 <spark_set_random_seed_from_cloud_handler>

    // Register application handler for the control requests
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
}
 80a62d0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
#endif
    // Register the random_seed_from_cloud handler
    spark_set_random_seed_from_cloud_handler(&random_seed_from_cloud, nullptr);

    // Register application handler for the control requests
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
 80a62d4:	2100      	movs	r1, #0
 80a62d6:	4805      	ldr	r0, [pc, #20]	; (80a62ec <module_user_init_hook+0x54>)
 80a62d8:	f7ff b8a0 	b.w	80a541c <system_ctrl_set_app_request_handler>
 80a62dc:	40024000 	.word	0x40024000
 80a62e0:	9a271c1e 	.word	0x9a271c1e
 80a62e4:	200010c0 	.word	0x200010c0
 80a62e8:	00000000 	.word	0x00000000
 80a62ec:	080a6261 	.word	0x080a6261

080a62f0 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EED1Ev>:
    class __shared_count;


  // Counted ptr with no deleter or allocator support
  template<typename _Ptr, _Lock_policy _Lp>
    class _Sp_counted_ptr final : public _Sp_counted_base<_Lp>
 80a62f0:	4770      	bx	lr

080a62f2 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE14_M_get_deleterERKSt9type_info>:
      _M_destroy() noexcept
      { delete this; }

      virtual void*
      _M_get_deleter(const std::type_info&) noexcept
      { return nullptr; }
 80a62f2:	2000      	movs	r0, #0
 80a62f4:	4770      	bx	lr

080a62f6 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EED0Ev>:
    class __shared_count;


  // Counted ptr with no deleter or allocator support
  template<typename _Ptr, _Lock_policy _Lp>
    class _Sp_counted_ptr final : public _Sp_counted_base<_Lp>
 80a62f6:	b510      	push	{r4, lr}
 80a62f8:	4604      	mov	r4, r0
 80a62fa:	f7f9 fed2 	bl	80a00a2 <_ZdlPv>
 80a62fe:	4620      	mov	r0, r4
 80a6300:	bd10      	pop	{r4, pc}

080a6302 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_destroyEv>:
      virtual void
      _M_dispose() noexcept
      { delete _M_ptr; }

      virtual void
      _M_destroy() noexcept
 80a6302:	b508      	push	{r3, lr}
      { delete this; }
 80a6304:	b108      	cbz	r0, 80a630a <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_destroyEv+0x8>
 80a6306:	f7ff fff6 	bl	80a62f6 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EED0Ev>
 80a630a:	bd08      	pop	{r3, pc}

080a630c <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv>:
      explicit
      _Sp_counted_ptr(_Ptr __p) noexcept
      : _M_ptr(__p) { }

      virtual void
      _M_dispose() noexcept
 80a630c:	b538      	push	{r3, r4, r5, lr}
      { delete _M_ptr; }
 80a630e:	68c4      	ldr	r4, [r0, #12]
 80a6310:	b1d4      	cbz	r4, 80a6348 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x3c>

      _Tp
      load(memory_order __m = memory_order_seq_cst) const noexcept
      { 
        _Tp tmp;
	__atomic_load(&_M_i, &tmp, __m);
 80a6312:	7823      	ldrb	r3, [r4, #0]
    ~FutureImpl() {
        // Call destructor of the appropriate unnamed enum's field
        const State s = this->state();
        if (s == State::SUCCEEDED) {
            result_.~ResultT();
        } else if (s == State::FAILED) {
 80a6314:	2b02      	cmp	r3, #2
 80a6316:	d102      	bne.n	80a631e <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x12>
        Error() {
    swap(*this, error);
}

inline particle::Error::~Error() {
    free((void*)msg_);
 80a6318:	68e0      	ldr	r0, [r4, #12]
 80a631a:	f7ff f8fb 	bl	80a5514 <free>
      {
        memory_order __b = __m & __memory_order_mask;
	__glibcxx_assert(__b != memory_order_release);
	__glibcxx_assert(__b != memory_order_acq_rel);

	return __atomic_load_n(&_M_p, __m);
 80a631e:	6865      	ldr	r5, [r4, #4]
    // Completion callback types
    typedef typename detail::FutureCallbackTypes<ResultT>::OnSuccess OnSuccessCallback;
    typedef typename detail::FutureCallbackTypes<ResultT>::OnError OnErrorCallback;

    ~FutureImplBase() {
        delete onSuccess_.load(std::memory_order_relaxed);
 80a6320:	b12d      	cbz	r5, 80a632e <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x22>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a6322:	4628      	mov	r0, r5
 80a6324:	f7fa fba2 	bl	80a0a6c <_ZNSt14_Function_baseD1Ev>
 80a6328:	4628      	mov	r0, r5
 80a632a:	f7f9 feba 	bl	80a00a2 <_ZdlPv>
 80a632e:	68a5      	ldr	r5, [r4, #8]
        delete onError_.load(std::memory_order_relaxed);
 80a6330:	b12d      	cbz	r5, 80a633e <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x32>
 80a6332:	4628      	mov	r0, r5
 80a6334:	f7fa fb9a 	bl	80a0a6c <_ZNSt14_Function_baseD1Ev>
 80a6338:	4628      	mov	r0, r5
 80a633a:	f7f9 feb2 	bl	80a00a2 <_ZdlPv>
 80a633e:	4620      	mov	r0, r4
 80a6340:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80a6344:	f7f9 bead 	b.w	80a00a2 <_ZdlPv>
 80a6348:	bd38      	pop	{r3, r4, r5, pc}

080a634a <_ZN8particle6FutureIbNS_6detail13FutureContextEEC1ESt10shared_ptrINS1_10FutureImplIbS2_EEE>:
};

template<typename ResultT, typename ContextT = detail::FutureContext>
class Future: public FutureBase<ResultT, ContextT> {
public:
    using FutureBase<ResultT, ContextT>::FutureBase;
 80a634a:	b513      	push	{r0, r1, r4, lr}
 80a634c:	4604      	mov	r4, r0
      }

      void
      _M_swap(__shared_count& __r) noexcept
      {
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 80a634e:	e891 0005 	ldmia.w	r1, {r0, r2}
	__r._M_pi = _M_pi;
 80a6352:	2300      	movs	r3, #0
 80a6354:	604b      	str	r3, [r1, #4]

      __shared_ptr(__shared_ptr&& __r) noexcept
      : _M_ptr(__r._M_ptr), _M_refcount()
      {
	_M_refcount._M_swap(__r._M_refcount);
	__r._M_ptr = 0;
 80a6356:	600b      	str	r3, [r1, #0]
	__shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
	: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
	{ }

      __shared_ptr(__shared_ptr&& __r) noexcept
      : _M_ptr(__r._M_ptr), _M_refcount()
 80a6358:	6020      	str	r0, [r4, #0]
      void
      _M_swap(__shared_count& __r) noexcept
      {
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
	__r._M_pi = _M_pi;
	_M_pi = __tmp;
 80a635a:	6062      	str	r2, [r4, #4]
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
 80a635c:	a801      	add	r0, sp, #4

      void
      _M_swap(__shared_count& __r) noexcept
      {
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
	__r._M_pi = _M_pi;
 80a635e:	9301      	str	r3, [sp, #4]

      __shared_ptr(__shared_ptr&& __r) noexcept
      : _M_ptr(__r._M_ptr), _M_refcount()
      {
	_M_refcount._M_swap(__r._M_refcount);
	__r._M_ptr = 0;
 80a6360:	9300      	str	r3, [sp, #0]
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
 80a6362:	f7fb f9d8 	bl	80a1716 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
 80a6366:	4620      	mov	r0, r4
 80a6368:	b002      	add	sp, #8
 80a636a:	bd10      	pop	{r4, pc}

080a636c <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE11fromDataPtrEPv>:
        // TODO: Use custom reference counting object to avoid unnecessary memory allocation
        return new detail::FutureImplPtr<ResultT, ContextT>(p_);
    }

    // Unwraps promise from an object pointer created via dataPtr() method
    static Promise<ResultT, ContextT> fromDataPtr(void* data) {
 80a636c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
      template<typename _Tp1>
	__shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, _Tp* __p) noexcept
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
 80a636e:	460c      	mov	r4, r1
 80a6370:	4606      	mov	r6, r0
 80a6372:	460f      	mov	r7, r1
 80a6374:	f854 3b04 	ldr.w	r3, [r4], #4
 80a6378:	ad02      	add	r5, sp, #8
 80a637a:	f845 3d08 	str.w	r3, [r5, #-8]!
 80a637e:	4621      	mov	r1, r4
 80a6380:	a801      	add	r0, sp, #4
 80a6382:	f7ff fbe4 	bl	80a5b4e <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
        auto d = static_cast<detail::FutureImplPtr<ResultT, ContextT>*>(data);
        const Promise<ResultT, ContextT> p(*d);
 80a6386:	4629      	mov	r1, r5
 80a6388:	4630      	mov	r0, r6
 80a638a:	f7ff ffde 	bl	80a634a <_ZN8particle6FutureIbNS_6detail13FutureContextEEC1ESt10shared_ptrINS1_10FutureImplIbS2_EEE>
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
 80a638e:	a801      	add	r0, sp, #4
 80a6390:	f7fb f9c1 	bl	80a1716 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
 80a6394:	4620      	mov	r0, r4
 80a6396:	f7fb f9be 	bl	80a1716 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
        delete d;
 80a639a:	4638      	mov	r0, r7
 80a639c:	f7f9 fe81 	bl	80a00a2 <_ZdlPv>
        return p;
    }
 80a63a0:	4630      	mov	r0, r6
 80a63a2:	b003      	add	sp, #12
 80a63a4:	bdf0      	pop	{r4, r5, r6, r7, pc}

080a63a6 <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_>:
  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 80a63a6:	6882      	ldr	r2, [r0, #8]
	  }
      }

  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
 80a63a8:	b510      	push	{r4, lr}
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 80a63aa:	b90a      	cbnz	r2, 80a63b0 <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_+0xa>
	__throw_bad_function_call();
 80a63ac:	f000 fcff 	bl	80a6dae <_ZSt25__throw_bad_function_callv>
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a63b0:	68c3      	ldr	r3, [r0, #12]
    }
 80a63b2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
	__throw_bad_function_call();
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a63b6:	4718      	bx	r3

080a63b8 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE9_M_invokeERKSt9_Any_data>:
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
 80a63b8:	b508      	push	{r3, lr}
	static _Functor*
	_M_get_pointer(const _Any_data& __source)
	{
	  const _Functor* __ptr =
	    __stored_locally? std::__addressof(__source._M_access<_Functor>())
	    /* have stored a pointer */ : __source._M_access<_Functor*>();
 80a63ba:	6800      	ldr	r0, [r0, #0]
      template<typename _Result, typename... _Args, std::size_t... _Indexes>
	_Result
	__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
	{
	  return _M_f(_Mu<_Bound_args>()
		      (std::get<_Indexes>(_M_bound_args), __args)...);
 80a63bc:	f100 0110 	add.w	r1, r0, #16
 80a63c0:	f7ff fff1 	bl	80a63a6 <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_>
 80a63c4:	bd08      	pop	{r3, pc}

080a63c6 <_ZNKSt8functionIFvRKbEEclES1_>:
  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 80a63c6:	6882      	ldr	r2, [r0, #8]
	  }
      }

  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
 80a63c8:	b510      	push	{r4, lr}
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 80a63ca:	b90a      	cbnz	r2, 80a63d0 <_ZNKSt8functionIFvRKbEEclES1_+0xa>
	__throw_bad_function_call();
 80a63cc:	f000 fcef 	bl	80a6dae <_ZSt25__throw_bad_function_callv>
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a63d0:	68c3      	ldr	r3, [r0, #12]
    }
 80a63d2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
	__throw_bad_function_call();
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a63d6:	4718      	bx	r3

080a63d8 <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKbEEbEEE9_M_invokeERKSt9_Any_data>:
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
 80a63d8:	b508      	push	{r3, lr}
	static _Functor*
	_M_get_pointer(const _Any_data& __source)
	{
	  const _Functor* __ptr =
	    __stored_locally? std::__addressof(__source._M_access<_Functor>())
	    /* have stored a pointer */ : __source._M_access<_Functor*>();
 80a63da:	6800      	ldr	r0, [r0, #0]
      template<typename _Result, typename... _Args, std::size_t... _Indexes>
	_Result
	__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
	{
	  return _M_f(_Mu<_Bound_args>()
		      (std::get<_Indexes>(_M_bound_args), __args)...);
 80a63dc:	f100 0110 	add.w	r1, r0, #16
 80a63e0:	f7ff fff1 	bl	80a63c6 <_ZNKSt8functionIFvRKbEEclES1_>
 80a63e4:	bd08      	pop	{r3, pc}

080a63e6 <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_>:
      _Invoker_type _M_invoker;
  };

  // Out-of-line member definitions.
  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
 80a63e6:	b538      	push	{r3, r4, r5, lr}
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a63e8:	2300      	movs	r3, #0
 80a63ea:	6083      	str	r3, [r0, #8]
 80a63ec:	688b      	ldr	r3, [r1, #8]
      _Invoker_type _M_invoker;
  };

  // Out-of-line member definitions.
  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
 80a63ee:	4604      	mov	r4, r0
 80a63f0:	460d      	mov	r5, r1
    function(const function& __x)
    : _Function_base()
    {
      if (static_cast<bool>(__x))
 80a63f2:	b12b      	cbz	r3, 80a6400 <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_+0x1a>
	{
	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
 80a63f4:	2202      	movs	r2, #2
 80a63f6:	4798      	blx	r3
	  _M_invoker = __x._M_invoker;
 80a63f8:	68eb      	ldr	r3, [r5, #12]
 80a63fa:	60e3      	str	r3, [r4, #12]
	  _M_manager = __x._M_manager;
 80a63fc:	68ab      	ldr	r3, [r5, #8]
 80a63fe:	60a3      	str	r3, [r4, #8]
	}
    }
 80a6400:	4620      	mov	r0, r4
 80a6402:	bd38      	pop	{r3, r4, r5, pc}

080a6404 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE>:

    explicit PromiseBase(detail::FutureImplPtr<ResultT, ContextT> ptr) :
            p_(std::move(ptr)) {
    }

    void setError(Error error) {
 80a6404:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
      __b = _GLIBCXX_MOVE(__tmp);
 80a6408:	f64f 739c 	movw	r3, #65436	; 0xff9c
 80a640c:	6804      	ldr	r4, [r0, #0]

      bool
      compare_exchange_strong(_Tp& __e, _Tp __i, memory_order __s, 
			      memory_order __f) noexcept
      {
	return __atomic_compare_exchange(&_M_i, &__e, &__i, false, __s, __f);
 80a640e:	f04f 0002 	mov.w	r0, #2
 80a6412:	b086      	sub	sp, #24
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
 80a6414:	f9b1 2004 	ldrsh.w	r2, [r1, #4]
      __b = _GLIBCXX_MOVE(__tmp);
 80a6418:	808b      	strh	r3, [r1, #4]
 80a641a:	2300      	movs	r3, #0
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
 80a641c:	680f      	ldr	r7, [r1, #0]
            onSuccess_(nullptr),
            onError_(nullptr) {
    }

    bool changeState(State state) {
        State s = State::RUNNING; // Expected state
 80a641e:	f88d 3000 	strb.w	r3, [sp]
      __b = _GLIBCXX_MOVE(__tmp);
 80a6422:	600b      	str	r3, [r1, #0]
 80a6424:	e8d4 1f4f 	ldrexb	r1, [r4]
 80a6428:	4299      	cmp	r1, r3
 80a642a:	d103      	bne.n	80a6434 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x30>
 80a642c:	e8c4 0f45 	strexb	r5, r0, [r4]
 80a6430:	2d00      	cmp	r5, #0
 80a6432:	d1f7      	bne.n	80a6424 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x20>
 80a6434:	d002      	beq.n	80a643c <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x38>
 80a6436:	f88d 1000 	strb.w	r1, [sp]
 80a643a:	e06b      	b.n	80a6514 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x110>
        return std::move(defaultValue);
    }

    void setError(Error error) {
        if (this->changeState(State::FAILED)) {
            new(&error_) Error(std::move(error));
 80a643c:	f114 050c 	adds.w	r5, r4, #12
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
 80a6440:	bf1c      	itt	ne
 80a6442:	60e7      	strne	r7, [r4, #12]
 80a6444:	8222      	strhne	r2, [r4, #16]
        memory_order __b = __m & __memory_order_mask;
	__glibcxx_assert(__b != memory_order_acquire);
	__glibcxx_assert(__b != memory_order_acq_rel);
	__glibcxx_assert(__b != memory_order_consume);

	__atomic_store_n(&_M_i, __i, __m);
 80a6446:	f3bf 8f5f 	dmb	sy
      __b = _GLIBCXX_MOVE(__tmp);
 80a644a:	bf18      	it	ne
 80a644c:	461f      	movne	r7, r3
 80a644e:	2301      	movs	r3, #1
 80a6450:	7063      	strb	r3, [r4, #1]

      _GLIBCXX_ALWAYS_INLINE __pointer_type
      exchange(__pointer_type __p,
	       memory_order __m = memory_order_seq_cst) noexcept
      {
	return __atomic_exchange_n(&_M_p, __p, __m);
 80a6452:	f3bf 8f5f 	dmb	sy
 80a6456:	f104 0308 	add.w	r3, r4, #8
 80a645a:	2000      	movs	r0, #0
 80a645c:	e853 6f00 	ldrex	r6, [r3]
 80a6460:	e843 0200 	strex	r2, r0, [r3]
 80a6464:	2a00      	cmp	r2, #0
 80a6466:	d1f9      	bne.n	80a645c <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x58>
 80a6468:	f3bf 8f5f 	dmb	sy

    // Takes a callback from its atomic wrapper and invokes it
    template<typename FunctionT, typename... ArgsT>
    static void invokeCallback(std::atomic<std::function<FunctionT>*>& wrapper, ArgsT&&... args) {
        std::function<FunctionT>* callbackPtr = wrapper.exchange(nullptr, std::memory_order_acq_rel);
        if (callbackPtr) {
 80a646c:	2e00      	cmp	r6, #0
 80a646e:	d051      	beq.n	80a6514 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x110>
        return (application_thread_invoke(callback, data, nullptr) == 0);
    }

    // Returns true if current thread is the application thread
    static bool isApplicationThreadCurrent() {
        return (application_thread_current(nullptr) != 0);
 80a6470:	f7fe ffbc 	bl	80a53ec <application_thread_current>
    }

    // Invokes std::function in the application context
    template<typename FunctionT, typename... ArgsT>
    static void invokeCallback(const std::function<FunctionT>& callback, ArgsT&&... args) {
        if (ContextT::isApplicationThreadCurrent()) {
 80a6474:	b120      	cbz	r0, 80a6480 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x7c>
            callback(std::forward<ArgsT>(args)...); // Synchronous call
 80a6476:	4629      	mov	r1, r5
 80a6478:	4630      	mov	r0, r6
 80a647a:	f7ff ff94 	bl	80a63a6 <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_>
 80a647e:	e043      	b.n	80a6508 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x104>
	}

     public:
      template<typename... _Args>
	explicit _Bind(const _Functor& __f, _Args&&... __args)
	: _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 80a6480:	4631      	mov	r1, r6
 80a6482:	4668      	mov	r0, sp
 80a6484:	f7ff ffaf 	bl	80a63e6 <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_>
inline particle::Error::Error(const char* msg) :
        Error(UNKNOWN, msg) {
}

inline particle::Error::Error(const Error& error) :
        Error(error.type_, error.msg_) {
 80a6488:	68e0      	ldr	r0, [r4, #12]
 80a648a:	f9b4 5010 	ldrsh.w	r5, [r4, #16]
        type_(type) {
}

inline particle::Error::Error(Type type, const char* msg) :
        msg_(msg ? (const char*)strdup(msg) : nullptr),
        type_(type) {
 80a648e:	b108      	cbz	r0, 80a6494 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x90>
 80a6490:	f001 fa70 	bl	80a7974 <strdup>
 80a6494:	9004      	str	r0, [sp, #16]
        } else {
            // Bind all arguments and wrap resulting function into a pointer
            auto callbackPtr = new std::function<void()>(std::bind(callback, std::forward<ArgsT>(args)...));
 80a6496:	2010      	movs	r0, #16
 80a6498:	f8ad 5014 	strh.w	r5, [sp, #20]
 80a649c:	f7f9 fdfd 	bl	80a009a <_Znwj>
 80a64a0:	4605      	mov	r5, r0
 80a64a2:	b330      	cbz	r0, 80a64f2 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xee>
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a64a4:	f04f 0800 	mov.w	r8, #0
 80a64a8:	f8c0 8008 	str.w	r8, [r0, #8]
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }

	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
 80a64ac:	2018      	movs	r0, #24
 80a64ae:	f7f9 fdf4 	bl	80a009a <_Znwj>
 80a64b2:	4604      	mov	r4, r0
 80a64b4:	b1c0      	cbz	r0, 80a64e8 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xe4>
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a64b6:	f8c0 8008 	str.w	r8, [r0, #8]
       *  Swap the targets of @c this function object and @a __f. This
       *  function will not throw an %exception.
       */
      void swap(function& __x)
      {
	std::swap(_M_functor, __x._M_functor);
 80a64ba:	4601      	mov	r1, r0
 80a64bc:	4668      	mov	r0, sp
 80a64be:	f7ff fe5c 	bl	80a617a <_ZSt4swapISt9_Any_dataEvRT_S2_>
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a64c2:	9b02      	ldr	r3, [sp, #8]
      __a = _GLIBCXX_MOVE(__b);
 80a64c4:	68a2      	ldr	r2, [r4, #8]
      __b = _GLIBCXX_MOVE(__tmp);
 80a64c6:	60a3      	str	r3, [r4, #8]
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a64c8:	9b03      	ldr	r3, [sp, #12]
      __a = _GLIBCXX_MOVE(__b);
 80a64ca:	9202      	str	r2, [sp, #8]
 80a64cc:	68e2      	ldr	r2, [r4, #12]
      __b = _GLIBCXX_MOVE(__tmp);
 80a64ce:	60e3      	str	r3, [r4, #12]
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
 80a64d0:	f8bd 3014 	ldrh.w	r3, [sp, #20]
 80a64d4:	9203      	str	r2, [sp, #12]
 80a64d6:	82a3      	strh	r3, [r4, #20]
      __b = _GLIBCXX_MOVE(__tmp);
 80a64d8:	f64f 739c 	movw	r3, #65436	; 0xff9c
 80a64dc:	f8ad 3014 	strh.w	r3, [sp, #20]
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
 80a64e0:	9b04      	ldr	r3, [sp, #16]
      __b = _GLIBCXX_MOVE(__tmp);
 80a64e2:	f8cd 8010 	str.w	r8, [sp, #16]
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
 80a64e6:	6123      	str	r3, [r4, #16]
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
 80a64e8:	4b0d      	ldr	r3, [pc, #52]	; (80a6520 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x11c>)
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }

	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
 80a64ea:	602c      	str	r4, [r5, #0]
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
 80a64ec:	60eb      	str	r3, [r5, #12]
	    _M_manager = &_My_handler::_M_manager;
 80a64ee:	4b0d      	ldr	r3, [pc, #52]	; (80a6524 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x120>)
 80a64f0:	60ab      	str	r3, [r5, #8]
        Error() {
    swap(*this, error);
}

inline particle::Error::~Error() {
    free((void*)msg_);
 80a64f2:	9804      	ldr	r0, [sp, #16]
 80a64f4:	f7ff f80e 	bl	80a5514 <free>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a64f8:	4668      	mov	r0, sp
 80a64fa:	f7fa fab7 	bl	80a0a6c <_ZNSt14_Function_baseD1Ev>
        spark_process();
    }

    // Asynchronously invokes a callback in the application context
    static bool invokeApplicationCallback(void (*callback)(void* data), void* data) {
        return (application_thread_invoke(callback, data, nullptr) == 0);
 80a64fe:	2200      	movs	r2, #0
 80a6500:	4629      	mov	r1, r5
 80a6502:	4809      	ldr	r0, [pc, #36]	; (80a6528 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x124>)
 80a6504:	f7fe ff7a 	bl	80a53fc <application_thread_invoke>
 80a6508:	4630      	mov	r0, r6
 80a650a:	f7fa faaf 	bl	80a0a6c <_ZNSt14_Function_baseD1Ev>
    template<typename FunctionT, typename... ArgsT>
    static void invokeCallback(std::atomic<std::function<FunctionT>*>& wrapper, ArgsT&&... args) {
        std::function<FunctionT>* callbackPtr = wrapper.exchange(nullptr, std::memory_order_acq_rel);
        if (callbackPtr) {
            invokeCallback(*callbackPtr, std::forward<ArgsT>(args)...);
            delete callbackPtr;
 80a650e:	4630      	mov	r0, r6
 80a6510:	f7f9 fdc7 	bl	80a00a2 <_ZdlPv>
 80a6514:	4638      	mov	r0, r7
 80a6516:	f7fe fffd 	bl	80a5514 <free>
            p_(std::move(ptr)) {
    }

    void setError(Error error) {
        p_->setError(std::move(error));
    }
 80a651a:	b006      	add	sp, #24
 80a651c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a6520:	080a63b9 	.word	0x080a63b9
 80a6524:	080a6615 	.word	0x080a6615
 80a6528:	080a6b15 	.word	0x080a6b15

080a652c <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE>:
    desc.data = (void*)data;
    desc.funcKey = funcKey;
    return spark_function(NULL, (user_function_int_str_t*)&desc, NULL);
}

Future<bool> CloudClass::publish_event(const char *eventName, const char *eventData, int ttl, PublishFlags flags) {
 80a652c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a6530:	b08b      	sub	sp, #44	; 0x2c
#ifndef SPARK_NO_CLOUD
    spark_send_event_data d = { sizeof(spark_send_event_data) };
 80a6532:	ad07      	add	r5, sp, #28
 80a6534:	f04f 0b00 	mov.w	fp, #0
    desc.data = (void*)data;
    desc.funcKey = funcKey;
    return spark_function(NULL, (user_function_int_str_t*)&desc, NULL);
}

Future<bool> CloudClass::publish_event(const char *eventName, const char *eventData, int ttl, PublishFlags flags) {
 80a6538:	4606      	mov	r6, r0
 80a653a:	4699      	mov	r9, r3
// can be acquired via Future
template<typename ResultT, typename ContextT>
class PromiseBase {
public:
    PromiseBase() :
            p_(new detail::FutureImpl<ResultT, ContextT>(State::RUNNING)) {
 80a653c:	2014      	movs	r0, #20
#ifndef SPARK_NO_CLOUD
    spark_send_event_data d = { sizeof(spark_send_event_data) };
 80a653e:	230c      	movs	r3, #12
    desc.data = (void*)data;
    desc.funcKey = funcKey;
    return spark_function(NULL, (user_function_int_str_t*)&desc, NULL);
}

Future<bool> CloudClass::publish_event(const char *eventName, const char *eventData, int ttl, PublishFlags flags) {
 80a6540:	460f      	mov	r7, r1
 80a6542:	4690      	mov	r8, r2
 80a6544:	f89d a050 	ldrb.w	sl, [sp, #80]	; 0x50
#ifndef SPARK_NO_CLOUD
    spark_send_event_data d = { sizeof(spark_send_event_data) };
 80a6548:	f8c5 b004 	str.w	fp, [r5, #4]
 80a654c:	f8c5 b008 	str.w	fp, [r5, #8]
 80a6550:	9307      	str	r3, [sp, #28]
 80a6552:	f7f9 fda2 	bl	80a009a <_Znwj>
 80a6556:	4604      	mov	r4, r0
 80a6558:	b138      	cbz	r0, 80a656a <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x3e>
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(_Tp __i) noexcept : _M_i(__i) { }
 80a655a:	f880 b000 	strb.w	fp, [r0]
      __atomic_base(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) volatile = delete;

      // Requires __int_type convertible to _M_i.
      constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }
 80a655e:	f880 b001 	strb.w	fp, [r0, #1]
      __atomic_base(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) volatile = delete;

      // Requires __pointer_type convertible to _M_p.
      constexpr __atomic_base(__pointer_type __p) noexcept : _M_p (__p) { }
 80a6562:	f8c0 b004 	str.w	fp, [r0, #4]
 80a6566:	f8c0 b008 	str.w	fp, [r0, #8]
      constexpr __shared_count() noexcept : _M_pi(0)
      { }

      template<typename _Ptr>
        explicit
	__shared_count(_Ptr __p) : _M_pi(0)
 80a656a:	2300      	movs	r3, #0
	{
	  __try
	    {
	      _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
 80a656c:	2010      	movs	r0, #16
      : _M_ptr(0), _M_refcount()
      { }

      template<typename _Tp1>
	explicit __shared_ptr(_Tp1* __p)
        : _M_ptr(__p), _M_refcount(__p)
 80a656e:	9403      	str	r4, [sp, #12]
      constexpr __shared_count() noexcept : _M_pi(0)
      { }

      template<typename _Ptr>
        explicit
	__shared_count(_Ptr __p) : _M_pi(0)
 80a6570:	9304      	str	r3, [sp, #16]
	{
	  __try
	    {
	      _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
 80a6572:	f7f9 fd92 	bl	80a009a <_Znwj>
 80a6576:	b128      	cbz	r0, 80a6584 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x58>
    class _Sp_counted_base
    : public _Mutex_base<_Lp>
    {
    public:  
      _Sp_counted_base() noexcept
      : _M_use_count(1), _M_weak_count(1) { }
 80a6578:	2301      	movs	r3, #1
 80a657a:	6043      	str	r3, [r0, #4]
 80a657c:	6083      	str	r3, [r0, #8]
    class _Sp_counted_ptr final : public _Sp_counted_base<_Lp>
    {
    public:
      explicit
      _Sp_counted_ptr(_Ptr __p) noexcept
      : _M_ptr(__p) { }
 80a657e:	4b23      	ldr	r3, [pc, #140]	; (80a660c <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0xe0>)
 80a6580:	60c4      	str	r4, [r0, #12]
 80a6582:	6003      	str	r3, [r0, #0]

    // Completion handler
    Promise<bool> p;
    d.handler_callback = publishCompletionCallback;
 80a6584:	4b22      	ldr	r3, [pc, #136]	; (80a6610 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0xe4>)
        explicit
	__shared_count(_Ptr __p) : _M_pi(0)
	{
	  __try
	    {
	      _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
 80a6586:	9004      	str	r0, [sp, #16]
    }

    // Wraps this promise into an object pointer that can be passed to a C function
    void* dataPtr() const {
        // TODO: Use custom reference counting object to avoid unnecessary memory allocation
        return new detail::FutureImplPtr<ResultT, ContextT>(p_);
 80a6588:	2008      	movs	r0, #8
 80a658a:	9308      	str	r3, [sp, #32]
 80a658c:	f7f9 fd85 	bl	80a009a <_Znwj>
 80a6590:	4604      	mov	r4, r0
 80a6592:	b128      	cbz	r0, 80a65a0 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x74>
      template<typename _Tp1>
	__shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, _Tp* __p) noexcept
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
 80a6594:	9b03      	ldr	r3, [sp, #12]
 80a6596:	a904      	add	r1, sp, #16
 80a6598:	f840 3b04 	str.w	r3, [r0], #4
 80a659c:	f7ff fad7 	bl	80a5b4e <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
    d.handler_data = p.dataPtr();

    if (!spark_send_event(eventName, eventData, ttl, flags.value(), &d) && !p.isDone()) {
 80a65a0:	9500      	str	r5, [sp, #0]
 80a65a2:	fa5f f38a 	uxtb.w	r3, sl
 80a65a6:	464a      	mov	r2, r9
 80a65a8:	4641      	mov	r1, r8
 80a65aa:	4638      	mov	r0, r7
    spark_send_event_data d = { sizeof(spark_send_event_data) };

    // Completion handler
    Promise<bool> p;
    d.handler_callback = publishCompletionCallback;
    d.handler_data = p.dataPtr();
 80a65ac:	9409      	str	r4, [sp, #36]	; 0x24

    if (!spark_send_event(eventName, eventData, ttl, flags.value(), &d) && !p.isDone()) {
 80a65ae:	f7fe ff89 	bl	80a54c4 <spark_send_event>
 80a65b2:	b9b8      	cbnz	r0, 80a65e4 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0xb8>
      {
       memory_order __b = __m & __memory_order_mask;
	__glibcxx_assert(__b != memory_order_release);
	__glibcxx_assert(__b != memory_order_acq_rel);

	return __atomic_load_n(&_M_i, __m);
 80a65b4:	9b03      	ldr	r3, [sp, #12]
 80a65b6:	785b      	ldrb	r3, [r3, #1]
 80a65b8:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80a65bc:	b993      	cbnz	r3, 80a65e4 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0xb8>

} // namespace particle

inline particle::Error::Error(Type type) :
        msg_(nullptr),
        type_(type) {
 80a65be:	f64f 739c 	movw	r3, #65436	; 0xff9c
        // Set generic error code in case completion callback wasn't invoked for some reason
        p.setError(Error::UNKNOWN);
 80a65c2:	a905      	add	r1, sp, #20
 80a65c4:	a803      	add	r0, sp, #12
 80a65c6:	9205      	str	r2, [sp, #20]
 80a65c8:	f8ad 3018 	strh.w	r3, [sp, #24]
 80a65cc:	f7ff ff1a 	bl	80a6404 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE>
        Error() {
    swap(*this, error);
}

inline particle::Error::~Error() {
    free((void*)msg_);
 80a65d0:	9805      	ldr	r0, [sp, #20]
 80a65d2:	f7fe ff9f 	bl	80a5514 <free>
        p.fromDataPtr(d.handler_data); // Free wrapper object
 80a65d6:	a805      	add	r0, sp, #20
 80a65d8:	9909      	ldr	r1, [sp, #36]	; 0x24
 80a65da:	f7ff fec7 	bl	80a636c <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE11fromDataPtrEPv>
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
 80a65de:	a806      	add	r0, sp, #24
 80a65e0:	f7fb f899 	bl	80a1716 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
      template<typename _Tp1>
	__shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, _Tp* __p) noexcept
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
 80a65e4:	9b03      	ldr	r3, [sp, #12]
 80a65e6:	a904      	add	r1, sp, #16
 80a65e8:	a806      	add	r0, sp, #24
 80a65ea:	9305      	str	r3, [sp, #20]
 80a65ec:	f7ff faaf 	bl	80a5b4e <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
    bool isDone() const {
        return p_->isDone();
    }

    Future<ResultT, ContextT> future() const {
        return Future<ResultT, ContextT>(p_);
 80a65f0:	a905      	add	r1, sp, #20
 80a65f2:	4630      	mov	r0, r6
 80a65f4:	f7ff fea9 	bl	80a634a <_ZN8particle6FutureIbNS_6detail13FutureContextEEC1ESt10shared_ptrINS1_10FutureImplIbS2_EEE>
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
 80a65f8:	a806      	add	r0, sp, #24
 80a65fa:	f7fb f88c 	bl	80a1716 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
 80a65fe:	a804      	add	r0, sp, #16
 80a6600:	f7fb f889 	bl	80a1716 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>

    return p.future();
#else
    return Future<bool>(Error::NOT_SUPPORTED);
#endif
}
 80a6604:	4630      	mov	r0, r6
 80a6606:	b00b      	add	sp, #44	; 0x2c
 80a6608:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a660c:	080a9458 	.word	0x080a9458
 80a6610:	080a677d 	.word	0x080a677d

080a6614 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation>:
      public:
	static bool
	_M_manager(_Any_data& __dest, const _Any_data& __source,
		   _Manager_operation __op)
	{
	  switch (__op)
 80a6614:	2a02      	cmp	r2, #2
	  delete __victim._M_access<_Functor*>();
	}

      public:
	static bool
	_M_manager(_Any_data& __dest, const _Any_data& __source,
 80a6616:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a6618:	4604      	mov	r4, r0
		   _Manager_operation __op)
	{
	  switch (__op)
 80a661a:	d006      	beq.n	80a662a <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x16>
 80a661c:	2a03      	cmp	r2, #3
 80a661e:	d017      	beq.n	80a6650 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x3c>
 80a6620:	2a01      	cmp	r2, #1
 80a6622:	d120      	bne.n	80a6666 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x52>
	static _Functor*
	_M_get_pointer(const _Any_data& __source)
	{
	  const _Functor* __ptr =
	    __stored_locally? std::__addressof(__source._M_access<_Functor>())
	    /* have stored a pointer */ : __source._M_access<_Functor*>();
 80a6624:	680b      	ldr	r3, [r1, #0]
	    case __get_type_info:
	      __dest._M_access<const type_info*>() = &typeid(_Functor);
	      break;
#endif
	    case __get_functor_ptr:
	      __dest._M_access<_Functor*>() = _M_get_pointer(__source);
 80a6626:	6003      	str	r3, [r0, #0]
	      break;
 80a6628:	e01d      	b.n	80a6666 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x52>
	// Clone a function object that is not location-invariant or
	// that cannot fit into an _Any_data structure.
	static void
	_M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
	{
	  __dest._M_access<_Functor*>() =
 80a662a:	2018      	movs	r0, #24
 80a662c:	680e      	ldr	r6, [r1, #0]
 80a662e:	f7f9 fd34 	bl	80a009a <_Znwj>
 80a6632:	4605      	mov	r5, r0
 80a6634:	b150      	cbz	r0, 80a664c <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x38>
      template<typename... _Args>
	explicit _Bind(_Functor&& __f, _Args&&... __args)
	: _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
	{ }

      _Bind(const _Bind&) = default;
 80a6636:	4631      	mov	r1, r6
 80a6638:	f7ff fed5 	bl	80a63e6 <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_>
inline particle::Error::Error(const char* msg) :
        Error(UNKNOWN, msg) {
}

inline particle::Error::Error(const Error& error) :
        Error(error.type_, error.msg_) {
 80a663c:	6930      	ldr	r0, [r6, #16]
 80a663e:	f9b6 7014 	ldrsh.w	r7, [r6, #20]
        type_(type) {
}

inline particle::Error::Error(Type type, const char* msg) :
        msg_(msg ? (const char*)strdup(msg) : nullptr),
        type_(type) {
 80a6642:	b108      	cbz	r0, 80a6648 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x34>
 80a6644:	f001 f996 	bl	80a7974 <strdup>
 80a6648:	6128      	str	r0, [r5, #16]
 80a664a:	82af      	strh	r7, [r5, #20]
	// Clone a function object that is not location-invariant or
	// that cannot fit into an _Any_data structure.
	static void
	_M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
	{
	  __dest._M_access<_Functor*>() =
 80a664c:	6025      	str	r5, [r4, #0]
 80a664e:	e00a      	b.n	80a6666 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x52>

	// Destroying an object located on the heap.
	static void
	_M_destroy(_Any_data& __victim, false_type)
	{
	  delete __victim._M_access<_Functor*>();
 80a6650:	6804      	ldr	r4, [r0, #0]
 80a6652:	b144      	cbz	r4, 80a6666 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x52>
        Error() {
    swap(*this, error);
}

inline particle::Error::~Error() {
    free((void*)msg_);
 80a6654:	6920      	ldr	r0, [r4, #16]
 80a6656:	f7fe ff5d 	bl	80a5514 <free>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a665a:	4620      	mov	r0, r4
 80a665c:	f7fa fa06 	bl	80a0a6c <_ZNSt14_Function_baseD1Ev>

	// Destroying an object located on the heap.
	static void
	_M_destroy(_Any_data& __victim, false_type)
	{
	  delete __victim._M_access<_Functor*>();
 80a6660:	4620      	mov	r0, r4
 80a6662:	f7f9 fd1e 	bl	80a00a2 <_ZdlPv>
	    case __destroy_functor:
	      _M_destroy(__dest, _Local_storage());
	      break;
	    }
	  return false;
	}
 80a6666:	2000      	movs	r0, #0
 80a6668:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a666a <_ZNSt8functionIFvRKbEEC1ERKS3_>:
      _Invoker_type _M_invoker;
  };

  // Out-of-line member definitions.
  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
 80a666a:	b538      	push	{r3, r4, r5, lr}
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a666c:	2300      	movs	r3, #0
 80a666e:	6083      	str	r3, [r0, #8]
 80a6670:	688b      	ldr	r3, [r1, #8]
      _Invoker_type _M_invoker;
  };

  // Out-of-line member definitions.
  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
 80a6672:	4604      	mov	r4, r0
 80a6674:	460d      	mov	r5, r1
    function(const function& __x)
    : _Function_base()
    {
      if (static_cast<bool>(__x))
 80a6676:	b12b      	cbz	r3, 80a6684 <_ZNSt8functionIFvRKbEEC1ERKS3_+0x1a>
	{
	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
 80a6678:	2202      	movs	r2, #2
 80a667a:	4798      	blx	r3
	  _M_invoker = __x._M_invoker;
 80a667c:	68eb      	ldr	r3, [r5, #12]
 80a667e:	60e3      	str	r3, [r4, #12]
	  _M_manager = __x._M_manager;
 80a6680:	68ab      	ldr	r3, [r5, #8]
 80a6682:	60a3      	str	r3, [r4, #8]
	}
    }
 80a6684:	4620      	mov	r0, r4
 80a6686:	bd38      	pop	{r3, r4, r5, pc}

080a6688 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation>:
      public:
	static bool
	_M_manager(_Any_data& __dest, const _Any_data& __source,
		   _Manager_operation __op)
	{
	  switch (__op)
 80a6688:	2a02      	cmp	r2, #2
	  delete __victim._M_access<_Functor*>();
	}

      public:
	static bool
	_M_manager(_Any_data& __dest, const _Any_data& __source,
 80a668a:	b570      	push	{r4, r5, r6, lr}
 80a668c:	4604      	mov	r4, r0
		   _Manager_operation __op)
	{
	  switch (__op)
 80a668e:	d006      	beq.n	80a669e <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x16>
 80a6690:	2a03      	cmp	r2, #3
 80a6692:	d011      	beq.n	80a66b8 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x30>
 80a6694:	2a01      	cmp	r2, #1
 80a6696:	d117      	bne.n	80a66c8 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x40>
	static _Functor*
	_M_get_pointer(const _Any_data& __source)
	{
	  const _Functor* __ptr =
	    __stored_locally? std::__addressof(__source._M_access<_Functor>())
	    /* have stored a pointer */ : __source._M_access<_Functor*>();
 80a6698:	680b      	ldr	r3, [r1, #0]
	    case __get_type_info:
	      __dest._M_access<const type_info*>() = &typeid(_Functor);
	      break;
#endif
	    case __get_functor_ptr:
	      __dest._M_access<_Functor*>() = _M_get_pointer(__source);
 80a669a:	6003      	str	r3, [r0, #0]
	      break;
 80a669c:	e014      	b.n	80a66c8 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x40>
	// Clone a function object that is not location-invariant or
	// that cannot fit into an _Any_data structure.
	static void
	_M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
	{
	  __dest._M_access<_Functor*>() =
 80a669e:	2014      	movs	r0, #20
 80a66a0:	680e      	ldr	r6, [r1, #0]
 80a66a2:	f7f9 fcfa 	bl	80a009a <_Znwj>
 80a66a6:	4605      	mov	r5, r0
 80a66a8:	b120      	cbz	r0, 80a66b4 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x2c>
      template<typename... _Args>
	explicit _Bind(_Functor&& __f, _Args&&... __args)
	: _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
	{ }

      _Bind(const _Bind&) = default;
 80a66aa:	4631      	mov	r1, r6
 80a66ac:	f7ff ffdd 	bl	80a666a <_ZNSt8functionIFvRKbEEC1ERKS3_>
 80a66b0:	7c33      	ldrb	r3, [r6, #16]
 80a66b2:	742b      	strb	r3, [r5, #16]
	// Clone a function object that is not location-invariant or
	// that cannot fit into an _Any_data structure.
	static void
	_M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
	{
	  __dest._M_access<_Functor*>() =
 80a66b4:	6025      	str	r5, [r4, #0]
 80a66b6:	e007      	b.n	80a66c8 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x40>

	// Destroying an object located on the heap.
	static void
	_M_destroy(_Any_data& __victim, false_type)
	{
	  delete __victim._M_access<_Functor*>();
 80a66b8:	6804      	ldr	r4, [r0, #0]
 80a66ba:	b12c      	cbz	r4, 80a66c8 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x40>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a66bc:	4620      	mov	r0, r4
 80a66be:	f7fa f9d5 	bl	80a0a6c <_ZNSt14_Function_baseD1Ev>

	// Destroying an object located on the heap.
	static void
	_M_destroy(_Any_data& __victim, false_type)
	{
	  delete __victim._M_access<_Functor*>();
 80a66c2:	4620      	mov	r0, r4
 80a66c4:	f7f9 fced 	bl	80a00a2 <_ZdlPv>
	    case __destroy_functor:
	      _M_destroy(__dest, _Local_storage());
	      break;
	    }
	  return false;
	}
 80a66c8:	2000      	movs	r0, #0
 80a66ca:	bd70      	pop	{r4, r5, r6, pc}

080a66cc <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_>:
        delete callbackPtr; // Delete old callback
    }

    // Takes a callback from its atomic wrapper and invokes it
    template<typename FunctionT, typename... ArgsT>
    static void invokeCallback(std::atomic<std::function<FunctionT>*>& wrapper, ArgsT&&... args) {
 80a66cc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a66ce:	460c      	mov	r4, r1

      _GLIBCXX_ALWAYS_INLINE __pointer_type
      exchange(__pointer_type __p,
	       memory_order __m = memory_order_seq_cst) noexcept
      {
	return __atomic_exchange_n(&_M_p, __p, __m);
 80a66d0:	f3bf 8f5f 	dmb	sy
 80a66d4:	b087      	sub	sp, #28
 80a66d6:	2300      	movs	r3, #0
 80a66d8:	e850 6f00 	ldrex	r6, [r0]
 80a66dc:	e840 3200 	strex	r2, r3, [r0]
 80a66e0:	2a00      	cmp	r2, #0
 80a66e2:	d1f9      	bne.n	80a66d8 <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0xc>
 80a66e4:	f3bf 8f5f 	dmb	sy
        std::function<FunctionT>* callbackPtr = wrapper.exchange(nullptr, std::memory_order_acq_rel);
        if (callbackPtr) {
 80a66e8:	2e00      	cmp	r6, #0
 80a66ea:	d03e      	beq.n	80a676a <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0x9e>
        return (application_thread_invoke(callback, data, nullptr) == 0);
    }

    // Returns true if current thread is the application thread
    static bool isApplicationThreadCurrent() {
        return (application_thread_current(nullptr) != 0);
 80a66ec:	4618      	mov	r0, r3
 80a66ee:	f7fe fe7d 	bl	80a53ec <application_thread_current>
    }

    // Invokes std::function in the application context
    template<typename FunctionT, typename... ArgsT>
    static void invokeCallback(const std::function<FunctionT>& callback, ArgsT&&... args) {
        if (ContextT::isApplicationThreadCurrent()) {
 80a66f2:	4607      	mov	r7, r0
 80a66f4:	b120      	cbz	r0, 80a6700 <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0x34>
            callback(std::forward<ArgsT>(args)...); // Synchronous call
 80a66f6:	4621      	mov	r1, r4
 80a66f8:	4630      	mov	r0, r6
 80a66fa:	f7ff fe64 	bl	80a63c6 <_ZNKSt8functionIFvRKbEEclES1_>
 80a66fe:	e02e      	b.n	80a675e <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0x92>
	}

     public:
      template<typename... _Args>
	explicit _Bind(const _Functor& __f, _Args&&... __args)
	: _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 80a6700:	4631      	mov	r1, r6
 80a6702:	a801      	add	r0, sp, #4
 80a6704:	f7ff ffb1 	bl	80a666a <_ZNSt8functionIFvRKbEEC1ERKS3_>
      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
	: _M_head_impl(std::forward<_UHead>(__h)) { }
 80a6708:	7823      	ldrb	r3, [r4, #0]
        } else {
            // Bind all arguments and wrap resulting function into a pointer
            auto callbackPtr = new std::function<void()>(std::bind(callback, std::forward<ArgsT>(args)...));
 80a670a:	2010      	movs	r0, #16
 80a670c:	f88d 3014 	strb.w	r3, [sp, #20]
 80a6710:	f7f9 fcc3 	bl	80a009a <_Znwj>
 80a6714:	4605      	mov	r5, r0
 80a6716:	b1d0      	cbz	r0, 80a674e <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0x82>
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a6718:	6087      	str	r7, [r0, #8]
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }

	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
 80a671a:	2014      	movs	r0, #20
 80a671c:	f7f9 fcbd 	bl	80a009a <_Znwj>
 80a6720:	4604      	mov	r4, r0
 80a6722:	b178      	cbz	r0, 80a6744 <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0x78>
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a6724:	6087      	str	r7, [r0, #8]
       *  Swap the targets of @c this function object and @a __f. This
       *  function will not throw an %exception.
       */
      void swap(function& __x)
      {
	std::swap(_M_functor, __x._M_functor);
 80a6726:	4601      	mov	r1, r0
 80a6728:	a801      	add	r0, sp, #4
 80a672a:	f7ff fd26 	bl	80a617a <_ZSt4swapISt9_Any_dataEvRT_S2_>
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a672e:	9b03      	ldr	r3, [sp, #12]
      __a = _GLIBCXX_MOVE(__b);
 80a6730:	68a2      	ldr	r2, [r4, #8]
      __b = _GLIBCXX_MOVE(__tmp);
 80a6732:	60a3      	str	r3, [r4, #8]
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a6734:	9b04      	ldr	r3, [sp, #16]
      __a = _GLIBCXX_MOVE(__b);
 80a6736:	9203      	str	r2, [sp, #12]
 80a6738:	68e2      	ldr	r2, [r4, #12]
      __b = _GLIBCXX_MOVE(__tmp);
 80a673a:	60e3      	str	r3, [r4, #12]
 80a673c:	f89d 3014 	ldrb.w	r3, [sp, #20]
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
 80a6740:	9204      	str	r2, [sp, #16]
 80a6742:	7423      	strb	r3, [r4, #16]
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
 80a6744:	4b0a      	ldr	r3, [pc, #40]	; (80a6770 <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0xa4>)
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }

	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
 80a6746:	602c      	str	r4, [r5, #0]
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
 80a6748:	60eb      	str	r3, [r5, #12]
	    _M_manager = &_My_handler::_M_manager;
 80a674a:	4b0a      	ldr	r3, [pc, #40]	; (80a6774 <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0xa8>)
 80a674c:	60ab      	str	r3, [r5, #8]
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a674e:	a801      	add	r0, sp, #4
 80a6750:	f7fa f98c 	bl	80a0a6c <_ZNSt14_Function_baseD1Ev>
        spark_process();
    }

    // Asynchronously invokes a callback in the application context
    static bool invokeApplicationCallback(void (*callback)(void* data), void* data) {
        return (application_thread_invoke(callback, data, nullptr) == 0);
 80a6754:	2200      	movs	r2, #0
 80a6756:	4629      	mov	r1, r5
 80a6758:	4807      	ldr	r0, [pc, #28]	; (80a6778 <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0xac>)
 80a675a:	f7fe fe4f 	bl	80a53fc <application_thread_invoke>
 80a675e:	4630      	mov	r0, r6
 80a6760:	f7fa f984 	bl	80a0a6c <_ZNSt14_Function_baseD1Ev>
    template<typename FunctionT, typename... ArgsT>
    static void invokeCallback(std::atomic<std::function<FunctionT>*>& wrapper, ArgsT&&... args) {
        std::function<FunctionT>* callbackPtr = wrapper.exchange(nullptr, std::memory_order_acq_rel);
        if (callbackPtr) {
            invokeCallback(*callbackPtr, std::forward<ArgsT>(args)...);
            delete callbackPtr;
 80a6764:	4630      	mov	r0, r6
 80a6766:	f7f9 fc9c 	bl	80a00a2 <_ZdlPv>
        }
    }
 80a676a:	b007      	add	sp, #28
 80a676c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a676e:	bf00      	nop
 80a6770:	080a63d9 	.word	0x080a63d9
 80a6774:	080a6689 	.word	0x080a6689
 80a6778:	080a6b15 	.word	0x080a6b15

080a677c <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_>:
namespace {

using namespace particle;

#ifndef SPARK_NO_CLOUD
void publishCompletionCallback(int error, const void* data, void* callbackData, void* reserved) {
 80a677c:	b530      	push	{r4, r5, lr}
 80a677e:	4604      	mov	r4, r0
 80a6780:	b085      	sub	sp, #20
 80a6782:	460d      	mov	r5, r1
    auto p = Promise<bool>::fromDataPtr(callbackData);
 80a6784:	4668      	mov	r0, sp
 80a6786:	4611      	mov	r1, r2
 80a6788:	f7ff fdf0 	bl	80a636c <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE11fromDataPtrEPv>
    if (error != Error::NONE) {
 80a678c:	b17c      	cbz	r4, 80a67ae <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x32>
        p.setError(Error((Error::Type)error, (const char*)data));
 80a678e:	b224      	sxth	r4, r4
        type_(type) {
}

inline particle::Error::Error(Type type, const char* msg) :
        msg_(msg ? (const char*)strdup(msg) : nullptr),
        type_(type) {
 80a6790:	4628      	mov	r0, r5
 80a6792:	b10d      	cbz	r5, 80a6798 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x1c>
 80a6794:	f001 f8ee 	bl	80a7974 <strdup>
 80a6798:	9002      	str	r0, [sp, #8]
 80a679a:	a902      	add	r1, sp, #8
 80a679c:	4668      	mov	r0, sp
 80a679e:	f8ad 400c 	strh.w	r4, [sp, #12]
 80a67a2:	f7ff fe2f 	bl	80a6404 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE>
        Error() {
    swap(*this, error);
}

inline particle::Error::~Error() {
    free((void*)msg_);
 80a67a6:	9802      	ldr	r0, [sp, #8]
 80a67a8:	f7fe feb4 	bl	80a5514 <free>
 80a67ac:	e01d      	b.n	80a67ea <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x6e>

      bool
      compare_exchange_strong(_Tp& __e, _Tp __i, memory_order __s, 
			      memory_order __f) noexcept
      {
	return __atomic_compare_exchange(&_M_i, &__e, &__i, false, __s, __f);
 80a67ae:	f04f 0201 	mov.w	r2, #1
 80a67b2:	9800      	ldr	r0, [sp, #0]
            onSuccess_(nullptr),
            onError_(nullptr) {
    }

    bool changeState(State state) {
        State s = State::RUNNING; // Expected state
 80a67b4:	f88d 4008 	strb.w	r4, [sp, #8]
 80a67b8:	e8d0 3f4f 	ldrexb	r3, [r0]
 80a67bc:	42a3      	cmp	r3, r4
 80a67be:	d103      	bne.n	80a67c8 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x4c>
 80a67c0:	e8c0 2f41 	strexb	r1, r2, [r0]
 80a67c4:	2900      	cmp	r1, #0
 80a67c6:	d1f7      	bne.n	80a67b8 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x3c>
 80a67c8:	d002      	beq.n	80a67d0 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x54>
 80a67ca:	f88d 3008 	strb.w	r3, [sp, #8]
 80a67ce:	e00c      	b.n	80a67ea <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x6e>
        }
    }

    void setResult(ResultT result) {
        if (this->changeState(State::SUCCEEDED)) {
            new(&result_) ResultT(std::move(result));
 80a67d0:	f110 010c 	adds.w	r1, r0, #12
 80a67d4:	f04f 0301 	mov.w	r3, #1
 80a67d8:	bf18      	it	ne
 80a67da:	7303      	strbne	r3, [r0, #12]
        memory_order __b = __m & __memory_order_mask;
	__glibcxx_assert(__b != memory_order_acquire);
	__glibcxx_assert(__b != memory_order_acq_rel);
	__glibcxx_assert(__b != memory_order_consume);

	__atomic_store_n(&_M_i, __i, __m);
 80a67dc:	f3bf 8f5f 	dmb	sy
            this->releaseDone();
            this->invokeCallback(this->onSuccess_, result_);
 80a67e0:	3004      	adds	r0, #4
 80a67e2:	f800 3c03 	strb.w	r3, [r0, #-3]
 80a67e6:	f7ff ff71 	bl	80a66cc <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_>
 80a67ea:	a801      	add	r0, sp, #4
 80a67ec:	f7fa ff93 	bl	80a1716 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
    } else {
        p.setResult(true);
    }
}
 80a67f0:	b005      	add	sp, #20
 80a67f2:	bd30      	pop	{r4, r5, pc}

080a67f4 <_ZN9IPAddressD1Ev>:
    IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet);
    IPAddress(uint32_t address);
    IPAddress(const uint8_t* address);
    IPAddress(const HAL_IPAddress& address);

    virtual ~IPAddress() {}
 80a67f4:	4770      	bx	lr

080a67f6 <_ZN9IPAddressD0Ev>:
 80a67f6:	b510      	push	{r4, lr}
 80a67f8:	4604      	mov	r4, r0
 80a67fa:	f7f9 fc52 	bl	80a00a2 <_ZdlPv>
 80a67fe:	4620      	mov	r0, r4
 80a6800:	bd10      	pop	{r4, pc}

080a6802 <_ZNK9IPAddress7printToER5Print>:
#endif
	return address.ipv4==that.address.ipv4;
}

size_t IPAddress::printTo(Print& p) const
{
 80a6802:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a6804:	460f      	mov	r7, r1
 80a6806:	f100 0608 	add.w	r6, r0, #8
 80a680a:	1d05      	adds	r5, r0, #4
 80a680c:	2400      	movs	r4, #0
    size_t n = 0;
    for (int i = 0; i < 4; i++)
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
 80a680e:	f816 1d01 	ldrb.w	r1, [r6, #-1]!
 80a6812:	220a      	movs	r2, #10
 80a6814:	4638      	mov	r0, r7
 80a6816:	f7ff f90e 	bl	80a5a36 <_ZN5Print5printEhi>
}

size_t IPAddress::printTo(Print& p) const
{
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a681a:	42ae      	cmp	r6, r5
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
 80a681c:	4404      	add	r4, r0
}

size_t IPAddress::printTo(Print& p) const
{
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a681e:	d007      	beq.n	80a6830 <_ZNK9IPAddress7printToER5Print+0x2e>
    {
        if (n)
 80a6820:	2c00      	cmp	r4, #0
 80a6822:	d0f4      	beq.n	80a680e <_ZNK9IPAddress7printToER5Print+0xc>
            n += p.print('.');
 80a6824:	212e      	movs	r1, #46	; 0x2e
 80a6826:	4638      	mov	r0, r7
 80a6828:	f7ff f8cc 	bl	80a59c4 <_ZN5Print5printEc>
 80a682c:	4404      	add	r4, r0
 80a682e:	e7ee      	b.n	80a680e <_ZNK9IPAddress7printToER5Print+0xc>
        n += p.print((*this)[i], DEC);
    }
    return n;
}
 80a6830:	4620      	mov	r0, r4
 80a6832:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a6834 <_ZN9IPAddressC1Ev>:
#include "spark_wiring_ipaddress.h"
#include "spark_wiring_print.h"
#include "spark_wiring_platform.h"
#include "string.h"

IPAddress::IPAddress()
 80a6834:	b510      	push	{r4, lr}
 80a6836:	4604      	mov	r4, r0
 80a6838:	4b04      	ldr	r3, [pc, #16]	; (80a684c <_ZN9IPAddressC1Ev+0x18>)
        return address;
    }

    virtual size_t printTo(Print& p) const;

    void clear() { memset(&address, 0, sizeof (address)); }
 80a683a:	2211      	movs	r2, #17
 80a683c:	f840 3b04 	str.w	r3, [r0], #4
 80a6840:	2100      	movs	r1, #0
 80a6842:	f001 f80a 	bl	80a785a <memset>
{
    clear();
}
 80a6846:	4620      	mov	r0, r4
 80a6848:	bd10      	pop	{r4, pc}
 80a684a:	bf00      	nop
 80a684c:	080a9474 	.word	0x080a9474

080a6850 <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>:

IPAddress::IPAddress(const HAL_IPAddress& address)
 80a6850:	4603      	mov	r3, r0
 80a6852:	4a07      	ldr	r2, [pc, #28]	; (80a6870 <_ZN9IPAddressC1ERK16_HAL_IPAddress_t+0x20>)
 80a6854:	b510      	push	{r4, lr}
 80a6856:	f843 2b04 	str.w	r2, [r3], #4
{
    memcpy(&this->address, &address, sizeof(address));
 80a685a:	f101 0210 	add.w	r2, r1, #16
 80a685e:	f851 4b04 	ldr.w	r4, [r1], #4
 80a6862:	4291      	cmp	r1, r2
 80a6864:	f843 4b04 	str.w	r4, [r3], #4
 80a6868:	d1f9      	bne.n	80a685e <_ZN9IPAddressC1ERK16_HAL_IPAddress_t+0xe>
 80a686a:	780a      	ldrb	r2, [r1, #0]
 80a686c:	701a      	strb	r2, [r3, #0]
}
 80a686e:	bd10      	pop	{r4, pc}
 80a6870:	080a9474 	.word	0x080a9474

080a6874 <_ZN9IPAddress8set_ipv4Ehhhh>:
    return address.ipv4!=0;
#endif
}

void IPAddress::set_ipv4(uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3)
{
 80a6874:	b510      	push	{r4, lr}
    address.ipv4 = b0<<24 | b1 << 16 | b2 << 8 | b3;
 80a6876:	f89d 4008 	ldrb.w	r4, [sp, #8]
 80a687a:	ea44 2303 	orr.w	r3, r4, r3, lsl #8
 80a687e:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
 80a6882:	ea42 6101 	orr.w	r1, r2, r1, lsl #24
        return &address;
    }

    inline void setVersion(uint8_t version) {
#if HAL_IPv6
        address.v = version;
 80a6886:	2304      	movs	r3, #4
 80a6888:	6041      	str	r1, [r0, #4]
 80a688a:	7503      	strb	r3, [r0, #20]
 80a688c:	bd10      	pop	{r4, pc}
	...

080a6890 <_ZN9IPAddressC1Ehhhh>:
{
    memcpy(&this->address, &address, sizeof(address));
}


IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
 80a6890:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a6892:	4d04      	ldr	r5, [pc, #16]	; (80a68a4 <_ZN9IPAddressC1Ehhhh+0x14>)
 80a6894:	6005      	str	r5, [r0, #0]
{
    set_ipv4(first_octet, second_octet, third_octet, fourth_octet);
 80a6896:	f89d 5018 	ldrb.w	r5, [sp, #24]
 80a689a:	9500      	str	r5, [sp, #0]
 80a689c:	f7ff ffea 	bl	80a6874 <_ZN9IPAddress8set_ipv4Ehhhh>
}
 80a68a0:	b003      	add	sp, #12
 80a68a2:	bd30      	pop	{r4, r5, pc}
 80a68a4:	080a9474 	.word	0x080a9474

080a68a8 <_ZN9IPAddressaSEPKh>:
    address.ipv4 = b0<<24 | b1 << 16 | b2 << 8 | b3;
    setVersion(4);
}

IPAddress& IPAddress::operator=(const uint8_t* address)
{
 80a68a8:	b537      	push	{r0, r1, r2, r4, r5, lr}
    set_ipv4(address[0], address[1], address[2], address[3]);
 80a68aa:	780d      	ldrb	r5, [r1, #0]
 80a68ac:	788b      	ldrb	r3, [r1, #2]
 80a68ae:	784a      	ldrb	r2, [r1, #1]
 80a68b0:	78c9      	ldrb	r1, [r1, #3]
 80a68b2:	9100      	str	r1, [sp, #0]
 80a68b4:	4629      	mov	r1, r5
 80a68b6:	f7ff ffdd 	bl	80a6874 <_ZN9IPAddress8set_ipv4Ehhhh>
    return *this;
}
 80a68ba:	b003      	add	sp, #12
 80a68bc:	bd30      	pop	{r4, r5, pc}

080a68be <_ZN9USBSerial14blockOnOverrunEb>:
  HAL_USB_USART_Flush_Data(_serial);
}

void USBSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a68be:	7441      	strb	r1, [r0, #17]
 80a68c0:	4770      	bx	lr

080a68c2 <_ZN9USBSerialD1Ev>:
#include "spark_wiring_platform.h"
#include "usb_hal.h"
#include "system_task.h"
#include "spark_wiring_startup.h"

class USBSerial : public Stream
 80a68c2:	4770      	bx	lr

080a68c4 <_ZN9USBSerial4readEv>:


// Read data from buffer
int USBSerial::read()
{
	return HAL_USB_USART_Receive_Data(_serial, false);
 80a68c4:	2100      	movs	r1, #0
 80a68c6:	7c00      	ldrb	r0, [r0, #16]
 80a68c8:	f7fe bd20 	b.w	80a530c <HAL_USB_USART_Receive_Data>

080a68cc <_ZN9USBSerial4peekEv>:
  _blocking = block;
}

int USBSerial::peek()
{
	return HAL_USB_USART_Receive_Data(_serial, true);
 80a68cc:	2101      	movs	r1, #1
 80a68ce:	7c00      	ldrb	r0, [r0, #16]
 80a68d0:	f7fe bd1c 	b.w	80a530c <HAL_USB_USART_Receive_Data>

080a68d4 <_ZN9USBSerial17availableForWriteEv>:
	return HAL_USB_USART_Receive_Data(_serial, false);
}

int USBSerial::availableForWrite()
{
  return HAL_USB_USART_Available_Data_For_Write(_serial);
 80a68d4:	7c00      	ldrb	r0, [r0, #16]
 80a68d6:	f7fe bd11 	b.w	80a52fc <HAL_USB_USART_Available_Data_For_Write>

080a68da <_ZN9USBSerial9availableEv>:
}

int USBSerial::available()
{
	return HAL_USB_USART_Available_Data(_serial);
 80a68da:	7c00      	ldrb	r0, [r0, #16]
 80a68dc:	f7fe bd06 	b.w	80a52ec <HAL_USB_USART_Available_Data>

080a68e0 <_ZN9USBSerial5writeEh>:
}

size_t USBSerial::write(uint8_t byte)
{
 80a68e0:	b538      	push	{r3, r4, r5, lr}
 80a68e2:	4604      	mov	r4, r0
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
 80a68e4:	7c00      	ldrb	r0, [r0, #16]
{
	return HAL_USB_USART_Available_Data(_serial);
}

size_t USBSerial::write(uint8_t byte)
{
 80a68e6:	460d      	mov	r5, r1
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
 80a68e8:	f7fe fd08 	bl	80a52fc <HAL_USB_USART_Available_Data_For_Write>
 80a68ec:	2800      	cmp	r0, #0
 80a68ee:	dc01      	bgt.n	80a68f4 <_ZN9USBSerial5writeEh+0x14>
 80a68f0:	7c60      	ldrb	r0, [r4, #17]
 80a68f2:	b120      	cbz	r0, 80a68fe <_ZN9USBSerial5writeEh+0x1e>
    HAL_USB_USART_Send_Data(_serial, byte);
 80a68f4:	4629      	mov	r1, r5
 80a68f6:	7c20      	ldrb	r0, [r4, #16]
 80a68f8:	f7fe fd10 	bl	80a531c <HAL_USB_USART_Send_Data>
    return 1;
 80a68fc:	2001      	movs	r0, #1
  }
  return 0;
}
 80a68fe:	bd38      	pop	{r3, r4, r5, pc}

080a6900 <_ZN9USBSerial5flushEv>:

void USBSerial::flush()
{
  HAL_USB_USART_Flush_Data(_serial);
 80a6900:	7c00      	ldrb	r0, [r0, #16]
 80a6902:	f7fe bd13 	b.w	80a532c <HAL_USB_USART_Flush_Data>

080a6906 <_ZN9USBSerialD0Ev>:
 80a6906:	b510      	push	{r4, lr}
 80a6908:	4604      	mov	r4, r0
 80a690a:	f7f9 fbca 	bl	80a00a2 <_ZdlPv>
 80a690e:	4620      	mov	r0, r4
 80a6910:	bd10      	pop	{r4, pc}
	...

080a6914 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>:

  HAL_USB_USART_Config conf = acquireSerialBuffer();
  HAL_USB_USART_Init(_serial, &conf);
}

USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
 80a6914:	b510      	push	{r4, lr}
 80a6916:	4604      	mov	r4, r0
 80a6918:	2300      	movs	r3, #0
 80a691a:	6063      	str	r3, [r4, #4]
 80a691c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a6920:	60a3      	str	r3, [r4, #8]
 80a6922:	4b05      	ldr	r3, [pc, #20]	; (80a6938 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config+0x24>)
 80a6924:	4608      	mov	r0, r1
 80a6926:	6023      	str	r3, [r4, #0]
{
  _serial = serial;
  _blocking = true;
 80a6928:	2301      	movs	r3, #1
  HAL_USB_USART_Init(_serial, &conf);
}

USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
{
  _serial = serial;
 80a692a:	7421      	strb	r1, [r4, #16]
  _blocking = true;
 80a692c:	7463      	strb	r3, [r4, #17]

  HAL_USB_USART_Init(_serial, &conf);
 80a692e:	4611      	mov	r1, r2
 80a6930:	f7fe fcd4 	bl	80a52dc <HAL_USB_USART_Init>
}
 80a6934:	4620      	mov	r0, r4
 80a6936:	bd10      	pop	{r4, pc}
 80a6938:	080a9488 	.word	0x080a9488

080a693c <_Z19acquireSerialBufferv>:

// Preinstantiate Objects //////////////////////////////////////////////////////
#ifdef SPARK_USB_SERIAL

HAL_USB_USART_Config __attribute__((weak)) acquireSerialBuffer()
{
 80a693c:	b510      	push	{r4, lr}
 80a693e:	4604      	mov	r4, r0
  HAL_USB_USART_Config conf = {0};
 80a6940:	2214      	movs	r2, #20
 80a6942:	2100      	movs	r1, #0
 80a6944:	f000 ff89 	bl	80a785a <memset>

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t serial_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t serial_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = serial_rx_buffer;
 80a6948:	4b05      	ldr	r3, [pc, #20]	; (80a6960 <_Z19acquireSerialBufferv+0x24>)
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
#endif

  return conf;
}
 80a694a:	4620      	mov	r0, r4

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t serial_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t serial_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = serial_rx_buffer;
 80a694c:	6063      	str	r3, [r4, #4]
  conf.tx_buffer = serial_tx_buffer;
 80a694e:	4b05      	ldr	r3, [pc, #20]	; (80a6964 <_Z19acquireSerialBufferv+0x28>)
 80a6950:	60e3      	str	r3, [r4, #12]
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
 80a6952:	f240 1301 	movw	r3, #257	; 0x101
 80a6956:	8123      	strh	r3, [r4, #8]
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
 80a6958:	2381      	movs	r3, #129	; 0x81
 80a695a:	8223      	strh	r3, [r4, #16]
#endif

  return conf;
}
 80a695c:	bd10      	pop	{r4, pc}
 80a695e:	bf00      	nop
 80a6960:	20001149 	.word	0x20001149
 80a6964:	200010c8 	.word	0x200010c8

080a6968 <_Z16_fetch_usbserialv>:

USBSerial& _fetch_usbserial()
{
 80a6968:	b530      	push	{r4, r5, lr}
  HAL_USB_USART_Config conf = acquireSerialBuffer();
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a696a:	4d0e      	ldr	r5, [pc, #56]	; (80a69a4 <_Z16_fetch_usbserialv+0x3c>)

  return conf;
}

USBSerial& _fetch_usbserial()
{
 80a696c:	b087      	sub	sp, #28
  HAL_USB_USART_Config conf = acquireSerialBuffer();
 80a696e:	a801      	add	r0, sp, #4
 80a6970:	f7ff ffe4 	bl	80a693c <_Z19acquireSerialBufferv>
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a6974:	6829      	ldr	r1, [r5, #0]
 80a6976:	f011 0401 	ands.w	r4, r1, #1
 80a697a:	d110      	bne.n	80a699e <_Z16_fetch_usbserialv+0x36>
 80a697c:	4628      	mov	r0, r5
 80a697e:	f7f9 fb9d 	bl	80a00bc <__cxa_guard_acquire>
 80a6982:	b160      	cbz	r0, 80a699e <_Z16_fetch_usbserialv+0x36>
 80a6984:	aa01      	add	r2, sp, #4
 80a6986:	4621      	mov	r1, r4
 80a6988:	4807      	ldr	r0, [pc, #28]	; (80a69a8 <_Z16_fetch_usbserialv+0x40>)
 80a698a:	f7ff ffc3 	bl	80a6914 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
 80a698e:	4628      	mov	r0, r5
 80a6990:	f7f9 fb99 	bl	80a00c6 <__cxa_guard_release>
 80a6994:	4a05      	ldr	r2, [pc, #20]	; (80a69ac <_Z16_fetch_usbserialv+0x44>)
 80a6996:	4906      	ldr	r1, [pc, #24]	; (80a69b0 <_Z16_fetch_usbserialv+0x48>)
 80a6998:	4803      	ldr	r0, [pc, #12]	; (80a69a8 <_Z16_fetch_usbserialv+0x40>)
 80a699a:	f000 fa03 	bl	80a6da4 <__aeabi_atexit>
	return _usbserial;
}
 80a699e:	4802      	ldr	r0, [pc, #8]	; (80a69a8 <_Z16_fetch_usbserialv+0x40>)
 80a69a0:	b007      	add	sp, #28
 80a69a2:	bd30      	pop	{r4, r5, pc}
 80a69a4:	200010c4 	.word	0x200010c4
 80a69a8:	2000124c 	.word	0x2000124c
 80a69ac:	200003bc 	.word	0x200003bc
 80a69b0:	080a68c3 	.word	0x080a68c3

080a69b4 <_Z23acquireUSBSerial1Bufferv>:

#if Wiring_USBSerial1

HAL_USB_USART_Config __attribute__((weak)) acquireUSBSerial1Buffer()
{
 80a69b4:	b510      	push	{r4, lr}
 80a69b6:	4604      	mov	r4, r0
  HAL_USB_USART_Config conf = {0};
 80a69b8:	2214      	movs	r2, #20
 80a69ba:	2100      	movs	r1, #0
 80a69bc:	f000 ff4d 	bl	80a785a <memset>

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t usbserial1_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t usbserial1_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = usbserial1_rx_buffer;
 80a69c0:	4b05      	ldr	r3, [pc, #20]	; (80a69d8 <_Z23acquireUSBSerial1Bufferv+0x24>)
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
#endif

  return conf;
}
 80a69c2:	4620      	mov	r0, r4

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t usbserial1_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t usbserial1_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = usbserial1_rx_buffer;
 80a69c4:	6063      	str	r3, [r4, #4]
  conf.tx_buffer = usbserial1_tx_buffer;
 80a69c6:	4b05      	ldr	r3, [pc, #20]	; (80a69dc <_Z23acquireUSBSerial1Bufferv+0x28>)
 80a69c8:	60e3      	str	r3, [r4, #12]
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
 80a69ca:	f240 1301 	movw	r3, #257	; 0x101
 80a69ce:	8123      	strh	r3, [r4, #8]
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
 80a69d0:	2381      	movs	r3, #129	; 0x81
 80a69d2:	8223      	strh	r3, [r4, #16]
#endif

  return conf;
}
 80a69d4:	bd10      	pop	{r4, pc}
 80a69d6:	bf00      	nop
 80a69d8:	200012fc 	.word	0x200012fc
 80a69dc:	20001264 	.word	0x20001264

080a69e0 <_Z17_fetch_usbserial1v>:

USBSerial& _fetch_usbserial1()
{
 80a69e0:	b510      	push	{r4, lr}
  HAL_USB_USART_Config conf = acquireUSBSerial1Buffer();
  static USBSerial _usbserial1(HAL_USB_USART_SERIAL1, conf);
 80a69e2:	4c0e      	ldr	r4, [pc, #56]	; (80a6a1c <_Z17_fetch_usbserial1v+0x3c>)

  return conf;
}

USBSerial& _fetch_usbserial1()
{
 80a69e4:	b086      	sub	sp, #24
  HAL_USB_USART_Config conf = acquireUSBSerial1Buffer();
 80a69e6:	a801      	add	r0, sp, #4
 80a69e8:	f7ff ffe4 	bl	80a69b4 <_Z23acquireUSBSerial1Bufferv>
  static USBSerial _usbserial1(HAL_USB_USART_SERIAL1, conf);
 80a69ec:	6823      	ldr	r3, [r4, #0]
 80a69ee:	07db      	lsls	r3, r3, #31
 80a69f0:	d410      	bmi.n	80a6a14 <_Z17_fetch_usbserial1v+0x34>
 80a69f2:	4620      	mov	r0, r4
 80a69f4:	f7f9 fb62 	bl	80a00bc <__cxa_guard_acquire>
 80a69f8:	b160      	cbz	r0, 80a6a14 <_Z17_fetch_usbserial1v+0x34>
 80a69fa:	aa01      	add	r2, sp, #4
 80a69fc:	2101      	movs	r1, #1
 80a69fe:	4808      	ldr	r0, [pc, #32]	; (80a6a20 <_Z17_fetch_usbserial1v+0x40>)
 80a6a00:	f7ff ff88 	bl	80a6914 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
 80a6a04:	4620      	mov	r0, r4
 80a6a06:	f7f9 fb5e 	bl	80a00c6 <__cxa_guard_release>
 80a6a0a:	4a06      	ldr	r2, [pc, #24]	; (80a6a24 <_Z17_fetch_usbserial1v+0x44>)
 80a6a0c:	4906      	ldr	r1, [pc, #24]	; (80a6a28 <_Z17_fetch_usbserial1v+0x48>)
 80a6a0e:	4804      	ldr	r0, [pc, #16]	; (80a6a20 <_Z17_fetch_usbserial1v+0x40>)
 80a6a10:	f000 f9c8 	bl	80a6da4 <__aeabi_atexit>
  return _usbserial1;
}
 80a6a14:	4802      	ldr	r0, [pc, #8]	; (80a6a20 <_Z17_fetch_usbserial1v+0x40>)
 80a6a16:	b006      	add	sp, #24
 80a6a18:	bd10      	pop	{r4, pc}
 80a6a1a:	bf00      	nop
 80a6a1c:	20001260 	.word	0x20001260
 80a6a20:	200012e8 	.word	0x200012e8
 80a6a24:	200003bc 	.word	0x200003bc
 80a6a28:	080a68c3 	.word	0x080a68c3

080a6a2c <_ZN11USARTSerialD1Ev>:
private:
  HAL_USART_Serial _serial;
  bool _blocking;
public:
  USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer);
  virtual ~USARTSerial() {};
 80a6a2c:	4770      	bx	lr

080a6a2e <_ZN11USARTSerial14blockOnOverrunEb>:
    HAL_USART_Half_Duplex(_serial, Enable);
}

void USARTSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a6a2e:	7441      	strb	r1, [r0, #17]
 80a6a30:	4770      	bx	lr

080a6a32 <_ZN11USARTSerial17availableForWriteEv>:
}


int USARTSerial::availableForWrite(void)
{
  return HAL_USART_Available_Data_For_Write(_serial);
 80a6a32:	7c00      	ldrb	r0, [r0, #16]
 80a6a34:	f7fe bbb8 	b.w	80a51a8 <HAL_USART_Available_Data_For_Write>

080a6a38 <_ZN11USARTSerial9availableEv>:
}

int USARTSerial::available(void)
{
  return HAL_USART_Available_Data(_serial);
 80a6a38:	7c00      	ldrb	r0, [r0, #16]
 80a6a3a:	f7fe bb8d 	b.w	80a5158 <HAL_USART_Available_Data>

080a6a3e <_ZN11USARTSerial4peekEv>:
}

int USARTSerial::peek(void)
{
  return HAL_USART_Peek_Data(_serial);
 80a6a3e:	7c00      	ldrb	r0, [r0, #16]
 80a6a40:	f7fe bb9a 	b.w	80a5178 <HAL_USART_Peek_Data>

080a6a44 <_ZN11USARTSerial4readEv>:
}

int USARTSerial::read(void)
{
  return HAL_USART_Read_Data(_serial);
 80a6a44:	7c00      	ldrb	r0, [r0, #16]
 80a6a46:	f7fe bb8f 	b.w	80a5168 <HAL_USART_Read_Data>

080a6a4a <_ZN11USARTSerial5flushEv>:
}

void USARTSerial::flush()
{
  HAL_USART_Flush_Data(_serial);
 80a6a4a:	7c00      	ldrb	r0, [r0, #16]
 80a6a4c:	f7fe bb9c 	b.w	80a5188 <HAL_USART_Flush_Data>

080a6a50 <_ZN11USARTSerialD0Ev>:
 80a6a50:	b510      	push	{r4, lr}
 80a6a52:	4604      	mov	r4, r0
 80a6a54:	f7f9 fb25 	bl	80a00a2 <_ZdlPv>
 80a6a58:	4620      	mov	r0, r4
 80a6a5a:	bd10      	pop	{r4, pc}

080a6a5c <_ZN11USARTSerial5writeEh>:
}

size_t USARTSerial::write(uint8_t c)
{
 80a6a5c:	b570      	push	{r4, r5, r6, lr}
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
 80a6a5e:	7c45      	ldrb	r5, [r0, #17]
{
  HAL_USART_Flush_Data(_serial);
}

size_t USARTSerial::write(uint8_t c)
{
 80a6a60:	4604      	mov	r4, r0
 80a6a62:	460e      	mov	r6, r1
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
 80a6a64:	b925      	cbnz	r5, 80a6a70 <_ZN11USARTSerial5writeEh+0x14>
 80a6a66:	7c00      	ldrb	r0, [r0, #16]
 80a6a68:	f7fe fb9e 	bl	80a51a8 <HAL_USART_Available_Data_For_Write>
 80a6a6c:	2800      	cmp	r0, #0
 80a6a6e:	dd05      	ble.n	80a6a7c <_ZN11USARTSerial5writeEh+0x20>
    // the HAL always blocks.
	  return HAL_USART_Write_Data(_serial, c);
 80a6a70:	4631      	mov	r1, r6
 80a6a72:	7c20      	ldrb	r0, [r4, #16]
  }
  return 0;
}
 80a6a74:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
size_t USARTSerial::write(uint8_t c)
{
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
    // the HAL always blocks.
	  return HAL_USART_Write_Data(_serial, c);
 80a6a78:	f7fe bb66 	b.w	80a5148 <HAL_USART_Write_Data>
  }
  return 0;
}
 80a6a7c:	4628      	mov	r0, r5
 80a6a7e:	bd70      	pop	{r4, r5, r6, pc}

080a6a80 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>:
#include "spark_wiring_constants.h"
#include "module_info.h"

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
 80a6a80:	b510      	push	{r4, lr}
 80a6a82:	4604      	mov	r4, r0
 80a6a84:	4608      	mov	r0, r1
 80a6a86:	4611      	mov	r1, r2
 80a6a88:	2200      	movs	r2, #0
 80a6a8a:	6062      	str	r2, [r4, #4]
 80a6a8c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80a6a90:	60a2      	str	r2, [r4, #8]
 80a6a92:	4a05      	ldr	r2, [pc, #20]	; (80a6aa8 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_+0x28>)
{
  _serial = serial;
 80a6a94:	7420      	strb	r0, [r4, #16]
#include "spark_wiring_constants.h"
#include "module_info.h"

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
 80a6a96:	6022      	str	r2, [r4, #0]
{
  _serial = serial;
  // Default is blocking mode
  _blocking = true;
 80a6a98:	2201      	movs	r2, #1
 80a6a9a:	7462      	strb	r2, [r4, #17]
  HAL_USART_Init(serial, rx_buffer, tx_buffer);
 80a6a9c:	461a      	mov	r2, r3
 80a6a9e:	f7fe fb43 	bl	80a5128 <HAL_USART_Init>
}
 80a6aa2:	4620      	mov	r0, r4
 80a6aa4:	bd10      	pop	{r4, pc}
 80a6aa6:	bf00      	nop
 80a6aa8:	080a94b8 	.word	0x080a94b8

080a6aac <_ZN11USARTSerial5beginEmm>:
  begin(baud, SERIAL_8N1);
}

void USARTSerial::begin(unsigned long baud, uint32_t config)
{
  HAL_USART_BeginConfig(_serial, baud, config, 0);
 80a6aac:	2300      	movs	r3, #0
 80a6aae:	7c00      	ldrb	r0, [r0, #16]
 80a6ab0:	f7fe bb82 	b.w	80a51b8 <HAL_USART_BeginConfig>

080a6ab4 <_ZN11USARTSerial5beginEm>:
}
// Public Methods //////////////////////////////////////////////////////////////

void USARTSerial::begin(unsigned long baud)
{
  begin(baud, SERIAL_8N1);
 80a6ab4:	2200      	movs	r2, #0
 80a6ab6:	f7ff bff9 	b.w	80a6aac <_ZN11USARTSerial5beginEmm>

080a6aba <_ZN11USARTSerial3endEv>:
  HAL_USART_BeginConfig(_serial, baud, config, 0);
}

void USARTSerial::end()
{
  HAL_USART_End(_serial);
 80a6aba:	7c00      	ldrb	r0, [r0, #16]
 80a6abc:	f7fe bb3c 	b.w	80a5138 <HAL_USART_End>

080a6ac0 <_ZN11USARTSerial9isEnabledEv>:
USARTSerial::operator bool() {
  return true;
}

bool USARTSerial::isEnabled() {
  return HAL_USART_Is_Enabled(_serial);
 80a6ac0:	7c00      	ldrb	r0, [r0, #16]
 80a6ac2:	f7fe bb69 	b.w	80a5198 <HAL_USART_Is_Enabled>
	...

080a6ac8 <_Z22__fetch_global_Serial1v>:
static Ring_Buffer* serial1_rx_buffer = NULL;
static Ring_Buffer* serial1_tx_buffer = NULL;
#endif

USARTSerial& __fetch_global_Serial1()
{
 80a6ac8:	b538      	push	{r3, r4, r5, lr}
#if ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
	static USARTSerial serial1(HAL_USART_SERIAL1, &serial1_rx_buffer, &serial1_tx_buffer);
 80a6aca:	4d0c      	ldr	r5, [pc, #48]	; (80a6afc <_Z22__fetch_global_Serial1v+0x34>)
 80a6acc:	6829      	ldr	r1, [r5, #0]
 80a6ace:	f011 0401 	ands.w	r4, r1, #1
 80a6ad2:	d111      	bne.n	80a6af8 <_Z22__fetch_global_Serial1v+0x30>
 80a6ad4:	4628      	mov	r0, r5
 80a6ad6:	f7f9 faf1 	bl	80a00bc <__cxa_guard_acquire>
 80a6ada:	b168      	cbz	r0, 80a6af8 <_Z22__fetch_global_Serial1v+0x30>
 80a6adc:	4a08      	ldr	r2, [pc, #32]	; (80a6b00 <_Z22__fetch_global_Serial1v+0x38>)
 80a6ade:	4621      	mov	r1, r4
 80a6ae0:	4b08      	ldr	r3, [pc, #32]	; (80a6b04 <_Z22__fetch_global_Serial1v+0x3c>)
 80a6ae2:	4809      	ldr	r0, [pc, #36]	; (80a6b08 <_Z22__fetch_global_Serial1v+0x40>)
 80a6ae4:	f7ff ffcc 	bl	80a6a80 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>
 80a6ae8:	4628      	mov	r0, r5
 80a6aea:	f7f9 faec 	bl	80a00c6 <__cxa_guard_release>
 80a6aee:	4a07      	ldr	r2, [pc, #28]	; (80a6b0c <_Z22__fetch_global_Serial1v+0x44>)
 80a6af0:	4907      	ldr	r1, [pc, #28]	; (80a6b10 <_Z22__fetch_global_Serial1v+0x48>)
 80a6af2:	4805      	ldr	r0, [pc, #20]	; (80a6b08 <_Z22__fetch_global_Serial1v+0x40>)
 80a6af4:	f000 f956 	bl	80a6da4 <__aeabi_atexit>
    serial1_tx_buffer = new Ring_Buffer();
  }
  static USARTSerial serial1(HAL_USART_SERIAL1, serial1_rx_buffer, serial1_tx_buffer);
#endif
	return serial1;
}
 80a6af8:	4803      	ldr	r0, [pc, #12]	; (80a6b08 <_Z22__fetch_global_Serial1v+0x40>)
 80a6afa:	bd38      	pop	{r3, r4, r5, pc}
 80a6afc:	20001498 	.word	0x20001498
 80a6b00:	2000149c 	.word	0x2000149c
 80a6b04:	20001414 	.word	0x20001414
 80a6b08:	20001400 	.word	0x20001400
 80a6b0c:	200003bc 	.word	0x200003bc
 80a6b10:	080a6a2d 	.word	0x080a6a2d

080a6b14 <_ZN8particle6detail21futureCallbackWrapperEPv>:
 * License along with this library; if not, see <http://www.gnu.org/licenses/>.
 */

#include "spark_wiring_async.h"

void particle::detail::futureCallbackWrapper(void* data) {
 80a6b14:	b510      	push	{r4, lr}
  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 80a6b16:	6883      	ldr	r3, [r0, #8]
 80a6b18:	4604      	mov	r4, r0
 80a6b1a:	b90b      	cbnz	r3, 80a6b20 <_ZN8particle6detail21futureCallbackWrapperEPv+0xc>
	__throw_bad_function_call();
 80a6b1c:	f000 f947 	bl	80a6dae <_ZSt25__throw_bad_function_callv>
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a6b20:	68c3      	ldr	r3, [r0, #12]
 80a6b22:	4798      	blx	r3

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
    {
      if (_M_manager)
 80a6b24:	68a3      	ldr	r3, [r4, #8]
 80a6b26:	b11b      	cbz	r3, 80a6b30 <_ZN8particle6detail21futureCallbackWrapperEPv+0x1c>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
 80a6b28:	2203      	movs	r2, #3
 80a6b2a:	4621      	mov	r1, r4
 80a6b2c:	4620      	mov	r0, r4
 80a6b2e:	4798      	blx	r3
    auto callbackPtr = static_cast<const std::function<void()>*>(data);
    (*callbackPtr)();
    delete callbackPtr;
 80a6b30:	4620      	mov	r0, r4
}
 80a6b32:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
#include "spark_wiring_async.h"

void particle::detail::futureCallbackWrapper(void* data) {
    auto callbackPtr = static_cast<const std::function<void()>*>(data);
    (*callbackPtr)();
    delete callbackPtr;
 80a6b36:	f7f9 bab4 	b.w	80a00a2 <_ZdlPv>

080a6b3a <_ZN7TwoWireD1Ev>:
private:
  HAL_I2C_Interface _i2c;

public:
  TwoWire(HAL_I2C_Interface i2c);
  virtual ~TwoWire() {};
 80a6b3a:	4770      	bx	lr

080a6b3c <_ZN7TwoWire5writeEPKhj>:

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
 80a6b3c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a6b3e:	4606      	mov	r6, r0
 80a6b40:	4615      	mov	r5, r2
 80a6b42:	460c      	mov	r4, r1
 80a6b44:	188f      	adds	r7, r1, r2
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
 80a6b46:	42bc      	cmp	r4, r7
 80a6b48:	d006      	beq.n	80a6b58 <_ZN7TwoWire5writeEPKhj+0x1c>
  {
    write(data[i]);
 80a6b4a:	6833      	ldr	r3, [r6, #0]
 80a6b4c:	f814 1b01 	ldrb.w	r1, [r4], #1
 80a6b50:	689b      	ldr	r3, [r3, #8]
 80a6b52:	4630      	mov	r0, r6
 80a6b54:	4798      	blx	r3
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
 80a6b56:	e7f6      	b.n	80a6b46 <_ZN7TwoWire5writeEPKhj+0xa>
  {
    write(data[i]);
  }

  return quantity;
}
 80a6b58:	4628      	mov	r0, r5
 80a6b5a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a6b5c <_ZN7TwoWire5writeEh>:
// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data)
{
  return HAL_I2C_Write_Data(_i2c, data, NULL);
 80a6b5c:	2200      	movs	r2, #0
 80a6b5e:	7c00      	ldrb	r0, [r0, #16]
 80a6b60:	f7fe bb52 	b.w	80a5208 <HAL_I2C_Write_Data>

080a6b64 <_ZN7TwoWire9availableEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
  return HAL_I2C_Available_Data(_i2c, NULL);
 80a6b64:	2100      	movs	r1, #0
 80a6b66:	7c00      	ldrb	r0, [r0, #16]
 80a6b68:	f7fe bb56 	b.w	80a5218 <HAL_I2C_Available_Data>

080a6b6c <_ZN7TwoWire4readEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void)
{
  return HAL_I2C_Read_Data(_i2c, NULL);
 80a6b6c:	2100      	movs	r1, #0
 80a6b6e:	7c00      	ldrb	r0, [r0, #16]
 80a6b70:	f7fe bb5a 	b.w	80a5228 <HAL_I2C_Read_Data>

080a6b74 <_ZN7TwoWire4peekEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::peek(void)
{
  return HAL_I2C_Peek_Data(_i2c, NULL);
 80a6b74:	2100      	movs	r1, #0
 80a6b76:	7c00      	ldrb	r0, [r0, #16]
 80a6b78:	f7fe bb5e 	b.w	80a5238 <HAL_I2C_Peek_Data>

080a6b7c <_ZN7TwoWire5flushEv>:
}

void TwoWire::flush(void)
{
  HAL_I2C_Flush_Data(_i2c, NULL);
 80a6b7c:	2100      	movs	r1, #0
 80a6b7e:	7c00      	ldrb	r0, [r0, #16]
 80a6b80:	f7fe bb62 	b.w	80a5248 <HAL_I2C_Flush_Data>

080a6b84 <_ZN7TwoWireD0Ev>:
 80a6b84:	b510      	push	{r4, lr}
 80a6b86:	4604      	mov	r4, r0
 80a6b88:	f7f9 fa8b 	bl	80a00a2 <_ZdlPv>
 80a6b8c:	4620      	mov	r0, r4
 80a6b8e:	bd10      	pop	{r4, pc}

080a6b90 <_ZN7TwoWireC1E17HAL_I2C_Interface>:
#include "i2c_hal.h"
#include "spark_wiring_thread.h"

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire(HAL_I2C_Interface i2c)
 80a6b90:	b510      	push	{r4, lr}
 80a6b92:	4604      	mov	r4, r0
 80a6b94:	4608      	mov	r0, r1
 80a6b96:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a6b9a:	60a3      	str	r3, [r4, #8]
 80a6b9c:	4b04      	ldr	r3, [pc, #16]	; (80a6bb0 <_ZN7TwoWireC1E17HAL_I2C_Interface+0x20>)
 80a6b9e:	2100      	movs	r1, #0
{
  _i2c = i2c;
 80a6ba0:	7420      	strb	r0, [r4, #16]
 80a6ba2:	6061      	str	r1, [r4, #4]
#include "i2c_hal.h"
#include "spark_wiring_thread.h"

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire(HAL_I2C_Interface i2c)
 80a6ba4:	6023      	str	r3, [r4, #0]
{
  _i2c = i2c;
  HAL_I2C_Init(_i2c, NULL);
 80a6ba6:	f7fe fb5f 	bl	80a5268 <HAL_I2C_Init>

}
 80a6baa:	4620      	mov	r0, r4
 80a6bac:	bd10      	pop	{r4, pc}
 80a6bae:	bf00      	nop
 80a6bb0:	080a94e8 	.word	0x080a94e8

080a6bb4 <_ZN7TwoWire5beginEv>:
  HAL_I2C_Stretch_Clock(_i2c, stretch, NULL);
}

void TwoWire::begin(void)
{
	HAL_I2C_Begin(_i2c, I2C_MODE_MASTER, 0x00, NULL);
 80a6bb4:	2300      	movs	r3, #0
 80a6bb6:	461a      	mov	r2, r3
 80a6bb8:	4619      	mov	r1, r3
 80a6bba:	7c00      	ldrb	r0, [r0, #16]
 80a6bbc:	f7fe bb04 	b.w	80a51c8 <HAL_I2C_Begin>

080a6bc0 <_ZN7TwoWire11requestFromEhhh>:
{
	HAL_I2C_End(_i2c, NULL);
}

uint8_t TwoWire::requestFrom(uint8_t address, uint8_t quantity, uint8_t sendStop)
{
 80a6bc0:	b513      	push	{r0, r1, r4, lr}
  uint8_t result = HAL_I2C_Request_Data(_i2c, address, quantity, sendStop, NULL);
 80a6bc2:	2400      	movs	r4, #0
 80a6bc4:	7c00      	ldrb	r0, [r0, #16]
 80a6bc6:	9400      	str	r4, [sp, #0]
 80a6bc8:	f7fe fb06 	bl	80a51d8 <HAL_I2C_Request_Data>
  return result;
}
 80a6bcc:	b2c0      	uxtb	r0, r0
 80a6bce:	b002      	add	sp, #8
 80a6bd0:	bd10      	pop	{r4, pc}

080a6bd2 <_ZN7TwoWire11requestFromEii>:
  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)true);
}

uint8_t TwoWire::requestFrom(int address, int quantity)
{
  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)true);
 80a6bd2:	2301      	movs	r3, #1
 80a6bd4:	b2d2      	uxtb	r2, r2
 80a6bd6:	b2c9      	uxtb	r1, r1
 80a6bd8:	f7ff bff2 	b.w	80a6bc0 <_ZN7TwoWire11requestFromEhhh>

080a6bdc <_ZN7TwoWire17beginTransmissionEh>:
  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)sendStop);
}

void TwoWire::beginTransmission(uint8_t address)
{
	HAL_I2C_Begin_Transmission(_i2c, address, NULL);
 80a6bdc:	2200      	movs	r2, #0
 80a6bde:	7c00      	ldrb	r0, [r0, #16]
 80a6be0:	f7fe bb02 	b.w	80a51e8 <HAL_I2C_Begin_Transmission>

080a6be4 <_ZN7TwoWire17beginTransmissionEi>:
}

void TwoWire::beginTransmission(int address)
{
  beginTransmission((uint8_t)address);
 80a6be4:	b2c9      	uxtb	r1, r1
 80a6be6:	f7ff bff9 	b.w	80a6bdc <_ZN7TwoWire17beginTransmissionEh>

080a6bea <_ZN7TwoWire15endTransmissionEh>:
//	no call to endTransmission(true) is made. Some I2C
//	devices will behave oddly if they do not see a STOP.
//
uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
	return HAL_I2C_End_Transmission(_i2c, sendStop, NULL);
 80a6bea:	2200      	movs	r2, #0
 80a6bec:	7c00      	ldrb	r0, [r0, #16]
 80a6bee:	f7fe bb03 	b.w	80a51f8 <HAL_I2C_End_Transmission>

080a6bf2 <_ZN7TwoWire15endTransmissionEv>:
//	This provides backwards compatibility with the original
//	definition, and expected behaviour, of endTransmission
//
uint8_t TwoWire::endTransmission(void)
{
  return endTransmission(true);
 80a6bf2:	2101      	movs	r1, #1
 80a6bf4:	f7ff bff9 	b.w	80a6bea <_ZN7TwoWire15endTransmissionEh>

080a6bf8 <_ZN7TwoWire9isEnabledEv>:
  HAL_I2C_Set_Callback_On_Request(_i2c, function, NULL);
}

bool TwoWire::isEnabled()
{
  return HAL_I2C_Is_Enabled(_i2c, NULL);
 80a6bf8:	2100      	movs	r1, #0
 80a6bfa:	7c00      	ldrb	r0, [r0, #16]
 80a6bfc:	f7fe bb2c 	b.w	80a5258 <HAL_I2C_Is_Enabled>

080a6c00 <_ZN5spark9WiFiClassD1Ev>:
        wlan_set_ipaddress_source(source, true, NULL);
    }

public:
    WiFiClass() {}
    ~WiFiClass() {}
 80a6c00:	4770      	bx	lr

080a6c02 <_ZN5spark9WiFiClass5readyEv>:
    bool connecting(void) {
        return network_connecting(*this, 0, NULL);
    }

    bool ready(void) {
        return network_ready(*this, 0, NULL);
 80a6c02:	2200      	movs	r2, #0
 80a6c04:	4611      	mov	r1, r2
 80a6c06:	4610      	mov	r0, r2
 80a6c08:	f7fe bc24 	b.w	80a5454 <network_ready>

080a6c0c <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t>:
    void setIPAddressSource(IPAddressSource source) {
        wlan_set_ipaddress_source(source, true, NULL);
    }

public:
    WiFiClass() {}
 80a6c0c:	4803      	ldr	r0, [pc, #12]	; (80a6c1c <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x10>)
 80a6c0e:	4b04      	ldr	r3, [pc, #16]	; (80a6c20 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x14>)
one second timeout is reached). If the aforementioned "bug" is ever fixed by
TI, no changes need to be made to this function, as it would be implemented
the same way.
*****************************************************************************/

    WiFiClass WiFi;
 80a6c10:	4a04      	ldr	r2, [pc, #16]	; (80a6c24 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x18>)
 80a6c12:	4905      	ldr	r1, [pc, #20]	; (80a6c28 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x1c>)
 80a6c14:	6003      	str	r3, [r0, #0]
 80a6c16:	f000 b8c5 	b.w	80a6da4 <__aeabi_atexit>
 80a6c1a:	bf00      	nop
 80a6c1c:	20001520 	.word	0x20001520
 80a6c20:	080a9510 	.word	0x080a9510
 80a6c24:	200003bc 	.word	0x200003bc
 80a6c28:	080a6c01 	.word	0x080a6c01

080a6c2c <pinAvailable>:

/*
 * @brief Perform safety check on desired pin to see if it's already
 * being used.  Return 0 if used, otherwise return 1 if available.
 */
bool pinAvailable(uint16_t pin) {
 80a6c2c:	b510      	push	{r4, lr}
 80a6c2e:	4604      	mov	r4, r0

  // SPI safety check
#ifndef SPARK_WIRING_NO_SPI
  if(SPI.isEnabled() == true && (pin == SCK || pin == MOSI || pin == MISO))
 80a6c30:	480f      	ldr	r0, [pc, #60]	; (80a6c70 <pinAvailable+0x44>)
 80a6c32:	f7fe fd9f 	bl	80a5774 <_ZN8SPIClass9isEnabledEv>
 80a6c36:	b128      	cbz	r0, 80a6c44 <pinAvailable+0x18>
 80a6c38:	f1a4 030d 	sub.w	r3, r4, #13
 80a6c3c:	2b02      	cmp	r3, #2
 80a6c3e:	d801      	bhi.n	80a6c44 <pinAvailable+0x18>
  {
    return 0; // 'pin' is used
 80a6c40:	2000      	movs	r0, #0
 80a6c42:	bd10      	pop	{r4, pc}
  }
#endif
  // I2C safety check
#ifndef SPARK_WIRING_NO_I2C
  if(Wire.isEnabled() == true && (pin == SCL || pin == SDA))
 80a6c44:	f000 f88e 	bl	80a6d64 <_Z19__fetch_global_Wirev>
 80a6c48:	f7ff ffd6 	bl	80a6bf8 <_ZN7TwoWire9isEnabledEv>
 80a6c4c:	b108      	cbz	r0, 80a6c52 <pinAvailable+0x26>
 80a6c4e:	2c01      	cmp	r4, #1
 80a6c50:	d9f6      	bls.n	80a6c40 <pinAvailable+0x14>
    return 0; // 'pin' is used
  }
#endif
#ifndef SPARK_WIRING_NO_USART_SERIAL
  // Serial1 safety check
  if(Serial1.isEnabled() == true && (pin == RX || pin == TX))
 80a6c52:	f7ff ff39 	bl	80a6ac8 <_Z22__fetch_global_Serial1v>
 80a6c56:	f7ff ff33 	bl	80a6ac0 <_ZN11USARTSerial9isEnabledEv>
 80a6c5a:	b118      	cbz	r0, 80a6c64 <pinAvailable+0x38>
 80a6c5c:	f1a4 0312 	sub.w	r3, r4, #18
 80a6c60:	2b01      	cmp	r3, #1
 80a6c62:	d9ed      	bls.n	80a6c40 <pinAvailable+0x14>
  {
    return 0; // 'pin' is used
  }
#endif

  if (pin >= TOTAL_PINS)
 80a6c64:	2c17      	cmp	r4, #23
 80a6c66:	bf8c      	ite	hi
 80a6c68:	2000      	movhi	r0, #0
 80a6c6a:	2001      	movls	r0, #1
    return 0;
  else
    return 1; // 'pin' is available
}
 80a6c6c:	bd10      	pop	{r4, pc}
 80a6c6e:	bf00      	nop
 80a6c70:	20001524 	.word	0x20001524

080a6c74 <pinMode>:
 * or INPUT_PULLDOWN
 */
void pinMode(uint16_t pin, PinMode setMode)
{

  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a6c74:	2817      	cmp	r0, #23
/*
 * @brief Set the mode of the pin to OUTPUT, INPUT, INPUT_PULLUP,
 * or INPUT_PULLDOWN
 */
void pinMode(uint16_t pin, PinMode setMode)
{
 80a6c76:	b538      	push	{r3, r4, r5, lr}
 80a6c78:	4604      	mov	r4, r0
 80a6c7a:	460d      	mov	r5, r1

  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a6c7c:	d80a      	bhi.n	80a6c94 <pinMode+0x20>
 80a6c7e:	29ff      	cmp	r1, #255	; 0xff
 80a6c80:	d008      	beq.n	80a6c94 <pinMode+0x20>
  {
    return;
  }

  // Safety check
  if( !pinAvailable(pin) ) {
 80a6c82:	f7ff ffd3 	bl	80a6c2c <pinAvailable>
 80a6c86:	b128      	cbz	r0, 80a6c94 <pinMode+0x20>
    return;
  }

  HAL_Pin_Mode(pin, setMode);
 80a6c88:	4629      	mov	r1, r5
 80a6c8a:	4620      	mov	r0, r4
}
 80a6c8c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  // Safety check
  if( !pinAvailable(pin) ) {
    return;
  }

  HAL_Pin_Mode(pin, setMode);
 80a6c90:	f7fe b962 	b.w	80a4f58 <HAL_Pin_Mode>
 80a6c94:	bd38      	pop	{r3, r4, r5, pc}

080a6c96 <digitalWrite>:

/*
 * @brief Sets a GPIO pin to HIGH or LOW.
 */
void digitalWrite(pin_t pin, uint8_t value)
{
 80a6c96:	b538      	push	{r3, r4, r5, lr}
 80a6c98:	4604      	mov	r4, r0
 80a6c9a:	460d      	mov	r5, r1
    PinMode mode = HAL_Get_Pin_Mode(pin);
 80a6c9c:	f7fe f964 	bl	80a4f68 <HAL_Get_Pin_Mode>
    if (mode==PIN_MODE_NONE || is_input_mode(mode))
 80a6ca0:	28ff      	cmp	r0, #255	; 0xff
 80a6ca2:	d010      	beq.n	80a6cc6 <digitalWrite+0x30>
}

inline bool is_input_mode(PinMode mode) {
    return  mode == INPUT ||
            mode == INPUT_PULLUP ||
            mode == INPUT_PULLDOWN ||
 80a6ca4:	2806      	cmp	r0, #6
 80a6ca6:	d804      	bhi.n	80a6cb2 <digitalWrite+0x1c>
 80a6ca8:	234d      	movs	r3, #77	; 0x4d
 80a6caa:	fa23 f000 	lsr.w	r0, r3, r0
 80a6cae:	07c3      	lsls	r3, r0, #31
 80a6cb0:	d409      	bmi.n	80a6cc6 <digitalWrite+0x30>
{
    PinMode mode = HAL_Get_Pin_Mode(pin);
    if (mode==PIN_MODE_NONE || is_input_mode(mode))
        return;
  // Safety check
  if( !pinAvailable(pin) ) {
 80a6cb2:	4620      	mov	r0, r4
 80a6cb4:	f7ff ffba 	bl	80a6c2c <pinAvailable>
 80a6cb8:	b128      	cbz	r0, 80a6cc6 <digitalWrite+0x30>
    return;
  }

  HAL_GPIO_Write(pin, value);
 80a6cba:	4629      	mov	r1, r5
 80a6cbc:	4620      	mov	r0, r4
}
 80a6cbe:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  // Safety check
  if( !pinAvailable(pin) ) {
    return;
  }

  HAL_GPIO_Write(pin, value);
 80a6cc2:	f7fe b959 	b.w	80a4f78 <HAL_GPIO_Write>
 80a6cc6:	bd38      	pop	{r3, r4, r5, pc}

080a6cc8 <digitalRead>:

/*
 * @brief Reads the value of a GPIO pin. Should return either 1 (HIGH) or 0 (LOW).
 */
int32_t digitalRead(pin_t pin)
{
 80a6cc8:	b510      	push	{r4, lr}
 80a6cca:	4604      	mov	r4, r0
    PinMode mode = HAL_Get_Pin_Mode(pin);
 80a6ccc:	f7fe f94c 	bl	80a4f68 <HAL_Get_Pin_Mode>
    if (is_af_output_mode(mode))
 80a6cd0:	3804      	subs	r0, #4
 80a6cd2:	b2c0      	uxtb	r0, r0
 80a6cd4:	2801      	cmp	r0, #1
 80a6cd6:	d908      	bls.n	80a6cea <digitalRead+0x22>
        return LOW;

    // Safety check
    if( !pinAvailable(pin) ) {
 80a6cd8:	4620      	mov	r0, r4
 80a6cda:	f7ff ffa7 	bl	80a6c2c <pinAvailable>
 80a6cde:	b120      	cbz	r0, 80a6cea <digitalRead+0x22>
      return LOW;
    }

    return HAL_GPIO_Read(pin);
 80a6ce0:	4620      	mov	r0, r4
}
 80a6ce2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    // Safety check
    if( !pinAvailable(pin) ) {
      return LOW;
    }

    return HAL_GPIO_Read(pin);
 80a6ce6:	f7fe b94f 	b.w	80a4f88 <HAL_GPIO_Read>
}
 80a6cea:	2000      	movs	r0, #0
 80a6cec:	bd10      	pop	{r4, pc}
	...

080a6cf0 <_GLOBAL__sub_I_SPI>:
#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a6cf0:	b570      	push	{r4, r5, r6, lr}
#include "core_hal.h"
#include "spark_macros.h"

#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);
 80a6cf2:	4c0c      	ldr	r4, [pc, #48]	; (80a6d24 <_GLOBAL__sub_I_SPI+0x34>)
 80a6cf4:	4e0c      	ldr	r6, [pc, #48]	; (80a6d28 <_GLOBAL__sub_I_SPI+0x38>)
 80a6cf6:	4d0d      	ldr	r5, [pc, #52]	; (80a6d2c <_GLOBAL__sub_I_SPI+0x3c>)
 80a6cf8:	2100      	movs	r1, #0
 80a6cfa:	4620      	mov	r0, r4
 80a6cfc:	f7fe fc42 	bl	80a5584 <_ZN8SPIClassC1E17HAL_SPI_Interface>
 80a6d00:	4620      	mov	r0, r4

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a6d02:	4c0b      	ldr	r4, [pc, #44]	; (80a6d30 <_GLOBAL__sub_I_SPI+0x40>)
#include "core_hal.h"
#include "spark_macros.h"

#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);
 80a6d04:	4632      	mov	r2, r6
 80a6d06:	4629      	mov	r1, r5
 80a6d08:	f000 f84c 	bl	80a6da4 <__aeabi_atexit>

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a6d0c:	2101      	movs	r1, #1
 80a6d0e:	4620      	mov	r0, r4
 80a6d10:	f7fe fc38 	bl	80a5584 <_ZN8SPIClassC1E17HAL_SPI_Interface>
 80a6d14:	4632      	mov	r2, r6
 80a6d16:	4629      	mov	r1, r5
 80a6d18:	4620      	mov	r0, r4
 80a6d1a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 80a6d1e:	f000 b841 	b.w	80a6da4 <__aeabi_atexit>
 80a6d22:	bf00      	nop
 80a6d24:	20001524 	.word	0x20001524
 80a6d28:	200003bc 	.word	0x200003bc
 80a6d2c:	080a5575 	.word	0x080a5575
 80a6d30:	20001534 	.word	0x20001534

080a6d34 <_GLOBAL__sub_I_INADDR_NONE>:
#include "spark_wiring_ipaddress.h"

const IPAddress INADDR_NONE(0, 0, 0, 0);
 80a6d34:	b513      	push	{r0, r1, r4, lr}
 80a6d36:	4c08      	ldr	r4, [pc, #32]	; (80a6d58 <_GLOBAL__sub_I_INADDR_NONE+0x24>)
 80a6d38:	2300      	movs	r3, #0
 80a6d3a:	461a      	mov	r2, r3
 80a6d3c:	4619      	mov	r1, r3
 80a6d3e:	9300      	str	r3, [sp, #0]
 80a6d40:	4620      	mov	r0, r4
 80a6d42:	f7ff fda5 	bl	80a6890 <_ZN9IPAddressC1Ehhhh>
 80a6d46:	4620      	mov	r0, r4
 80a6d48:	4a04      	ldr	r2, [pc, #16]	; (80a6d5c <_GLOBAL__sub_I_INADDR_NONE+0x28>)
 80a6d4a:	4905      	ldr	r1, [pc, #20]	; (80a6d60 <_GLOBAL__sub_I_INADDR_NONE+0x2c>)
 80a6d4c:	b002      	add	sp, #8
 80a6d4e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a6d52:	f000 b827 	b.w	80a6da4 <__aeabi_atexit>
 80a6d56:	bf00      	nop
 80a6d58:	20001548 	.word	0x20001548
 80a6d5c:	200003bc 	.word	0x200003bc
 80a6d60:	080a67f5 	.word	0x080a67f5

080a6d64 <_Z19__fetch_global_Wirev>:
#include "i2c_hal.h"

#ifndef SPARK_WIRING_NO_I2C

TwoWire& __fetch_global_Wire()
{
 80a6d64:	b538      	push	{r3, r4, r5, lr}
	static TwoWire wire(HAL_I2C_INTERFACE1);
 80a6d66:	4d0b      	ldr	r5, [pc, #44]	; (80a6d94 <_Z19__fetch_global_Wirev+0x30>)
 80a6d68:	6829      	ldr	r1, [r5, #0]
 80a6d6a:	f011 0401 	ands.w	r4, r1, #1
 80a6d6e:	d10f      	bne.n	80a6d90 <_Z19__fetch_global_Wirev+0x2c>
 80a6d70:	4628      	mov	r0, r5
 80a6d72:	f7f9 f9a3 	bl	80a00bc <__cxa_guard_acquire>
 80a6d76:	b158      	cbz	r0, 80a6d90 <_Z19__fetch_global_Wirev+0x2c>
 80a6d78:	4621      	mov	r1, r4
 80a6d7a:	4807      	ldr	r0, [pc, #28]	; (80a6d98 <_Z19__fetch_global_Wirev+0x34>)
 80a6d7c:	f7ff ff08 	bl	80a6b90 <_ZN7TwoWireC1E17HAL_I2C_Interface>
 80a6d80:	4628      	mov	r0, r5
 80a6d82:	f7f9 f9a0 	bl	80a00c6 <__cxa_guard_release>
 80a6d86:	4a05      	ldr	r2, [pc, #20]	; (80a6d9c <_Z19__fetch_global_Wirev+0x38>)
 80a6d88:	4905      	ldr	r1, [pc, #20]	; (80a6da0 <_Z19__fetch_global_Wirev+0x3c>)
 80a6d8a:	4803      	ldr	r0, [pc, #12]	; (80a6d98 <_Z19__fetch_global_Wirev+0x34>)
 80a6d8c:	f000 f80a 	bl	80a6da4 <__aeabi_atexit>
	return wire;
}
 80a6d90:	4801      	ldr	r0, [pc, #4]	; (80a6d98 <_Z19__fetch_global_Wirev+0x34>)
 80a6d92:	bd38      	pop	{r3, r4, r5, pc}
 80a6d94:	20001560 	.word	0x20001560
 80a6d98:	20001564 	.word	0x20001564
 80a6d9c:	200003bc 	.word	0x200003bc
 80a6da0:	080a6b3b 	.word	0x080a6b3b

080a6da4 <__aeabi_atexit>:
 80a6da4:	460b      	mov	r3, r1
 80a6da6:	4601      	mov	r1, r0
 80a6da8:	4618      	mov	r0, r3
 80a6daa:	f000 bc45 	b.w	80a7638 <__cxa_atexit>

080a6dae <_ZSt25__throw_bad_function_callv>:
 80a6dae:	b508      	push	{r3, lr}
 80a6db0:	f7fe fbd0 	bl	80a5554 <abort>

080a6db4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj>:
 80a6db4:	4b18      	ldr	r3, [pc, #96]	; (80a6e18 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x64>)
 80a6db6:	681a      	ldr	r2, [r3, #0]
 80a6db8:	07d1      	lsls	r1, r2, #31
 80a6dba:	bf5c      	itt	pl
 80a6dbc:	2201      	movpl	r2, #1
 80a6dbe:	601a      	strpl	r2, [r3, #0]
 80a6dc0:	4b16      	ldr	r3, [pc, #88]	; (80a6e1c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x68>)
 80a6dc2:	681a      	ldr	r2, [r3, #0]
 80a6dc4:	07d2      	lsls	r2, r2, #31
 80a6dc6:	bf5c      	itt	pl
 80a6dc8:	2201      	movpl	r2, #1
 80a6dca:	601a      	strpl	r2, [r3, #0]
 80a6dcc:	4b14      	ldr	r3, [pc, #80]	; (80a6e20 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x6c>)
 80a6dce:	681a      	ldr	r2, [r3, #0]
 80a6dd0:	07d0      	lsls	r0, r2, #31
 80a6dd2:	bf5c      	itt	pl
 80a6dd4:	2201      	movpl	r2, #1
 80a6dd6:	601a      	strpl	r2, [r3, #0]
 80a6dd8:	4b12      	ldr	r3, [pc, #72]	; (80a6e24 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x70>)
 80a6dda:	681a      	ldr	r2, [r3, #0]
 80a6ddc:	07d1      	lsls	r1, r2, #31
 80a6dde:	bf5c      	itt	pl
 80a6de0:	2201      	movpl	r2, #1
 80a6de2:	601a      	strpl	r2, [r3, #0]
 80a6de4:	4b10      	ldr	r3, [pc, #64]	; (80a6e28 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x74>)
 80a6de6:	681a      	ldr	r2, [r3, #0]
 80a6de8:	07d2      	lsls	r2, r2, #31
 80a6dea:	bf5c      	itt	pl
 80a6dec:	2201      	movpl	r2, #1
 80a6dee:	601a      	strpl	r2, [r3, #0]
 80a6df0:	4b0e      	ldr	r3, [pc, #56]	; (80a6e2c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x78>)
 80a6df2:	681a      	ldr	r2, [r3, #0]
 80a6df4:	07d0      	lsls	r0, r2, #31
 80a6df6:	bf5c      	itt	pl
 80a6df8:	2201      	movpl	r2, #1
 80a6dfa:	601a      	strpl	r2, [r3, #0]
 80a6dfc:	4b0c      	ldr	r3, [pc, #48]	; (80a6e30 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x7c>)
 80a6dfe:	681a      	ldr	r2, [r3, #0]
 80a6e00:	07d1      	lsls	r1, r2, #31
 80a6e02:	bf5c      	itt	pl
 80a6e04:	2201      	movpl	r2, #1
 80a6e06:	601a      	strpl	r2, [r3, #0]
 80a6e08:	4b0a      	ldr	r3, [pc, #40]	; (80a6e34 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x80>)
 80a6e0a:	681a      	ldr	r2, [r3, #0]
 80a6e0c:	07d2      	lsls	r2, r2, #31
 80a6e0e:	bf5c      	itt	pl
 80a6e10:	2201      	movpl	r2, #1
 80a6e12:	601a      	strpl	r2, [r3, #0]
 80a6e14:	4770      	bx	lr
 80a6e16:	bf00      	nop
 80a6e18:	20001594 	.word	0x20001594
 80a6e1c:	20001590 	.word	0x20001590
 80a6e20:	2000158c 	.word	0x2000158c
 80a6e24:	20001588 	.word	0x20001588
 80a6e28:	20001584 	.word	0x20001584
 80a6e2c:	20001580 	.word	0x20001580
 80a6e30:	2000157c 	.word	0x2000157c
 80a6e34:	20001578 	.word	0x20001578

080a6e38 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj>:
 80a6e38:	4b24      	ldr	r3, [pc, #144]	; (80a6ecc <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x94>)
 80a6e3a:	681a      	ldr	r2, [r3, #0]
 80a6e3c:	07d0      	lsls	r0, r2, #31
 80a6e3e:	bf5c      	itt	pl
 80a6e40:	2201      	movpl	r2, #1
 80a6e42:	601a      	strpl	r2, [r3, #0]
 80a6e44:	4b22      	ldr	r3, [pc, #136]	; (80a6ed0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x98>)
 80a6e46:	681a      	ldr	r2, [r3, #0]
 80a6e48:	07d1      	lsls	r1, r2, #31
 80a6e4a:	bf5c      	itt	pl
 80a6e4c:	2201      	movpl	r2, #1
 80a6e4e:	601a      	strpl	r2, [r3, #0]
 80a6e50:	4b20      	ldr	r3, [pc, #128]	; (80a6ed4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x9c>)
 80a6e52:	681a      	ldr	r2, [r3, #0]
 80a6e54:	07d2      	lsls	r2, r2, #31
 80a6e56:	bf5c      	itt	pl
 80a6e58:	2201      	movpl	r2, #1
 80a6e5a:	601a      	strpl	r2, [r3, #0]
 80a6e5c:	4b1e      	ldr	r3, [pc, #120]	; (80a6ed8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa0>)
 80a6e5e:	681a      	ldr	r2, [r3, #0]
 80a6e60:	07d0      	lsls	r0, r2, #31
 80a6e62:	bf5c      	itt	pl
 80a6e64:	2201      	movpl	r2, #1
 80a6e66:	601a      	strpl	r2, [r3, #0]
 80a6e68:	4b1c      	ldr	r3, [pc, #112]	; (80a6edc <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa4>)
 80a6e6a:	681a      	ldr	r2, [r3, #0]
 80a6e6c:	07d1      	lsls	r1, r2, #31
 80a6e6e:	bf5c      	itt	pl
 80a6e70:	2201      	movpl	r2, #1
 80a6e72:	601a      	strpl	r2, [r3, #0]
 80a6e74:	4b1a      	ldr	r3, [pc, #104]	; (80a6ee0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa8>)
 80a6e76:	681a      	ldr	r2, [r3, #0]
 80a6e78:	07d2      	lsls	r2, r2, #31
 80a6e7a:	bf5c      	itt	pl
 80a6e7c:	2201      	movpl	r2, #1
 80a6e7e:	601a      	strpl	r2, [r3, #0]
 80a6e80:	4b18      	ldr	r3, [pc, #96]	; (80a6ee4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xac>)
 80a6e82:	681a      	ldr	r2, [r3, #0]
 80a6e84:	07d0      	lsls	r0, r2, #31
 80a6e86:	bf5c      	itt	pl
 80a6e88:	2201      	movpl	r2, #1
 80a6e8a:	601a      	strpl	r2, [r3, #0]
 80a6e8c:	4b16      	ldr	r3, [pc, #88]	; (80a6ee8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb0>)
 80a6e8e:	681a      	ldr	r2, [r3, #0]
 80a6e90:	07d1      	lsls	r1, r2, #31
 80a6e92:	bf5c      	itt	pl
 80a6e94:	2201      	movpl	r2, #1
 80a6e96:	601a      	strpl	r2, [r3, #0]
 80a6e98:	4b14      	ldr	r3, [pc, #80]	; (80a6eec <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb4>)
 80a6e9a:	681a      	ldr	r2, [r3, #0]
 80a6e9c:	07d2      	lsls	r2, r2, #31
 80a6e9e:	bf5c      	itt	pl
 80a6ea0:	2201      	movpl	r2, #1
 80a6ea2:	601a      	strpl	r2, [r3, #0]
 80a6ea4:	4b12      	ldr	r3, [pc, #72]	; (80a6ef0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb8>)
 80a6ea6:	681a      	ldr	r2, [r3, #0]
 80a6ea8:	07d0      	lsls	r0, r2, #31
 80a6eaa:	bf5c      	itt	pl
 80a6eac:	2201      	movpl	r2, #1
 80a6eae:	601a      	strpl	r2, [r3, #0]
 80a6eb0:	4b10      	ldr	r3, [pc, #64]	; (80a6ef4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xbc>)
 80a6eb2:	681a      	ldr	r2, [r3, #0]
 80a6eb4:	07d1      	lsls	r1, r2, #31
 80a6eb6:	bf5c      	itt	pl
 80a6eb8:	2201      	movpl	r2, #1
 80a6eba:	601a      	strpl	r2, [r3, #0]
 80a6ebc:	4b0e      	ldr	r3, [pc, #56]	; (80a6ef8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xc0>)
 80a6ebe:	681a      	ldr	r2, [r3, #0]
 80a6ec0:	07d2      	lsls	r2, r2, #31
 80a6ec2:	bf5c      	itt	pl
 80a6ec4:	2201      	movpl	r2, #1
 80a6ec6:	601a      	strpl	r2, [r3, #0]
 80a6ec8:	4770      	bx	lr
 80a6eca:	bf00      	nop
 80a6ecc:	200015c4 	.word	0x200015c4
 80a6ed0:	200015c0 	.word	0x200015c0
 80a6ed4:	200015bc 	.word	0x200015bc
 80a6ed8:	200015b8 	.word	0x200015b8
 80a6edc:	200015b4 	.word	0x200015b4
 80a6ee0:	200015b0 	.word	0x200015b0
 80a6ee4:	200015ac 	.word	0x200015ac
 80a6ee8:	200015a8 	.word	0x200015a8
 80a6eec:	200015a4 	.word	0x200015a4
 80a6ef0:	200015a0 	.word	0x200015a0
 80a6ef4:	2000159c 	.word	0x2000159c
 80a6ef8:	20001598 	.word	0x20001598

080a6efc <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj>:
 80a6efc:	4b24      	ldr	r3, [pc, #144]	; (80a6f90 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x94>)
 80a6efe:	681a      	ldr	r2, [r3, #0]
 80a6f00:	07d0      	lsls	r0, r2, #31
 80a6f02:	bf5c      	itt	pl
 80a6f04:	2201      	movpl	r2, #1
 80a6f06:	601a      	strpl	r2, [r3, #0]
 80a6f08:	4b22      	ldr	r3, [pc, #136]	; (80a6f94 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x98>)
 80a6f0a:	681a      	ldr	r2, [r3, #0]
 80a6f0c:	07d1      	lsls	r1, r2, #31
 80a6f0e:	bf5c      	itt	pl
 80a6f10:	2201      	movpl	r2, #1
 80a6f12:	601a      	strpl	r2, [r3, #0]
 80a6f14:	4b20      	ldr	r3, [pc, #128]	; (80a6f98 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x9c>)
 80a6f16:	681a      	ldr	r2, [r3, #0]
 80a6f18:	07d2      	lsls	r2, r2, #31
 80a6f1a:	bf5c      	itt	pl
 80a6f1c:	2201      	movpl	r2, #1
 80a6f1e:	601a      	strpl	r2, [r3, #0]
 80a6f20:	4b1e      	ldr	r3, [pc, #120]	; (80a6f9c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa0>)
 80a6f22:	681a      	ldr	r2, [r3, #0]
 80a6f24:	07d0      	lsls	r0, r2, #31
 80a6f26:	bf5c      	itt	pl
 80a6f28:	2201      	movpl	r2, #1
 80a6f2a:	601a      	strpl	r2, [r3, #0]
 80a6f2c:	4b1c      	ldr	r3, [pc, #112]	; (80a6fa0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa4>)
 80a6f2e:	681a      	ldr	r2, [r3, #0]
 80a6f30:	07d1      	lsls	r1, r2, #31
 80a6f32:	bf5c      	itt	pl
 80a6f34:	2201      	movpl	r2, #1
 80a6f36:	601a      	strpl	r2, [r3, #0]
 80a6f38:	4b1a      	ldr	r3, [pc, #104]	; (80a6fa4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa8>)
 80a6f3a:	681a      	ldr	r2, [r3, #0]
 80a6f3c:	07d2      	lsls	r2, r2, #31
 80a6f3e:	bf5c      	itt	pl
 80a6f40:	2201      	movpl	r2, #1
 80a6f42:	601a      	strpl	r2, [r3, #0]
 80a6f44:	4b18      	ldr	r3, [pc, #96]	; (80a6fa8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xac>)
 80a6f46:	681a      	ldr	r2, [r3, #0]
 80a6f48:	07d0      	lsls	r0, r2, #31
 80a6f4a:	bf5c      	itt	pl
 80a6f4c:	2201      	movpl	r2, #1
 80a6f4e:	601a      	strpl	r2, [r3, #0]
 80a6f50:	4b16      	ldr	r3, [pc, #88]	; (80a6fac <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb0>)
 80a6f52:	681a      	ldr	r2, [r3, #0]
 80a6f54:	07d1      	lsls	r1, r2, #31
 80a6f56:	bf5c      	itt	pl
 80a6f58:	2201      	movpl	r2, #1
 80a6f5a:	601a      	strpl	r2, [r3, #0]
 80a6f5c:	4b14      	ldr	r3, [pc, #80]	; (80a6fb0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb4>)
 80a6f5e:	681a      	ldr	r2, [r3, #0]
 80a6f60:	07d2      	lsls	r2, r2, #31
 80a6f62:	bf5c      	itt	pl
 80a6f64:	2201      	movpl	r2, #1
 80a6f66:	601a      	strpl	r2, [r3, #0]
 80a6f68:	4b12      	ldr	r3, [pc, #72]	; (80a6fb4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb8>)
 80a6f6a:	681a      	ldr	r2, [r3, #0]
 80a6f6c:	07d0      	lsls	r0, r2, #31
 80a6f6e:	bf5c      	itt	pl
 80a6f70:	2201      	movpl	r2, #1
 80a6f72:	601a      	strpl	r2, [r3, #0]
 80a6f74:	4b10      	ldr	r3, [pc, #64]	; (80a6fb8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xbc>)
 80a6f76:	681a      	ldr	r2, [r3, #0]
 80a6f78:	07d1      	lsls	r1, r2, #31
 80a6f7a:	bf5c      	itt	pl
 80a6f7c:	2201      	movpl	r2, #1
 80a6f7e:	601a      	strpl	r2, [r3, #0]
 80a6f80:	4b0e      	ldr	r3, [pc, #56]	; (80a6fbc <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xc0>)
 80a6f82:	681a      	ldr	r2, [r3, #0]
 80a6f84:	07d2      	lsls	r2, r2, #31
 80a6f86:	bf5c      	itt	pl
 80a6f88:	2201      	movpl	r2, #1
 80a6f8a:	601a      	strpl	r2, [r3, #0]
 80a6f8c:	4770      	bx	lr
 80a6f8e:	bf00      	nop
 80a6f90:	200015f4 	.word	0x200015f4
 80a6f94:	200015f0 	.word	0x200015f0
 80a6f98:	200015ec 	.word	0x200015ec
 80a6f9c:	200015e8 	.word	0x200015e8
 80a6fa0:	200015e4 	.word	0x200015e4
 80a6fa4:	200015e0 	.word	0x200015e0
 80a6fa8:	200015dc 	.word	0x200015dc
 80a6fac:	200015d8 	.word	0x200015d8
 80a6fb0:	200015d4 	.word	0x200015d4
 80a6fb4:	200015d0 	.word	0x200015d0
 80a6fb8:	200015cc 	.word	0x200015cc
 80a6fbc:	200015c8 	.word	0x200015c8

080a6fc0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj>:
 80a6fc0:	4b18      	ldr	r3, [pc, #96]	; (80a7024 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x64>)
 80a6fc2:	681a      	ldr	r2, [r3, #0]
 80a6fc4:	07d1      	lsls	r1, r2, #31
 80a6fc6:	bf5c      	itt	pl
 80a6fc8:	2201      	movpl	r2, #1
 80a6fca:	601a      	strpl	r2, [r3, #0]
 80a6fcc:	4b16      	ldr	r3, [pc, #88]	; (80a7028 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x68>)
 80a6fce:	681a      	ldr	r2, [r3, #0]
 80a6fd0:	07d2      	lsls	r2, r2, #31
 80a6fd2:	bf5c      	itt	pl
 80a6fd4:	2201      	movpl	r2, #1
 80a6fd6:	601a      	strpl	r2, [r3, #0]
 80a6fd8:	4b14      	ldr	r3, [pc, #80]	; (80a702c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x6c>)
 80a6fda:	681a      	ldr	r2, [r3, #0]
 80a6fdc:	07d0      	lsls	r0, r2, #31
 80a6fde:	bf5c      	itt	pl
 80a6fe0:	2201      	movpl	r2, #1
 80a6fe2:	601a      	strpl	r2, [r3, #0]
 80a6fe4:	4b12      	ldr	r3, [pc, #72]	; (80a7030 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x70>)
 80a6fe6:	681a      	ldr	r2, [r3, #0]
 80a6fe8:	07d1      	lsls	r1, r2, #31
 80a6fea:	bf5c      	itt	pl
 80a6fec:	2201      	movpl	r2, #1
 80a6fee:	601a      	strpl	r2, [r3, #0]
 80a6ff0:	4b10      	ldr	r3, [pc, #64]	; (80a7034 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x74>)
 80a6ff2:	681a      	ldr	r2, [r3, #0]
 80a6ff4:	07d2      	lsls	r2, r2, #31
 80a6ff6:	bf5c      	itt	pl
 80a6ff8:	2201      	movpl	r2, #1
 80a6ffa:	601a      	strpl	r2, [r3, #0]
 80a6ffc:	4b0e      	ldr	r3, [pc, #56]	; (80a7038 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x78>)
 80a6ffe:	681a      	ldr	r2, [r3, #0]
 80a7000:	07d0      	lsls	r0, r2, #31
 80a7002:	bf5c      	itt	pl
 80a7004:	2201      	movpl	r2, #1
 80a7006:	601a      	strpl	r2, [r3, #0]
 80a7008:	4b0c      	ldr	r3, [pc, #48]	; (80a703c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x7c>)
 80a700a:	681a      	ldr	r2, [r3, #0]
 80a700c:	07d1      	lsls	r1, r2, #31
 80a700e:	bf5c      	itt	pl
 80a7010:	2201      	movpl	r2, #1
 80a7012:	601a      	strpl	r2, [r3, #0]
 80a7014:	4b0a      	ldr	r3, [pc, #40]	; (80a7040 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x80>)
 80a7016:	681a      	ldr	r2, [r3, #0]
 80a7018:	07d2      	lsls	r2, r2, #31
 80a701a:	bf5c      	itt	pl
 80a701c:	2201      	movpl	r2, #1
 80a701e:	601a      	strpl	r2, [r3, #0]
 80a7020:	4770      	bx	lr
 80a7022:	bf00      	nop
 80a7024:	20001614 	.word	0x20001614
 80a7028:	20001610 	.word	0x20001610
 80a702c:	2000160c 	.word	0x2000160c
 80a7030:	20001608 	.word	0x20001608
 80a7034:	20001604 	.word	0x20001604
 80a7038:	20001600 	.word	0x20001600
 80a703c:	200015fc 	.word	0x200015fc
 80a7040:	200015f8 	.word	0x200015f8

080a7044 <__aeabi_frsub>:
 80a7044:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
 80a7048:	e002      	b.n	80a7050 <__addsf3>
 80a704a:	bf00      	nop

080a704c <__aeabi_fsub>:
 80a704c:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

080a7050 <__addsf3>:
 80a7050:	0042      	lsls	r2, r0, #1
 80a7052:	bf1f      	itttt	ne
 80a7054:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 80a7058:	ea92 0f03 	teqne	r2, r3
 80a705c:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 80a7060:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80a7064:	d06a      	beq.n	80a713c <__addsf3+0xec>
 80a7066:	ea4f 6212 	mov.w	r2, r2, lsr #24
 80a706a:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 80a706e:	bfc1      	itttt	gt
 80a7070:	18d2      	addgt	r2, r2, r3
 80a7072:	4041      	eorgt	r1, r0
 80a7074:	4048      	eorgt	r0, r1
 80a7076:	4041      	eorgt	r1, r0
 80a7078:	bfb8      	it	lt
 80a707a:	425b      	neglt	r3, r3
 80a707c:	2b19      	cmp	r3, #25
 80a707e:	bf88      	it	hi
 80a7080:	4770      	bxhi	lr
 80a7082:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 80a7086:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a708a:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 80a708e:	bf18      	it	ne
 80a7090:	4240      	negne	r0, r0
 80a7092:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80a7096:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 80a709a:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 80a709e:	bf18      	it	ne
 80a70a0:	4249      	negne	r1, r1
 80a70a2:	ea92 0f03 	teq	r2, r3
 80a70a6:	d03f      	beq.n	80a7128 <__addsf3+0xd8>
 80a70a8:	f1a2 0201 	sub.w	r2, r2, #1
 80a70ac:	fa41 fc03 	asr.w	ip, r1, r3
 80a70b0:	eb10 000c 	adds.w	r0, r0, ip
 80a70b4:	f1c3 0320 	rsb	r3, r3, #32
 80a70b8:	fa01 f103 	lsl.w	r1, r1, r3
 80a70bc:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 80a70c0:	d502      	bpl.n	80a70c8 <__addsf3+0x78>
 80a70c2:	4249      	negs	r1, r1
 80a70c4:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 80a70c8:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 80a70cc:	d313      	bcc.n	80a70f6 <__addsf3+0xa6>
 80a70ce:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 80a70d2:	d306      	bcc.n	80a70e2 <__addsf3+0x92>
 80a70d4:	0840      	lsrs	r0, r0, #1
 80a70d6:	ea4f 0131 	mov.w	r1, r1, rrx
 80a70da:	f102 0201 	add.w	r2, r2, #1
 80a70de:	2afe      	cmp	r2, #254	; 0xfe
 80a70e0:	d251      	bcs.n	80a7186 <__addsf3+0x136>
 80a70e2:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 80a70e6:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80a70ea:	bf08      	it	eq
 80a70ec:	f020 0001 	biceq.w	r0, r0, #1
 80a70f0:	ea40 0003 	orr.w	r0, r0, r3
 80a70f4:	4770      	bx	lr
 80a70f6:	0049      	lsls	r1, r1, #1
 80a70f8:	eb40 0000 	adc.w	r0, r0, r0
 80a70fc:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
 80a7100:	f1a2 0201 	sub.w	r2, r2, #1
 80a7104:	d1ed      	bne.n	80a70e2 <__addsf3+0x92>
 80a7106:	fab0 fc80 	clz	ip, r0
 80a710a:	f1ac 0c08 	sub.w	ip, ip, #8
 80a710e:	ebb2 020c 	subs.w	r2, r2, ip
 80a7112:	fa00 f00c 	lsl.w	r0, r0, ip
 80a7116:	bfaa      	itet	ge
 80a7118:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 80a711c:	4252      	neglt	r2, r2
 80a711e:	4318      	orrge	r0, r3
 80a7120:	bfbc      	itt	lt
 80a7122:	40d0      	lsrlt	r0, r2
 80a7124:	4318      	orrlt	r0, r3
 80a7126:	4770      	bx	lr
 80a7128:	f092 0f00 	teq	r2, #0
 80a712c:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
 80a7130:	bf06      	itte	eq
 80a7132:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
 80a7136:	3201      	addeq	r2, #1
 80a7138:	3b01      	subne	r3, #1
 80a713a:	e7b5      	b.n	80a70a8 <__addsf3+0x58>
 80a713c:	ea4f 0341 	mov.w	r3, r1, lsl #1
 80a7140:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 80a7144:	bf18      	it	ne
 80a7146:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80a714a:	d021      	beq.n	80a7190 <__addsf3+0x140>
 80a714c:	ea92 0f03 	teq	r2, r3
 80a7150:	d004      	beq.n	80a715c <__addsf3+0x10c>
 80a7152:	f092 0f00 	teq	r2, #0
 80a7156:	bf08      	it	eq
 80a7158:	4608      	moveq	r0, r1
 80a715a:	4770      	bx	lr
 80a715c:	ea90 0f01 	teq	r0, r1
 80a7160:	bf1c      	itt	ne
 80a7162:	2000      	movne	r0, #0
 80a7164:	4770      	bxne	lr
 80a7166:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
 80a716a:	d104      	bne.n	80a7176 <__addsf3+0x126>
 80a716c:	0040      	lsls	r0, r0, #1
 80a716e:	bf28      	it	cs
 80a7170:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
 80a7174:	4770      	bx	lr
 80a7176:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 80a717a:	bf3c      	itt	cc
 80a717c:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
 80a7180:	4770      	bxcc	lr
 80a7182:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 80a7186:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
 80a718a:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a718e:	4770      	bx	lr
 80a7190:	ea7f 6222 	mvns.w	r2, r2, asr #24
 80a7194:	bf16      	itet	ne
 80a7196:	4608      	movne	r0, r1
 80a7198:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 80a719c:	4601      	movne	r1, r0
 80a719e:	0242      	lsls	r2, r0, #9
 80a71a0:	bf06      	itte	eq
 80a71a2:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 80a71a6:	ea90 0f01 	teqeq	r0, r1
 80a71aa:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
 80a71ae:	4770      	bx	lr

080a71b0 <__aeabi_ui2f>:
 80a71b0:	f04f 0300 	mov.w	r3, #0
 80a71b4:	e004      	b.n	80a71c0 <__aeabi_i2f+0x8>
 80a71b6:	bf00      	nop

080a71b8 <__aeabi_i2f>:
 80a71b8:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
 80a71bc:	bf48      	it	mi
 80a71be:	4240      	negmi	r0, r0
 80a71c0:	ea5f 0c00 	movs.w	ip, r0
 80a71c4:	bf08      	it	eq
 80a71c6:	4770      	bxeq	lr
 80a71c8:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
 80a71cc:	4601      	mov	r1, r0
 80a71ce:	f04f 0000 	mov.w	r0, #0
 80a71d2:	e01c      	b.n	80a720e <__aeabi_l2f+0x2a>

080a71d4 <__aeabi_ul2f>:
 80a71d4:	ea50 0201 	orrs.w	r2, r0, r1
 80a71d8:	bf08      	it	eq
 80a71da:	4770      	bxeq	lr
 80a71dc:	f04f 0300 	mov.w	r3, #0
 80a71e0:	e00a      	b.n	80a71f8 <__aeabi_l2f+0x14>
 80a71e2:	bf00      	nop

080a71e4 <__aeabi_l2f>:
 80a71e4:	ea50 0201 	orrs.w	r2, r0, r1
 80a71e8:	bf08      	it	eq
 80a71ea:	4770      	bxeq	lr
 80a71ec:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
 80a71f0:	d502      	bpl.n	80a71f8 <__aeabi_l2f+0x14>
 80a71f2:	4240      	negs	r0, r0
 80a71f4:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80a71f8:	ea5f 0c01 	movs.w	ip, r1
 80a71fc:	bf02      	ittt	eq
 80a71fe:	4684      	moveq	ip, r0
 80a7200:	4601      	moveq	r1, r0
 80a7202:	2000      	moveq	r0, #0
 80a7204:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
 80a7208:	bf08      	it	eq
 80a720a:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
 80a720e:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 80a7212:	fabc f28c 	clz	r2, ip
 80a7216:	3a08      	subs	r2, #8
 80a7218:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 80a721c:	db10      	blt.n	80a7240 <__aeabi_l2f+0x5c>
 80a721e:	fa01 fc02 	lsl.w	ip, r1, r2
 80a7222:	4463      	add	r3, ip
 80a7224:	fa00 fc02 	lsl.w	ip, r0, r2
 80a7228:	f1c2 0220 	rsb	r2, r2, #32
 80a722c:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80a7230:	fa20 f202 	lsr.w	r2, r0, r2
 80a7234:	eb43 0002 	adc.w	r0, r3, r2
 80a7238:	bf08      	it	eq
 80a723a:	f020 0001 	biceq.w	r0, r0, #1
 80a723e:	4770      	bx	lr
 80a7240:	f102 0220 	add.w	r2, r2, #32
 80a7244:	fa01 fc02 	lsl.w	ip, r1, r2
 80a7248:	f1c2 0220 	rsb	r2, r2, #32
 80a724c:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 80a7250:	fa21 f202 	lsr.w	r2, r1, r2
 80a7254:	eb43 0002 	adc.w	r0, r3, r2
 80a7258:	bf08      	it	eq
 80a725a:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 80a725e:	4770      	bx	lr

080a7260 <__aeabi_fmul>:
 80a7260:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80a7264:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 80a7268:	bf1e      	ittt	ne
 80a726a:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 80a726e:	ea92 0f0c 	teqne	r2, ip
 80a7272:	ea93 0f0c 	teqne	r3, ip
 80a7276:	d06f      	beq.n	80a7358 <__aeabi_fmul+0xf8>
 80a7278:	441a      	add	r2, r3
 80a727a:	ea80 0c01 	eor.w	ip, r0, r1
 80a727e:	0240      	lsls	r0, r0, #9
 80a7280:	bf18      	it	ne
 80a7282:	ea5f 2141 	movsne.w	r1, r1, lsl #9
 80a7286:	d01e      	beq.n	80a72c6 <__aeabi_fmul+0x66>
 80a7288:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 80a728c:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
 80a7290:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
 80a7294:	fba0 3101 	umull	r3, r1, r0, r1
 80a7298:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 80a729c:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 80a72a0:	bf3e      	ittt	cc
 80a72a2:	0049      	lslcc	r1, r1, #1
 80a72a4:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
 80a72a8:	005b      	lslcc	r3, r3, #1
 80a72aa:	ea40 0001 	orr.w	r0, r0, r1
 80a72ae:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
 80a72b2:	2afd      	cmp	r2, #253	; 0xfd
 80a72b4:	d81d      	bhi.n	80a72f2 <__aeabi_fmul+0x92>
 80a72b6:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 80a72ba:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80a72be:	bf08      	it	eq
 80a72c0:	f020 0001 	biceq.w	r0, r0, #1
 80a72c4:	4770      	bx	lr
 80a72c6:	f090 0f00 	teq	r0, #0
 80a72ca:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 80a72ce:	bf08      	it	eq
 80a72d0:	0249      	lsleq	r1, r1, #9
 80a72d2:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 80a72d6:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
 80a72da:	3a7f      	subs	r2, #127	; 0x7f
 80a72dc:	bfc2      	ittt	gt
 80a72de:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 80a72e2:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 80a72e6:	4770      	bxgt	lr
 80a72e8:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a72ec:	f04f 0300 	mov.w	r3, #0
 80a72f0:	3a01      	subs	r2, #1
 80a72f2:	dc5d      	bgt.n	80a73b0 <__aeabi_fmul+0x150>
 80a72f4:	f112 0f19 	cmn.w	r2, #25
 80a72f8:	bfdc      	itt	le
 80a72fa:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
 80a72fe:	4770      	bxle	lr
 80a7300:	f1c2 0200 	rsb	r2, r2, #0
 80a7304:	0041      	lsls	r1, r0, #1
 80a7306:	fa21 f102 	lsr.w	r1, r1, r2
 80a730a:	f1c2 0220 	rsb	r2, r2, #32
 80a730e:	fa00 fc02 	lsl.w	ip, r0, r2
 80a7312:	ea5f 0031 	movs.w	r0, r1, rrx
 80a7316:	f140 0000 	adc.w	r0, r0, #0
 80a731a:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
 80a731e:	bf08      	it	eq
 80a7320:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 80a7324:	4770      	bx	lr
 80a7326:	f092 0f00 	teq	r2, #0
 80a732a:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 80a732e:	bf02      	ittt	eq
 80a7330:	0040      	lsleq	r0, r0, #1
 80a7332:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 80a7336:	3a01      	subeq	r2, #1
 80a7338:	d0f9      	beq.n	80a732e <__aeabi_fmul+0xce>
 80a733a:	ea40 000c 	orr.w	r0, r0, ip
 80a733e:	f093 0f00 	teq	r3, #0
 80a7342:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 80a7346:	bf02      	ittt	eq
 80a7348:	0049      	lsleq	r1, r1, #1
 80a734a:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 80a734e:	3b01      	subeq	r3, #1
 80a7350:	d0f9      	beq.n	80a7346 <__aeabi_fmul+0xe6>
 80a7352:	ea41 010c 	orr.w	r1, r1, ip
 80a7356:	e78f      	b.n	80a7278 <__aeabi_fmul+0x18>
 80a7358:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 80a735c:	ea92 0f0c 	teq	r2, ip
 80a7360:	bf18      	it	ne
 80a7362:	ea93 0f0c 	teqne	r3, ip
 80a7366:	d00a      	beq.n	80a737e <__aeabi_fmul+0x11e>
 80a7368:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 80a736c:	bf18      	it	ne
 80a736e:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 80a7372:	d1d8      	bne.n	80a7326 <__aeabi_fmul+0xc6>
 80a7374:	ea80 0001 	eor.w	r0, r0, r1
 80a7378:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 80a737c:	4770      	bx	lr
 80a737e:	f090 0f00 	teq	r0, #0
 80a7382:	bf17      	itett	ne
 80a7384:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
 80a7388:	4608      	moveq	r0, r1
 80a738a:	f091 0f00 	teqne	r1, #0
 80a738e:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
 80a7392:	d014      	beq.n	80a73be <__aeabi_fmul+0x15e>
 80a7394:	ea92 0f0c 	teq	r2, ip
 80a7398:	d101      	bne.n	80a739e <__aeabi_fmul+0x13e>
 80a739a:	0242      	lsls	r2, r0, #9
 80a739c:	d10f      	bne.n	80a73be <__aeabi_fmul+0x15e>
 80a739e:	ea93 0f0c 	teq	r3, ip
 80a73a2:	d103      	bne.n	80a73ac <__aeabi_fmul+0x14c>
 80a73a4:	024b      	lsls	r3, r1, #9
 80a73a6:	bf18      	it	ne
 80a73a8:	4608      	movne	r0, r1
 80a73aa:	d108      	bne.n	80a73be <__aeabi_fmul+0x15e>
 80a73ac:	ea80 0001 	eor.w	r0, r0, r1
 80a73b0:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 80a73b4:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 80a73b8:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a73bc:	4770      	bx	lr
 80a73be:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 80a73c2:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
 80a73c6:	4770      	bx	lr

080a73c8 <__aeabi_fdiv>:
 80a73c8:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80a73cc:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 80a73d0:	bf1e      	ittt	ne
 80a73d2:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 80a73d6:	ea92 0f0c 	teqne	r2, ip
 80a73da:	ea93 0f0c 	teqne	r3, ip
 80a73de:	d069      	beq.n	80a74b4 <__aeabi_fdiv+0xec>
 80a73e0:	eba2 0203 	sub.w	r2, r2, r3
 80a73e4:	ea80 0c01 	eor.w	ip, r0, r1
 80a73e8:	0249      	lsls	r1, r1, #9
 80a73ea:	ea4f 2040 	mov.w	r0, r0, lsl #9
 80a73ee:	d037      	beq.n	80a7460 <__aeabi_fdiv+0x98>
 80a73f0:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 80a73f4:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
 80a73f8:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
 80a73fc:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 80a7400:	428b      	cmp	r3, r1
 80a7402:	bf38      	it	cc
 80a7404:	005b      	lslcc	r3, r3, #1
 80a7406:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
 80a740a:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
 80a740e:	428b      	cmp	r3, r1
 80a7410:	bf24      	itt	cs
 80a7412:	1a5b      	subcs	r3, r3, r1
 80a7414:	ea40 000c 	orrcs.w	r0, r0, ip
 80a7418:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
 80a741c:	bf24      	itt	cs
 80a741e:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
 80a7422:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 80a7426:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
 80a742a:	bf24      	itt	cs
 80a742c:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
 80a7430:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 80a7434:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
 80a7438:	bf24      	itt	cs
 80a743a:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
 80a743e:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 80a7442:	011b      	lsls	r3, r3, #4
 80a7444:	bf18      	it	ne
 80a7446:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
 80a744a:	d1e0      	bne.n	80a740e <__aeabi_fdiv+0x46>
 80a744c:	2afd      	cmp	r2, #253	; 0xfd
 80a744e:	f63f af50 	bhi.w	80a72f2 <__aeabi_fmul+0x92>
 80a7452:	428b      	cmp	r3, r1
 80a7454:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80a7458:	bf08      	it	eq
 80a745a:	f020 0001 	biceq.w	r0, r0, #1
 80a745e:	4770      	bx	lr
 80a7460:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 80a7464:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 80a7468:	327f      	adds	r2, #127	; 0x7f
 80a746a:	bfc2      	ittt	gt
 80a746c:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 80a7470:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 80a7474:	4770      	bxgt	lr
 80a7476:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a747a:	f04f 0300 	mov.w	r3, #0
 80a747e:	3a01      	subs	r2, #1
 80a7480:	e737      	b.n	80a72f2 <__aeabi_fmul+0x92>
 80a7482:	f092 0f00 	teq	r2, #0
 80a7486:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 80a748a:	bf02      	ittt	eq
 80a748c:	0040      	lsleq	r0, r0, #1
 80a748e:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 80a7492:	3a01      	subeq	r2, #1
 80a7494:	d0f9      	beq.n	80a748a <__aeabi_fdiv+0xc2>
 80a7496:	ea40 000c 	orr.w	r0, r0, ip
 80a749a:	f093 0f00 	teq	r3, #0
 80a749e:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 80a74a2:	bf02      	ittt	eq
 80a74a4:	0049      	lsleq	r1, r1, #1
 80a74a6:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 80a74aa:	3b01      	subeq	r3, #1
 80a74ac:	d0f9      	beq.n	80a74a2 <__aeabi_fdiv+0xda>
 80a74ae:	ea41 010c 	orr.w	r1, r1, ip
 80a74b2:	e795      	b.n	80a73e0 <__aeabi_fdiv+0x18>
 80a74b4:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 80a74b8:	ea92 0f0c 	teq	r2, ip
 80a74bc:	d108      	bne.n	80a74d0 <__aeabi_fdiv+0x108>
 80a74be:	0242      	lsls	r2, r0, #9
 80a74c0:	f47f af7d 	bne.w	80a73be <__aeabi_fmul+0x15e>
 80a74c4:	ea93 0f0c 	teq	r3, ip
 80a74c8:	f47f af70 	bne.w	80a73ac <__aeabi_fmul+0x14c>
 80a74cc:	4608      	mov	r0, r1
 80a74ce:	e776      	b.n	80a73be <__aeabi_fmul+0x15e>
 80a74d0:	ea93 0f0c 	teq	r3, ip
 80a74d4:	d104      	bne.n	80a74e0 <__aeabi_fdiv+0x118>
 80a74d6:	024b      	lsls	r3, r1, #9
 80a74d8:	f43f af4c 	beq.w	80a7374 <__aeabi_fmul+0x114>
 80a74dc:	4608      	mov	r0, r1
 80a74de:	e76e      	b.n	80a73be <__aeabi_fmul+0x15e>
 80a74e0:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 80a74e4:	bf18      	it	ne
 80a74e6:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 80a74ea:	d1ca      	bne.n	80a7482 <__aeabi_fdiv+0xba>
 80a74ec:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
 80a74f0:	f47f af5c 	bne.w	80a73ac <__aeabi_fmul+0x14c>
 80a74f4:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
 80a74f8:	f47f af3c 	bne.w	80a7374 <__aeabi_fmul+0x114>
 80a74fc:	e75f      	b.n	80a73be <__aeabi_fmul+0x15e>
 80a74fe:	bf00      	nop

080a7500 <__gesf2>:
 80a7500:	f04f 3cff 	mov.w	ip, #4294967295
 80a7504:	e006      	b.n	80a7514 <__cmpsf2+0x4>
 80a7506:	bf00      	nop

080a7508 <__lesf2>:
 80a7508:	f04f 0c01 	mov.w	ip, #1
 80a750c:	e002      	b.n	80a7514 <__cmpsf2+0x4>
 80a750e:	bf00      	nop

080a7510 <__cmpsf2>:
 80a7510:	f04f 0c01 	mov.w	ip, #1
 80a7514:	f84d cd04 	str.w	ip, [sp, #-4]!
 80a7518:	ea4f 0240 	mov.w	r2, r0, lsl #1
 80a751c:	ea4f 0341 	mov.w	r3, r1, lsl #1
 80a7520:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 80a7524:	bf18      	it	ne
 80a7526:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80a752a:	d011      	beq.n	80a7550 <__cmpsf2+0x40>
 80a752c:	b001      	add	sp, #4
 80a752e:	ea52 0c53 	orrs.w	ip, r2, r3, lsr #1
 80a7532:	bf18      	it	ne
 80a7534:	ea90 0f01 	teqne	r0, r1
 80a7538:	bf58      	it	pl
 80a753a:	ebb2 0003 	subspl.w	r0, r2, r3
 80a753e:	bf88      	it	hi
 80a7540:	17c8      	asrhi	r0, r1, #31
 80a7542:	bf38      	it	cc
 80a7544:	ea6f 70e1 	mvncc.w	r0, r1, asr #31
 80a7548:	bf18      	it	ne
 80a754a:	f040 0001 	orrne.w	r0, r0, #1
 80a754e:	4770      	bx	lr
 80a7550:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 80a7554:	d102      	bne.n	80a755c <__cmpsf2+0x4c>
 80a7556:	ea5f 2c40 	movs.w	ip, r0, lsl #9
 80a755a:	d105      	bne.n	80a7568 <__cmpsf2+0x58>
 80a755c:	ea7f 6c23 	mvns.w	ip, r3, asr #24
 80a7560:	d1e4      	bne.n	80a752c <__cmpsf2+0x1c>
 80a7562:	ea5f 2c41 	movs.w	ip, r1, lsl #9
 80a7566:	d0e1      	beq.n	80a752c <__cmpsf2+0x1c>
 80a7568:	f85d 0b04 	ldr.w	r0, [sp], #4
 80a756c:	4770      	bx	lr
 80a756e:	bf00      	nop

080a7570 <__aeabi_cfrcmple>:
 80a7570:	4684      	mov	ip, r0
 80a7572:	4608      	mov	r0, r1
 80a7574:	4661      	mov	r1, ip
 80a7576:	e7ff      	b.n	80a7578 <__aeabi_cfcmpeq>

080a7578 <__aeabi_cfcmpeq>:
 80a7578:	b50f      	push	{r0, r1, r2, r3, lr}
 80a757a:	f7ff ffc9 	bl	80a7510 <__cmpsf2>
 80a757e:	2800      	cmp	r0, #0
 80a7580:	bf48      	it	mi
 80a7582:	f110 0f00 	cmnmi.w	r0, #0
 80a7586:	bd0f      	pop	{r0, r1, r2, r3, pc}

080a7588 <__aeabi_fcmpeq>:
 80a7588:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a758c:	f7ff fff4 	bl	80a7578 <__aeabi_cfcmpeq>
 80a7590:	bf0c      	ite	eq
 80a7592:	2001      	moveq	r0, #1
 80a7594:	2000      	movne	r0, #0
 80a7596:	f85d fb08 	ldr.w	pc, [sp], #8
 80a759a:	bf00      	nop

080a759c <__aeabi_fcmplt>:
 80a759c:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a75a0:	f7ff ffea 	bl	80a7578 <__aeabi_cfcmpeq>
 80a75a4:	bf34      	ite	cc
 80a75a6:	2001      	movcc	r0, #1
 80a75a8:	2000      	movcs	r0, #0
 80a75aa:	f85d fb08 	ldr.w	pc, [sp], #8
 80a75ae:	bf00      	nop

080a75b0 <__aeabi_fcmple>:
 80a75b0:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a75b4:	f7ff ffe0 	bl	80a7578 <__aeabi_cfcmpeq>
 80a75b8:	bf94      	ite	ls
 80a75ba:	2001      	movls	r0, #1
 80a75bc:	2000      	movhi	r0, #0
 80a75be:	f85d fb08 	ldr.w	pc, [sp], #8
 80a75c2:	bf00      	nop

080a75c4 <__aeabi_fcmpge>:
 80a75c4:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a75c8:	f7ff ffd2 	bl	80a7570 <__aeabi_cfrcmple>
 80a75cc:	bf94      	ite	ls
 80a75ce:	2001      	movls	r0, #1
 80a75d0:	2000      	movhi	r0, #0
 80a75d2:	f85d fb08 	ldr.w	pc, [sp], #8
 80a75d6:	bf00      	nop

080a75d8 <__aeabi_fcmpgt>:
 80a75d8:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a75dc:	f7ff ffc8 	bl	80a7570 <__aeabi_cfrcmple>
 80a75e0:	bf34      	ite	cc
 80a75e2:	2001      	movcc	r0, #1
 80a75e4:	2000      	movcs	r0, #0
 80a75e6:	f85d fb08 	ldr.w	pc, [sp], #8
 80a75ea:	bf00      	nop

080a75ec <__aeabi_f2iz>:
 80a75ec:	ea4f 0240 	mov.w	r2, r0, lsl #1
 80a75f0:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
 80a75f4:	d30f      	bcc.n	80a7616 <__aeabi_f2iz+0x2a>
 80a75f6:	f04f 039e 	mov.w	r3, #158	; 0x9e
 80a75fa:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
 80a75fe:	d90d      	bls.n	80a761c <__aeabi_f2iz+0x30>
 80a7600:	ea4f 2300 	mov.w	r3, r0, lsl #8
 80a7604:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80a7608:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 80a760c:	fa23 f002 	lsr.w	r0, r3, r2
 80a7610:	bf18      	it	ne
 80a7612:	4240      	negne	r0, r0
 80a7614:	4770      	bx	lr
 80a7616:	f04f 0000 	mov.w	r0, #0
 80a761a:	4770      	bx	lr
 80a761c:	f112 0f61 	cmn.w	r2, #97	; 0x61
 80a7620:	d101      	bne.n	80a7626 <__aeabi_f2iz+0x3a>
 80a7622:	0242      	lsls	r2, r0, #9
 80a7624:	d105      	bne.n	80a7632 <__aeabi_f2iz+0x46>
 80a7626:	f010 4000 	ands.w	r0, r0, #2147483648	; 0x80000000
 80a762a:	bf08      	it	eq
 80a762c:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 80a7630:	4770      	bx	lr
 80a7632:	f04f 0000 	mov.w	r0, #0
 80a7636:	4770      	bx	lr

080a7638 <__cxa_atexit>:
 80a7638:	b510      	push	{r4, lr}
 80a763a:	4c05      	ldr	r4, [pc, #20]	; (80a7650 <__cxa_atexit+0x18>)
 80a763c:	4613      	mov	r3, r2
 80a763e:	b12c      	cbz	r4, 80a764c <__cxa_atexit+0x14>
 80a7640:	460a      	mov	r2, r1
 80a7642:	4601      	mov	r1, r0
 80a7644:	2002      	movs	r0, #2
 80a7646:	f3af 8000 	nop.w
 80a764a:	bd10      	pop	{r4, pc}
 80a764c:	4620      	mov	r0, r4
 80a764e:	bd10      	pop	{r4, pc}
 80a7650:	00000000 	.word	0x00000000

080a7654 <localtime>:
 80a7654:	b538      	push	{r3, r4, r5, lr}
 80a7656:	4b07      	ldr	r3, [pc, #28]	; (80a7674 <localtime+0x20>)
 80a7658:	4605      	mov	r5, r0
 80a765a:	681c      	ldr	r4, [r3, #0]
 80a765c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80a765e:	b91b      	cbnz	r3, 80a7668 <localtime+0x14>
 80a7660:	2024      	movs	r0, #36	; 0x24
 80a7662:	f7fd ff4f 	bl	80a5504 <malloc>
 80a7666:	63e0      	str	r0, [r4, #60]	; 0x3c
 80a7668:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 80a766a:	4628      	mov	r0, r5
 80a766c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80a7670:	f000 b802 	b.w	80a7678 <localtime_r>
 80a7674:	2000036c 	.word	0x2000036c

080a7678 <localtime_r>:
 80a7678:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a767c:	460c      	mov	r4, r1
 80a767e:	4680      	mov	r8, r0
 80a7680:	f000 fcc0 	bl	80a8004 <__gettzinfo>
 80a7684:	4621      	mov	r1, r4
 80a7686:	4607      	mov	r7, r0
 80a7688:	4640      	mov	r0, r8
 80a768a:	f000 fcbf 	bl	80a800c <gmtime_r>
 80a768e:	6946      	ldr	r6, [r0, #20]
 80a7690:	4604      	mov	r4, r0
 80a7692:	f206 766c 	addw	r6, r6, #1900	; 0x76c
 80a7696:	07b3      	lsls	r3, r6, #30
 80a7698:	d105      	bne.n	80a76a6 <localtime_r+0x2e>
 80a769a:	2264      	movs	r2, #100	; 0x64
 80a769c:	fb96 f3f2 	sdiv	r3, r6, r2
 80a76a0:	fb02 6313 	mls	r3, r2, r3, r6
 80a76a4:	b94b      	cbnz	r3, 80a76ba <localtime_r+0x42>
 80a76a6:	f44f 75c8 	mov.w	r5, #400	; 0x190
 80a76aa:	fb96 f3f5 	sdiv	r3, r6, r5
 80a76ae:	fb05 6513 	mls	r5, r5, r3, r6
 80a76b2:	fab5 f385 	clz	r3, r5
 80a76b6:	095b      	lsrs	r3, r3, #5
 80a76b8:	e000      	b.n	80a76bc <localtime_r+0x44>
 80a76ba:	2301      	movs	r3, #1
 80a76bc:	4a5f      	ldr	r2, [pc, #380]	; (80a783c <localtime_r+0x1c4>)
 80a76be:	2530      	movs	r5, #48	; 0x30
 80a76c0:	fb05 2503 	mla	r5, r5, r3, r2
 80a76c4:	f000 fad2 	bl	80a7c6c <__tz_lock>
 80a76c8:	f000 fad2 	bl	80a7c70 <_tzset_unlocked>
 80a76cc:	4b5c      	ldr	r3, [pc, #368]	; (80a7840 <localtime_r+0x1c8>)
 80a76ce:	681b      	ldr	r3, [r3, #0]
 80a76d0:	b1f3      	cbz	r3, 80a7710 <localtime_r+0x98>
 80a76d2:	687b      	ldr	r3, [r7, #4]
 80a76d4:	429e      	cmp	r6, r3
 80a76d6:	d105      	bne.n	80a76e4 <localtime_r+0x6c>
 80a76d8:	6839      	ldr	r1, [r7, #0]
 80a76da:	f8d8 3000 	ldr.w	r3, [r8]
 80a76de:	69fa      	ldr	r2, [r7, #28]
 80a76e0:	b941      	cbnz	r1, 80a76f4 <localtime_r+0x7c>
 80a76e2:	e00a      	b.n	80a76fa <localtime_r+0x82>
 80a76e4:	4630      	mov	r0, r6
 80a76e6:	f000 fa19 	bl	80a7b1c <__tzcalc_limits>
 80a76ea:	2800      	cmp	r0, #0
 80a76ec:	d1f4      	bne.n	80a76d8 <localtime_r+0x60>
 80a76ee:	f04f 33ff 	mov.w	r3, #4294967295
 80a76f2:	e00d      	b.n	80a7710 <localtime_r+0x98>
 80a76f4:	4293      	cmp	r3, r2
 80a76f6:	db08      	blt.n	80a770a <localtime_r+0x92>
 80a76f8:	e001      	b.n	80a76fe <localtime_r+0x86>
 80a76fa:	4293      	cmp	r3, r2
 80a76fc:	da07      	bge.n	80a770e <localtime_r+0x96>
 80a76fe:	6bba      	ldr	r2, [r7, #56]	; 0x38
 80a7700:	4293      	cmp	r3, r2
 80a7702:	bfac      	ite	ge
 80a7704:	2300      	movge	r3, #0
 80a7706:	2301      	movlt	r3, #1
 80a7708:	e002      	b.n	80a7710 <localtime_r+0x98>
 80a770a:	2300      	movs	r3, #0
 80a770c:	e000      	b.n	80a7710 <localtime_r+0x98>
 80a770e:	2301      	movs	r3, #1
 80a7710:	6223      	str	r3, [r4, #32]
 80a7712:	6a23      	ldr	r3, [r4, #32]
 80a7714:	203c      	movs	r0, #60	; 0x3c
 80a7716:	2b01      	cmp	r3, #1
 80a7718:	bf0c      	ite	eq
 80a771a:	6bf9      	ldreq	r1, [r7, #60]	; 0x3c
 80a771c:	6a39      	ldrne	r1, [r7, #32]
 80a771e:	f44f 6361 	mov.w	r3, #3600	; 0xe10
 80a7722:	fb91 f6f3 	sdiv	r6, r1, r3
 80a7726:	fb03 1316 	mls	r3, r3, r6, r1
 80a772a:	fb93 f2f0 	sdiv	r2, r3, r0
 80a772e:	fb00 3012 	mls	r0, r0, r2, r3
 80a7732:	6861      	ldr	r1, [r4, #4]
 80a7734:	6823      	ldr	r3, [r4, #0]
 80a7736:	1a89      	subs	r1, r1, r2
 80a7738:	68a2      	ldr	r2, [r4, #8]
 80a773a:	1a1b      	subs	r3, r3, r0
 80a773c:	1b92      	subs	r2, r2, r6
 80a773e:	2b3b      	cmp	r3, #59	; 0x3b
 80a7740:	6023      	str	r3, [r4, #0]
 80a7742:	6061      	str	r1, [r4, #4]
 80a7744:	60a2      	str	r2, [r4, #8]
 80a7746:	dd03      	ble.n	80a7750 <localtime_r+0xd8>
 80a7748:	3101      	adds	r1, #1
 80a774a:	6061      	str	r1, [r4, #4]
 80a774c:	3b3c      	subs	r3, #60	; 0x3c
 80a774e:	e004      	b.n	80a775a <localtime_r+0xe2>
 80a7750:	2b00      	cmp	r3, #0
 80a7752:	da03      	bge.n	80a775c <localtime_r+0xe4>
 80a7754:	3901      	subs	r1, #1
 80a7756:	6061      	str	r1, [r4, #4]
 80a7758:	333c      	adds	r3, #60	; 0x3c
 80a775a:	6023      	str	r3, [r4, #0]
 80a775c:	6863      	ldr	r3, [r4, #4]
 80a775e:	2b3b      	cmp	r3, #59	; 0x3b
 80a7760:	dd03      	ble.n	80a776a <localtime_r+0xf2>
 80a7762:	3201      	adds	r2, #1
 80a7764:	60a2      	str	r2, [r4, #8]
 80a7766:	3b3c      	subs	r3, #60	; 0x3c
 80a7768:	e004      	b.n	80a7774 <localtime_r+0xfc>
 80a776a:	2b00      	cmp	r3, #0
 80a776c:	da03      	bge.n	80a7776 <localtime_r+0xfe>
 80a776e:	3a01      	subs	r2, #1
 80a7770:	60a2      	str	r2, [r4, #8]
 80a7772:	333c      	adds	r3, #60	; 0x3c
 80a7774:	6063      	str	r3, [r4, #4]
 80a7776:	68a3      	ldr	r3, [r4, #8]
 80a7778:	2b17      	cmp	r3, #23
 80a777a:	dd22      	ble.n	80a77c2 <localtime_r+0x14a>
 80a777c:	69e2      	ldr	r2, [r4, #28]
 80a777e:	3b18      	subs	r3, #24
 80a7780:	3201      	adds	r2, #1
 80a7782:	61e2      	str	r2, [r4, #28]
 80a7784:	69a2      	ldr	r2, [r4, #24]
 80a7786:	60a3      	str	r3, [r4, #8]
 80a7788:	3201      	adds	r2, #1
 80a778a:	2a06      	cmp	r2, #6
 80a778c:	bfc8      	it	gt
 80a778e:	2200      	movgt	r2, #0
 80a7790:	61a2      	str	r2, [r4, #24]
 80a7792:	68e2      	ldr	r2, [r4, #12]
 80a7794:	6923      	ldr	r3, [r4, #16]
 80a7796:	3201      	adds	r2, #1
 80a7798:	60e2      	str	r2, [r4, #12]
 80a779a:	f855 1023 	ldr.w	r1, [r5, r3, lsl #2]
 80a779e:	428a      	cmp	r2, r1
 80a77a0:	dd46      	ble.n	80a7830 <localtime_r+0x1b8>
 80a77a2:	3301      	adds	r3, #1
 80a77a4:	2b0c      	cmp	r3, #12
 80a77a6:	bf08      	it	eq
 80a77a8:	6963      	ldreq	r3, [r4, #20]
 80a77aa:	eba2 0201 	sub.w	r2, r2, r1
 80a77ae:	60e2      	str	r2, [r4, #12]
 80a77b0:	bf05      	ittet	eq
 80a77b2:	3301      	addeq	r3, #1
 80a77b4:	2200      	moveq	r2, #0
 80a77b6:	6123      	strne	r3, [r4, #16]
 80a77b8:	6122      	streq	r2, [r4, #16]
 80a77ba:	bf04      	itt	eq
 80a77bc:	6163      	streq	r3, [r4, #20]
 80a77be:	61e2      	streq	r2, [r4, #28]
 80a77c0:	e036      	b.n	80a7830 <localtime_r+0x1b8>
 80a77c2:	2b00      	cmp	r3, #0
 80a77c4:	da34      	bge.n	80a7830 <localtime_r+0x1b8>
 80a77c6:	69e2      	ldr	r2, [r4, #28]
 80a77c8:	3318      	adds	r3, #24
 80a77ca:	3a01      	subs	r2, #1
 80a77cc:	61e2      	str	r2, [r4, #28]
 80a77ce:	69a2      	ldr	r2, [r4, #24]
 80a77d0:	60a3      	str	r3, [r4, #8]
 80a77d2:	3a01      	subs	r2, #1
 80a77d4:	bf48      	it	mi
 80a77d6:	2206      	movmi	r2, #6
 80a77d8:	61a2      	str	r2, [r4, #24]
 80a77da:	68e2      	ldr	r2, [r4, #12]
 80a77dc:	3a01      	subs	r2, #1
 80a77de:	60e2      	str	r2, [r4, #12]
 80a77e0:	bb32      	cbnz	r2, 80a7830 <localtime_r+0x1b8>
 80a77e2:	6923      	ldr	r3, [r4, #16]
 80a77e4:	3b01      	subs	r3, #1
 80a77e6:	d401      	bmi.n	80a77ec <localtime_r+0x174>
 80a77e8:	6123      	str	r3, [r4, #16]
 80a77ea:	e01d      	b.n	80a7828 <localtime_r+0x1b0>
 80a77ec:	230b      	movs	r3, #11
 80a77ee:	6123      	str	r3, [r4, #16]
 80a77f0:	6963      	ldr	r3, [r4, #20]
 80a77f2:	1e5a      	subs	r2, r3, #1
 80a77f4:	f012 0f03 	tst.w	r2, #3
 80a77f8:	6162      	str	r2, [r4, #20]
 80a77fa:	f203 736b 	addw	r3, r3, #1899	; 0x76b
 80a77fe:	d105      	bne.n	80a780c <localtime_r+0x194>
 80a7800:	2164      	movs	r1, #100	; 0x64
 80a7802:	fb93 f2f1 	sdiv	r2, r3, r1
 80a7806:	fb01 3212 	mls	r2, r1, r2, r3
 80a780a:	b94a      	cbnz	r2, 80a7820 <localtime_r+0x1a8>
 80a780c:	f44f 71c8 	mov.w	r1, #400	; 0x190
 80a7810:	fb93 f2f1 	sdiv	r2, r3, r1
 80a7814:	fb01 3312 	mls	r3, r1, r2, r3
 80a7818:	fab3 f383 	clz	r3, r3
 80a781c:	095b      	lsrs	r3, r3, #5
 80a781e:	e000      	b.n	80a7822 <localtime_r+0x1aa>
 80a7820:	2301      	movs	r3, #1
 80a7822:	f503 73b6 	add.w	r3, r3, #364	; 0x16c
 80a7826:	61e3      	str	r3, [r4, #28]
 80a7828:	6923      	ldr	r3, [r4, #16]
 80a782a:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 80a782e:	60e3      	str	r3, [r4, #12]
 80a7830:	f000 fa1d 	bl	80a7c6e <__tz_unlock>
 80a7834:	4620      	mov	r0, r4
 80a7836:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a783a:	bf00      	nop
 80a783c:	080a9680 	.word	0x080a9680
 80a7840:	20001634 	.word	0x20001634

080a7844 <memcpy>:
 80a7844:	b510      	push	{r4, lr}
 80a7846:	1e43      	subs	r3, r0, #1
 80a7848:	440a      	add	r2, r1
 80a784a:	4291      	cmp	r1, r2
 80a784c:	d004      	beq.n	80a7858 <memcpy+0x14>
 80a784e:	f811 4b01 	ldrb.w	r4, [r1], #1
 80a7852:	f803 4f01 	strb.w	r4, [r3, #1]!
 80a7856:	e7f8      	b.n	80a784a <memcpy+0x6>
 80a7858:	bd10      	pop	{r4, pc}

080a785a <memset>:
 80a785a:	4603      	mov	r3, r0
 80a785c:	4402      	add	r2, r0
 80a785e:	4293      	cmp	r3, r2
 80a7860:	d002      	beq.n	80a7868 <memset+0xe>
 80a7862:	f803 1b01 	strb.w	r1, [r3], #1
 80a7866:	e7fa      	b.n	80a785e <memset+0x4>
 80a7868:	4770      	bx	lr
	...

080a786c <srand>:
 80a786c:	b538      	push	{r3, r4, r5, lr}
 80a786e:	4b12      	ldr	r3, [pc, #72]	; (80a78b8 <srand+0x4c>)
 80a7870:	4605      	mov	r5, r0
 80a7872:	681c      	ldr	r4, [r3, #0]
 80a7874:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80a7876:	b9d3      	cbnz	r3, 80a78ae <srand+0x42>
 80a7878:	2018      	movs	r0, #24
 80a787a:	f7fd fe43 	bl	80a5504 <malloc>
 80a787e:	f243 330e 	movw	r3, #13070	; 0x330e
 80a7882:	63a0      	str	r0, [r4, #56]	; 0x38
 80a7884:	8003      	strh	r3, [r0, #0]
 80a7886:	f64a 33cd 	movw	r3, #43981	; 0xabcd
 80a788a:	8043      	strh	r3, [r0, #2]
 80a788c:	f241 2334 	movw	r3, #4660	; 0x1234
 80a7890:	8083      	strh	r3, [r0, #4]
 80a7892:	f24e 636d 	movw	r3, #58989	; 0xe66d
 80a7896:	80c3      	strh	r3, [r0, #6]
 80a7898:	f64d 63ec 	movw	r3, #57068	; 0xdeec
 80a789c:	8103      	strh	r3, [r0, #8]
 80a789e:	2305      	movs	r3, #5
 80a78a0:	8143      	strh	r3, [r0, #10]
 80a78a2:	230b      	movs	r3, #11
 80a78a4:	8183      	strh	r3, [r0, #12]
 80a78a6:	2201      	movs	r2, #1
 80a78a8:	2300      	movs	r3, #0
 80a78aa:	e9c0 2304 	strd	r2, r3, [r0, #16]
 80a78ae:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80a78b0:	2200      	movs	r2, #0
 80a78b2:	611d      	str	r5, [r3, #16]
 80a78b4:	615a      	str	r2, [r3, #20]
 80a78b6:	bd38      	pop	{r3, r4, r5, pc}
 80a78b8:	2000036c 	.word	0x2000036c

080a78bc <rand>:
 80a78bc:	4b19      	ldr	r3, [pc, #100]	; (80a7924 <rand+0x68>)
 80a78be:	b510      	push	{r4, lr}
 80a78c0:	681c      	ldr	r4, [r3, #0]
 80a78c2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80a78c4:	b9d3      	cbnz	r3, 80a78fc <rand+0x40>
 80a78c6:	2018      	movs	r0, #24
 80a78c8:	f7fd fe1c 	bl	80a5504 <malloc>
 80a78cc:	f243 330e 	movw	r3, #13070	; 0x330e
 80a78d0:	63a0      	str	r0, [r4, #56]	; 0x38
 80a78d2:	8003      	strh	r3, [r0, #0]
 80a78d4:	f64a 33cd 	movw	r3, #43981	; 0xabcd
 80a78d8:	8043      	strh	r3, [r0, #2]
 80a78da:	f241 2334 	movw	r3, #4660	; 0x1234
 80a78de:	8083      	strh	r3, [r0, #4]
 80a78e0:	f24e 636d 	movw	r3, #58989	; 0xe66d
 80a78e4:	80c3      	strh	r3, [r0, #6]
 80a78e6:	f64d 63ec 	movw	r3, #57068	; 0xdeec
 80a78ea:	8103      	strh	r3, [r0, #8]
 80a78ec:	2305      	movs	r3, #5
 80a78ee:	8143      	strh	r3, [r0, #10]
 80a78f0:	230b      	movs	r3, #11
 80a78f2:	8183      	strh	r3, [r0, #12]
 80a78f4:	2201      	movs	r2, #1
 80a78f6:	2300      	movs	r3, #0
 80a78f8:	e9c0 2304 	strd	r2, r3, [r0, #16]
 80a78fc:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 80a78fe:	4c0a      	ldr	r4, [pc, #40]	; (80a7928 <rand+0x6c>)
 80a7900:	690b      	ldr	r3, [r1, #16]
 80a7902:	6948      	ldr	r0, [r1, #20]
 80a7904:	435c      	muls	r4, r3
 80a7906:	4a09      	ldr	r2, [pc, #36]	; (80a792c <rand+0x70>)
 80a7908:	fb02 4000 	mla	r0, r2, r0, r4
 80a790c:	fba3 2302 	umull	r2, r3, r3, r2
 80a7910:	3201      	adds	r2, #1
 80a7912:	4403      	add	r3, r0
 80a7914:	f143 0300 	adc.w	r3, r3, #0
 80a7918:	e9c1 2304 	strd	r2, r3, [r1, #16]
 80a791c:	f023 4000 	bic.w	r0, r3, #2147483648	; 0x80000000
 80a7920:	bd10      	pop	{r4, pc}
 80a7922:	bf00      	nop
 80a7924:	2000036c 	.word	0x2000036c
 80a7928:	5851f42d 	.word	0x5851f42d
 80a792c:	4c957f2d 	.word	0x4c957f2d

080a7930 <strcat>:
 80a7930:	4602      	mov	r2, r0
 80a7932:	b510      	push	{r4, lr}
 80a7934:	4613      	mov	r3, r2
 80a7936:	781c      	ldrb	r4, [r3, #0]
 80a7938:	3201      	adds	r2, #1
 80a793a:	2c00      	cmp	r4, #0
 80a793c:	d1fa      	bne.n	80a7934 <strcat+0x4>
 80a793e:	3b01      	subs	r3, #1
 80a7940:	f811 2b01 	ldrb.w	r2, [r1], #1
 80a7944:	f803 2f01 	strb.w	r2, [r3, #1]!
 80a7948:	2a00      	cmp	r2, #0
 80a794a:	d1f9      	bne.n	80a7940 <strcat+0x10>
 80a794c:	bd10      	pop	{r4, pc}

080a794e <strcmp>:
 80a794e:	f810 2b01 	ldrb.w	r2, [r0], #1
 80a7952:	f811 3b01 	ldrb.w	r3, [r1], #1
 80a7956:	2a01      	cmp	r2, #1
 80a7958:	bf28      	it	cs
 80a795a:	429a      	cmpcs	r2, r3
 80a795c:	d0f7      	beq.n	80a794e <strcmp>
 80a795e:	1ad0      	subs	r0, r2, r3
 80a7960:	4770      	bx	lr

080a7962 <strcpy>:
 80a7962:	4603      	mov	r3, r0
 80a7964:	f811 2b01 	ldrb.w	r2, [r1], #1
 80a7968:	f803 2b01 	strb.w	r2, [r3], #1
 80a796c:	2a00      	cmp	r2, #0
 80a796e:	d1f9      	bne.n	80a7964 <strcpy+0x2>
 80a7970:	4770      	bx	lr
	...

080a7974 <strdup>:
 80a7974:	4b02      	ldr	r3, [pc, #8]	; (80a7980 <strdup+0xc>)
 80a7976:	4601      	mov	r1, r0
 80a7978:	6818      	ldr	r0, [r3, #0]
 80a797a:	f000 b803 	b.w	80a7984 <_strdup_r>
 80a797e:	bf00      	nop
 80a7980:	2000036c 	.word	0x2000036c

080a7984 <_strdup_r>:
 80a7984:	b570      	push	{r4, r5, r6, lr}
 80a7986:	4606      	mov	r6, r0
 80a7988:	4608      	mov	r0, r1
 80a798a:	460c      	mov	r4, r1
 80a798c:	f000 f80d 	bl	80a79aa <strlen>
 80a7990:	1c45      	adds	r5, r0, #1
 80a7992:	4629      	mov	r1, r5
 80a7994:	4630      	mov	r0, r6
 80a7996:	f7fd fde5 	bl	80a5564 <_malloc_r>
 80a799a:	4606      	mov	r6, r0
 80a799c:	b118      	cbz	r0, 80a79a6 <_strdup_r+0x22>
 80a799e:	462a      	mov	r2, r5
 80a79a0:	4621      	mov	r1, r4
 80a79a2:	f7ff ff4f 	bl	80a7844 <memcpy>
 80a79a6:	4630      	mov	r0, r6
 80a79a8:	bd70      	pop	{r4, r5, r6, pc}

080a79aa <strlen>:
 80a79aa:	4603      	mov	r3, r0
 80a79ac:	f813 2b01 	ldrb.w	r2, [r3], #1
 80a79b0:	2a00      	cmp	r2, #0
 80a79b2:	d1fb      	bne.n	80a79ac <strlen+0x2>
 80a79b4:	1a18      	subs	r0, r3, r0
 80a79b6:	3801      	subs	r0, #1
 80a79b8:	4770      	bx	lr

080a79ba <strncmp>:
 80a79ba:	b530      	push	{r4, r5, lr}
 80a79bc:	b182      	cbz	r2, 80a79e0 <strncmp+0x26>
 80a79be:	1e45      	subs	r5, r0, #1
 80a79c0:	3901      	subs	r1, #1
 80a79c2:	f815 3f01 	ldrb.w	r3, [r5, #1]!
 80a79c6:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 80a79ca:	42a3      	cmp	r3, r4
 80a79cc:	d106      	bne.n	80a79dc <strncmp+0x22>
 80a79ce:	43ec      	mvns	r4, r5
 80a79d0:	4414      	add	r4, r2
 80a79d2:	42e0      	cmn	r0, r4
 80a79d4:	d001      	beq.n	80a79da <strncmp+0x20>
 80a79d6:	2b00      	cmp	r3, #0
 80a79d8:	d1f3      	bne.n	80a79c2 <strncmp+0x8>
 80a79da:	461c      	mov	r4, r3
 80a79dc:	1b18      	subs	r0, r3, r4
 80a79de:	bd30      	pop	{r4, r5, pc}
 80a79e0:	4610      	mov	r0, r2
 80a79e2:	bd30      	pop	{r4, r5, pc}

080a79e4 <strncpy>:
 80a79e4:	4603      	mov	r3, r0
 80a79e6:	b510      	push	{r4, lr}
 80a79e8:	b142      	cbz	r2, 80a79fc <strncpy+0x18>
 80a79ea:	f811 4b01 	ldrb.w	r4, [r1], #1
 80a79ee:	3a01      	subs	r2, #1
 80a79f0:	f803 4b01 	strb.w	r4, [r3], #1
 80a79f4:	2c00      	cmp	r4, #0
 80a79f6:	d1f7      	bne.n	80a79e8 <strncpy+0x4>
 80a79f8:	441a      	add	r2, r3
 80a79fa:	e000      	b.n	80a79fe <strncpy+0x1a>
 80a79fc:	bd10      	pop	{r4, pc}
 80a79fe:	4293      	cmp	r3, r2
 80a7a00:	d002      	beq.n	80a7a08 <strncpy+0x24>
 80a7a02:	f803 4b01 	strb.w	r4, [r3], #1
 80a7a06:	e7fa      	b.n	80a79fe <strncpy+0x1a>
 80a7a08:	bd10      	pop	{r4, pc}
	...

080a7a0c <_strtoul_r>:
 80a7a0c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80a7a10:	460e      	mov	r6, r1
 80a7a12:	4680      	mov	r8, r0
 80a7a14:	483b      	ldr	r0, [pc, #236]	; (80a7b04 <_strtoul_r+0xf8>)
 80a7a16:	f8d0 9000 	ldr.w	r9, [r0]
 80a7a1a:	4635      	mov	r5, r6
 80a7a1c:	f815 4b01 	ldrb.w	r4, [r5], #1
 80a7a20:	eb09 0004 	add.w	r0, r9, r4
 80a7a24:	7840      	ldrb	r0, [r0, #1]
 80a7a26:	f000 0008 	and.w	r0, r0, #8
 80a7a2a:	f000 07ff 	and.w	r7, r0, #255	; 0xff
 80a7a2e:	b108      	cbz	r0, 80a7a34 <_strtoul_r+0x28>
 80a7a30:	462e      	mov	r6, r5
 80a7a32:	e7f2      	b.n	80a7a1a <_strtoul_r+0xe>
 80a7a34:	2c2d      	cmp	r4, #45	; 0x2d
 80a7a36:	d103      	bne.n	80a7a40 <_strtoul_r+0x34>
 80a7a38:	1cb5      	adds	r5, r6, #2
 80a7a3a:	7874      	ldrb	r4, [r6, #1]
 80a7a3c:	2701      	movs	r7, #1
 80a7a3e:	e003      	b.n	80a7a48 <_strtoul_r+0x3c>
 80a7a40:	2c2b      	cmp	r4, #43	; 0x2b
 80a7a42:	bf04      	itt	eq
 80a7a44:	7874      	ldrbeq	r4, [r6, #1]
 80a7a46:	1cb5      	addeq	r5, r6, #2
 80a7a48:	b113      	cbz	r3, 80a7a50 <_strtoul_r+0x44>
 80a7a4a:	2b10      	cmp	r3, #16
 80a7a4c:	d10a      	bne.n	80a7a64 <_strtoul_r+0x58>
 80a7a4e:	e053      	b.n	80a7af8 <_strtoul_r+0xec>
 80a7a50:	2c30      	cmp	r4, #48	; 0x30
 80a7a52:	d14f      	bne.n	80a7af4 <_strtoul_r+0xe8>
 80a7a54:	7828      	ldrb	r0, [r5, #0]
 80a7a56:	f000 00df 	and.w	r0, r0, #223	; 0xdf
 80a7a5a:	2858      	cmp	r0, #88	; 0x58
 80a7a5c:	d145      	bne.n	80a7aea <_strtoul_r+0xde>
 80a7a5e:	786c      	ldrb	r4, [r5, #1]
 80a7a60:	2310      	movs	r3, #16
 80a7a62:	3502      	adds	r5, #2
 80a7a64:	f04f 3cff 	mov.w	ip, #4294967295
 80a7a68:	fbbc fcf3 	udiv	ip, ip, r3
 80a7a6c:	fb03 fa0c 	mul.w	sl, r3, ip
 80a7a70:	2600      	movs	r6, #0
 80a7a72:	ea6f 0a0a 	mvn.w	sl, sl
 80a7a76:	4630      	mov	r0, r6
 80a7a78:	eb09 0e04 	add.w	lr, r9, r4
 80a7a7c:	f89e e001 	ldrb.w	lr, [lr, #1]
 80a7a80:	f01e 0f04 	tst.w	lr, #4
 80a7a84:	d001      	beq.n	80a7a8a <_strtoul_r+0x7e>
 80a7a86:	3c30      	subs	r4, #48	; 0x30
 80a7a88:	e00b      	b.n	80a7aa2 <_strtoul_r+0x96>
 80a7a8a:	f01e 0e03 	ands.w	lr, lr, #3
 80a7a8e:	d01a      	beq.n	80a7ac6 <_strtoul_r+0xba>
 80a7a90:	f1be 0f01 	cmp.w	lr, #1
 80a7a94:	bf0c      	ite	eq
 80a7a96:	f04f 0e37 	moveq.w	lr, #55	; 0x37
 80a7a9a:	f04f 0e57 	movne.w	lr, #87	; 0x57
 80a7a9e:	ebce 0404 	rsb	r4, lr, r4
 80a7aa2:	42a3      	cmp	r3, r4
 80a7aa4:	dd0f      	ble.n	80a7ac6 <_strtoul_r+0xba>
 80a7aa6:	2e00      	cmp	r6, #0
 80a7aa8:	db08      	blt.n	80a7abc <_strtoul_r+0xb0>
 80a7aaa:	4560      	cmp	r0, ip
 80a7aac:	d806      	bhi.n	80a7abc <_strtoul_r+0xb0>
 80a7aae:	d101      	bne.n	80a7ab4 <_strtoul_r+0xa8>
 80a7ab0:	4554      	cmp	r4, sl
 80a7ab2:	dc03      	bgt.n	80a7abc <_strtoul_r+0xb0>
 80a7ab4:	fb03 4000 	mla	r0, r3, r0, r4
 80a7ab8:	2601      	movs	r6, #1
 80a7aba:	e001      	b.n	80a7ac0 <_strtoul_r+0xb4>
 80a7abc:	f04f 36ff 	mov.w	r6, #4294967295
 80a7ac0:	f815 4b01 	ldrb.w	r4, [r5], #1
 80a7ac4:	e7d8      	b.n	80a7a78 <_strtoul_r+0x6c>
 80a7ac6:	2e00      	cmp	r6, #0
 80a7ac8:	da07      	bge.n	80a7ada <_strtoul_r+0xce>
 80a7aca:	2322      	movs	r3, #34	; 0x22
 80a7acc:	f8c8 3000 	str.w	r3, [r8]
 80a7ad0:	f04f 30ff 	mov.w	r0, #4294967295
 80a7ad4:	b92a      	cbnz	r2, 80a7ae2 <_strtoul_r+0xd6>
 80a7ad6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a7ada:	b107      	cbz	r7, 80a7ade <_strtoul_r+0xd2>
 80a7adc:	4240      	negs	r0, r0
 80a7ade:	b172      	cbz	r2, 80a7afe <_strtoul_r+0xf2>
 80a7ae0:	b106      	cbz	r6, 80a7ae4 <_strtoul_r+0xd8>
 80a7ae2:	1e69      	subs	r1, r5, #1
 80a7ae4:	6011      	str	r1, [r2, #0]
 80a7ae6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a7aea:	2430      	movs	r4, #48	; 0x30
 80a7aec:	2b00      	cmp	r3, #0
 80a7aee:	d1b9      	bne.n	80a7a64 <_strtoul_r+0x58>
 80a7af0:	2308      	movs	r3, #8
 80a7af2:	e7b7      	b.n	80a7a64 <_strtoul_r+0x58>
 80a7af4:	230a      	movs	r3, #10
 80a7af6:	e7b5      	b.n	80a7a64 <_strtoul_r+0x58>
 80a7af8:	2c30      	cmp	r4, #48	; 0x30
 80a7afa:	d0ab      	beq.n	80a7a54 <_strtoul_r+0x48>
 80a7afc:	e7b2      	b.n	80a7a64 <_strtoul_r+0x58>
 80a7afe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a7b02:	bf00      	nop
 80a7b04:	20000308 	.word	0x20000308

080a7b08 <strtoul>:
 80a7b08:	4613      	mov	r3, r2
 80a7b0a:	460a      	mov	r2, r1
 80a7b0c:	4601      	mov	r1, r0
 80a7b0e:	4802      	ldr	r0, [pc, #8]	; (80a7b18 <strtoul+0x10>)
 80a7b10:	6800      	ldr	r0, [r0, #0]
 80a7b12:	f7ff bf7b 	b.w	80a7a0c <_strtoul_r>
 80a7b16:	bf00      	nop
 80a7b18:	2000036c 	.word	0x2000036c

080a7b1c <__tzcalc_limits>:
 80a7b1c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a7b20:	4604      	mov	r4, r0
 80a7b22:	f000 fa6f 	bl	80a8004 <__gettzinfo>
 80a7b26:	f240 73b1 	movw	r3, #1969	; 0x7b1
 80a7b2a:	429c      	cmp	r4, r3
 80a7b2c:	f340 8096 	ble.w	80a7c5c <__tzcalc_limits+0x140>
 80a7b30:	f240 156d 	movw	r5, #365	; 0x16d
 80a7b34:	f46f 63f6 	mvn.w	r3, #1968	; 0x7b0
 80a7b38:	18e3      	adds	r3, r4, r3
 80a7b3a:	f2a4 72b2 	subw	r2, r4, #1970	; 0x7b2
 80a7b3e:	109b      	asrs	r3, r3, #2
 80a7b40:	fb05 3502 	mla	r5, r5, r2, r3
 80a7b44:	f2a4 726d 	subw	r2, r4, #1901	; 0x76d
 80a7b48:	f06f 0363 	mvn.w	r3, #99	; 0x63
 80a7b4c:	fb92 f3f3 	sdiv	r3, r2, r3
 80a7b50:	f46f 62c8 	mvn.w	r2, #1600	; 0x640
 80a7b54:	442b      	add	r3, r5
 80a7b56:	18a5      	adds	r5, r4, r2
 80a7b58:	f44f 72c8 	mov.w	r2, #400	; 0x190
 80a7b5c:	fb94 f7f2 	sdiv	r7, r4, r2
 80a7b60:	fb95 f5f2 	sdiv	r5, r5, r2
 80a7b64:	fb02 4717 	mls	r7, r2, r7, r4
 80a7b68:	441d      	add	r5, r3
 80a7b6a:	2364      	movs	r3, #100	; 0x64
 80a7b6c:	fb94 f6f3 	sdiv	r6, r4, r3
 80a7b70:	fab7 fe87 	clz	lr, r7
 80a7b74:	4601      	mov	r1, r0
 80a7b76:	fb03 4616 	mls	r6, r3, r6, r4
 80a7b7a:	f100 0338 	add.w	r3, r0, #56	; 0x38
 80a7b7e:	9301      	str	r3, [sp, #4]
 80a7b80:	f004 0303 	and.w	r3, r4, #3
 80a7b84:	6044      	str	r4, [r0, #4]
 80a7b86:	ea4f 1e5e 	mov.w	lr, lr, lsr #5
 80a7b8a:	9300      	str	r3, [sp, #0]
 80a7b8c:	f04f 0c07 	mov.w	ip, #7
 80a7b90:	7a0b      	ldrb	r3, [r1, #8]
 80a7b92:	2b4a      	cmp	r3, #74	; 0x4a
 80a7b94:	d10e      	bne.n	80a7bb4 <__tzcalc_limits+0x98>
 80a7b96:	694b      	ldr	r3, [r1, #20]
 80a7b98:	9a00      	ldr	r2, [sp, #0]
 80a7b9a:	18ec      	adds	r4, r5, r3
 80a7b9c:	b902      	cbnz	r2, 80a7ba0 <__tzcalc_limits+0x84>
 80a7b9e:	b906      	cbnz	r6, 80a7ba2 <__tzcalc_limits+0x86>
 80a7ba0:	b927      	cbnz	r7, 80a7bac <__tzcalc_limits+0x90>
 80a7ba2:	2b3b      	cmp	r3, #59	; 0x3b
 80a7ba4:	bfd4      	ite	le
 80a7ba6:	2300      	movle	r3, #0
 80a7ba8:	2301      	movgt	r3, #1
 80a7baa:	e000      	b.n	80a7bae <__tzcalc_limits+0x92>
 80a7bac:	2300      	movs	r3, #0
 80a7bae:	4423      	add	r3, r4
 80a7bb0:	3b01      	subs	r3, #1
 80a7bb2:	e03f      	b.n	80a7c34 <__tzcalc_limits+0x118>
 80a7bb4:	2b44      	cmp	r3, #68	; 0x44
 80a7bb6:	d102      	bne.n	80a7bbe <__tzcalc_limits+0xa2>
 80a7bb8:	694b      	ldr	r3, [r1, #20]
 80a7bba:	442b      	add	r3, r5
 80a7bbc:	e03a      	b.n	80a7c34 <__tzcalc_limits+0x118>
 80a7bbe:	9b00      	ldr	r3, [sp, #0]
 80a7bc0:	b92b      	cbnz	r3, 80a7bce <__tzcalc_limits+0xb2>
 80a7bc2:	2e00      	cmp	r6, #0
 80a7bc4:	bf0c      	ite	eq
 80a7bc6:	46f0      	moveq	r8, lr
 80a7bc8:	f04f 0801 	movne.w	r8, #1
 80a7bcc:	e000      	b.n	80a7bd0 <__tzcalc_limits+0xb4>
 80a7bce:	46f0      	mov	r8, lr
 80a7bd0:	46a9      	mov	r9, r5
 80a7bd2:	4b24      	ldr	r3, [pc, #144]	; (80a7c64 <__tzcalc_limits+0x148>)
 80a7bd4:	2230      	movs	r2, #48	; 0x30
 80a7bd6:	fb02 3808 	mla	r8, r2, r8, r3
 80a7bda:	68cc      	ldr	r4, [r1, #12]
 80a7bdc:	f1a8 0a04 	sub.w	sl, r8, #4
 80a7be0:	2301      	movs	r3, #1
 80a7be2:	42a3      	cmp	r3, r4
 80a7be4:	da04      	bge.n	80a7bf0 <__tzcalc_limits+0xd4>
 80a7be6:	f85a bf04 	ldr.w	fp, [sl, #4]!
 80a7bea:	3301      	adds	r3, #1
 80a7bec:	44d9      	add	r9, fp
 80a7bee:	e7f8      	b.n	80a7be2 <__tzcalc_limits+0xc6>
 80a7bf0:	f109 0304 	add.w	r3, r9, #4
 80a7bf4:	fb93 fbfc 	sdiv	fp, r3, ip
 80a7bf8:	ebcb 0acb 	rsb	sl, fp, fp, lsl #3
 80a7bfc:	ebca 0a03 	rsb	sl, sl, r3
 80a7c00:	694b      	ldr	r3, [r1, #20]
 80a7c02:	2c01      	cmp	r4, #1
 80a7c04:	bfb8      	it	lt
 80a7c06:	2401      	movlt	r4, #1
 80a7c08:	ebb3 0a0a 	subs.w	sl, r3, sl
 80a7c0c:	690b      	ldr	r3, [r1, #16]
 80a7c0e:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 80a7c12:	f103 33ff 	add.w	r3, r3, #4294967295
 80a7c16:	f104 34ff 	add.w	r4, r4, #4294967295
 80a7c1a:	bf48      	it	mi
 80a7c1c:	f10a 0a07 	addmi.w	sl, sl, #7
 80a7c20:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a7c24:	f858 4024 	ldr.w	r4, [r8, r4, lsl #2]
 80a7c28:	4453      	add	r3, sl
 80a7c2a:	42a3      	cmp	r3, r4
 80a7c2c:	db01      	blt.n	80a7c32 <__tzcalc_limits+0x116>
 80a7c2e:	3b07      	subs	r3, #7
 80a7c30:	e7fb      	b.n	80a7c2a <__tzcalc_limits+0x10e>
 80a7c32:	444b      	add	r3, r9
 80a7c34:	698c      	ldr	r4, [r1, #24]
 80a7c36:	4a0c      	ldr	r2, [pc, #48]	; (80a7c68 <__tzcalc_limits+0x14c>)
 80a7c38:	fb02 4303 	mla	r3, r2, r3, r4
 80a7c3c:	6a0c      	ldr	r4, [r1, #32]
 80a7c3e:	4423      	add	r3, r4
 80a7c40:	f841 3f1c 	str.w	r3, [r1, #28]!
 80a7c44:	9b01      	ldr	r3, [sp, #4]
 80a7c46:	4299      	cmp	r1, r3
 80a7c48:	d1a2      	bne.n	80a7b90 <__tzcalc_limits+0x74>
 80a7c4a:	69c3      	ldr	r3, [r0, #28]
 80a7c4c:	6b82      	ldr	r2, [r0, #56]	; 0x38
 80a7c4e:	4293      	cmp	r3, r2
 80a7c50:	bfac      	ite	ge
 80a7c52:	2300      	movge	r3, #0
 80a7c54:	2301      	movlt	r3, #1
 80a7c56:	6003      	str	r3, [r0, #0]
 80a7c58:	2001      	movs	r0, #1
 80a7c5a:	e000      	b.n	80a7c5e <__tzcalc_limits+0x142>
 80a7c5c:	2000      	movs	r0, #0
 80a7c5e:	b003      	add	sp, #12
 80a7c60:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a7c64:	080a9680 	.word	0x080a9680
 80a7c68:	00015180 	.word	0x00015180

080a7c6c <__tz_lock>:
 80a7c6c:	4770      	bx	lr

080a7c6e <__tz_unlock>:
 80a7c6e:	4770      	bx	lr

080a7c70 <_tzset_unlocked>:
 80a7c70:	4b01      	ldr	r3, [pc, #4]	; (80a7c78 <_tzset_unlocked+0x8>)
 80a7c72:	6818      	ldr	r0, [r3, #0]
 80a7c74:	f000 b802 	b.w	80a7c7c <_tzset_unlocked_r>
 80a7c78:	2000036c 	.word	0x2000036c

080a7c7c <_tzset_unlocked_r>:
 80a7c7c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a7c80:	b08d      	sub	sp, #52	; 0x34
 80a7c82:	4607      	mov	r7, r0
 80a7c84:	f000 f9be 	bl	80a8004 <__gettzinfo>
 80a7c88:	49b0      	ldr	r1, [pc, #704]	; (80a7f4c <_tzset_unlocked_r+0x2d0>)
 80a7c8a:	4604      	mov	r4, r0
 80a7c8c:	4638      	mov	r0, r7
 80a7c8e:	f000 f9b1 	bl	80a7ff4 <_getenv_r>
 80a7c92:	4eaf      	ldr	r6, [pc, #700]	; (80a7f50 <_tzset_unlocked_r+0x2d4>)
 80a7c94:	4605      	mov	r5, r0
 80a7c96:	b960      	cbnz	r0, 80a7cb2 <_tzset_unlocked_r+0x36>
 80a7c98:	4bae      	ldr	r3, [pc, #696]	; (80a7f54 <_tzset_unlocked_r+0x2d8>)
 80a7c9a:	4aaf      	ldr	r2, [pc, #700]	; (80a7f58 <_tzset_unlocked_r+0x2dc>)
 80a7c9c:	6018      	str	r0, [r3, #0]
 80a7c9e:	4baf      	ldr	r3, [pc, #700]	; (80a7f5c <_tzset_unlocked_r+0x2e0>)
 80a7ca0:	6018      	str	r0, [r3, #0]
 80a7ca2:	4baf      	ldr	r3, [pc, #700]	; (80a7f60 <_tzset_unlocked_r+0x2e4>)
 80a7ca4:	6830      	ldr	r0, [r6, #0]
 80a7ca6:	601a      	str	r2, [r3, #0]
 80a7ca8:	605a      	str	r2, [r3, #4]
 80a7caa:	f7fd fc33 	bl	80a5514 <free>
 80a7cae:	6035      	str	r5, [r6, #0]
 80a7cb0:	e148      	b.n	80a7f44 <_tzset_unlocked_r+0x2c8>
 80a7cb2:	6831      	ldr	r1, [r6, #0]
 80a7cb4:	b979      	cbnz	r1, 80a7cd6 <_tzset_unlocked_r+0x5a>
 80a7cb6:	6830      	ldr	r0, [r6, #0]
 80a7cb8:	f7fd fc2c 	bl	80a5514 <free>
 80a7cbc:	4628      	mov	r0, r5
 80a7cbe:	f7ff fe74 	bl	80a79aa <strlen>
 80a7cc2:	1c41      	adds	r1, r0, #1
 80a7cc4:	4638      	mov	r0, r7
 80a7cc6:	f7fd fc4d 	bl	80a5564 <_malloc_r>
 80a7cca:	6030      	str	r0, [r6, #0]
 80a7ccc:	b148      	cbz	r0, 80a7ce2 <_tzset_unlocked_r+0x66>
 80a7cce:	4629      	mov	r1, r5
 80a7cd0:	f7ff fe47 	bl	80a7962 <strcpy>
 80a7cd4:	e005      	b.n	80a7ce2 <_tzset_unlocked_r+0x66>
 80a7cd6:	f7ff fe3a 	bl	80a794e <strcmp>
 80a7cda:	2800      	cmp	r0, #0
 80a7cdc:	f000 8132 	beq.w	80a7f44 <_tzset_unlocked_r+0x2c8>
 80a7ce0:	e7e9      	b.n	80a7cb6 <_tzset_unlocked_r+0x3a>
 80a7ce2:	782b      	ldrb	r3, [r5, #0]
 80a7ce4:	ae0a      	add	r6, sp, #40	; 0x28
 80a7ce6:	2b3a      	cmp	r3, #58	; 0x3a
 80a7ce8:	bf08      	it	eq
 80a7cea:	3501      	addeq	r5, #1
 80a7cec:	4633      	mov	r3, r6
 80a7cee:	4a9d      	ldr	r2, [pc, #628]	; (80a7f64 <_tzset_unlocked_r+0x2e8>)
 80a7cf0:	499d      	ldr	r1, [pc, #628]	; (80a7f68 <_tzset_unlocked_r+0x2ec>)
 80a7cf2:	4628      	mov	r0, r5
 80a7cf4:	f7fd fc1e 	bl	80a5534 <siscanf>
 80a7cf8:	2800      	cmp	r0, #0
 80a7cfa:	f340 8123 	ble.w	80a7f44 <_tzset_unlocked_r+0x2c8>
 80a7cfe:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80a7d00:	18ef      	adds	r7, r5, r3
 80a7d02:	5ceb      	ldrb	r3, [r5, r3]
 80a7d04:	2b2d      	cmp	r3, #45	; 0x2d
 80a7d06:	d103      	bne.n	80a7d10 <_tzset_unlocked_r+0x94>
 80a7d08:	3701      	adds	r7, #1
 80a7d0a:	f04f 35ff 	mov.w	r5, #4294967295
 80a7d0e:	e003      	b.n	80a7d18 <_tzset_unlocked_r+0x9c>
 80a7d10:	2b2b      	cmp	r3, #43	; 0x2b
 80a7d12:	bf08      	it	eq
 80a7d14:	3701      	addeq	r7, #1
 80a7d16:	2501      	movs	r5, #1
 80a7d18:	f10d 0a20 	add.w	sl, sp, #32
 80a7d1c:	f10d 0b1e 	add.w	fp, sp, #30
 80a7d20:	f04f 0800 	mov.w	r8, #0
 80a7d24:	9603      	str	r6, [sp, #12]
 80a7d26:	f8cd a008 	str.w	sl, [sp, #8]
 80a7d2a:	9601      	str	r6, [sp, #4]
 80a7d2c:	f8cd b000 	str.w	fp, [sp]
 80a7d30:	4633      	mov	r3, r6
 80a7d32:	aa07      	add	r2, sp, #28
 80a7d34:	498d      	ldr	r1, [pc, #564]	; (80a7f6c <_tzset_unlocked_r+0x2f0>)
 80a7d36:	4638      	mov	r0, r7
 80a7d38:	f8ad 801e 	strh.w	r8, [sp, #30]
 80a7d3c:	f8ad 8020 	strh.w	r8, [sp, #32]
 80a7d40:	f7fd fbf8 	bl	80a5534 <siscanf>
 80a7d44:	4540      	cmp	r0, r8
 80a7d46:	f340 80fd 	ble.w	80a7f44 <_tzset_unlocked_r+0x2c8>
 80a7d4a:	f8bd 201e 	ldrh.w	r2, [sp, #30]
 80a7d4e:	f8bd 3020 	ldrh.w	r3, [sp, #32]
 80a7d52:	213c      	movs	r1, #60	; 0x3c
 80a7d54:	fb01 3302 	mla	r3, r1, r2, r3
 80a7d58:	f8bd 201c 	ldrh.w	r2, [sp, #28]
 80a7d5c:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 80a7d60:	fb01 3302 	mla	r3, r1, r2, r3
 80a7d64:	435d      	muls	r5, r3
 80a7d66:	4b7f      	ldr	r3, [pc, #508]	; (80a7f64 <_tzset_unlocked_r+0x2e8>)
 80a7d68:	6225      	str	r5, [r4, #32]
 80a7d6a:	4d7d      	ldr	r5, [pc, #500]	; (80a7f60 <_tzset_unlocked_r+0x2e4>)
 80a7d6c:	f8df 9208 	ldr.w	r9, [pc, #520]	; 80a7f78 <_tzset_unlocked_r+0x2fc>
 80a7d70:	602b      	str	r3, [r5, #0]
 80a7d72:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80a7d74:	464a      	mov	r2, r9
 80a7d76:	441f      	add	r7, r3
 80a7d78:	497b      	ldr	r1, [pc, #492]	; (80a7f68 <_tzset_unlocked_r+0x2ec>)
 80a7d7a:	4633      	mov	r3, r6
 80a7d7c:	4638      	mov	r0, r7
 80a7d7e:	f7fd fbd9 	bl	80a5534 <siscanf>
 80a7d82:	4540      	cmp	r0, r8
 80a7d84:	dc08      	bgt.n	80a7d98 <_tzset_unlocked_r+0x11c>
 80a7d86:	682b      	ldr	r3, [r5, #0]
 80a7d88:	6a22      	ldr	r2, [r4, #32]
 80a7d8a:	606b      	str	r3, [r5, #4]
 80a7d8c:	4b71      	ldr	r3, [pc, #452]	; (80a7f54 <_tzset_unlocked_r+0x2d8>)
 80a7d8e:	601a      	str	r2, [r3, #0]
 80a7d90:	4b72      	ldr	r3, [pc, #456]	; (80a7f5c <_tzset_unlocked_r+0x2e0>)
 80a7d92:	f8c3 8000 	str.w	r8, [r3]
 80a7d96:	e0d5      	b.n	80a7f44 <_tzset_unlocked_r+0x2c8>
 80a7d98:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80a7d9a:	f8c5 9004 	str.w	r9, [r5, #4]
 80a7d9e:	18fd      	adds	r5, r7, r3
 80a7da0:	5cfb      	ldrb	r3, [r7, r3]
 80a7da2:	2b2d      	cmp	r3, #45	; 0x2d
 80a7da4:	d103      	bne.n	80a7dae <_tzset_unlocked_r+0x132>
 80a7da6:	3501      	adds	r5, #1
 80a7da8:	f04f 37ff 	mov.w	r7, #4294967295
 80a7dac:	e003      	b.n	80a7db6 <_tzset_unlocked_r+0x13a>
 80a7dae:	2b2b      	cmp	r3, #43	; 0x2b
 80a7db0:	bf08      	it	eq
 80a7db2:	3501      	addeq	r5, #1
 80a7db4:	2701      	movs	r7, #1
 80a7db6:	2300      	movs	r3, #0
 80a7db8:	f8ad 301c 	strh.w	r3, [sp, #28]
 80a7dbc:	f8ad 301e 	strh.w	r3, [sp, #30]
 80a7dc0:	f8ad 3020 	strh.w	r3, [sp, #32]
 80a7dc4:	930a      	str	r3, [sp, #40]	; 0x28
 80a7dc6:	9603      	str	r6, [sp, #12]
 80a7dc8:	f8cd a008 	str.w	sl, [sp, #8]
 80a7dcc:	9601      	str	r6, [sp, #4]
 80a7dce:	f8cd b000 	str.w	fp, [sp]
 80a7dd2:	4633      	mov	r3, r6
 80a7dd4:	aa07      	add	r2, sp, #28
 80a7dd6:	4965      	ldr	r1, [pc, #404]	; (80a7f6c <_tzset_unlocked_r+0x2f0>)
 80a7dd8:	4628      	mov	r0, r5
 80a7dda:	f7fd fbab 	bl	80a5534 <siscanf>
 80a7dde:	2800      	cmp	r0, #0
 80a7de0:	dc04      	bgt.n	80a7dec <_tzset_unlocked_r+0x170>
 80a7de2:	6a23      	ldr	r3, [r4, #32]
 80a7de4:	f5a3 6361 	sub.w	r3, r3, #3600	; 0xe10
 80a7de8:	63e3      	str	r3, [r4, #60]	; 0x3c
 80a7dea:	e00e      	b.n	80a7e0a <_tzset_unlocked_r+0x18e>
 80a7dec:	f8bd 201e 	ldrh.w	r2, [sp, #30]
 80a7df0:	f8bd 3020 	ldrh.w	r3, [sp, #32]
 80a7df4:	213c      	movs	r1, #60	; 0x3c
 80a7df6:	fb01 3302 	mla	r3, r1, r2, r3
 80a7dfa:	f8bd 201c 	ldrh.w	r2, [sp, #28]
 80a7dfe:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 80a7e02:	fb01 3302 	mla	r3, r1, r2, r3
 80a7e06:	435f      	muls	r7, r3
 80a7e08:	63e7      	str	r7, [r4, #60]	; 0x3c
 80a7e0a:	4627      	mov	r7, r4
 80a7e0c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80a7e0e:	f04f 0900 	mov.w	r9, #0
 80a7e12:	441d      	add	r5, r3
 80a7e14:	782b      	ldrb	r3, [r5, #0]
 80a7e16:	2b2c      	cmp	r3, #44	; 0x2c
 80a7e18:	bf08      	it	eq
 80a7e1a:	3501      	addeq	r5, #1
 80a7e1c:	f895 8000 	ldrb.w	r8, [r5]
 80a7e20:	f1b8 0f4d 	cmp.w	r8, #77	; 0x4d
 80a7e24:	d126      	bne.n	80a7e74 <_tzset_unlocked_r+0x1f8>
 80a7e26:	f10d 0326 	add.w	r3, sp, #38	; 0x26
 80a7e2a:	9302      	str	r3, [sp, #8]
 80a7e2c:	ab09      	add	r3, sp, #36	; 0x24
 80a7e2e:	9300      	str	r3, [sp, #0]
 80a7e30:	9603      	str	r6, [sp, #12]
 80a7e32:	9601      	str	r6, [sp, #4]
 80a7e34:	4633      	mov	r3, r6
 80a7e36:	f10d 0222 	add.w	r2, sp, #34	; 0x22
 80a7e3a:	494d      	ldr	r1, [pc, #308]	; (80a7f70 <_tzset_unlocked_r+0x2f4>)
 80a7e3c:	4628      	mov	r0, r5
 80a7e3e:	f7fd fb79 	bl	80a5534 <siscanf>
 80a7e42:	2803      	cmp	r0, #3
 80a7e44:	d17e      	bne.n	80a7f44 <_tzset_unlocked_r+0x2c8>
 80a7e46:	f8bd 1022 	ldrh.w	r1, [sp, #34]	; 0x22
 80a7e4a:	1e4b      	subs	r3, r1, #1
 80a7e4c:	2b0b      	cmp	r3, #11
 80a7e4e:	d879      	bhi.n	80a7f44 <_tzset_unlocked_r+0x2c8>
 80a7e50:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
 80a7e54:	1e53      	subs	r3, r2, #1
 80a7e56:	2b04      	cmp	r3, #4
 80a7e58:	d874      	bhi.n	80a7f44 <_tzset_unlocked_r+0x2c8>
 80a7e5a:	f8bd 3026 	ldrh.w	r3, [sp, #38]	; 0x26
 80a7e5e:	2b06      	cmp	r3, #6
 80a7e60:	d870      	bhi.n	80a7f44 <_tzset_unlocked_r+0x2c8>
 80a7e62:	f887 8008 	strb.w	r8, [r7, #8]
 80a7e66:	60f9      	str	r1, [r7, #12]
 80a7e68:	613a      	str	r2, [r7, #16]
 80a7e6a:	617b      	str	r3, [r7, #20]
 80a7e6c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80a7e6e:	eb05 0803 	add.w	r8, r5, r3
 80a7e72:	e02a      	b.n	80a7eca <_tzset_unlocked_r+0x24e>
 80a7e74:	f1b8 0f4a 	cmp.w	r8, #74	; 0x4a
 80a7e78:	bf06      	itte	eq
 80a7e7a:	4643      	moveq	r3, r8
 80a7e7c:	3501      	addeq	r5, #1
 80a7e7e:	2344      	movne	r3, #68	; 0x44
 80a7e80:	220a      	movs	r2, #10
 80a7e82:	a90b      	add	r1, sp, #44	; 0x2c
 80a7e84:	4628      	mov	r0, r5
 80a7e86:	9305      	str	r3, [sp, #20]
 80a7e88:	f7ff fe3e 	bl	80a7b08 <strtoul>
 80a7e8c:	f8dd 802c 	ldr.w	r8, [sp, #44]	; 0x2c
 80a7e90:	f8ad 0026 	strh.w	r0, [sp, #38]	; 0x26
 80a7e94:	4545      	cmp	r5, r8
 80a7e96:	9b05      	ldr	r3, [sp, #20]
 80a7e98:	d114      	bne.n	80a7ec4 <_tzset_unlocked_r+0x248>
 80a7e9a:	234d      	movs	r3, #77	; 0x4d
 80a7e9c:	f1b9 0f00 	cmp.w	r9, #0
 80a7ea0:	d107      	bne.n	80a7eb2 <_tzset_unlocked_r+0x236>
 80a7ea2:	7223      	strb	r3, [r4, #8]
 80a7ea4:	2303      	movs	r3, #3
 80a7ea6:	60e3      	str	r3, [r4, #12]
 80a7ea8:	2302      	movs	r3, #2
 80a7eaa:	6123      	str	r3, [r4, #16]
 80a7eac:	f8c4 9014 	str.w	r9, [r4, #20]
 80a7eb0:	e00b      	b.n	80a7eca <_tzset_unlocked_r+0x24e>
 80a7eb2:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
 80a7eb6:	230b      	movs	r3, #11
 80a7eb8:	62a3      	str	r3, [r4, #40]	; 0x28
 80a7eba:	2301      	movs	r3, #1
 80a7ebc:	62e3      	str	r3, [r4, #44]	; 0x2c
 80a7ebe:	2300      	movs	r3, #0
 80a7ec0:	6323      	str	r3, [r4, #48]	; 0x30
 80a7ec2:	e002      	b.n	80a7eca <_tzset_unlocked_r+0x24e>
 80a7ec4:	b280      	uxth	r0, r0
 80a7ec6:	723b      	strb	r3, [r7, #8]
 80a7ec8:	6178      	str	r0, [r7, #20]
 80a7eca:	2302      	movs	r3, #2
 80a7ecc:	f8ad 301c 	strh.w	r3, [sp, #28]
 80a7ed0:	2300      	movs	r3, #0
 80a7ed2:	f8ad 301e 	strh.w	r3, [sp, #30]
 80a7ed6:	f8ad 3020 	strh.w	r3, [sp, #32]
 80a7eda:	930a      	str	r3, [sp, #40]	; 0x28
 80a7edc:	f898 3000 	ldrb.w	r3, [r8]
 80a7ee0:	2b2f      	cmp	r3, #47	; 0x2f
 80a7ee2:	d10b      	bne.n	80a7efc <_tzset_unlocked_r+0x280>
 80a7ee4:	9603      	str	r6, [sp, #12]
 80a7ee6:	f8cd a008 	str.w	sl, [sp, #8]
 80a7eea:	9601      	str	r6, [sp, #4]
 80a7eec:	f8cd b000 	str.w	fp, [sp]
 80a7ef0:	4633      	mov	r3, r6
 80a7ef2:	aa07      	add	r2, sp, #28
 80a7ef4:	491f      	ldr	r1, [pc, #124]	; (80a7f74 <_tzset_unlocked_r+0x2f8>)
 80a7ef6:	4640      	mov	r0, r8
 80a7ef8:	f7fd fb1c 	bl	80a5534 <siscanf>
 80a7efc:	f8bd 201e 	ldrh.w	r2, [sp, #30]
 80a7f00:	f8bd 3020 	ldrh.w	r3, [sp, #32]
 80a7f04:	213c      	movs	r1, #60	; 0x3c
 80a7f06:	fb01 3302 	mla	r3, r1, r2, r3
 80a7f0a:	f8bd 201c 	ldrh.w	r2, [sp, #28]
 80a7f0e:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 80a7f12:	fb01 3302 	mla	r3, r1, r2, r3
 80a7f16:	61bb      	str	r3, [r7, #24]
 80a7f18:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 80a7f1a:	f109 0901 	add.w	r9, r9, #1
 80a7f1e:	f1b9 0f02 	cmp.w	r9, #2
 80a7f22:	4445      	add	r5, r8
 80a7f24:	f107 071c 	add.w	r7, r7, #28
 80a7f28:	f47f af74 	bne.w	80a7e14 <_tzset_unlocked_r+0x198>
 80a7f2c:	6860      	ldr	r0, [r4, #4]
 80a7f2e:	f7ff fdf5 	bl	80a7b1c <__tzcalc_limits>
 80a7f32:	6a22      	ldr	r2, [r4, #32]
 80a7f34:	4b07      	ldr	r3, [pc, #28]	; (80a7f54 <_tzset_unlocked_r+0x2d8>)
 80a7f36:	601a      	str	r2, [r3, #0]
 80a7f38:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80a7f3a:	1a9b      	subs	r3, r3, r2
 80a7f3c:	4a07      	ldr	r2, [pc, #28]	; (80a7f5c <_tzset_unlocked_r+0x2e0>)
 80a7f3e:	bf18      	it	ne
 80a7f40:	2301      	movne	r3, #1
 80a7f42:	6013      	str	r3, [r2, #0]
 80a7f44:	b00d      	add	sp, #52	; 0x34
 80a7f46:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a7f4a:	bf00      	nop
 80a7f4c:	080a96e0 	.word	0x080a96e0
 80a7f50:	20001630 	.word	0x20001630
 80a7f54:	20001638 	.word	0x20001638
 80a7f58:	080a96e3 	.word	0x080a96e3
 80a7f5c:	20001634 	.word	0x20001634
 80a7f60:	20000370 	.word	0x20000370
 80a7f64:	20001623 	.word	0x20001623
 80a7f68:	080a96e7 	.word	0x080a96e7
 80a7f6c:	080a970a 	.word	0x080a970a
 80a7f70:	080a96f6 	.word	0x080a96f6
 80a7f74:	080a9709 	.word	0x080a9709
 80a7f78:	20001618 	.word	0x20001618

080a7f7c <_findenv_r>:
 80a7f7c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a7f80:	4607      	mov	r7, r0
 80a7f82:	468b      	mov	fp, r1
 80a7f84:	4690      	mov	r8, r2
 80a7f86:	f000 f8d7 	bl	80a8138 <__env_lock>
 80a7f8a:	4b19      	ldr	r3, [pc, #100]	; (80a7ff0 <_findenv_r+0x74>)
 80a7f8c:	681d      	ldr	r5, [r3, #0]
 80a7f8e:	469a      	mov	sl, r3
 80a7f90:	b13d      	cbz	r5, 80a7fa2 <_findenv_r+0x26>
 80a7f92:	465c      	mov	r4, fp
 80a7f94:	4623      	mov	r3, r4
 80a7f96:	f813 2b01 	ldrb.w	r2, [r3], #1
 80a7f9a:	b142      	cbz	r2, 80a7fae <_findenv_r+0x32>
 80a7f9c:	2a3d      	cmp	r2, #61	; 0x3d
 80a7f9e:	461c      	mov	r4, r3
 80a7fa0:	d1f8      	bne.n	80a7f94 <_findenv_r+0x18>
 80a7fa2:	4638      	mov	r0, r7
 80a7fa4:	f000 f8c9 	bl	80a813a <__env_unlock>
 80a7fa8:	2000      	movs	r0, #0
 80a7faa:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a7fae:	ebcb 0404 	rsb	r4, fp, r4
 80a7fb2:	46a9      	mov	r9, r5
 80a7fb4:	f859 0b04 	ldr.w	r0, [r9], #4
 80a7fb8:	2800      	cmp	r0, #0
 80a7fba:	d0f2      	beq.n	80a7fa2 <_findenv_r+0x26>
 80a7fbc:	4622      	mov	r2, r4
 80a7fbe:	4659      	mov	r1, fp
 80a7fc0:	f7ff fcfb 	bl	80a79ba <strncmp>
 80a7fc4:	b988      	cbnz	r0, 80a7fea <_findenv_r+0x6e>
 80a7fc6:	f859 3c04 	ldr.w	r3, [r9, #-4]
 80a7fca:	191e      	adds	r6, r3, r4
 80a7fcc:	5d1b      	ldrb	r3, [r3, r4]
 80a7fce:	2b3d      	cmp	r3, #61	; 0x3d
 80a7fd0:	d10b      	bne.n	80a7fea <_findenv_r+0x6e>
 80a7fd2:	f8da 3000 	ldr.w	r3, [sl]
 80a7fd6:	4638      	mov	r0, r7
 80a7fd8:	1aed      	subs	r5, r5, r3
 80a7fda:	10ad      	asrs	r5, r5, #2
 80a7fdc:	f8c8 5000 	str.w	r5, [r8]
 80a7fe0:	f000 f8ab 	bl	80a813a <__env_unlock>
 80a7fe4:	1c70      	adds	r0, r6, #1
 80a7fe6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a7fea:	464d      	mov	r5, r9
 80a7fec:	e7e1      	b.n	80a7fb2 <_findenv_r+0x36>
 80a7fee:	bf00      	nop
 80a7ff0:	200003b8 	.word	0x200003b8

080a7ff4 <_getenv_r>:
 80a7ff4:	b507      	push	{r0, r1, r2, lr}
 80a7ff6:	aa01      	add	r2, sp, #4
 80a7ff8:	f7ff ffc0 	bl	80a7f7c <_findenv_r>
 80a7ffc:	b003      	add	sp, #12
 80a7ffe:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080a8004 <__gettzinfo>:
 80a8004:	4800      	ldr	r0, [pc, #0]	; (80a8008 <__gettzinfo+0x4>)
 80a8006:	4770      	bx	lr
 80a8008:	20000378 	.word	0x20000378

080a800c <gmtime_r>:
 80a800c:	6802      	ldr	r2, [r0, #0]
 80a800e:	4b46      	ldr	r3, [pc, #280]	; (80a8128 <gmtime_r+0x11c>)
 80a8010:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a8012:	fb92 f4f3 	sdiv	r4, r2, r3
 80a8016:	fb03 2214 	mls	r2, r3, r4, r2
 80a801a:	2a00      	cmp	r2, #0
 80a801c:	bfbc      	itt	lt
 80a801e:	f502 32a8 	addlt.w	r2, r2, #86016	; 0x15000
 80a8022:	f502 72c0 	addlt.w	r2, r2, #384	; 0x180
 80a8026:	f44f 6061 	mov.w	r0, #3600	; 0xe10
 80a802a:	fb92 f3f0 	sdiv	r3, r2, r0
 80a802e:	fb00 2213 	mls	r2, r0, r3, r2
 80a8032:	f04f 003c 	mov.w	r0, #60	; 0x3c
 80a8036:	608b      	str	r3, [r1, #8]
 80a8038:	fb92 f3f0 	sdiv	r3, r2, r0
 80a803c:	fb00 2213 	mls	r2, r0, r3, r2
 80a8040:	f504 242f 	add.w	r4, r4, #716800	; 0xaf000
 80a8044:	bfac      	ite	ge
 80a8046:	f604 246c 	addwge	r4, r4, #2668	; 0xa6c
 80a804a:	f604 246b 	addwlt	r4, r4, #2667	; 0xa6b
 80a804e:	604b      	str	r3, [r1, #4]
 80a8050:	600a      	str	r2, [r1, #0]
 80a8052:	2307      	movs	r3, #7
 80a8054:	1ce2      	adds	r2, r4, #3
 80a8056:	fb92 f3f3 	sdiv	r3, r2, r3
 80a805a:	4d34      	ldr	r5, [pc, #208]	; (80a812c <gmtime_r+0x120>)
 80a805c:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a8060:	fb94 f5f5 	sdiv	r5, r4, r5
 80a8064:	1ad3      	subs	r3, r2, r3
 80a8066:	f648 62ac 	movw	r2, #36524	; 0x8eac
 80a806a:	f240 57b4 	movw	r7, #1460	; 0x5b4
 80a806e:	618b      	str	r3, [r1, #24]
 80a8070:	4b2f      	ldr	r3, [pc, #188]	; (80a8130 <gmtime_r+0x124>)
 80a8072:	4830      	ldr	r0, [pc, #192]	; (80a8134 <gmtime_r+0x128>)
 80a8074:	fb03 4405 	mla	r4, r3, r5, r4
 80a8078:	fbb4 f2f2 	udiv	r2, r4, r2
 80a807c:	fbb4 f3f7 	udiv	r3, r4, r7
 80a8080:	fbb4 f0f0 	udiv	r0, r4, r0
 80a8084:	4422      	add	r2, r4
 80a8086:	1ad2      	subs	r2, r2, r3
 80a8088:	f648 6694 	movw	r6, #36500	; 0x8e94
 80a808c:	1a13      	subs	r3, r2, r0
 80a808e:	f240 126d 	movw	r2, #365	; 0x16d
 80a8092:	fbb3 f6f6 	udiv	r6, r3, r6
 80a8096:	fbb3 f0f2 	udiv	r0, r3, r2
 80a809a:	fbb3 f3f7 	udiv	r3, r3, r7
 80a809e:	4434      	add	r4, r6
 80a80a0:	1ae3      	subs	r3, r4, r3
 80a80a2:	fb02 3310 	mls	r3, r2, r0, r3
 80a80a6:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 80a80aa:	2499      	movs	r4, #153	; 0x99
 80a80ac:	3202      	adds	r2, #2
 80a80ae:	fbb2 f2f4 	udiv	r2, r2, r4
 80a80b2:	4354      	muls	r4, r2
 80a80b4:	1ca6      	adds	r6, r4, #2
 80a80b6:	2405      	movs	r4, #5
 80a80b8:	fbb6 f4f4 	udiv	r4, r6, r4
 80a80bc:	2a0a      	cmp	r2, #10
 80a80be:	bf34      	ite	cc
 80a80c0:	2602      	movcc	r6, #2
 80a80c2:	f06f 0609 	mvncs.w	r6, #9
 80a80c6:	4416      	add	r6, r2
 80a80c8:	f44f 72c8 	mov.w	r2, #400	; 0x190
 80a80cc:	fb02 0505 	mla	r5, r2, r5, r0
 80a80d0:	1c5f      	adds	r7, r3, #1
 80a80d2:	2e01      	cmp	r6, #1
 80a80d4:	bf98      	it	ls
 80a80d6:	3501      	addls	r5, #1
 80a80d8:	f5b3 7f99 	cmp.w	r3, #306	; 0x132
 80a80dc:	eba7 0704 	sub.w	r7, r7, r4
 80a80e0:	d302      	bcc.n	80a80e8 <gmtime_r+0xdc>
 80a80e2:	f5a3 7299 	sub.w	r2, r3, #306	; 0x132
 80a80e6:	e014      	b.n	80a8112 <gmtime_r+0x106>
 80a80e8:	0782      	lsls	r2, r0, #30
 80a80ea:	d105      	bne.n	80a80f8 <gmtime_r+0xec>
 80a80ec:	2464      	movs	r4, #100	; 0x64
 80a80ee:	fbb0 f2f4 	udiv	r2, r0, r4
 80a80f2:	fb04 0212 	mls	r2, r4, r2, r0
 80a80f6:	b94a      	cbnz	r2, 80a810c <gmtime_r+0x100>
 80a80f8:	f44f 72c8 	mov.w	r2, #400	; 0x190
 80a80fc:	fbb0 f4f2 	udiv	r4, r0, r2
 80a8100:	fb02 0014 	mls	r0, r2, r4, r0
 80a8104:	fab0 f280 	clz	r2, r0
 80a8108:	0952      	lsrs	r2, r2, #5
 80a810a:	e000      	b.n	80a810e <gmtime_r+0x102>
 80a810c:	2201      	movs	r2, #1
 80a810e:	333b      	adds	r3, #59	; 0x3b
 80a8110:	441a      	add	r2, r3
 80a8112:	f2a5 756c 	subw	r5, r5, #1900	; 0x76c
 80a8116:	2300      	movs	r3, #0
 80a8118:	61ca      	str	r2, [r1, #28]
 80a811a:	614d      	str	r5, [r1, #20]
 80a811c:	610e      	str	r6, [r1, #16]
 80a811e:	60cf      	str	r7, [r1, #12]
 80a8120:	620b      	str	r3, [r1, #32]
 80a8122:	4608      	mov	r0, r1
 80a8124:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a8126:	bf00      	nop
 80a8128:	00015180 	.word	0x00015180
 80a812c:	00023ab1 	.word	0x00023ab1
 80a8130:	fffdc54f 	.word	0xfffdc54f
 80a8134:	00023ab0 	.word	0x00023ab0

080a8138 <__env_lock>:
 80a8138:	4770      	bx	lr

080a813a <__env_unlock>:
 80a813a:	4770      	bx	lr

080a813c <dynalib_user>:
 80a813c:	001d 080a 005d 080a 0089 080a 008d 080a     ....]...........
 80a814c:	0000 0000 6c73 6565 3d70 0030 6964 3d6d     ....sleep=0.dim=
 80a815c:	3036 7000 6761 2065 0034 6170 6567 3020     60.page 4.page 0
 80a816c:	7300 656c 7065 3d20 3020 6400 6d69 3d20     .sleep = 0.dim =
 80a817c:	3520 0030 6c73 6565 2070 203d 0031 6964      50.sleep = 1.di
 80a818c:	206d 203d 0030 3067 742e 7478 003d 7271     m = 0.g0.txt=.qr
 80a819c:	2e30 7874 3d74 7000 6761 2065 3331 6400     0.txt=.page 13.d
 80a81ac:	6d69 323d 0030 003a 002f 654d 7272 2079     im=20.:./.Merry 
 80a81bc:	6843 6972 7473 616d 0073 6854 6e61 736b     Christmas.Thanks
 80a81cc:	6967 6976 676e 0073 6148 7070 2079 6156     givings.Happy Va
 80a81dc:	656c 746e 6e69 7365 4900 6c20 766f 2065     lentines.I love 
 80a81ec:	6f79 2075 293a 0000                         you :)..

080a81f4 <_ZTV5Timer>:
	...
 80a81fc:	0b31 080a 0b71 080a 0915 080a 2828 4132     1...q.......((2A
 80a820c:	2800 3228 0141 7865 7469 4500 6978 6974     .((2A.exit.Exiti
 80a821c:	676e 4500 6978 6974 676e 002e 7845 7469     ng.Exiting..Exit
 80a822c:	6e69 2e67 002e 7845 7469 6e69 2e67 2e2e     ing...Exiting...
 80a823c:	4500 6978 6974 676e 2e2e 2e2e 7200 7365     .Exiting.....res
 80a824c:	7465 5200 7365 7465 6974 676e 4420 7665     et.Resetting Dev
 80a825c:	6369 0065 6552 6573 7474 6e69 2067 6544     ice.Resetting De
 80a826c:	6976 6563 002e 6552 6573 7474 6e69 2067     vice..Resetting 
 80a827c:	6544 6976 6563 2e2e 5200 7365 7465 6974     Device...Resetti
 80a828c:	676e 4420 7665 6369 2e65 2e2e 5200 7365     ng Device....Res
 80a829c:	7465 6974 676e 4420 7665 6369 2e65 2e2e     etting Device...
 80a82ac:	002e 6552 6573 7474 6e69 2067 6544 6976     ..Resetting Devi
 80a82bc:	6563 2e2e 2e2e 002e 6977 6966 696c 7473     ce......wifilist
 80a82cc:	6e65 5300 7465 6974 676e 5720 6669 2069     en.Setting Wifi 
 80a82dc:	6f74 6c20 7369 6574 696e 676e 6d20 646f     to listening mod
 80a82ec:	2e65 2e2e 5700 4669 2069 6168 2073 6562     e....WiFi has be
 80a82fc:	6e65 7320 7465 7420 206f 696c 7473 6e65     en set to listen
 80a830c:	6e69 2067 6f6d 6564 2121 6200 6565 0070     ing mode!!.beep.
 80a831c:	6562 7065 6e69 2e67 2e2e 4300 6d6f 6c70     beeping....Compl
 80a832c:	7465 6465 4220 6565 6970 676e 4d00 7365     eted Beeping.Mes
 80a833c:	6173 6567 5220 6365 6965 7665 6465 5100     sage Receieved.Q
 80a834c:	6975 6b63 654d 7373 6761 0065 4c73 7400     uickMessage.sL.t
 80a835c:	004c 6f74 6767 656c 6957 6966 7700 6b61     L.toggleWifi.wak
 80a836c:	5565 4270 7475 6f74 006e 306a 7400 7865     eUpButton.j0.tex
 80a837c:	4274 786f 6700 0030 506e 7400 0030 7271     tBox.g0.nP.t0.qr
 80a838c:	6154 0067 3162 6200 0032 3362 6200 0034     Tag.b1.b2.b3.b4.
 80a839c:	3562 6200 3733 7400 3062 6200 0039 3162     b5.b37.tb0.b9.b1
 80a83ac:	0030 3862 6600 6e75 7463 6f69 316e 0031     0.b8.function11.
 80a83bc:	7566 636e 6974 6e6f 3231 6600 6e75 7463     function12.funct
 80a83cc:	6f69 316e 0033 7566 636e 6974 6e6f 3431     ion13.function14
 80a83dc:	6600 6e75 7463 6f69 316e 0035 7566 636e     .function15.func
 80a83ec:	6974 6e6f 3631 6600 6e75 7463 6f69 316e     tion16.function1
 80a83fc:	0037 7566 636e 6974 6e6f 3831 6600 6e75     7.function18.fun
 80a840c:	7463 6f69 326e 0031 7566 636e 6974 6e6f     ction21.function
 80a841c:	3232 6600 6e75 7463 6f69 326e 0033 7566     22.function23.fu
 80a842c:	636e 6974 6e6f 3432 6600 6e75 7463 6f69     nction24.functio
 80a843c:	326e 0035 7566 636e 6974 6e6f 3632 6600     n25.function26.f
 80a844c:	6e75 7463 6f69 206e 3732 7a00 0030 6568     unction 27.z0.he
 80a845c:	7a00 0031 327a 6e00 0030 316e 6e00 0032     .z1.z2.n0.n1.n2.
 80a846c:	6f6e 6974 6f66 6666 6e00 746f 6669 6e6f     notifoff.notifon
 80a847c:	7000 6369 666f 0066 6970 6f63 006e 6f74     .picoff.picon.to
 80a848c:	6767 656c 454c 0044 6572 6f62 746f 7300     ggleLED.reboot.s
 80a849c:	656c 7065 7700 6b61 0065 6e75 6f6c 6b63     leep.wake.unlock
 80a84ac:	5300 7465 6974 676e 7520 2e70 2e2e 7000     .Setting up....p
 80a84bc:	7375 0068 6f6c 6475 6300 6d6f 616d 646e     ush.loud.command
 80a84cc:	5700 6168 2074 7261 2065 6f79 2075 6f64     .What are you do
 80a84dc:	6e69 3f67 4900 6d20 7369 2073 6f79 2075     ing?.I miss you 
 80a84ec:	283a 4100 6572 7920 756f 6920 206e 6f79     :(.Are you in yo
 80a84fc:	7275 6420 726f 3f6d 4800 776f 6120 6572     ur dorm?.How are
 80a850c:	7920 756f 6420 696f 676e 003f 6548 2079      you doing?.Hey 
 80a851c:	6142 6562 0000 0000                         Babe....

080a8524 <_ZTVN8particle13__SPISettingsE>:
	...
 80a852c:	1a4d 080a                                   M...

080a8530 <_ZTV16Adafruit_ILI9341>:
	...
 80a8538:	1a49 080a 1aa5 080a 41c9 080a 5971 080a     I........A..qY..
 80a8548:	22ad 080a 401d 080a 2371 080a 20b1 080a     ."...@..q#... ..
 80a8558:	40dd 080a 219d 080a 1a2d 080a 1bc9 080a     .@...!..-.......
 80a8568:	4413 080a 6564 6166 6c75 2074 4d00 4253     .D..default .MSB
 80a8578:	4c00 4253 3c00 5053 5349 7465 6974 676e     .LSB.<SPISetting
 80a8588:	2073 6564 6166 6c75 3e74 3c00 5053 5349     s default>.<SPIS
 80a8598:	7465 6974 676e 2073 7325 6c25 2075 7325     ettings %s%lu %s
 80a85a8:	4d20 444f 2545 3e64 0000 0000                MODE%d>....

080a85b4 <CSWTCH.215>:
 80a85b4:	012c 0000 0018 0000 01f4 0000 012c 0000     ,...........,...
 80a85c4:	0050 0000                                   P...

080a85c8 <_ZTV12Adafruit_GFX>:
	...
 80a85d8:	41c9 080a 5971 080a 00a9 080a 401d 080a     .A..qY.......@..
 80a85e8:	413d 080a 4159 080a 40dd 080a 4173 080a     =A..YA...@..sA..
 80a85f8:	41ab 080a 41c7 080a 4413 080a               .A...A...D..

080a8604 <glcdfontBitmaps>:
 80a8604:	ff00 0000 0000 0000 0000 f870 f8a8 88d8     ..........p.....
 80a8614:	0070 f870 f8a8 d888 0070 5000 f8f8 70f8     p.p.....p..P...p
 80a8624:	0020 2000 f870 70f8 0020 5070 a8f8 20f8      .. p..p .pP... 
 80a8634:	0070 7020 f8f8 20f8 0070 0000 7020 2070     p. p... p... pp 
 80a8644:	0000 f8f8 88d8 d888 f8f8 0000 5020 2050     ............ PP 
 80a8654:	0000 f8f8 a8d8 d8a8 f8f8 3800 6818 a0a0     ...........8.h..
 80a8664:	0040 8870 7088 f820 0020 4878 4078 4040     @.p..p . .xHx@@@
 80a8674:	00c0 4878 4878 5848 00c0 a820 d870 70d8     ..xHxHHX.. .p..p
 80a8684:	20a8 c080 f8f0 c0f0 0080 1808 f878 1878     . ..........x.x.
 80a8694:	0008 7020 20a8 70a8 0020 d8d8 d8d8 00d8     .. p. .p .......
 80a86a4:	00d8 a878 68a8 2828 0028 4830 2850 4810     ..x..h(((.0HP(.H
 80a86b4:	3048 0000 0000 f800 00f8 7020 20a8 70a8     H0........ p. .p
 80a86c4:	f820 2000 a870 2020 0020 2000 2020 70a8      .. p.   ..   .p
 80a86d4:	0020 2000 f810 2010 0000 2000 f840 2040      .. ... ... @.@ 
 80a86e4:	0000 8000 8080 00f8 0000 5000 f8f8 0050     ...........P..P.
 80a86f4:	0000 2000 7020 f8f8 0000 f800 70f8 2020     ...  p.......p  
	...
 80a870c:	0000 2020 2020 0020 0020 5050 0050 0000     ..     . .PPP...
 80a871c:	0000 5050 50f8 50f8 0050 7820 70a0 f028     ..PP.P.PP. x.p(.
 80a872c:	0020 c8c0 2010 9840 0018 a040 40a0 90a8      .... @...@..@..
 80a873c:	0068 3030 4020 0000 0000 2010 4040 2040     h.00 @..... @@@ 
 80a874c:	0010 2040 1010 2010 0040 a820 f870 a870     ..@ ... @. .p.p.
 80a875c:	0020 2000 f820 2020 0000 0000 0000 3030      ..  .  ......00
 80a876c:	4020 0000 f800 0000 0000 0000 0000 3000      @.............0
 80a877c:	0030 0800 2010 8040 0000 8870 a898 88c8     0.... @...p.....
 80a878c:	0070 6020 2020 2020 0070 8870 7008 8080     p. `    p.p..p..
 80a879c:	00f8 08f8 3010 8808 0070 3010 9050 10f8     .....0..p..0P...
 80a87ac:	0010 80f8 08f0 8808 0070 4038 f080 8888     ........p.8@....
 80a87bc:	0070 08f8 1008 4020 0080 8870 7088 8888     p..... @..p..p..
 80a87cc:	0070 8870 7888 1008 00e0 0000 0020 0020     p.p..x...... . .
 80a87dc:	0000 0000 0020 2020 0040 1008 4020 1020     .... .  @... @ .
 80a87ec:	0008 0000 00f8 00f8 0000 2040 0810 2010     ..........@ ... 
 80a87fc:	0040 8870 3008 0020 0020 8870 b8a8 80b0     @.p..0 . .p.....
 80a880c:	0078 5020 8888 88f8 0088 88f0 f088 8888     x. P............
 80a881c:	00f0 8870 8080 8880 0070 88f0 8888 8888     ..p.....p.......
 80a882c:	00f0 80f8 f080 8080 00f8 80f8 f080 8080     ................
 80a883c:	0080 8878 8080 8898 0078 8888 f888 8888     ..x.....x.......
 80a884c:	0088 2070 2020 2020 0070 1038 1010 9010     ..p     p.8.....
 80a885c:	0060 9088 c0a0 90a0 0088 8080 8080 8080     `...............
 80a886c:	00f8 d888 a8a8 88a8 0088 8888 a8c8 8898     ................
 80a887c:	0088 8870 8888 8888 0070 88f0 f088 8080     ..p.....p.......
 80a888c:	0080 8870 8888 90a8 0068 88f0 f088 90a0     ..p.....h.......
 80a889c:	0088 8870 7080 8808 0070 a8f8 2020 2020     ..p..p..p...    
 80a88ac:	0020 8888 8888 8888 0070 8888 8888 5088      .......p......P
 80a88bc:	0020 8888 a888 a8a8 0050 8888 2050 8850      .......P...P P.
 80a88cc:	0088 8888 2050 2020 0020 08f8 7010 8040     ....P    ....p@.
 80a88dc:	00f8 4078 4040 4040 0078 8000 2040 0810     ..x@@@@@x...@ ..
 80a88ec:	0000 0878 0808 0808 0078 5020 0088 0000     ..x.....x. P....
	...
 80a8904:	00f8 6060 1020 0000 0000 0000 1060 9070     ..`` .......`.p.
 80a8914:	0078 8080 c8b0 c888 00b0 0000 8870 8880     x...........p...
 80a8924:	0070 0808 9868 9888 0068 0000 8870 80f8     p...h...h...p...
 80a8934:	0070 2810 7020 2020 0020 0000 9870 6898     p..( p   ...p..h
 80a8944:	7008 8080 c8b0 8888 0088 0020 2060 2020     .p........ .`   
 80a8954:	0070 0010 1010 9010 0060 8080 a090 a0c0     p.......`.......
 80a8964:	0090 2060 2020 2020 0070 0000 a8d0 a8a8     ..`     p.......
 80a8974:	00a8 0000 c8b0 8888 0088 0000 8870 8888     ............p...
 80a8984:	0070 0000 c8b0 b0c8 8080 0000 9868 6898     p...........h..h
 80a8994:	0808 0000 c8b0 8080 0080 0000 8078 0870     ............x.p.
 80a89a4:	00f0 2020 20f8 2820 0010 0000 8888 9888     ..  .  (........
 80a89b4:	0068 0000 8888 5088 0020 0000 8888 a8a8     h......P .......
 80a89c4:	0050 0000 5088 5020 0088 0000 8888 0878     P....P P......x.
 80a89d4:	7088 0000 10f8 4020 00f8 2010 4020 2020     .p.... @...  @  
 80a89e4:	0010 2020 0020 2020 0020 2040 1020 2020     ..   .   .@  .  
 80a89f4:	0040 a840 0010 0000 0000 7020 88d8 f888     @.@....... p....
 80a8a04:	0000 8870 8080 7088 6010 8800 8800 9888     ..p....p.`......
 80a8a14:	0068 0018 8870 80f8 0078 00f8 1060 9070     h...p...x...`.p.
 80a8a24:	0078 0088 1060 9070 0078 00c0 1060 9070     x...`.p.x...`.p.
 80a8a34:	0078 0030 1060 9070 0078 7800 c0c0 1078     x.0.`.p.x..x..x.
 80a8a44:	0030 00f8 8870 80f8 0078 0088 8870 80f8     0...p...x...p...
 80a8a54:	0078 00c0 8870 80f8 0078 0028 1030 1010     x...p...x.(.0...
 80a8a64:	0038 4830 1030 1010 0038 0060 1030 1010     8.0H0...8.`.0...
 80a8a74:	0038 0050 5020 f888 8888 0020 5020 f888     8.P. P.... . P..
 80a8a84:	8888 0030 80f0 80e0 00f0 0000 1078 9078     ..0.........x.x.
 80a8a94:	0078 5038 f890 9090 0098 8870 7000 8888     x.8P......p..p..
 80a8aa4:	0070 8800 7000 8888 0070 c000 7000 8888     p....p..p....p..
 80a8ab4:	0070 8870 8800 9888 0068 c000 8800 9888     p.p.....h.......
 80a8ac4:	0068 0048 4848 3848 7008 0088 8870 8888     h.H.HHH8.p..p...
 80a8ad4:	0070 0088 8888 8888 0070 2020 a0f8 f8a0     p.......p.  ....
 80a8ae4:	2020 5830 e048 4840 00f8 d8d8 f870 f820       0XH.@H....p. .
 80a8af4:	2020 90e0 e090 b890 9090 2818 7020 2020       .........( p  
 80a8b04:	c0a0 0018 1060 9070 0078 0018 1030 1010     ....`.p.x...0...
 80a8b14:	0038 1800 7000 8888 0070 1800 8800 9888     8....p..p.......
 80a8b24:	0068 7800 7000 4848 0048 00f8 e8c8 98b8     h..x.pHHH.......
 80a8b34:	0088 9070 7890 f800 0000 8870 7088 f800     ..p..x....p..p..
 80a8b44:	0000 0020 6020 8880 0070 0000 f800 8080     .. . `..p.......
 80a8b54:	0000 0000 f800 0808 0000 8880 b890 9848     ..............H.
 80a8b64:	3820 8880 a890 b858 0808 2020 2000 2020      8....X...  .   
 80a8b74:	0020 2800 a050 2850 0000 a000 2850 a050      ..(P.P(....P(P.
 80a8b84:	0000 8820 8820 8820 8820 a850 a850 a850     .. . . . .P.P.P.
 80a8b94:	a850 1010 1010 1010 1010 1010 1010 10f0     P...............
 80a8ba4:	1010 1010 10f0 10f0 1010 2828 2828 28e8     ..........((((.(
 80a8bb4:	2828 0000 0000 28f8 2828 0000 10f0 10f0     ((.....(((......
 80a8bc4:	1010 2828 08e8 28e8 2828 2828 2828 2828     ..((...(((((((((
 80a8bd4:	2828 0000 08f8 28e8 2828 2828 08e8 00f8     ((.....(((((....
 80a8be4:	0000 2828 2828 00f8 0000 1010 10f0 00f0     ..((((..........
 80a8bf4:	0000 0000 0000 10f0 1010 1010 1010 0018     ................
 80a8c04:	0000 1010 1010 00f8 0000 0000 0000 10f8     ................
 80a8c14:	1010 1010 1010 1018 1010 0000 0000 00f8     ................
 80a8c24:	0000 1010 1010 10f8 1010 1010 1018 1018     ................
 80a8c34:	1010 2828 2828 2828 2828 2828 2028 0038     ..((((((((((( 8.
 80a8c44:	0000 0000 2038 2828 2828 2828 00e8 00f8     ....8 ((((((....
 80a8c54:	0000 0000 00f8 28e8 2828 2828 2028 2828     .......(((((( ((
 80a8c64:	2828 0000 00f8 00f8 0000 2828 00e8 28e8     ((........((...(
 80a8c74:	2828 1010 00f8 00f8 0000 2828 2828 00f8     ((........((((..
 80a8c84:	0000 0000 00f8 10f8 1010 0000 0000 28f8     ...............(
 80a8c94:	2828 2828 2828 0038 0000 1010 1018 0018     ((((((8.........
 80a8ca4:	0000 0000 1018 1018 1010 0000 0000 2838     ..............8(
 80a8cb4:	2828 2828 2828 28f8 2828 1010 10f8 10f8     ((((((.(((......
 80a8cc4:	1010 1010 1010 00f0 0000 0000 0000 1018     ................
 80a8cd4:	1010 f8f8 f8f8 f8f8 f8f8 0000 0000 f8f8     ................
 80a8ce4:	f8f8 e0e0 e0e0 e0e0 e0e0 1818 1818 1818     ................
 80a8cf4:	1818 f8f8 f8f8 0000 0000 0000 9068 9090     ............h...
 80a8d04:	0068 7000 f098 f098 0080 f800 8098 8080     h..p............
 80a8d14:	0080 f800 5050 5050 0050 88f8 2040 8840     ....PPPPP...@ @.
 80a8d24:	00f8 0000 9078 9090 0060 5000 5050 6850     ....x...`..PPPPh
 80a8d34:	00c0 f800 20a0 2020 0020 20f8 8870 7088     .....    .. p..p
 80a8d44:	f820 5020 f888 5088 0020 5020 8888 5050      . P...P . P..PP
 80a8d54:	00d8 4030 7030 8888 0070 0000 7000 a8a8     ..0@0p..p....p..
 80a8d64:	0070 7008 a898 c8a8 8070 8070 f080 8080     p..p....p.p.....
 80a8d74:	0070 8870 8888 8888 0088 f800 f800 f800     p.p.............
 80a8d84:	0000 2020 20f8 0020 00f8 2040 2010 0040     ..  .  ...@ . @.
 80a8d94:	00f8 2010 2040 0010 00f8 2838 2020 2020     ... @ ....8(    
 80a8da4:	2020 2020 2020 a020 e0a0 3030 f800 3000            ...00...0
 80a8db4:	0030 e800 00b8 b8e8 0000 d870 70d8 0000     0.........p..p..
 80a8dc4:	0000 0000 3000 0030 0000 0000 0000 0030     .....00.......0.
 80a8dd4:	0000 2038 2020 a0a0 2060 4870 4848 0048     ..8   ..` pHHHH.
 80a8de4:	0000 1870 6030 0078 0000 0000 7878 7878     ..p.0`x.....xxxx
	...

080a8dfe <glcdfontDescriptors>:
 80a8dfe:	0805 0000 0805 0008 0805 0010 0805 0018     ................
 80a8e0e:	0805 0020 0805 0028 0805 0030 0805 0038     .. ...(...0...8.
 80a8e1e:	0805 0040 0805 0048 0805 0050 0805 0058     ..@...H...P...X.
 80a8e2e:	0805 0060 0805 0068 0805 0070 0805 0078     ..`...h...p...x.
 80a8e3e:	0805 0080 0805 0088 0805 0090 0805 0098     ................
 80a8e4e:	0805 00a0 0805 00a8 0805 00b0 0805 00b8     ................
 80a8e5e:	0805 00c0 0805 00c8 0805 00d0 0805 00d8     ................
 80a8e6e:	0805 00e0 0805 00e8 0805 00f0 0805 00f8     ................
 80a8e7e:	0805 0100 0805 0108 0805 0110 0805 0118     ................
 80a8e8e:	0805 0120 0805 0128 0805 0130 0805 0138     .. ...(...0...8.
 80a8e9e:	0805 0140 0805 0148 0805 0150 0805 0158     ..@...H...P...X.
 80a8eae:	0805 0160 0805 0168 0805 0170 0805 0178     ..`...h...p...x.
 80a8ebe:	0805 0180 0805 0188 0805 0190 0805 0198     ................
 80a8ece:	0805 01a0 0805 01a8 0805 01b0 0805 01b8     ................
 80a8ede:	0805 01c0 0805 01c8 0805 01d0 0805 01d8     ................
 80a8eee:	0805 01e0 0805 01e8 0805 01f0 0805 01f8     ................
 80a8efe:	0805 0200 0805 0208 0805 0210 0805 0218     ................
 80a8f0e:	0805 0220 0805 0228 0805 0230 0805 0238     .. ...(...0...8.
 80a8f1e:	0805 0240 0805 0248 0805 0250 0805 0258     ..@...H...P...X.
 80a8f2e:	0805 0260 0805 0268 0805 0270 0805 0278     ..`...h...p...x.
 80a8f3e:	0805 0280 0805 0288 0805 0290 0805 0298     ................
 80a8f4e:	0805 02a0 0805 02a8 0805 02b0 0805 02b8     ................
 80a8f5e:	0805 02c0 0805 02c8 0805 02d0 0805 02d8     ................
 80a8f6e:	0805 02e0 0805 02e8 0805 02f0 0805 02f8     ................
 80a8f7e:	0805 0300 0805 0308 0805 0310 0805 0318     ................
 80a8f8e:	0805 0320 0805 0328 0805 0330 0805 0338     .. ...(...0...8.
 80a8f9e:	0805 0340 0805 0348 0805 0350 0805 0358     ..@...H...P...X.
 80a8fae:	0805 0360 0805 0368 0805 0370 0805 0378     ..`...h...p...x.
 80a8fbe:	0805 0380 0805 0388 0805 0390 0805 0398     ................
 80a8fce:	0805 03a0 0805 03a8 0805 03b0 0805 03b8     ................
 80a8fde:	0805 03c0 0805 03c8 0805 03d0 0805 03d8     ................
 80a8fee:	0805 03e0 0805 03e8 0805 03f0 0805 03f8     ................
 80a8ffe:	0805 0400 0805 0408 0805 0410 0805 0418     ................
 80a900e:	0805 0420 0805 0428 0805 0430 0805 0438     .. ...(...0...8.
 80a901e:	0805 0440 0805 0448 0805 0450 0805 0458     ..@...H...P...X.
 80a902e:	0805 0460 0805 0468 0805 0470 0805 0478     ..`...h...p...x.
 80a903e:	0805 0480 0805 0488 0805 0490 0805 0498     ................
 80a904e:	0805 04a0 0805 04a8 0805 04b0 0805 04b8     ................
 80a905e:	0805 04c0 0805 04c8 0805 04d0 0805 04d8     ................
 80a906e:	0805 04e0 0805 04e8 0805 04f0 0805 04f8     ................
 80a907e:	0805 0500 0805 0508 0805 0510 0805 0518     ................
 80a908e:	0805 0520 0805 0528 0805 0530 0805 0538     .. ...(...0...8.
 80a909e:	0805 0540 0805 0548 0805 0550 0805 0558     ..@...H...P...X.
 80a90ae:	0805 0560 0805 0568 0805 0570 0805 0578     ..`...h...p...x.
 80a90be:	0805 0580 0805 0588 0805 0590 0805 0598     ................
 80a90ce:	0805 05a0 0805 05a8 0805 05b0 0805 05b8     ................
 80a90de:	0805 05c0 0805 05c8 0805 05d0 0805 05d8     ................
 80a90ee:	0805 05e0 0805 05e8 0805 05f0 0805 05f8     ................
 80a90fe:	0805 0600 0805 0608 0805 0610 0805 0618     ................
 80a910e:	0805 0620 0805 0628 0805 0630 0805 0638     .. ...(...0...8.
 80a911e:	0805 0640 0805 0648 0805 0650 0805 0658     ..@...H...P...X.
 80a912e:	0805 0660 0805 0668 0805 0670 0805 0678     ..`...h...p...x.
 80a913e:	0805 0680 0805 0688 0805 0690 0805 0698     ................
 80a914e:	0805 06a0 0805 06a8 0805 06b0 0805 06b8     ................
 80a915e:	0805 06c0 0805 06c8 0805 06d0 0805 06d8     ................
 80a916e:	0805 06e0 0805 06e8 0805 06f0 0805 06f8     ................
 80a917e:	0805 0700 0805 0708 0805 0710 0805 0718     ................
 80a918e:	0805 0720 0805 0728 0805 0730 0805 0738     .. ...(...0...8.
 80a919e:	0805 0740 0805 0748 0805 0750 0805 0758     ..@...H...P...X.
 80a91ae:	0805 0760 0805 0768 0805 0770 0805 0778     ..`...h...p...x.
 80a91be:	0805 0780 0805 0788 0805 0790 0805 0798     ................
 80a91ce:	0805 07a0 0805 07a8 0805 07b0 0805 07b8     ................
 80a91de:	0805 07c0 0805 07c8 0805 07d0 0805 07d8     ................
 80a91ee:	0805 07e0 0805 07e8 0805 07f0 0805 07f8     ................
 80a91fe:	494c 3353 4844 0000 0000                    LIS3DH....

080a9208 <_ZTV15Adafruit_LIS3DH>:
	...
 80a9210:	4445 080a 4481 080a 06bf 080a 48b9 080a     ED...D.......H..
 80a9220:	4449 080a 6176 006c 6964 3d6d 0000 0000     ID..val.dim=....
	...
 80a9238:	6162 6475 3d73 0000 0000 0000 0000 0000     bauds=..........
 80a9248:	6162 6475 003d 0000 0000 0000 0000 0000     baud=...........
 80a9258:	6567 2074 0000 0000 0000 0000 0000 0000     get ............
	...
 80a9278:	6b62 6d63 3d64 ff30 ffff 6200 636b 646d     bkcmd=0....bkcmd
 80a9288:	253d ff64 ffff 6200 636b 646d 313d 7300     =%d....bkcmd=1.s
 80a9298:	6e65 6d64 0065 6964 736d 003d 6572 2066     endme.dims=.ref 
 80a92a8:	0030 223d 7400 7478 7000 6f63 6200 6f63     0.=".txt.pco.bco
 80a92b8:	0000 0000                                   ....

080a92bc <_ZTV8SPIClass>:
	...
 80a92c4:	5575 080a 5577 080a                         uU..wU..

080a92cc <_ZL14clock_divisors>:
 80a92cc:	0800 1810 2820 3830 6e6c 6600 006e 6f63     .... (08ln.fn.co
 80a92dc:	6564 6400 7465 6961 006c 0a0d 2500 3130     de.detail....%01
 80a92ec:	7530 0020 205d 2500 0064 202c 2800 3a29     0u .] .%d., .():
 80a92fc:	0020 5b20 6300 646f 2065 203d 2500 0069      . [.code = .%i.
 80a930c:	6564 6174 6c69 2073 203d 6200 7561 0064     details = .baud.
 80a931c:	6553 6972 6c61 5500 4253 6553 6972 6c61     Serial.USBSerial
 80a932c:	0031 7974 6570 7000 7261 6d61 6300 646d     1.type.param.cmd
 80a933c:	6900 0064 6e68 0064 7473 6d72 6600 6c69     .id.hnd.strm.fil
 80a934c:	0074 766c 006c 6461 4864 6e61 6c64 7265     t.lvl.addHandler
 80a935c:	7200 6d65 766f 4865 6e61 6c64 7265 6500     .removeHandler.e
 80a936c:	756e 486d 6e61 6c64 7265 0073 534a 4e4f     numHandlers.JSON
 80a937c:	7453 6572 6d61 6f4c 4867 6e61 6c64 7265     StreamLogHandler
 80a938c:	6100 7070 6e00 6e6f 0065 7274 6361 0065     .app.none.trace.
 80a939c:	6e69 6f66 7700 7261 006e 7265 6f72 0072     info.warn.error.
 80a93ac:	6170 696e 0063 6c61 006c 2b25 3330 3a64     panic.all.%+03d:
 80a93bc:	3025 7532 2500 2d59 6d25 252d 5464 4825     %02u.%Y-%m-%dT%H
 80a93cc:	253a 3a4d 5325 7a25 6100 6373 6974 656d     :%M:%S%z.asctime
 80a93dc:	0000 0000                                   ....

080a93e0 <_ZTV3UDP>:
	...
 80a93e8:	092d 080a 0b83 080a 5d1b 080a 5e3f 080a     -........]..?^..
 80a93f8:	5d13 080a 5d31 080a 5d4f 080a 5d69 080a     .]..1]..O]..i]..
 80a9408:	5d8d 080a 5dd9 080a 5dfb 080a 5f99 080a     .]...]...]..._..
 80a9418:	5ea5 080a 5d03 080a 60a7 080a 5f11 080a     .^...]...`..._..
 80a9428:	5fd1 080a 60d5 080a 5e69 080a 5d09 080a     ._...`..i^...]..
 80a9438:	5f79 080a 5d0f 080a 5d6b 080a fff0 ffff     y_...]..k]......
 80a9448:	0000 0000 5d83 080a                         .....]..

080a9450 <_ZTVSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE>:
	...
 80a9458:	62f1 080a 62f7 080a 630d 080a 6303 080a     .b...b...c...c..
 80a9468:	62f3 080a                                   .b..

080a946c <_ZTV9IPAddress>:
	...
 80a9474:	6803 080a 67f5 080a 67f7 080a               .h...g...g..

080a9480 <_ZTV9USBSerial>:
	...
 80a9488:	68c3 080a 6907 080a 68e1 080a 5971 080a     .h...i...h..qY..
 80a9498:	68db 080a 68c5 080a 68cd 080a 6901 080a     .h...h...h...i..
 80a94a8:	68d5 080a 68bf 080a                         .h...h..

080a94b0 <_ZTV11USARTSerial>:
	...
 80a94b8:	6a2d 080a 6a51 080a 6a5d 080a 5971 080a     -j..Qj..]j..qY..
 80a94c8:	6a39 080a 6a45 080a 6a3f 080a 6a4b 080a     9j..Ej..?j..Kj..
 80a94d8:	6a2f 080a 6a33 080a                         /j..3j..

080a94e0 <_ZTV7TwoWire>:
	...
 80a94e8:	6b3b 080a 6b85 080a 6b5d 080a 6b3d 080a     ;k...k..]k..=k..
 80a94f8:	6b65 080a 6b6d 080a 6b75 080a 6b7d 080a     ek..mk..uk..}k..

080a9508 <_ZTVN5spark9WiFiClassE>:
	...
 80a9510:	6c03 080a                                   .l..

080a9514 <_ZN5spark7NetworkE>:
 80a9514:	1520 2000                                    .. 

080a9518 <_ctype_>:
 80a9518:	2000 2020 2020 2020 2020 2828 2828 2028     .         ((((( 
 80a9528:	2020 2020 2020 2020 2020 2020 2020 2020                     
 80a9538:	8820 1010 1010 1010 1010 1010 1010 1010      ...............
 80a9548:	0410 0404 0404 0404 0404 1004 1010 1010     ................
 80a9558:	1010 4141 4141 4141 0101 0101 0101 0101     ..AAAAAA........
 80a9568:	0101 0101 0101 0101 0101 0101 1010 1010     ................
 80a9578:	1010 4242 4242 4242 0202 0202 0202 0202     ..BBBBBB........
 80a9588:	0202 0202 0202 0202 0202 0202 1010 1010     ................
 80a9598:	0020 0000 0000 0000 0000 0000 0000 0000      ...............
	...

080a961c <__sf_fake_stdin>:
	...

080a963c <__sf_fake_stdout>:
	...

080a965c <__sf_fake_stderr>:
	...
 80a967c:	0043 0000                                   C...

080a9680 <__month_lengths>:
 80a9680:	001f 0000 001c 0000 001f 0000 001e 0000     ................
 80a9690:	001f 0000 001e 0000 001f 0000 001f 0000     ................
 80a96a0:	001e 0000 001f 0000 001e 0000 001f 0000     ................
 80a96b0:	001f 0000 001d 0000 001f 0000 001e 0000     ................
 80a96c0:	001f 0000 001e 0000 001f 0000 001f 0000     ................
 80a96d0:	001e 0000 001f 0000 001e 0000 001f 0000     ................
 80a96e0:	5a54 4700 544d 2500 3031 5e5b 2d30 2c39     TZ.GMT.%10[^0-9,
 80a96f0:	2d2b 255d 006e 254d 7568 6e25 252e 7568     +-]%n.M%hu%n.%hu
 80a9700:	6e25 252e 7568 6e25 2f00 6825 2575 3a6e     %n.%hu%n./%hu%n:
 80a9710:	6825 2575 3a6e 6825 2575 006e               %hu%n:%hu%n.

080a971c <link_const_variable_data_end>:
 80a971c:	080a00f1 	.word	0x080a00f1
 80a9720:	080a01e3 	.word	0x080a01e3
 80a9724:	080a0229 	.word	0x080a0229
 80a9728:	080a0339 	.word	0x080a0339
 80a972c:	080a03b1 	.word	0x080a03b1
 80a9730:	080a0475 	.word	0x080a0475
 80a9734:	080a04ad 	.word	0x080a04ad
 80a9738:	080a04d5 	.word	0x080a04d5
 80a973c:	080a06bb 	.word	0x080a06bb
 80a9740:	080a17d1 	.word	0x080a17d1
 80a9744:	080a24f1 	.word	0x080a24f1
 80a9748:	080a2d1f 	.word	0x080a2d1f
 80a974c:	080a4009 	.word	0x080a4009
 80a9750:	080a443d 	.word	0x080a443d
 80a9754:	080a4441 	.word	0x080a4441
 80a9758:	080a48ed 	.word	0x080a48ed
 80a975c:	080a4903 	.word	0x080a4903
 80a9760:	080a4907 	.word	0x080a4907
 80a9764:	080a4929 	.word	0x080a4929
 80a9768:	080a492d 	.word	0x080a492d
 80a976c:	080a4943 	.word	0x080a4943
 80a9770:	080a4947 	.word	0x080a4947
 80a9774:	080a494b 	.word	0x080a494b
 80a9778:	080a4961 	.word	0x080a4961
 80a977c:	080a4965 	.word	0x080a4965
 80a9780:	080a49a1 	.word	0x080a49a1
 80a9784:	080a49a5 	.word	0x080a49a5
 80a9788:	080a49a9 	.word	0x080a49a9
 80a978c:	080a49ad 	.word	0x080a49ad
 80a9790:	080a49c3 	.word	0x080a49c3
 80a9794:	080a4e39 	.word	0x080a4e39
 80a9798:	080a4e3d 	.word	0x080a4e3d
 80a979c:	080a4e41 	.word	0x080a4e41
 80a97a0:	080a4e75 	.word	0x080a4e75
 80a97a4:	080a4e79 	.word	0x080a4e79
 80a97a8:	080a4f43 	.word	0x080a4f43
 80a97ac:	080a578d 	.word	0x080a578d
 80a97b0:	080a5b5d 	.word	0x080a5b5d
 80a97b4:	080a5ce9 	.word	0x080a5ce9
 80a97b8:	080a619d 	.word	0x080a619d
 80a97bc:	080a6c0d 	.word	0x080a6c0d
 80a97c0:	080a6cf1 	.word	0x080a6cf1
 80a97c4:	080a6d35 	.word	0x080a6d35
 80a97c8:	080a6db5 	.word	0x080a6db5
 80a97cc:	080a6e39 	.word	0x080a6e39
 80a97d0:	080a6efd 	.word	0x080a6efd
 80a97d4:	080a6fc1 	.word	0x080a6fc1

080a97d8 <link_constructors_end>:
	...
