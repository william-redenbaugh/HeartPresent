
/home/ANT.AMAZON.COM/wredenba/git/HeartPresent/HeartPresentV10/HeartPresentV10/target/2.3.0/photon/HeartPresentV10.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .module_info  00000018  080a0000  080a0000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .dynalib      00000004  080a0018  080a0018  00010018  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         0000a824  080a001c  080a001c  0001001c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .ARM.exidx    00000008  080aa840  080aa840  0001a840  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .backup       00000004  40024000  080aa848  00024000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         000000d4  20000000  080aa84c  00030000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00000e90  200000d8  200000d8  000400d8  2**3
                  ALLOC
  7 .module_info_suffix 00000028  080aa920  080aa920  0003a920  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .module_info_crc 00000004  080aa948  080aa948  0003a948  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 .debug_info   002fcd24  00000000  00000000  0003a94c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 0002ecaa  00000000  00000000  00337670  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 00003068  00000000  00000000  0036631a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  00047640  00000000  00000000  00369382  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0006c00d  00000000  00000000  003b09c2  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    000bdc67  00000000  00000000  0041c9cf  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_loc    0002ccf4  00000000  00000000  004da636  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00007828  00000000  00000000  0050732a  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_frame  000086c0  00000000  00000000  0050eb54  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080a001c <module_user_pre_init>:
/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a001c:	4809      	ldr	r0, [pc, #36]	; (80a0044 <link_dynalib_end+0x28>)
 80a001e:	490a      	ldr	r1, [pc, #40]	; (80a0048 <link_dynalib_end+0x2c>)
void* module_user_pre_init() {
 80a0020:	b508      	push	{r3, lr}
    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a0022:	4288      	cmp	r0, r1
 80a0024:	d005      	beq.n	80a0032 <module_user_pre_init+0x16>
 80a0026:	4a09      	ldr	r2, [pc, #36]	; (80a004c <link_dynalib_end+0x30>)
 80a0028:	4282      	cmp	r2, r0
 80a002a:	d002      	beq.n	80a0032 <module_user_pre_init+0x16>
    {
        memcpy(&link_global_data_start, &link_global_data_initial_values, link_global_data_size);
 80a002c:	1a12      	subs	r2, r2, r0
 80a002e:	f008 fc4d 	bl	80a88cc <memcpy>
    }

    memset(&link_bss_location, 0, link_bss_size );
 80a0032:	4807      	ldr	r0, [pc, #28]	; (80a0050 <link_dynalib_end+0x34>)
 80a0034:	4a07      	ldr	r2, [pc, #28]	; (80a0054 <link_dynalib_end+0x38>)
 80a0036:	2100      	movs	r1, #0
 80a0038:	1a12      	subs	r2, r2, r0
 80a003a:	f008 fc55 	bl	80a88e8 <memset>
    return &link_heap_start;
}
 80a003e:	4806      	ldr	r0, [pc, #24]	; (80a0058 <link_dynalib_end+0x3c>)
 80a0040:	bd08      	pop	{r3, pc}
 80a0042:	bf00      	nop
 80a0044:	20000000 	.word	0x20000000
 80a0048:	080aa84c 	.word	0x080aa84c
 80a004c:	200000d4 	.word	0x200000d4
 80a0050:	200000d8 	.word	0x200000d8
 80a0054:	20000f65 	.word	0x20000f65
 80a0058:	20000f65 	.word	0x20000f65

080a005c <module_user_init>:
extern constructor_ptr_t link_constructors_location[];
extern constructor_ptr_t link_constructors_end;
#define link_constructors_size   ((unsigned long)&link_constructors_end  -  (unsigned long)&link_constructors_location )

void module_user_init()
{
 80a005c:	b570      	push	{r4, r5, r6, lr}
    module_user_init_hook();
 80a005e:	f006 fcd7 	bl	80a6a10 <module_user_init_hook>

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a0062:	2500      	movs	r5, #0
 80a0064:	4e05      	ldr	r6, [pc, #20]	; (80a007c <module_user_init+0x20>)
 80a0066:	4c06      	ldr	r4, [pc, #24]	; (80a0080 <module_user_init+0x24>)
 80a0068:	1ba4      	subs	r4, r4, r6
 80a006a:	08a4      	lsrs	r4, r4, #2
 80a006c:	42a5      	cmp	r5, r4
 80a006e:	d100      	bne.n	80a0072 <module_user_init+0x16>
    {
        link_constructors_location[ctor_num]();
    }
}
 80a0070:	bd70      	pop	{r4, r5, r6, pc}
        link_constructors_location[ctor_num]();
 80a0072:	f856 3b04 	ldr.w	r3, [r6], #4
 80a0076:	4798      	blx	r3
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a0078:	3501      	adds	r5, #1
 80a007a:	e7f7      	b.n	80a006c <module_user_init+0x10>
 80a007c:	080aa818 	.word	0x080aa818
 80a0080:	080aa840 	.word	0x080aa840

080a0084 <module_user_setup>:

/**
 * Export these functions with a fuller name so they don't clash with the setup/loop wrappers in the system module.
 */
void module_user_setup() {
    setup();
 80a0084:	f001 b9ec 	b.w	80a1460 <setup>

080a0088 <module_user_loop>:
}

void module_user_loop() {
 80a0088:	b508      	push	{r3, lr}
    loop();
 80a008a:	f001 f873 	bl	80a1174 <loop>
    _post_loop();
}
 80a008e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    _post_loop();
 80a0092:	f006 bc75 	b.w	80a6980 <_post_loop>

080a0096 <_Znwj>:
 * Implement C++ new/delete operators using the heap
 */

void *operator new(size_t size)
{
	return malloc(size);
 80a0096:	f005 bd01 	b.w	80a5a9c <malloc>

080a009a <_Znaj>:
 80a009a:	f005 bcff 	b.w	80a5a9c <malloc>

080a009e <_ZdlPv>:
	return malloc(size);
}

void operator delete(void *p)
{
	free(p);
 80a009e:	f005 bd05 	b.w	80a5aac <free>
	...

080a00a4 <__cxa_pure_virtual>:
    return (char*)"";
}

/* Default implementation for call made to pure virtual function. */
void __cxa_pure_virtual() {
  PANIC(PureVirtualCall,"Call on pure virtual");
 80a00a4:	2100      	movs	r1, #0
 80a00a6:	200c      	movs	r0, #12
void __cxa_pure_virtual() {
 80a00a8:	b508      	push	{r3, lr}
  PANIC(PureVirtualCall,"Call on pure virtual");
 80a00aa:	4a02      	ldr	r2, [pc, #8]	; (80a00b4 <__cxa_pure_virtual+0x10>)
 80a00ac:	f005 fc08 	bl	80a58c0 <panic_>
  while (1);
 80a00b0:	e7fe      	b.n	80a00b0 <__cxa_pure_virtual+0xc>
 80a00b2:	bf00      	nop
 80a00b4:	080a57c1 	.word	0x080a57c1

080a00b8 <__cxa_guard_acquire>:

/* Provide default implemenation for __cxa_guard_acquire() and
 * __cxa_guard_release(). Note: these must be revisited if a multitasking
 * OS is ported to this platform. */
__extension__ typedef int __guard __attribute__((mode (__DI__)));
int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
 80a00b8:	7800      	ldrb	r0, [r0, #0]
 80a00ba:	fab0 f080 	clz	r0, r0
 80a00be:	0940      	lsrs	r0, r0, #5
 80a00c0:	4770      	bx	lr

080a00c2 <__cxa_guard_release>:
void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
 80a00c2:	2301      	movs	r3, #1
 80a00c4:	7003      	strb	r3, [r0, #0]
 80a00c6:	4770      	bx	lr

080a00c8 <_Z18toggleWifiParticlev>:
function: toggleWifiParticle()
description: toggles the Wifi on or off on the particle device. 
parameters: none
returns: none
*/
void toggleWifiParticle(void){
 80a00c8:	b510      	push	{r4, lr}
    static void sleep(Spark_Sleep_TypeDef sleepMode, long seconds=0) __attribute__ ((deprecated("Please use System.sleep() instead.")))
    { SystemClass::sleep(sleepMode, seconds); }
    static void sleep(uint16_t wakeUpPin, InterruptMode edgeTriggerMode, long seconds=0) __attribute__ ((deprecated("Please use System.sleep() instead.")))
    { SystemClass::sleep(wakeUpPin, edgeTriggerMode, seconds); }

    static bool connected(void) { return spark_cloud_flag_connected(); }
 80a00ca:	f005 fc11 	bl	80a58f0 <spark_cloud_flag_connected>
    if(Particle.connected())
 80a00ce:	4603      	mov	r3, r0
 80a00d0:	4809      	ldr	r0, [pc, #36]	; (80a00f8 <_Z18toggleWifiParticlev+0x30>)
 80a00d2:	b13b      	cbz	r3, 80a00e4 <_Z18toggleWifiParticlev+0x1c>
        WiFi.off();
    else{
        WiFi.on();
        Particle.connect();
    }
}
 80a00d4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    void on(void) {
        network_on(*this, 0, 0, NULL);
    }

    void off(void) {
        network_off(*this, 0, 0, NULL);
 80a00d8:	2300      	movs	r3, #0
 80a00da:	6840      	ldr	r0, [r0, #4]
 80a00dc:	461a      	mov	r2, r3
 80a00de:	4619      	mov	r1, r3
 80a00e0:	f005 bc56 	b.w	80a5990 <network_off>
        network_on(*this, 0, 0, NULL);
 80a00e4:	461a      	mov	r2, r3
 80a00e6:	4619      	mov	r1, r3
 80a00e8:	6840      	ldr	r0, [r0, #4]
 80a00ea:	f005 fc49 	bl	80a5980 <network_on>
 80a00ee:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    static bool disconnected(void) { return !connected(); }
    static void connect(void) {
        spark_cloud_flag_connect();
 80a00f2:	f005 bbf5 	b.w	80a58e0 <spark_cloud_flag_connect>
 80a00f6:	bf00      	nop
 80a00f8:	20000da4 	.word	0x20000da4

080a00fc <_Z19enableListeningModev>:
function: enableListeningMode()
description: enables listening mode on the particle photon
parameters: none
returns: none
*/
void enableListeningMode(void){
 80a00fc:	b510      	push	{r4, lr}
        network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, NULL);
 80a00fe:	4c06      	ldr	r4, [pc, #24]	; (80a0118 <_Z19enableListeningModev+0x1c>)
 80a0100:	2200      	movs	r2, #0
 80a0102:	6860      	ldr	r0, [r4, #4]
 80a0104:	2102      	movs	r1, #2
 80a0106:	f005 fc2b 	bl	80a5960 <network_disconnect>
    }
    
    void listen(bool begin=true) {
        network_listen(*this, begin ? 0 : 1, NULL);
 80a010a:	2200      	movs	r2, #0
 80a010c:	6860      	ldr	r0, [r4, #4]
 80a010e:	4611      	mov	r1, r2
    WiFi.disconnect();
    WiFi.listen();
 80a0110:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a0114:	f005 bc44 	b.w	80a59a0 <network_listen>
 80a0118:	20000da4 	.word	0x20000da4

080a011c <_ZN5Print5printIiLi0EEEjT_i.part.0>:
    size_t vprintf(bool newline, const char* format, va_list args) __attribute__ ((format(printf, 3, 0)));
};

template <typename T, std::enable_if_t<!std::is_base_of<Printable, T>::value && (std::is_integral<T>::value || std::is_convertible<T, unsigned long long>::value ||
    std::is_convertible<T, long long>::value), int>>
size_t Print::print(T n, int base)
 80a011c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
// FIXME: avoids 'comparison of constant '0' with boolean expression is always false'
#if __GNUC__ >= 9
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wbool-compare"
#endif // __GNUC__ >= 9
        if (n < 0 && base == 10) {
 80a011e:	1e0c      	subs	r4, r1, #0
size_t Print::print(T n, int base)
 80a0120:	4607      	mov	r7, r0
 80a0122:	4616      	mov	r6, r2
        if (n < 0 && base == 10) {
 80a0124:	da0c      	bge.n	80a0140 <_ZN5Print5printIiLi0EEEjT_i.part.0+0x24>
 80a0126:	2a0a      	cmp	r2, #10
 80a0128:	d10a      	bne.n	80a0140 <_ZN5Print5printIiLi0EEEjT_i.part.0+0x24>
            t = print('-');
 80a012a:	212d      	movs	r1, #45	; 0x2d
 80a012c:	f007 f844 	bl	80a71b8 <_ZN5Print5printEc>
 80a0130:	4605      	mov	r5, r0
            val = -n;
 80a0132:	4261      	negs	r1, r4
            val = n;
        }
#if __GNUC__ >= 9
#pragma GCC diagnostic pop
#endif // __GNUC__ >= 9
        return printNumber(val, base) + t;
 80a0134:	4638      	mov	r0, r7
 80a0136:	b2f2      	uxtb	r2, r6
 80a0138:	f007 f84d 	bl	80a71d6 <_ZN5Print11printNumberEmh>
    }
}
 80a013c:	4428      	add	r0, r5
 80a013e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
            val = n;
 80a0140:	4621      	mov	r1, r4
        size_t t = 0;
 80a0142:	2500      	movs	r5, #0
 80a0144:	e7f6      	b.n	80a0134 <_ZN5Print5printIiLi0EEEjT_i.part.0+0x18>

080a0146 <_ZN10TFTDisplay8printTFTEiii6String>:
description: takes in a string, and some paramaters, and prints that text onto the TFT according to said paramters. 
parameters: x axis(x, integer), y axis(y, integer), font size (fontSize, integer), String (str)
returns: none
*/
void TFTDisplay::printTFT(int x, int y, int fontSize, String Str)
{
 80a0146:	b570      	push	{r4, r5, r6, lr}
 80a0148:	4604      	mov	r4, r0
 80a014a:	461d      	mov	r5, r3
 80a014c:	9e04      	ldr	r6, [sp, #16]
    this->tft.setCursor(x,y);// set the cursor. 
 80a014e:	b212      	sxth	r2, r2
 80a0150:	b209      	sxth	r1, r1
 80a0152:	f002 fb5f 	bl	80a2814 <_ZN12Adafruit_GFX9setCursorEss>
    this->tft.setTextSize(fontSize);//set the fontsie
 80a0156:	4620      	mov	r0, r4
 80a0158:	b2e9      	uxtb	r1, r5
 80a015a:	f002 fb5e 	bl	80a281a <_ZN12Adafruit_GFX11setTextSizeEh>
    this->tft.print(Str);//print text!
 80a015e:	4620      	mov	r0, r4
 80a0160:	6831      	ldr	r1, [r6, #0]
}
 80a0162:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    this->tft.print(Str);//print text!
 80a0166:	f007 b823 	b.w	80a71b0 <_ZN5Print5printEPKc>

080a016a <_ZN10TFTDisplay15setupTFTDisplayEv>:
void TFTDisplay::setupTFTDisplay(void){
 80a016a:	b510      	push	{r4, lr}
 80a016c:	4604      	mov	r4, r0
    this->tft.begin();
 80a016e:	f004 ff85 	bl	80a507c <_ZN16Adafruit_ILI93415beginEv>
    this->tft.fillScreen(ILI9341_BLACK);
 80a0172:	4620      	mov	r0, r4
 80a0174:	2100      	movs	r1, #0
 80a0176:	f004 f8b4 	bl	80a42e2 <_ZN16Adafruit_ILI934110fillScreenEt>
    this->tft.setRotation(1);
 80a017a:	2101      	movs	r1, #1
 80a017c:	4620      	mov	r0, r4
 80a017e:	f004 fbb5 	bl	80a48ec <_ZN16Adafruit_ILI934111setRotationEh>
#define digitalPinToInterrupt(P)      (P)
#endif

inline void yield() {
#if PLATFORM_THREADING
  os_thread_yield();
 80a0182:	f005 fabd 	bl	80a5700 <os_thread_yield>
    this->tft.fillScreen(ILI9341_RED);
 80a0186:	f44f 4178 	mov.w	r1, #63488	; 0xf800
 80a018a:	4620      	mov	r0, r4
 80a018c:	f004 f8a9 	bl	80a42e2 <_ZN16Adafruit_ILI934110fillScreenEt>
 80a0190:	f005 fab6 	bl	80a5700 <os_thread_yield>
    this->tft.fillScreen(ILI9341_GREEN);
 80a0194:	f44f 61fc 	mov.w	r1, #2016	; 0x7e0
 80a0198:	4620      	mov	r0, r4
 80a019a:	f004 f8a2 	bl	80a42e2 <_ZN16Adafruit_ILI934110fillScreenEt>
 80a019e:	f005 faaf 	bl	80a5700 <os_thread_yield>
    this->tft.fillScreen(ILI9341_BLUE);
 80a01a2:	211f      	movs	r1, #31
 80a01a4:	4620      	mov	r0, r4
 80a01a6:	f004 f89c 	bl	80a42e2 <_ZN16Adafruit_ILI934110fillScreenEt>
 80a01aa:	f005 faa9 	bl	80a5700 <os_thread_yield>
    this->tft.fillScreen(ILI9341_BLACK);
 80a01ae:	4620      	mov	r0, r4
 80a01b0:	2100      	movs	r1, #0
 80a01b2:	f004 f896 	bl	80a42e2 <_ZN16Adafruit_ILI934110fillScreenEt>
}
 80a01b6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a01ba:	f005 baa1 	b.w	80a5700 <os_thread_yield>
	...

080a01c0 <_ZN10TFTDisplay17updateTimeDisplayEv>:
void TFTDisplay::updateTimeDisplay(void){
 80a01c0:	b510      	push	{r4, lr}
 80a01c2:	4604      	mov	r4, r0
    this->tft.fillScreen(ILI9341_BLACK);
 80a01c4:	2100      	movs	r1, #0
 80a01c6:	f004 f88c 	bl	80a42e2 <_ZN16Adafruit_ILI934110fillScreenEt>
    this->tft.setCursor(105,40);
 80a01ca:	2228      	movs	r2, #40	; 0x28
 80a01cc:	2169      	movs	r1, #105	; 0x69
 80a01ce:	4620      	mov	r0, r4
 80a01d0:	f002 fb20 	bl	80a2814 <_ZN12Adafruit_GFX9setCursorEss>
    this->tft.setTextSize(4);//sets to normal text size
 80a01d4:	2104      	movs	r1, #4
 80a01d6:	4620      	mov	r0, r4
 80a01d8:	f002 fb1f 	bl	80a281a <_ZN12Adafruit_GFX11setTextSizeEh>
    this->tft.print(Time.hour());
 80a01dc:	f006 ff50 	bl	80a7080 <_ZN9TimeClass4hourEv>
 80a01e0:	220a      	movs	r2, #10
 80a01e2:	4601      	mov	r1, r0
size_t Print::print(T n, int base)
 80a01e4:	4620      	mov	r0, r4
 80a01e6:	f7ff ff99 	bl	80a011c <_ZN5Print5printIiLi0EEEjT_i.part.0>
    this->tft.print(":");
 80a01ea:	4936      	ldr	r1, [pc, #216]	; (80a02c4 <_ZN10TFTDisplay17updateTimeDisplayEv+0x104>)
 80a01ec:	4620      	mov	r0, r4
 80a01ee:	f006 ffdf 	bl	80a71b0 <_ZN5Print5printEPKc>
    if(Time.minute() < 10){
 80a01f2:	f006 ff51 	bl	80a7098 <_ZN9TimeClass6minuteEv>
 80a01f6:	2809      	cmp	r0, #9
 80a01f8:	dc03      	bgt.n	80a0202 <_ZN10TFTDisplay17updateTimeDisplayEv+0x42>
        this->tft.print("0");
 80a01fa:	4620      	mov	r0, r4
 80a01fc:	4932      	ldr	r1, [pc, #200]	; (80a02c8 <_ZN10TFTDisplay17updateTimeDisplayEv+0x108>)
 80a01fe:	f006 ffd7 	bl	80a71b0 <_ZN5Print5printEPKc>
        this->tft.print(Time.minute());
 80a0202:	f006 ff49 	bl	80a7098 <_ZN9TimeClass6minuteEv>
 80a0206:	220a      	movs	r2, #10
 80a0208:	4601      	mov	r1, r0
 80a020a:	4620      	mov	r0, r4
 80a020c:	f7ff ff86 	bl	80a011c <_ZN5Print5printIiLi0EEEjT_i.part.0>
        this->tft.setTextSize(3);//sets to normal text size
 80a0210:	2103      	movs	r1, #3
 80a0212:	4620      	mov	r0, r4
 80a0214:	f002 fb01 	bl	80a281a <_ZN12Adafruit_GFX11setTextSizeEh>
    this->tft.setCursor(85,100);
 80a0218:	2264      	movs	r2, #100	; 0x64
 80a021a:	2155      	movs	r1, #85	; 0x55
 80a021c:	4620      	mov	r0, r4
 80a021e:	f002 faf9 	bl	80a2814 <_ZN12Adafruit_GFX9setCursorEss>
    this->tft.print(Time.month());//prints month 
 80a0222:	f006 ff51 	bl	80a70c8 <_ZN9TimeClass5monthEv>
 80a0226:	220a      	movs	r2, #10
 80a0228:	4601      	mov	r1, r0
 80a022a:	4620      	mov	r0, r4
 80a022c:	f7ff ff76 	bl	80a011c <_ZN5Print5printIiLi0EEEjT_i.part.0>
    this->tft.print("/");
 80a0230:	4926      	ldr	r1, [pc, #152]	; (80a02cc <_ZN10TFTDisplay17updateTimeDisplayEv+0x10c>)
 80a0232:	4620      	mov	r0, r4
 80a0234:	f006 ffbc 	bl	80a71b0 <_ZN5Print5printEPKc>
    this->tft.print(Time.day());
 80a0238:	f006 ff3a 	bl	80a70b0 <_ZN9TimeClass3dayEv>
 80a023c:	220a      	movs	r2, #10
 80a023e:	4601      	mov	r1, r0
 80a0240:	4620      	mov	r0, r4
 80a0242:	f7ff ff6b 	bl	80a011c <_ZN5Print5printIiLi0EEEjT_i.part.0>
    this->tft.print(":");
 80a0246:	491f      	ldr	r1, [pc, #124]	; (80a02c4 <_ZN10TFTDisplay17updateTimeDisplayEv+0x104>)
 80a0248:	4620      	mov	r0, r4
 80a024a:	f006 ffb1 	bl	80a71b0 <_ZN5Print5printEPKc>
    this->tft.print(Time.year());
 80a024e:	f006 ff43 	bl	80a70d8 <_ZN9TimeClass4yearEv>
 80a0252:	220a      	movs	r2, #10
 80a0254:	4601      	mov	r1, r0
 80a0256:	4620      	mov	r0, r4
 80a0258:	f7ff ff60 	bl	80a011c <_ZN5Print5printIiLi0EEEjT_i.part.0>
    if (Time.month() > 10){
 80a025c:	f006 ff34 	bl	80a70c8 <_ZN9TimeClass5monthEv>
 80a0260:	280a      	cmp	r0, #10
 80a0262:	dd11      	ble.n	80a0288 <_ZN10TFTDisplay17updateTimeDisplayEv+0xc8>
        this->tft.setCursor(25, 140);
 80a0264:	228c      	movs	r2, #140	; 0x8c
 80a0266:	2119      	movs	r1, #25
 80a0268:	4620      	mov	r0, r4
 80a026a:	f002 fad3 	bl	80a2814 <_ZN12Adafruit_GFX9setCursorEss>
        this->tft.print("Merry Christmas");
 80a026e:	4918      	ldr	r1, [pc, #96]	; (80a02d0 <_ZN10TFTDisplay17updateTimeDisplayEv+0x110>)
 80a0270:	4620      	mov	r0, r4
 80a0272:	f006 ff9d 	bl	80a71b0 <_ZN5Print5printEPKc>
        this->tft.setCursor(40, 170);
 80a0276:	2128      	movs	r1, #40	; 0x28
 80a0278:	4620      	mov	r0, r4
 80a027a:	22aa      	movs	r2, #170	; 0xaa
 80a027c:	f002 faca 	bl	80a2814 <_ZN12Adafruit_GFX9setCursorEss>
        this->tft.print("Thanksgivings");
 80a0280:	4620      	mov	r0, r4
 80a0282:	4914      	ldr	r1, [pc, #80]	; (80a02d4 <_ZN10TFTDisplay17updateTimeDisplayEv+0x114>)
 80a0284:	f006 ff94 	bl	80a71b0 <_ZN5Print5printEPKc>
    if (Time.month() == 2 && Time.day() == 14){
 80a0288:	f006 ff1e 	bl	80a70c8 <_ZN9TimeClass5monthEv>
 80a028c:	2802      	cmp	r0, #2
 80a028e:	d117      	bne.n	80a02c0 <_ZN10TFTDisplay17updateTimeDisplayEv+0x100>
 80a0290:	f006 ff0e 	bl	80a70b0 <_ZN9TimeClass3dayEv>
 80a0294:	280e      	cmp	r0, #14
 80a0296:	d113      	bne.n	80a02c0 <_ZN10TFTDisplay17updateTimeDisplayEv+0x100>
        this->tft.setCursor(25, 140);
 80a0298:	228c      	movs	r2, #140	; 0x8c
 80a029a:	4620      	mov	r0, r4
 80a029c:	2119      	movs	r1, #25
 80a029e:	f002 fab9 	bl	80a2814 <_ZN12Adafruit_GFX9setCursorEss>
        this->tft.print("Happy Valentines");
 80a02a2:	4620      	mov	r0, r4
 80a02a4:	490c      	ldr	r1, [pc, #48]	; (80a02d8 <_ZN10TFTDisplay17updateTimeDisplayEv+0x118>)
 80a02a6:	f006 ff83 	bl	80a71b0 <_ZN5Print5printEPKc>
        this->tft.setCursor(40, 170);
 80a02aa:	4620      	mov	r0, r4
 80a02ac:	2128      	movs	r1, #40	; 0x28
 80a02ae:	22aa      	movs	r2, #170	; 0xaa
 80a02b0:	f002 fab0 	bl	80a2814 <_ZN12Adafruit_GFX9setCursorEss>
        this->tft.print("I love you :)");
 80a02b4:	4620      	mov	r0, r4
} 
 80a02b6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        this->tft.print("I love you :)");
 80a02ba:	4908      	ldr	r1, [pc, #32]	; (80a02dc <_ZN10TFTDisplay17updateTimeDisplayEv+0x11c>)
 80a02bc:	f006 bf78 	b.w	80a71b0 <_ZN5Print5printEPKc>
} 
 80a02c0:	bd10      	pop	{r4, pc}
 80a02c2:	bf00      	nop
 80a02c4:	080a9384 	.word	0x080a9384
 80a02c8:	080a972d 	.word	0x080a972d
 80a02cc:	080a9386 	.word	0x080a9386
 80a02d0:	080a9388 	.word	0x080a9388
 80a02d4:	080a9398 	.word	0x080a9398
 80a02d8:	080a93a6 	.word	0x080a93a6
 80a02dc:	080a93b7 	.word	0x080a93b7

080a02e0 <_ZN10TFTDisplay8printTFTE6String>:
function: printTFT()
description: clears out a string. takes in a string, sets font to size 3, and prints out the texts. 
parameters: String str. 
returns: none
*/
void TFTDisplay::printTFT(String str){
 80a02e0:	b538      	push	{r3, r4, r5, lr}
 80a02e2:	460d      	mov	r5, r1
    tft.fillScreen(ILI9341_BLACK);//blacks out the whole display
 80a02e4:	2100      	movs	r1, #0
void TFTDisplay::printTFT(String str){
 80a02e6:	4604      	mov	r4, r0
    tft.fillScreen(ILI9341_BLACK);//blacks out the whole display
 80a02e8:	f003 fffb 	bl	80a42e2 <_ZN16Adafruit_ILI934110fillScreenEt>
    tft.setCursor(0, 0);//resets cursor
 80a02ec:	2200      	movs	r2, #0
 80a02ee:	4620      	mov	r0, r4
 80a02f0:	4611      	mov	r1, r2
 80a02f2:	f002 fa8f 	bl	80a2814 <_ZN12Adafruit_GFX9setCursorEss>
    tft.setTextSize(3);//sets to normal text size
 80a02f6:	4620      	mov	r0, r4
 80a02f8:	2103      	movs	r1, #3
 80a02fa:	f002 fa8e 	bl	80a281a <_ZN12Adafruit_GFX11setTextSizeEh>
    tft.print(str);
 80a02fe:	4620      	mov	r0, r4
 80a0300:	6829      	ldr	r1, [r5, #0]
}
 80a0302:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    tft.print(str);
 80a0306:	f006 bf53 	b.w	80a71b0 <_ZN5Print5printEPKc>

080a030a <_ZN12ClockControl5setupEP3UDP>:
description:  Sets up the udp interface. 
parameters: none
returns:  none
*/
void ClockControl::setup(UDP *Udp){
    this->Udp = Udp; 
 80a030a:	6001      	str	r1, [r0, #0]
}
 80a030c:	4770      	bx	lr
	...

080a0310 <_ZN12ClockControl4wakeEv>:
function: wake(void)
description:  sends the wake command to the clock
parameters: none
returns:  none
*/
void ClockControl::wake(void){
 80a0310:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    Udp->sendPacket(this->wake_buff, sizeof(this->wake_buff), this->remoteIP, this->port);
 80a0314:	4604      	mov	r4, r0
void ClockControl::wake(void){
 80a0316:	4606      	mov	r6, r0
    Udp->sendPacket(this->wake_buff, sizeof(this->wake_buff), this->remoteIP, this->port);
 80a0318:	f854 7b08 	ldr.w	r7, [r4], #8
void ClockControl::wake(void){
 80a031c:	b088      	sub	sp, #32
    Udp->sendPacket(this->wake_buff, sizeof(this->wake_buff), this->remoteIP, this->port);
 80a031e:	683b      	ldr	r3, [r7, #0]

/**
 * The IP address stored in host order.
 *
 */
class IPAddress : public Printable {
 80a0320:	ad03      	add	r5, sp, #12
 80a0322:	f8d3 8028 	ldr.w	r8, [r3, #40]	; 0x28
 80a0326:	4b08      	ldr	r3, [pc, #32]	; (80a0348 <_ZN12ClockControl4wakeEv+0x38>)
 80a0328:	9302      	str	r3, [sp, #8]
 80a032a:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80a032c:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80a032e:	6823      	ldr	r3, [r4, #0]
 80a0330:	2205      	movs	r2, #5
 80a0332:	702b      	strb	r3, [r5, #0]
 80a0334:	8bb3      	ldrh	r3, [r6, #28]
 80a0336:	4638      	mov	r0, r7
 80a0338:	9300      	str	r3, [sp, #0]
 80a033a:	f106 0125 	add.w	r1, r6, #37	; 0x25
 80a033e:	ab02      	add	r3, sp, #8
 80a0340:	47c0      	blx	r8
}
 80a0342:	b008      	add	sp, #32
 80a0344:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a0348:	080aa5bc 	.word	0x080aa5bc

080a034c <_ZN12ClockControl5sleepEv>:
function: sleep(void)
description:  sends the sleep command to clock
parameters: none
returns:  none
*/
void ClockControl::sleep(void){
 80a034c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    Udp->sendPacket(this->sleep_buff, sizeof(this->wake_buff), this->remoteIP, this->port);
 80a0350:	4604      	mov	r4, r0
void ClockControl::sleep(void){
 80a0352:	4606      	mov	r6, r0
    Udp->sendPacket(this->sleep_buff, sizeof(this->wake_buff), this->remoteIP, this->port);
 80a0354:	f854 7b08 	ldr.w	r7, [r4], #8
void ClockControl::sleep(void){
 80a0358:	b088      	sub	sp, #32
    Udp->sendPacket(this->sleep_buff, sizeof(this->wake_buff), this->remoteIP, this->port);
 80a035a:	683b      	ldr	r3, [r7, #0]
 80a035c:	ad03      	add	r5, sp, #12
 80a035e:	f8d3 8028 	ldr.w	r8, [r3, #40]	; 0x28
 80a0362:	4b08      	ldr	r3, [pc, #32]	; (80a0384 <_ZN12ClockControl5sleepEv+0x38>)
 80a0364:	9302      	str	r3, [sp, #8]
 80a0366:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80a0368:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80a036a:	6823      	ldr	r3, [r4, #0]
 80a036c:	2205      	movs	r2, #5
 80a036e:	702b      	strb	r3, [r5, #0]
 80a0370:	8bb3      	ldrh	r3, [r6, #28]
 80a0372:	4638      	mov	r0, r7
 80a0374:	9300      	str	r3, [sp, #0]
 80a0376:	f106 0120 	add.w	r1, r6, #32
 80a037a:	ab02      	add	r3, sp, #8
 80a037c:	47c0      	blx	r8
}
 80a037e:	b008      	add	sp, #32
 80a0380:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a0384:	080aa5bc 	.word	0x080aa5bc

080a0388 <_ZN12ClockControl8send_msgE6String>:
description:  sends a message to be displayed on the heart. 
parameters: String str(message to be sent)
returns:  none
*/

void ClockControl::send_msg(String str){
 80a0388:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80a038c:	b088      	sub	sp, #32
    
    uint8_t msg[4 + str.length()];
 80a038e:	688b      	ldr	r3, [r1, #8]
void ClockControl::send_msg(String str){
 80a0390:	af02      	add	r7, sp, #8
    uint8_t msg[4 + str.length()];
 80a0392:	f103 0804 	add.w	r8, r3, #4
 80a0396:	330b      	adds	r3, #11
 80a0398:	f023 0307 	bic.w	r3, r3, #7
 80a039c:	ebad 0d03 	sub.w	sp, sp, r3
    msg[0] = 40; 
 80a03a0:	2328      	movs	r3, #40	; 0x28
    uint8_t msg[4 + str.length()];
 80a03a2:	f10d 0908 	add.w	r9, sp, #8
    msg[0] = 40; 
 80a03a6:	f88d 3008 	strb.w	r3, [sp, #8]
    msg[1] = 40; 
 80a03aa:	f889 3001 	strb.w	r3, [r9, #1]
    msg[2] = 50; 
 80a03ae:	2332      	movs	r3, #50	; 0x32
 80a03b0:	f889 3002 	strb.w	r3, [r9, #2]
    msg[3] = 60; 
 80a03b4:	233c      	movs	r3, #60	; 0x3c
void ClockControl::send_msg(String str){
 80a03b6:	4606      	mov	r6, r0
    msg[3] = 60; 
 80a03b8:	f889 3003 	strb.w	r3, [r9, #3]
void ClockControl::send_msg(String str){
 80a03bc:	460d      	mov	r5, r1
    msg[3] = 60; 
 80a03be:	2300      	movs	r3, #0
    
    for(uint16_t i = 0; i < str.length(); i++){
 80a03c0:	fa1f fa83 	uxth.w	sl, r3
	// memory management
	// return true on success, false on failure (in which case, the string
	// is left unchanged).  reserve(0), if successful, will validate an
	// invalid string (i.e., "if (s)" will be true afterwards)
	unsigned char reserve(unsigned int size);
	inline unsigned int length(void) const {return len;}
 80a03c4:	1c5c      	adds	r4, r3, #1
 80a03c6:	68ab      	ldr	r3, [r5, #8]
 80a03c8:	4553      	cmp	r3, sl
 80a03ca:	d909      	bls.n	80a03e0 <_ZN12ClockControl8send_msgE6String+0x58>
        msg[4 + i] = str[i];
 80a03cc:	4651      	mov	r1, sl
 80a03ce:	4628      	mov	r0, r5
 80a03d0:	f006 ffd8 	bl	80a7384 <_ZN6StringixEj>
 80a03d4:	7803      	ldrb	r3, [r0, #0]
 80a03d6:	44ca      	add	sl, r9
 80a03d8:	f88a 3004 	strb.w	r3, [sl, #4]
    for(uint16_t i = 0; i < str.length(); i++){
 80a03dc:	4623      	mov	r3, r4
 80a03de:	e7ef      	b.n	80a03c0 <_ZN12ClockControl8send_msgE6String+0x38>
    }
    
    Udp->sendPacket(msg, sizeof(msg), this->remoteIP, this->port);
 80a03e0:	4634      	mov	r4, r6
 80a03e2:	f854 cb08 	ldr.w	ip, [r4], #8
 80a03e6:	1d3d      	adds	r5, r7, #4
 80a03e8:	f8dc 3000 	ldr.w	r3, [ip]
 80a03ec:	f8d3 a028 	ldr.w	sl, [r3, #40]	; 0x28
 80a03f0:	4b08      	ldr	r3, [pc, #32]	; (80a0414 <_ZN12ClockControl8send_msgE6String+0x8c>)
 80a03f2:	603b      	str	r3, [r7, #0]
 80a03f4:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80a03f6:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80a03f8:	6823      	ldr	r3, [r4, #0]
 80a03fa:	4642      	mov	r2, r8
 80a03fc:	702b      	strb	r3, [r5, #0]
 80a03fe:	8bb3      	ldrh	r3, [r6, #28]
 80a0400:	4649      	mov	r1, r9
 80a0402:	9300      	str	r3, [sp, #0]
 80a0404:	4660      	mov	r0, ip
 80a0406:	463b      	mov	r3, r7
 80a0408:	47d0      	blx	sl
 80a040a:	3718      	adds	r7, #24
 80a040c:	46bd      	mov	sp, r7
 80a040e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a0412:	bf00      	nop
 80a0414:	080aa5bc 	.word	0x080aa5bc

080a0418 <_ZN10alarmRelay10setupRelayEi>:
function: setupRelay()
description: initializes a relay object with a specific pin value
parameters: none
returns: none
*/
void alarmRelay::setupRelay(int p){
 80a0418:	460b      	mov	r3, r1
    this->pin = p; 
 80a041a:	6001      	str	r1, [r0, #0]
    this->armed = true; 
 80a041c:	2101      	movs	r1, #1
 80a041e:	7101      	strb	r1, [r0, #4]
    pinMode(pin, OUTPUT);
 80a0420:	b298      	uxth	r0, r3
 80a0422:	f007 b8b9 	b.w	80a7598 <pinMode>

080a0426 <_ZN10alarmRelay8beepOnceEi>:
function: beepOnce()
description: beeps once within a given delay interval, with a 50 percent duty cycle
parameters: none
returns: none
*/
void alarmRelay::beepOnce(int d){
 80a0426:	b538      	push	{r3, r4, r5, lr}
    if(this->armed){
 80a0428:	7903      	ldrb	r3, [r0, #4]
void alarmRelay::beepOnce(int d){
 80a042a:	4604      	mov	r4, r0
 80a042c:	460d      	mov	r5, r1
    if(this->armed){
 80a042e:	b163      	cbz	r3, 80a044a <_ZN10alarmRelay8beepOnceEi+0x24>
        digitalWrite(pin, HIGH);
 80a0430:	2101      	movs	r1, #1
 80a0432:	8800      	ldrh	r0, [r0, #0]
 80a0434:	f007 f8c1 	bl	80a75ba <digitalWrite>
        delay(d);
 80a0438:	4628      	mov	r0, r5
 80a043a:	f006 fa67 	bl	80a690c <delay>
        digitalWrite(pin, LOW);
 80a043e:	8820      	ldrh	r0, [r4, #0]
 80a0440:	2100      	movs	r1, #0
    }
}
 80a0442:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        digitalWrite(pin, LOW);
 80a0446:	f007 b8b8 	b.w	80a75ba <digitalWrite>
}
 80a044a:	bd38      	pop	{r3, r4, r5, pc}

080a044c <_Z12ms_1000_taskv>:
    lockStatus.system_locked = false;
}

void ms_1000_task(void)
{
}
 80a044c:	4770      	bx	lr

080a044e <_Z16quickMessageJumpPv>:
parameters: none 
returns: none
*/
void quickMessageJump(void *ptr)
{
}
 80a044e:	4770      	bx	lr

080a0450 <_ZNSt17_Function_handlerIFvvEPS0_E9_M_invokeERKSt9_Any_data>:

     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
	(*_Base::_M_get_pointer(__functor))(
 80a0450:	6803      	ldr	r3, [r0, #0]
 80a0452:	4718      	bx	r3

080a0454 <_ZNSt14_Function_base13_Base_managerIPFvvEE10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation>:
	  switch (__op)
 80a0454:	2a01      	cmp	r2, #1
 80a0456:	d003      	beq.n	80a0460 <_ZNSt14_Function_base13_Base_managerIPFvvEE10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation+0xc>
 80a0458:	2a02      	cmp	r2, #2
 80a045a:	d003      	beq.n	80a0464 <_ZNSt14_Function_base13_Base_managerIPFvvEE10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation+0x10>
	}
 80a045c:	2000      	movs	r0, #0
 80a045e:	4770      	bx	lr
	      __dest._M_access<_Functor*>() = _M_get_pointer(__source);
 80a0460:	6001      	str	r1, [r0, #0]
	      break;
 80a0462:	e7fb      	b.n	80a045c <_ZNSt14_Function_base13_Base_managerIPFvvEE10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation+0x8>
	  ::new (__dest._M_access()) _Functor(__source._M_access<_Functor>());
 80a0464:	680b      	ldr	r3, [r1, #0]
 80a0466:	6003      	str	r3, [r0, #0]
	}
 80a0468:	e7f8      	b.n	80a045c <_ZNSt14_Function_base13_Base_managerIPFvvEE10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation+0x8>
	...

080a046c <_Z17toggleLEDCallbackPv>:
    lampLight.toggle();
 80a046c:	4801      	ldr	r0, [pc, #4]	; (80a0474 <_Z17toggleLEDCallbackPv+0x8>)
 80a046e:	f001 b9d9 	b.w	80a1824 <_ZN8LEDRelay6toggleEv>
 80a0472:	bf00      	nop
 80a0474:	20000c18 	.word	0x20000c18

080a0478 <_Z21quickMessage6FunctionPv>:
parameters: none 
returns: none
*/
void quickMessage6Function(void *ptr)
{
    hmiScreen.home();
 80a0478:	4801      	ldr	r0, [pc, #4]	; (80a0480 <_Z21quickMessage6FunctionPv+0x8>)
 80a047a:	f001 b985 	b.w	80a1788 <_ZN9HMIScreen4homeEv>
 80a047e:	bf00      	nop
 80a0480:	20000180 	.word	0x20000180

080a0484 <_Z9s_10_taskv>:
    tftDisplay.updateTimeDisplay();
 80a0484:	4801      	ldr	r0, [pc, #4]	; (80a048c <_Z9s_10_taskv+0x8>)
 80a0486:	f7ff be9b 	b.w	80a01c0 <_ZN10TFTDisplay17updateTimeDisplayEv>
 80a048a:	bf00      	nop
 80a048c:	20000d34 	.word	0x20000d34

080a0490 <_Z9s_30_taskv>:
    if (lockStatus.system_locked)
 80a0490:	4b03      	ldr	r3, [pc, #12]	; (80a04a0 <_Z9s_30_taskv+0x10>)
 80a0492:	781b      	ldrb	r3, [r3, #0]
 80a0494:	b113      	cbz	r3, 80a049c <_Z9s_30_taskv+0xc>
        tftDisplay.updateTimeDisplay();
 80a0496:	4803      	ldr	r0, [pc, #12]	; (80a04a4 <_Z9s_30_taskv+0x14>)
 80a0498:	f7ff be92 	b.w	80a01c0 <_ZN10TFTDisplay17updateTimeDisplayEv>
}
 80a049c:	4770      	bx	lr
 80a049e:	bf00      	nop
 80a04a0:	20000c19 	.word	0x20000c19
 80a04a4:	20000d34 	.word	0x20000d34

080a04a8 <_Z17sleepModeCallbackPv>:
    sleepMode.sleep_mode_enabled = true;
 80a04a8:	2201      	movs	r2, #1
{
 80a04aa:	b508      	push	{r3, lr}
    sleepMode.sleep_mode_enabled = true;
 80a04ac:	4b09      	ldr	r3, [pc, #36]	; (80a04d4 <_Z17sleepModeCallbackPv+0x2c>)
    hmiScreen.sleep();
 80a04ae:	480a      	ldr	r0, [pc, #40]	; (80a04d8 <_Z17sleepModeCallbackPv+0x30>)
    sleepMode.sleep_mode_enabled = true;
 80a04b0:	701a      	strb	r2, [r3, #0]
    hmiScreen.sleep();
 80a04b2:	f001 f97d 	bl	80a17b0 <_ZN9HMIScreen5sleepEv>
    notifLight.setStrip(0, 0, 0);
 80a04b6:	2300      	movs	r3, #0
 80a04b8:	4808      	ldr	r0, [pc, #32]	; (80a04dc <_Z17sleepModeCallbackPv+0x34>)
 80a04ba:	4619      	mov	r1, r3
 80a04bc:	461a      	mov	r2, r3
 80a04be:	f001 f9c9 	bl	80a1854 <_ZN17notificationLight8setStripEhhh>
    lampLight.setLED(false);
 80a04c2:	4807      	ldr	r0, [pc, #28]	; (80a04e0 <_Z17sleepModeCallbackPv+0x38>)
 80a04c4:	2100      	movs	r1, #0
 80a04c6:	f001 f9b4 	bl	80a1832 <_ZN8LEDRelay6setLEDEb>
}
 80a04ca:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    clock_control.sleep();
 80a04ce:	4805      	ldr	r0, [pc, #20]	; (80a04e4 <_Z17sleepModeCallbackPv+0x3c>)
 80a04d0:	f7ff bf3c 	b.w	80a034c <_ZN12ClockControl5sleepEv>
 80a04d4:	20000d30 	.word	0x20000d30
 80a04d8:	20000180 	.word	0x20000180
 80a04dc:	20000cc4 	.word	0x20000cc4
 80a04e0:	20000c18 	.word	0x20000c18
 80a04e4:	20000144 	.word	0x20000144

080a04e8 <_Z18toggleWifiCallbackPv>:
    toggleWifiParticle();
 80a04e8:	f7ff bdee 	b.w	80a00c8 <_Z18toggleWifiParticlev>

080a04ec <_Z14wakeUpCallbackPv>:
    sleepMode.sleep_mode_enabled = false;
 80a04ec:	2200      	movs	r2, #0
{
 80a04ee:	b510      	push	{r4, lr}
    hmiScreen.home();
 80a04f0:	4c06      	ldr	r4, [pc, #24]	; (80a050c <_Z14wakeUpCallbackPv+0x20>)
    sleepMode.sleep_mode_enabled = false;
 80a04f2:	4b07      	ldr	r3, [pc, #28]	; (80a0510 <_Z14wakeUpCallbackPv+0x24>)
    hmiScreen.home();
 80a04f4:	4620      	mov	r0, r4
    sleepMode.sleep_mode_enabled = false;
 80a04f6:	701a      	strb	r2, [r3, #0]
    hmiScreen.home();
 80a04f8:	f001 f946 	bl	80a1788 <_ZN9HMIScreen4homeEv>
    hmiScreen.wake();
 80a04fc:	4620      	mov	r0, r4
 80a04fe:	f001 f949 	bl	80a1794 <_ZN9HMIScreen4wakeEv>
}
 80a0502:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    clock_control.wake();
 80a0506:	4803      	ldr	r0, [pc, #12]	; (80a0514 <_Z14wakeUpCallbackPv+0x28>)
 80a0508:	f7ff bf02 	b.w	80a0310 <_ZN12ClockControl4wakeEv>
 80a050c:	20000180 	.word	0x20000180
 80a0510:	20000d30 	.word	0x20000d30
 80a0514:	20000144 	.word	0x20000144

080a0518 <_Z16keyBoardCallbackPv>:
{
 80a0518:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    hmiScreen.keyboardText.getText(hmiScreen.keyBuffer, sizeof(hmiScreen.keyBuffer));
 80a051a:	4948      	ldr	r1, [pc, #288]	; (80a063c <_Z16keyBoardCallbackPv+0x124>)
 80a051c:	22c0      	movs	r2, #192	; 0xc0
 80a051e:	f1a1 0048 	sub.w	r0, r1, #72	; 0x48
 80a0522:	f001 fa7d 	bl	80a1a20 <_ZN7NexText7getTextEPct>
    String buffer = hmiScreen.keyBuffer;
 80a0526:	4945      	ldr	r1, [pc, #276]	; (80a063c <_Z16keyBoardCallbackPv+0x124>)
 80a0528:	4668      	mov	r0, sp
 80a052a:	f006 feec 	bl	80a7306 <_ZN6StringC1EPKc>
    if (buffer.equals("exit"))
 80a052e:	4668      	mov	r0, sp
 80a0530:	4943      	ldr	r1, [pc, #268]	; (80a0640 <_Z16keyBoardCallbackPv+0x128>)
 80a0532:	f006 ff15 	bl	80a7360 <_ZNK6String6equalsEPKc>
 80a0536:	b328      	cbz	r0, 80a0584 <_Z16keyBoardCallbackPv+0x6c>
        hmiScreen.terminalText.setText("Exiting");
 80a0538:	4942      	ldr	r1, [pc, #264]	; (80a0644 <_Z16keyBoardCallbackPv+0x12c>)
 80a053a:	4843      	ldr	r0, [pc, #268]	; (80a0648 <_Z16keyBoardCallbackPv+0x130>)
 80a053c:	f001 fa78 	bl	80a1a30 <_ZN7NexText7setTextEPKc>
        delay(100);
 80a0540:	2064      	movs	r0, #100	; 0x64
 80a0542:	f006 f9e3 	bl	80a690c <delay>
        hmiScreen.terminalText.setText("Exiting.");
 80a0546:	4941      	ldr	r1, [pc, #260]	; (80a064c <_Z16keyBoardCallbackPv+0x134>)
 80a0548:	483f      	ldr	r0, [pc, #252]	; (80a0648 <_Z16keyBoardCallbackPv+0x130>)
 80a054a:	f001 fa71 	bl	80a1a30 <_ZN7NexText7setTextEPKc>
        delay(100);
 80a054e:	2064      	movs	r0, #100	; 0x64
 80a0550:	f006 f9dc 	bl	80a690c <delay>
        hmiScreen.terminalText.setText("Exiting..");
 80a0554:	493e      	ldr	r1, [pc, #248]	; (80a0650 <_Z16keyBoardCallbackPv+0x138>)
 80a0556:	483c      	ldr	r0, [pc, #240]	; (80a0648 <_Z16keyBoardCallbackPv+0x130>)
 80a0558:	f001 fa6a 	bl	80a1a30 <_ZN7NexText7setTextEPKc>
        delay(100);
 80a055c:	2064      	movs	r0, #100	; 0x64
 80a055e:	f006 f9d5 	bl	80a690c <delay>
        hmiScreen.terminalText.setText("Exiting...");
 80a0562:	493c      	ldr	r1, [pc, #240]	; (80a0654 <_Z16keyBoardCallbackPv+0x13c>)
 80a0564:	4838      	ldr	r0, [pc, #224]	; (80a0648 <_Z16keyBoardCallbackPv+0x130>)
 80a0566:	f001 fa63 	bl	80a1a30 <_ZN7NexText7setTextEPKc>
        delay(100);
 80a056a:	2064      	movs	r0, #100	; 0x64
 80a056c:	f006 f9ce 	bl	80a690c <delay>
        hmiScreen.terminalText.setText("Exiting....");
 80a0570:	4939      	ldr	r1, [pc, #228]	; (80a0658 <_Z16keyBoardCallbackPv+0x140>)
 80a0572:	4835      	ldr	r0, [pc, #212]	; (80a0648 <_Z16keyBoardCallbackPv+0x130>)
 80a0574:	f001 fa5c 	bl	80a1a30 <_ZN7NexText7setTextEPKc>
        delay(100);
 80a0578:	2064      	movs	r0, #100	; 0x64
 80a057a:	f006 f9c7 	bl	80a690c <delay>
        hmiScreen.home();
 80a057e:	4837      	ldr	r0, [pc, #220]	; (80a065c <_Z16keyBoardCallbackPv+0x144>)
 80a0580:	f001 f902 	bl	80a1788 <_ZN9HMIScreen4homeEv>
    if (buffer.equals("reset"))
 80a0584:	4668      	mov	r0, sp
 80a0586:	4936      	ldr	r1, [pc, #216]	; (80a0660 <_Z16keyBoardCallbackPv+0x148>)
 80a0588:	f006 feea 	bl	80a7360 <_ZNK6String6equalsEPKc>
 80a058c:	b358      	cbz	r0, 80a05e6 <_Z16keyBoardCallbackPv+0xce>
        hmiScreen.terminalText.setText("Resetting Device");
 80a058e:	4935      	ldr	r1, [pc, #212]	; (80a0664 <_Z16keyBoardCallbackPv+0x14c>)
 80a0590:	482d      	ldr	r0, [pc, #180]	; (80a0648 <_Z16keyBoardCallbackPv+0x130>)
 80a0592:	f001 fa4d 	bl	80a1a30 <_ZN7NexText7setTextEPKc>
        delay(100);
 80a0596:	2064      	movs	r0, #100	; 0x64
 80a0598:	f006 f9b8 	bl	80a690c <delay>
        hmiScreen.terminalText.setText("Resetting Device.");
 80a059c:	4932      	ldr	r1, [pc, #200]	; (80a0668 <_Z16keyBoardCallbackPv+0x150>)
 80a059e:	482a      	ldr	r0, [pc, #168]	; (80a0648 <_Z16keyBoardCallbackPv+0x130>)
 80a05a0:	f001 fa46 	bl	80a1a30 <_ZN7NexText7setTextEPKc>
        delay(100);
 80a05a4:	2064      	movs	r0, #100	; 0x64
 80a05a6:	f006 f9b1 	bl	80a690c <delay>
        hmiScreen.terminalText.setText("Resetting Device..");
 80a05aa:	4930      	ldr	r1, [pc, #192]	; (80a066c <_Z16keyBoardCallbackPv+0x154>)
 80a05ac:	4826      	ldr	r0, [pc, #152]	; (80a0648 <_Z16keyBoardCallbackPv+0x130>)
 80a05ae:	f001 fa3f 	bl	80a1a30 <_ZN7NexText7setTextEPKc>
        delay(100);
 80a05b2:	2064      	movs	r0, #100	; 0x64
 80a05b4:	f006 f9aa 	bl	80a690c <delay>
        hmiScreen.terminalText.setText("Resetting Device...");
 80a05b8:	492d      	ldr	r1, [pc, #180]	; (80a0670 <_Z16keyBoardCallbackPv+0x158>)
 80a05ba:	4823      	ldr	r0, [pc, #140]	; (80a0648 <_Z16keyBoardCallbackPv+0x130>)
 80a05bc:	f001 fa38 	bl	80a1a30 <_ZN7NexText7setTextEPKc>
        delay(100);
 80a05c0:	2064      	movs	r0, #100	; 0x64
 80a05c2:	f006 f9a3 	bl	80a690c <delay>
        hmiScreen.terminalText.setText("Resetting Device....");
 80a05c6:	492b      	ldr	r1, [pc, #172]	; (80a0674 <_Z16keyBoardCallbackPv+0x15c>)
 80a05c8:	481f      	ldr	r0, [pc, #124]	; (80a0648 <_Z16keyBoardCallbackPv+0x130>)
 80a05ca:	f001 fa31 	bl	80a1a30 <_ZN7NexText7setTextEPKc>
        delay(100);
 80a05ce:	2064      	movs	r0, #100	; 0x64
 80a05d0:	f006 f99c 	bl	80a690c <delay>
        hmiScreen.terminalText.setText("Resetting Device.....");
 80a05d4:	4928      	ldr	r1, [pc, #160]	; (80a0678 <_Z16keyBoardCallbackPv+0x160>)
 80a05d6:	481c      	ldr	r0, [pc, #112]	; (80a0648 <_Z16keyBoardCallbackPv+0x130>)
 80a05d8:	f001 fa2a 	bl	80a1a30 <_ZN7NexText7setTextEPKc>
        delay(100);
 80a05dc:	2064      	movs	r0, #100	; 0x64
 80a05de:	f006 f995 	bl	80a690c <delay>
        System.reset();
 80a05e2:	f006 ff2d 	bl	80a7440 <_ZN11SystemClass5resetEv>
    if (buffer.equals("wifilisten"))
 80a05e6:	4668      	mov	r0, sp
 80a05e8:	4924      	ldr	r1, [pc, #144]	; (80a067c <_Z16keyBoardCallbackPv+0x164>)
 80a05ea:	f006 feb9 	bl	80a7360 <_ZNK6String6equalsEPKc>
 80a05ee:	b168      	cbz	r0, 80a060c <_Z16keyBoardCallbackPv+0xf4>
        hmiScreen.terminalText.setText("Setting Wifi to listening mode...");
 80a05f0:	4923      	ldr	r1, [pc, #140]	; (80a0680 <_Z16keyBoardCallbackPv+0x168>)
 80a05f2:	4815      	ldr	r0, [pc, #84]	; (80a0648 <_Z16keyBoardCallbackPv+0x130>)
 80a05f4:	f001 fa1c 	bl	80a1a30 <_ZN7NexText7setTextEPKc>
        enableListeningMode();
 80a05f8:	f7ff fd80 	bl	80a00fc <_Z19enableListeningModev>
        delay(700);
 80a05fc:	f44f 702f 	mov.w	r0, #700	; 0x2bc
 80a0600:	f006 f984 	bl	80a690c <delay>
        hmiScreen.terminalText.setText("WiFi has been set to listening mode!!");
 80a0604:	491f      	ldr	r1, [pc, #124]	; (80a0684 <_Z16keyBoardCallbackPv+0x16c>)
 80a0606:	4810      	ldr	r0, [pc, #64]	; (80a0648 <_Z16keyBoardCallbackPv+0x130>)
 80a0608:	f001 fa12 	bl	80a1a30 <_ZN7NexText7setTextEPKc>
    if (buffer.equals("beep"))
 80a060c:	4668      	mov	r0, sp
 80a060e:	491e      	ldr	r1, [pc, #120]	; (80a0688 <_Z16keyBoardCallbackPv+0x170>)
 80a0610:	f006 fea6 	bl	80a7360 <_ZNK6String6equalsEPKc>
 80a0614:	b138      	cbz	r0, 80a0626 <_Z16keyBoardCallbackPv+0x10e>
        hmiScreen.terminalText.setText("beeping...");
 80a0616:	491d      	ldr	r1, [pc, #116]	; (80a068c <_Z16keyBoardCallbackPv+0x174>)
 80a0618:	480b      	ldr	r0, [pc, #44]	; (80a0648 <_Z16keyBoardCallbackPv+0x130>)
 80a061a:	f001 fa09 	bl	80a1a30 <_ZN7NexText7setTextEPKc>
        hmiScreen.terminalText.setText("Completed Beeping");
 80a061e:	491c      	ldr	r1, [pc, #112]	; (80a0690 <_Z16keyBoardCallbackPv+0x178>)
 80a0620:	4809      	ldr	r0, [pc, #36]	; (80a0648 <_Z16keyBoardCallbackPv+0x130>)
 80a0622:	f001 fa05 	bl	80a1a30 <_ZN7NexText7setTextEPKc>
    hmiScreen.keyboardText.setText("");
 80a0626:	491b      	ldr	r1, [pc, #108]	; (80a0694 <_Z16keyBoardCallbackPv+0x17c>)
 80a0628:	481b      	ldr	r0, [pc, #108]	; (80a0698 <_Z16keyBoardCallbackPv+0x180>)
 80a062a:	f001 fa01 	bl	80a1a30 <_ZN7NexText7setTextEPKc>
    String buffer = hmiScreen.keyBuffer;
 80a062e:	4668      	mov	r0, sp
 80a0630:	f006 fe1f 	bl	80a7272 <_ZN6StringD1Ev>
}
 80a0634:	b005      	add	sp, #20
 80a0636:	f85d fb04 	ldr.w	pc, [sp], #4
 80a063a:	bf00      	nop
 80a063c:	20000418 	.word	0x20000418
 80a0640:	080a93c5 	.word	0x080a93c5
 80a0644:	080a93ca 	.word	0x080a93ca
 80a0648:	200003f4 	.word	0x200003f4
 80a064c:	080a93d2 	.word	0x080a93d2
 80a0650:	080a93db 	.word	0x080a93db
 80a0654:	080a93e5 	.word	0x080a93e5
 80a0658:	080a93f0 	.word	0x080a93f0
 80a065c:	20000180 	.word	0x20000180
 80a0660:	080a93fc 	.word	0x080a93fc
 80a0664:	080a9402 	.word	0x080a9402
 80a0668:	080a9413 	.word	0x080a9413
 80a066c:	080a9425 	.word	0x080a9425
 80a0670:	080a9438 	.word	0x080a9438
 80a0674:	080a944c 	.word	0x080a944c
 80a0678:	080a9461 	.word	0x080a9461
 80a067c:	080a9477 	.word	0x080a9477
 80a0680:	080a9482 	.word	0x080a9482
 80a0684:	080a94a4 	.word	0x080a94a4
 80a0688:	080a94ca 	.word	0x080a94ca
 80a068c:	080a94cf 	.word	0x080a94cf
 80a0690:	080a94da 	.word	0x080a94da
 80a0694:	080aa420 	.word	0x080aa420
 80a0698:	200003d0 	.word	0x200003d0

080a069c <_ZN5Timer7timeoutEv>:
     * Subclasses can either provide a callback function, or override
     * this timeout method.
     */
    virtual void timeout()
    {
        if (callback) {
 80a069c:	6943      	ldr	r3, [r0, #20]
 80a069e:	b113      	cbz	r3, 80a06a6 <_ZN5Timer7timeoutEv+0xa>
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
	__throw_bad_function_call();
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a06a0:	6983      	ldr	r3, [r0, #24]
 80a06a2:	300c      	adds	r0, #12
 80a06a4:	4718      	bx	r3
            callback();
        }
    }
 80a06a6:	4770      	bx	lr

080a06a8 <_ZN5Timer12invoke_timerEPv>:
private:
	volatile bool running;
    os_timer_t handle;
    timer_callback_fn callback;

    static void invoke_timer(os_timer_t timer)
 80a06a8:	b513      	push	{r0, r1, r4, lr}
typedef std::function<os_thread_return_t(void)> wiring_thread_fn_t;

class SingleThreadedSection {
public:
    SingleThreadedSection() {
        os_thread_scheduling(false, NULL);
 80a06aa:	2100      	movs	r1, #0
 80a06ac:	4604      	mov	r4, r0
 80a06ae:	4608      	mov	r0, r1
 80a06b0:	f005 f82e 	bl	80a5710 <os_thread_scheduling>
    {
        Timer* t = nullptr;
        SINGLE_THREADED_BLOCK() {
            void* id = nullptr;
 80a06b4:	2300      	movs	r3, #0
            os_timer_get_id(timer, &id);
 80a06b6:	4620      	mov	r0, r4
 80a06b8:	a901      	add	r1, sp, #4
            void* id = nullptr;
 80a06ba:	9301      	str	r3, [sp, #4]
            os_timer_get_id(timer, &id);
 80a06bc:	f005 f840 	bl	80a5740 <os_timer_get_id>
            t = static_cast<Timer*>(id);
 80a06c0:	9c01      	ldr	r4, [sp, #4]
            if (t) {
 80a06c2:	b10c      	cbz	r4, 80a06c8 <_ZN5Timer12invoke_timerEPv+0x20>
                t->running = true;
 80a06c4:	2301      	movs	r3, #1
 80a06c6:	7123      	strb	r3, [r4, #4]
    }

    ~SingleThreadedSection() {
        os_thread_scheduling(true, NULL);
 80a06c8:	2100      	movs	r1, #0
 80a06ca:	2001      	movs	r0, #1
 80a06cc:	f005 f820 	bl	80a5710 <os_thread_scheduling>
            }
        }
        if (t) {
 80a06d0:	b12c      	cbz	r4, 80a06de <_ZN5Timer12invoke_timerEPv+0x36>
            t->timeout();
 80a06d2:	6823      	ldr	r3, [r4, #0]
 80a06d4:	4620      	mov	r0, r4
 80a06d6:	689b      	ldr	r3, [r3, #8]
 80a06d8:	4798      	blx	r3
            t->running = false;
 80a06da:	2300      	movs	r3, #0
 80a06dc:	7123      	strb	r3, [r4, #4]
        }
    }
 80a06de:	b002      	add	sp, #8
 80a06e0:	bd10      	pop	{r4, pc}
	...

080a06e4 <_Z4pushPKcS0_>:
description: pushes a notification by printing to the tft led, and blinking the rgb leds :)
parameters:  *event, *data const char 
returns: none
*/
void push(const char *event, const char *data)
{
 80a06e4:	b500      	push	{lr}
    if (!lockStatus.system_locked && !sleepMode.sleep_mode_enabled)
 80a06e6:	4b24      	ldr	r3, [pc, #144]	; (80a0778 <_Z4pushPKcS0_+0x94>)
 80a06e8:	4a24      	ldr	r2, [pc, #144]	; (80a077c <_Z4pushPKcS0_+0x98>)
 80a06ea:	7818      	ldrb	r0, [r3, #0]
{
 80a06ec:	b089      	sub	sp, #36	; 0x24
    if (!lockStatus.system_locked && !sleepMode.sleep_mode_enabled)
 80a06ee:	bb78      	cbnz	r0, 80a0750 <_Z4pushPKcS0_+0x6c>
 80a06f0:	7810      	ldrb	r0, [r2, #0]
 80a06f2:	bb68      	cbnz	r0, 80a0750 <_Z4pushPKcS0_+0x6c>
    {
        String buffer = data;
 80a06f4:	4668      	mov	r0, sp
 80a06f6:	f006 fe06 	bl	80a7306 <_ZN6StringC1EPKc>
        tftDisplay.printTFT(buffer);
 80a06fa:	4669      	mov	r1, sp
 80a06fc:	a804      	add	r0, sp, #16
 80a06fe:	f006 fe24 	bl	80a734a <_ZN6StringC1ERKS_>
 80a0702:	a904      	add	r1, sp, #16
 80a0704:	481e      	ldr	r0, [pc, #120]	; (80a0780 <_Z4pushPKcS0_+0x9c>)
 80a0706:	f7ff fdeb 	bl	80a02e0 <_ZN10TFTDisplay8printTFTE6String>
 80a070a:	a804      	add	r0, sp, #16
 80a070c:	f006 fdb1 	bl	80a7272 <_ZN6StringD1Ev>
        hmiScreen.home();
 80a0710:	481c      	ldr	r0, [pc, #112]	; (80a0784 <_Z4pushPKcS0_+0xa0>)
 80a0712:	f001 f839 	bl	80a1788 <_ZN9HMIScreen4homeEv>
        hmiScreen.homeText.setText(buffer);
 80a0716:	9900      	ldr	r1, [sp, #0]
 80a0718:	481b      	ldr	r0, [pc, #108]	; (80a0788 <_Z4pushPKcS0_+0xa4>)
 80a071a:	f001 f989 	bl	80a1a30 <_ZN7NexText7setTextEPKc>
        counter.stagger_push = true;
 80a071e:	2201      	movs	r2, #1
 80a0720:	4b1a      	ldr	r3, [pc, #104]	; (80a078c <_Z4pushPKcS0_+0xa8>)
        alarmrelay.beepOnce(300);
 80a0722:	f44f 7196 	mov.w	r1, #300	; 0x12c
 80a0726:	481a      	ldr	r0, [pc, #104]	; (80a0790 <_Z4pushPKcS0_+0xac>)
        counter.stagger_push = true;
 80a0728:	731a      	strb	r2, [r3, #12]
        alarmrelay.beepOnce(300);
 80a072a:	f7ff fe7c 	bl	80a0426 <_ZN10alarmRelay8beepOnceEi>
        clock_control.send_msg(buffer);
 80a072e:	4669      	mov	r1, sp
 80a0730:	a804      	add	r0, sp, #16
 80a0732:	f006 fe0a 	bl	80a734a <_ZN6StringC1ERKS_>
 80a0736:	4817      	ldr	r0, [pc, #92]	; (80a0794 <_Z4pushPKcS0_+0xb0>)
 80a0738:	a904      	add	r1, sp, #16
 80a073a:	f7ff fe25 	bl	80a0388 <_ZN12ClockControl8send_msgE6String>
 80a073e:	a804      	add	r0, sp, #16
 80a0740:	f006 fd97 	bl	80a7272 <_ZN6StringD1Ev>
        String buffer = data;
 80a0744:	4668      	mov	r0, sp
 80a0746:	f006 fd94 	bl	80a7272 <_ZN6StringD1Ev>
    }
    else if (lockStatus.system_locked & sleepMode.sleep_mode_enabled)
    {
        tftDisplay.printTFT("Message Receieved");
    }
}
 80a074a:	b009      	add	sp, #36	; 0x24
 80a074c:	f85d fb04 	ldr.w	pc, [sp], #4
    else if (lockStatus.system_locked & sleepMode.sleep_mode_enabled)
 80a0750:	7819      	ldrb	r1, [r3, #0]
 80a0752:	7813      	ldrb	r3, [r2, #0]
 80a0754:	b2db      	uxtb	r3, r3
 80a0756:	2900      	cmp	r1, #0
 80a0758:	d0f7      	beq.n	80a074a <_Z4pushPKcS0_+0x66>
 80a075a:	2b00      	cmp	r3, #0
 80a075c:	d0f5      	beq.n	80a074a <_Z4pushPKcS0_+0x66>
        tftDisplay.printTFT("Message Receieved");
 80a075e:	490e      	ldr	r1, [pc, #56]	; (80a0798 <_Z4pushPKcS0_+0xb4>)
 80a0760:	a804      	add	r0, sp, #16
 80a0762:	f006 fdd0 	bl	80a7306 <_ZN6StringC1EPKc>
 80a0766:	4806      	ldr	r0, [pc, #24]	; (80a0780 <_Z4pushPKcS0_+0x9c>)
 80a0768:	a904      	add	r1, sp, #16
 80a076a:	f7ff fdb9 	bl	80a02e0 <_ZN10TFTDisplay8printTFTE6String>
 80a076e:	a804      	add	r0, sp, #16
 80a0770:	f006 fd7f 	bl	80a7272 <_ZN6StringD1Ev>
}
 80a0774:	e7e9      	b.n	80a074a <_Z4pushPKcS0_+0x66>
 80a0776:	bf00      	nop
 80a0778:	20000c19 	.word	0x20000c19
 80a077c:	20000d30 	.word	0x20000d30
 80a0780:	20000d34 	.word	0x20000d34
 80a0784:	20000180 	.word	0x20000180
 80a0788:	20000244 	.word	0x20000244
 80a078c:	20000170 	.word	0x20000170
 80a0790:	20000128 	.word	0x20000128
 80a0794:	20000144 	.word	0x20000144
 80a0798:	080a94ec 	.word	0x080a94ec

080a079c <_ZN10CloudClass7publishEPKcS1_.isra.0.constprop.0>:

inline particle::Future<bool> CloudClass::publish(const char* name) {
    return publish(name, PUBLIC);
}

inline particle::Future<bool> CloudClass::publish(const char* name, const char* data) {
 80a079c:	b513      	push	{r0, r1, r4, lr}
 80a079e:	4604      	mov	r4, r0
 80a07a0:	4b05      	ldr	r3, [pc, #20]	; (80a07b8 <_ZN10CloudClass7publishEPKcS1_.isra.0.constprop.0+0x1c>)
 80a07a2:	460a      	mov	r2, r1
inline particle::Flags<TagT, ValueT>::Flags(Flag<TagT, ValueT> flag) :
        val_(flag.value()) {
}

template<typename TagT, typename ValueT>
inline particle::Flags<TagT, ValueT>::Flags(ValueT val) :
 80a07a4:	781b      	ldrb	r3, [r3, #0]
        return publish_event(eventName, eventData, ttl, flags1 | flags2);
 80a07a6:	4905      	ldr	r1, [pc, #20]	; (80a07bc <_ZN10CloudClass7publishEPKcS1_.isra.0.constprop.0+0x20>)
 80a07a8:	f88d 3000 	strb.w	r3, [sp]
 80a07ac:	233c      	movs	r3, #60	; 0x3c
 80a07ae:	f005 ff37 	bl	80a6620 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE>
    return publish(name, data, PUBLIC);
}
 80a07b2:	4620      	mov	r0, r4
 80a07b4:	b002      	add	sp, #8
 80a07b6:	bd10      	pop	{r4, pc}
 80a07b8:	20000124 	.word	0x20000124
 80a07bc:	080a94fe 	.word	0x080a94fe

080a07c0 <_ZN10CloudClass9subscribeEPKcPFvS1_S1_E32Spark_Subscription_Scope_TypeDef.isra.0.constprop.0>:
        return spark_subscribe(eventName, handler, NULL, scope, NULL, NULL);
 80a07c0:	2300      	movs	r3, #0
    inline bool subscribe(const char *eventName, EventHandler handler, Spark_Subscription_Scope_TypeDef scope)
 80a07c2:	b507      	push	{r0, r1, r2, lr}
        return spark_subscribe(eventName, handler, NULL, scope, NULL, NULL);
 80a07c4:	461a      	mov	r2, r3
 80a07c6:	e9cd 3300 	strd	r3, r3, [sp]
 80a07ca:	f005 f8a1 	bl	80a5910 <spark_subscribe>
    }
 80a07ce:	b003      	add	sp, #12
 80a07d0:	f85d fb04 	ldr.w	pc, [sp], #4

080a07d4 <_Z8pushLoudPKcS0_>:
 80a07d4:	4770      	bx	lr

080a07d6 <_ZNSt14_Function_baseD1Ev>:
    ~_Function_base()
 80a07d6:	b510      	push	{r4, lr}
      if (_M_manager)
 80a07d8:	6883      	ldr	r3, [r0, #8]
    ~_Function_base()
 80a07da:	4604      	mov	r4, r0
      if (_M_manager)
 80a07dc:	b113      	cbz	r3, 80a07e4 <_ZNSt14_Function_baseD1Ev+0xe>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
 80a07de:	2203      	movs	r2, #3
 80a07e0:	4601      	mov	r1, r0
 80a07e2:	4798      	blx	r3
    }
 80a07e4:	4620      	mov	r0, r4
 80a07e6:	bd10      	pop	{r4, pc}

080a07e8 <_ZN5TimerC1EjSt8functionIFvvEEb>:
    Timer(unsigned period, timer_callback_fn callback_, bool one_shot=false) : running(false), handle(nullptr), callback(std::move(callback_)) {
 80a07e8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a07ea:	2500      	movs	r5, #0
 80a07ec:	4604      	mov	r4, r0
 80a07ee:	468c      	mov	ip, r1
 80a07f0:	b085      	sub	sp, #20
 80a07f2:	4913      	ldr	r1, [pc, #76]	; (80a0840 <_ZN5TimerC1EjSt8functionIFvvEEb+0x58>)
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a07f4:	af02      	add	r7, sp, #8
 80a07f6:	7105      	strb	r5, [r0, #4]
 80a07f8:	6085      	str	r5, [r0, #8]
 80a07fa:	6001      	str	r1, [r0, #0]
 80a07fc:	e892 0003 	ldmia.w	r2, {r0, r1}
 80a0800:	e887 0003 	stmia.w	r7, {r0, r1}
      __a = _GLIBCXX_MOVE(__b);
 80a0804:	f104 060c 	add.w	r6, r4, #12
 80a0808:	e896 0003 	ldmia.w	r6, {r0, r1}
 80a080c:	e882 0003 	stmia.w	r2, {r0, r1}
      __b = _GLIBCXX_MOVE(__tmp);
 80a0810:	e897 0003 	ldmia.w	r7, {r0, r1}
 80a0814:	e886 0003 	stmia.w	r6, {r0, r1}
      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a0818:	6891      	ldr	r1, [r2, #8]
      __a = _GLIBCXX_MOVE(__b);
 80a081a:	69a0      	ldr	r0, [r4, #24]
      __b = _GLIBCXX_MOVE(__tmp);
 80a081c:	6161      	str	r1, [r4, #20]
      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a081e:	68d1      	ldr	r1, [r2, #12]
      __a = _GLIBCXX_MOVE(__b);
 80a0820:	6095      	str	r5, [r2, #8]
 80a0822:	60d0      	str	r0, [r2, #12]
      __b = _GLIBCXX_MOVE(__tmp);
 80a0824:	61a1      	str	r1, [r4, #24]
        os_timer_create(&handle, period, invoke_timer, this, one_shot, nullptr);
 80a0826:	e9cd 3500 	strd	r3, r5, [sp]
 80a082a:	4661      	mov	r1, ip
 80a082c:	4623      	mov	r3, r4
 80a082e:	4a05      	ldr	r2, [pc, #20]	; (80a0844 <_ZN5TimerC1EjSt8functionIFvvEEb+0x5c>)
 80a0830:	f104 0008 	add.w	r0, r4, #8
 80a0834:	f004 ff74 	bl	80a5720 <os_timer_create>
    }
 80a0838:	4620      	mov	r0, r4
 80a083a:	b005      	add	sp, #20
 80a083c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a083e:	bf00      	nop
 80a0840:	080a96dc 	.word	0x080a96dc
 80a0844:	080a06a9 	.word	0x080a06a9

080a0848 <_ZN5Timer5_stopEjb>:
    bool _stop(unsigned block, bool fromISR=false)
 80a0848:	b507      	push	{r0, r1, r2, lr}
        return handle ? !os_timer_change(handle, OS_TIMER_CHANGE_STOP, fromISR, 0, block, nullptr) : false;
 80a084a:	6880      	ldr	r0, [r0, #8]
 80a084c:	2300      	movs	r3, #0
 80a084e:	b138      	cbz	r0, 80a0860 <_ZN5Timer5_stopEjb+0x18>
 80a0850:	e9cd 1300 	strd	r1, r3, [sp]
 80a0854:	2102      	movs	r1, #2
 80a0856:	f004 ff7b 	bl	80a5750 <os_timer_change>
 80a085a:	fab0 f080 	clz	r0, r0
 80a085e:	0940      	lsrs	r0, r0, #5
    }
 80a0860:	b003      	add	sp, #12
 80a0862:	f85d fb04 	ldr.w	pc, [sp], #4

080a0866 <_ZN5Timer6_startEjb>:
    bool _start(unsigned block, bool fromISR=false)
 80a0866:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80a0868:	4614      	mov	r4, r2
 80a086a:	4606      	mov	r6, r0
 80a086c:	460d      	mov	r5, r1
    bool stop(unsigned block=default_wait) { return _stop(block, false); }
 80a086e:	2200      	movs	r2, #0
 80a0870:	4621      	mov	r1, r4
 80a0872:	f7ff ffe9 	bl	80a0848 <_ZN5Timer5_stopEjb>
        return handle ? !os_timer_change(handle, OS_TIMER_CHANGE_START, fromISR, 0, block, nullptr) : false;
 80a0876:	68b0      	ldr	r0, [r6, #8]
 80a0878:	2300      	movs	r3, #0
 80a087a:	b140      	cbz	r0, 80a088e <_ZN5Timer6_startEjb+0x28>
 80a087c:	4622      	mov	r2, r4
 80a087e:	4619      	mov	r1, r3
 80a0880:	e9cd 5300 	strd	r5, r3, [sp]
 80a0884:	f004 ff64 	bl	80a5750 <os_timer_change>
 80a0888:	fab0 f080 	clz	r0, r0
 80a088c:	0940      	lsrs	r0, r0, #5
    }
 80a088e:	b002      	add	sp, #8
 80a0890:	bd70      	pop	{r4, r5, r6, pc}
	...

080a0894 <_ZN5TimerD1Ev>:
    virtual ~Timer() {
 80a0894:	b538      	push	{r3, r4, r5, lr}
 80a0896:	4b10      	ldr	r3, [pc, #64]	; (80a08d8 <_ZN5TimerD1Ev+0x44>)
 80a0898:	4604      	mov	r4, r0
 80a089a:	6003      	str	r3, [r0, #0]
        if (handle) {
 80a089c:	6883      	ldr	r3, [r0, #8]
 80a089e:	b1a3      	cbz	r3, 80a08ca <_ZN5TimerD1Ev+0x36>
    bool stop(unsigned block=default_wait) { return _stop(block, false); }
 80a08a0:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 80a08a4:	2200      	movs	r2, #0
 80a08a6:	f7ff ffcf 	bl	80a0848 <_ZN5Timer5_stopEjb>
            os_timer_set_id(handle, nullptr);
 80a08aa:	2100      	movs	r1, #0
 80a08ac:	68a0      	ldr	r0, [r4, #8]
 80a08ae:	f004 ff77 	bl	80a57a0 <os_timer_set_id>
            while (running) {
 80a08b2:	7923      	ldrb	r3, [r4, #4]
 80a08b4:	f003 05ff 	and.w	r5, r3, #255	; 0xff
 80a08b8:	b113      	cbz	r3, 80a08c0 <_ZN5TimerD1Ev+0x2c>
                os_thread_yield();
 80a08ba:	f004 ff21 	bl	80a5700 <os_thread_yield>
            while (running) {
 80a08be:	e7f8      	b.n	80a08b2 <_ZN5TimerD1Ev+0x1e>
            os_timer_destroy(handle, nullptr);
 80a08c0:	4629      	mov	r1, r5
 80a08c2:	68a0      	ldr	r0, [r4, #8]
 80a08c4:	f004 ff34 	bl	80a5730 <os_timer_destroy>
            handle = nullptr;
 80a08c8:	60a5      	str	r5, [r4, #8]
    class function<_Res(_ArgTypes...)>
 80a08ca:	f104 000c 	add.w	r0, r4, #12
 80a08ce:	f7ff ff82 	bl	80a07d6 <_ZNSt14_Function_baseD1Ev>
    }
 80a08d2:	4620      	mov	r0, r4
 80a08d4:	bd38      	pop	{r3, r4, r5, pc}
 80a08d6:	bf00      	nop
 80a08d8:	080a96dc 	.word	0x080a96dc

080a08dc <_ZN5TimerD0Ev>:
    virtual ~Timer() {
 80a08dc:	b510      	push	{r4, lr}
 80a08de:	4604      	mov	r4, r0
    }
 80a08e0:	f7ff ffd8 	bl	80a0894 <_ZN5TimerD1Ev>
 80a08e4:	4620      	mov	r0, r4
 80a08e6:	211c      	movs	r1, #28
 80a08e8:	f006 fe93 	bl	80a7612 <_ZdlPvj>
 80a08ec:	4620      	mov	r0, r4
 80a08ee:	bd10      	pop	{r4, pc}

080a08f0 <_ZN9HMIScreenC1Ev>:
/*
class: HMIScreen
description: Allows me to deal with interactions with the Human machine interace.

*/
struct HMIScreen{
 80a08f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a08f4:	2500      	movs	r5, #0
 80a08f6:	4680      	mov	r8, r0
 80a08f8:	4604      	mov	r4, r0
 80a08fa:	b08d      	sub	sp, #52	; 0x34
 80a08fc:	f828 5b04 	strh.w	r5, [r8], #4
 80a0900:	4629      	mov	r1, r5
 80a0902:	2203      	movs	r2, #3
 80a0904:	4640      	mov	r0, r8
 80a0906:	4bc9      	ldr	r3, [pc, #804]	; (80a0c2c <_ZN9HMIScreenC1Ev+0x33c>)
 80a0908:	9500      	str	r5, [sp, #0]
 80a090a:	f001 fad3 	bl	80a1eb4 <_ZN9NexButtonC1EhhPKcPv>
 80a090e:	f104 0328 	add.w	r3, r4, #40	; 0x28
 80a0912:	9303      	str	r3, [sp, #12]
 80a0914:	4629      	mov	r1, r5
 80a0916:	2205      	movs	r2, #5
 80a0918:	4bc5      	ldr	r3, [pc, #788]	; (80a0c30 <_ZN9HMIScreenC1Ev+0x340>)
 80a091a:	9803      	ldr	r0, [sp, #12]
 80a091c:	9500      	str	r5, [sp, #0]
 80a091e:	f001 fac9 	bl	80a1eb4 <_ZN9NexButtonC1EhhPKcPv>
 80a0922:	2201      	movs	r2, #1
 80a0924:	f104 034c 	add.w	r3, r4, #76	; 0x4c
 80a0928:	9304      	str	r3, [sp, #16]
 80a092a:	4611      	mov	r1, r2
 80a092c:	4bc1      	ldr	r3, [pc, #772]	; (80a0c34 <_ZN9HMIScreenC1Ev+0x344>)
 80a092e:	9804      	ldr	r0, [sp, #16]
 80a0930:	9500      	str	r5, [sp, #0]
 80a0932:	f001 fabf 	bl	80a1eb4 <_ZN9NexButtonC1EhhPKcPv>
 80a0936:	f104 0370 	add.w	r3, r4, #112	; 0x70
 80a093a:	9305      	str	r3, [sp, #20]
 80a093c:	2201      	movs	r2, #1
 80a093e:	2103      	movs	r1, #3
 80a0940:	4bbd      	ldr	r3, [pc, #756]	; (80a0c38 <_ZN9HMIScreenC1Ev+0x348>)
 80a0942:	9805      	ldr	r0, [sp, #20]
 80a0944:	9500      	str	r5, [sp, #0]
 80a0946:	f001 fab5 	bl	80a1eb4 <_ZN9NexButtonC1EhhPKcPv>
 80a094a:	2202      	movs	r2, #2
 80a094c:	2104      	movs	r1, #4
 80a094e:	4bbb      	ldr	r3, [pc, #748]	; (80a0c3c <_ZN9HMIScreenC1Ev+0x34c>)
 80a0950:	9500      	str	r5, [sp, #0]
 80a0952:	f104 0094 	add.w	r0, r4, #148	; 0x94
 80a0956:	f001 fab6 	bl	80a1ec6 <_ZN14NexProgressBarC1EhhPKcPv>
 80a095a:	2203      	movs	r2, #3
 80a095c:	2104      	movs	r1, #4
 80a095e:	4bb8      	ldr	r3, [pc, #736]	; (80a0c40 <_ZN9HMIScreenC1Ev+0x350>)
 80a0960:	9500      	str	r5, [sp, #0]
 80a0962:	f104 00a0 	add.w	r0, r4, #160	; 0xa0
 80a0966:	f001 f852 	bl	80a1a0e <_ZN7NexTextC1EhhPKcPv>
 80a096a:	4629      	mov	r1, r5
 80a096c:	2206      	movs	r2, #6
 80a096e:	4bb5      	ldr	r3, [pc, #724]	; (80a0c44 <_ZN9HMIScreenC1Ev+0x354>)
 80a0970:	9500      	str	r5, [sp, #0]
 80a0972:	f104 00c4 	add.w	r0, r4, #196	; 0xc4
 80a0976:	f001 f84a 	bl	80a1a0e <_ZN7NexTextC1EhhPKcPv>
 80a097a:	f104 03e8 	add.w	r3, r4, #232	; 0xe8
 80a097e:	9306      	str	r3, [sp, #24]
 80a0980:	f8df a348 	ldr.w	sl, [pc, #840]	; 80a0ccc <_ZN9HMIScreenC1Ev+0x3dc>
 80a0984:	4629      	mov	r1, r5
 80a0986:	2202      	movs	r2, #2
 80a0988:	4baf      	ldr	r3, [pc, #700]	; (80a0c48 <_ZN9HMIScreenC1Ev+0x358>)
 80a098a:	9806      	ldr	r0, [sp, #24]
 80a098c:	9500      	str	r5, [sp, #0]
 80a098e:	f001 fa91 	bl	80a1eb4 <_ZN9NexButtonC1EhhPKcPv>
 80a0992:	4653      	mov	r3, sl
 80a0994:	2201      	movs	r2, #1
 80a0996:	2111      	movs	r1, #17
 80a0998:	9500      	str	r5, [sp, #0]
 80a099a:	f504 7086 	add.w	r0, r4, #268	; 0x10c
 80a099e:	f001 f836 	bl	80a1a0e <_ZN7NexTextC1EhhPKcPv>
 80a09a2:	2201      	movs	r2, #1
 80a09a4:	210e      	movs	r1, #14
 80a09a6:	4ba9      	ldr	r3, [pc, #676]	; (80a0c4c <_ZN9HMIScreenC1Ev+0x35c>)
 80a09a8:	9500      	str	r5, [sp, #0]
 80a09aa:	f504 7098 	add.w	r0, r4, #304	; 0x130
 80a09ae:	f001 f82e 	bl	80a1a0e <_ZN7NexTextC1EhhPKcPv>
 80a09b2:	f504 73aa 	add.w	r3, r4, #340	; 0x154
 80a09b6:	9307      	str	r3, [sp, #28]
 80a09b8:	2201      	movs	r2, #1
 80a09ba:	2117      	movs	r1, #23
 80a09bc:	4ba4      	ldr	r3, [pc, #656]	; (80a0c50 <_ZN9HMIScreenC1Ev+0x360>)
 80a09be:	9807      	ldr	r0, [sp, #28]
 80a09c0:	9500      	str	r5, [sp, #0]
 80a09c2:	f001 fa77 	bl	80a1eb4 <_ZN9NexButtonC1EhhPKcPv>
 80a09c6:	f504 73bc 	add.w	r3, r4, #376	; 0x178
 80a09ca:	9308      	str	r3, [sp, #32]
 80a09cc:	2203      	movs	r2, #3
 80a09ce:	2117      	movs	r1, #23
 80a09d0:	4ba0      	ldr	r3, [pc, #640]	; (80a0c54 <_ZN9HMIScreenC1Ev+0x364>)
 80a09d2:	9808      	ldr	r0, [sp, #32]
 80a09d4:	9500      	str	r5, [sp, #0]
 80a09d6:	f001 fa6d 	bl	80a1eb4 <_ZN9NexButtonC1EhhPKcPv>
 80a09da:	4f9f      	ldr	r7, [pc, #636]	; (80a0c58 <_ZN9HMIScreenC1Ev+0x368>)
 80a09dc:	f504 73ce 	add.w	r3, r4, #412	; 0x19c
 80a09e0:	9309      	str	r3, [sp, #36]	; 0x24
 80a09e2:	2204      	movs	r2, #4
 80a09e4:	463b      	mov	r3, r7
 80a09e6:	2117      	movs	r1, #23
 80a09e8:	9809      	ldr	r0, [sp, #36]	; 0x24
 80a09ea:	9500      	str	r5, [sp, #0]
 80a09ec:	f001 fa62 	bl	80a1eb4 <_ZN9NexButtonC1EhhPKcPv>
 80a09f0:	4e9a      	ldr	r6, [pc, #616]	; (80a0c5c <_ZN9HMIScreenC1Ev+0x36c>)
 80a09f2:	f504 73e0 	add.w	r3, r4, #448	; 0x1c0
 80a09f6:	930a      	str	r3, [sp, #40]	; 0x28
 80a09f8:	2205      	movs	r2, #5
 80a09fa:	4633      	mov	r3, r6
 80a09fc:	2117      	movs	r1, #23
 80a09fe:	980a      	ldr	r0, [sp, #40]	; 0x28
 80a0a00:	9500      	str	r5, [sp, #0]
 80a0a02:	f001 fa57 	bl	80a1eb4 <_ZN9NexButtonC1EhhPKcPv>
 80a0a06:	f504 73f2 	add.w	r3, r4, #484	; 0x1e4
 80a0a0a:	930b      	str	r3, [sp, #44]	; 0x2c
 80a0a0c:	f504 7b02 	add.w	fp, r4, #520	; 0x208
 80a0a10:	2206      	movs	r2, #6
 80a0a12:	2117      	movs	r1, #23
 80a0a14:	4b92      	ldr	r3, [pc, #584]	; (80a0c60 <_ZN9HMIScreenC1Ev+0x370>)
 80a0a16:	980b      	ldr	r0, [sp, #44]	; 0x2c
 80a0a18:	9500      	str	r5, [sp, #0]
 80a0a1a:	f001 fa4b 	bl	80a1eb4 <_ZN9NexButtonC1EhhPKcPv>
 80a0a1e:	f504 790b 	add.w	r9, r4, #556	; 0x22c
 80a0a22:	2207      	movs	r2, #7
 80a0a24:	2117      	movs	r1, #23
 80a0a26:	4658      	mov	r0, fp
 80a0a28:	4b8e      	ldr	r3, [pc, #568]	; (80a0c64 <_ZN9HMIScreenC1Ev+0x374>)
 80a0a2a:	9500      	str	r5, [sp, #0]
 80a0a2c:	f001 fa42 	bl	80a1eb4 <_ZN9NexButtonC1EhhPKcPv>
 80a0a30:	2226      	movs	r2, #38	; 0x26
 80a0a32:	2116      	movs	r1, #22
 80a0a34:	4648      	mov	r0, r9
 80a0a36:	4b8c      	ldr	r3, [pc, #560]	; (80a0c68 <_ZN9HMIScreenC1Ev+0x378>)
 80a0a38:	9500      	str	r5, [sp, #0]
 80a0a3a:	f001 fa3b 	bl	80a1eb4 <_ZN9NexButtonC1EhhPKcPv>
 80a0a3e:	2202      	movs	r2, #2
 80a0a40:	2116      	movs	r1, #22
 80a0a42:	4b8a      	ldr	r3, [pc, #552]	; (80a0c6c <_ZN9HMIScreenC1Ev+0x37c>)
 80a0a44:	9500      	str	r5, [sp, #0]
 80a0a46:	f504 7014 	add.w	r0, r4, #592	; 0x250
 80a0a4a:	f000 ffe0 	bl	80a1a0e <_ZN7NexTextC1EhhPKcPv>
 80a0a4e:	4653      	mov	r3, sl
 80a0a50:	2228      	movs	r2, #40	; 0x28
 80a0a52:	2116      	movs	r1, #22
 80a0a54:	9500      	str	r5, [sp, #0]
 80a0a56:	f504 701d 	add.w	r0, r4, #628	; 0x274
 80a0a5a:	f000 ffd8 	bl	80a1a0e <_ZN7NexTextC1EhhPKcPv>
 80a0a5e:	4629      	mov	r1, r5
 80a0a60:	22c0      	movs	r2, #192	; 0xc0
 80a0a62:	f504 7026 	add.w	r0, r4, #664	; 0x298
 80a0a66:	f007 ff3f 	bl	80a88e8 <memset>
 80a0a6a:	463b      	mov	r3, r7
 80a0a6c:	2205      	movs	r2, #5
 80a0a6e:	2101      	movs	r1, #1
 80a0a70:	9500      	str	r5, [sp, #0]
 80a0a72:	f504 7056 	add.w	r0, r4, #856	; 0x358
 80a0a76:	f001 fa1d 	bl	80a1eb4 <_ZN9NexButtonC1EhhPKcPv>
 80a0a7a:	4633      	mov	r3, r6
 80a0a7c:	2206      	movs	r2, #6
 80a0a7e:	2101      	movs	r1, #1
 80a0a80:	9500      	str	r5, [sp, #0]
 80a0a82:	f504 705f 	add.w	r0, r4, #892	; 0x37c
 80a0a86:	f001 fa15 	bl	80a1eb4 <_ZN9NexButtonC1EhhPKcPv>
 80a0a8a:	220c      	movs	r2, #12
 80a0a8c:	2101      	movs	r1, #1
 80a0a8e:	4b78      	ldr	r3, [pc, #480]	; (80a0c70 <_ZN9HMIScreenC1Ev+0x380>)
 80a0a90:	9500      	str	r5, [sp, #0]
 80a0a92:	f504 7068 	add.w	r0, r4, #928	; 0x3a0
 80a0a96:	f001 fa0d 	bl	80a1eb4 <_ZN9NexButtonC1EhhPKcPv>
 80a0a9a:	f504 7a7a 	add.w	sl, r4, #1000	; 0x3e8
 80a0a9e:	220d      	movs	r2, #13
 80a0aa0:	2101      	movs	r1, #1
 80a0aa2:	4b74      	ldr	r3, [pc, #464]	; (80a0c74 <_ZN9HMIScreenC1Ev+0x384>)
 80a0aa4:	9500      	str	r5, [sp, #0]
 80a0aa6:	f504 7071 	add.w	r0, r4, #964	; 0x3c4
 80a0aaa:	f001 fa03 	bl	80a1eb4 <_ZN9NexButtonC1EhhPKcPv>
 80a0aae:	220b      	movs	r2, #11
 80a0ab0:	2101      	movs	r1, #1
 80a0ab2:	4650      	mov	r0, sl
 80a0ab4:	4b70      	ldr	r3, [pc, #448]	; (80a0c78 <_ZN9HMIScreenC1Ev+0x388>)
 80a0ab6:	9500      	str	r5, [sp, #0]
 80a0ab8:	f001 f9fc 	bl	80a1eb4 <_ZN9NexButtonC1EhhPKcPv>
 80a0abc:	2201      	movs	r2, #1
 80a0abe:	210b      	movs	r1, #11
 80a0ac0:	4b6e      	ldr	r3, [pc, #440]	; (80a0c7c <_ZN9HMIScreenC1Ev+0x38c>)
 80a0ac2:	9500      	str	r5, [sp, #0]
 80a0ac4:	f204 400c 	addw	r0, r4, #1036	; 0x40c
 80a0ac8:	f001 f9f4 	bl	80a1eb4 <_ZN9NexButtonC1EhhPKcPv>
 80a0acc:	2202      	movs	r2, #2
 80a0ace:	210b      	movs	r1, #11
 80a0ad0:	4b6b      	ldr	r3, [pc, #428]	; (80a0c80 <_ZN9HMIScreenC1Ev+0x390>)
 80a0ad2:	9500      	str	r5, [sp, #0]
 80a0ad4:	f504 6086 	add.w	r0, r4, #1072	; 0x430
 80a0ad8:	f001 f9ec 	bl	80a1eb4 <_ZN9NexButtonC1EhhPKcPv>
 80a0adc:	2203      	movs	r2, #3
 80a0ade:	210b      	movs	r1, #11
 80a0ae0:	4b68      	ldr	r3, [pc, #416]	; (80a0c84 <_ZN9HMIScreenC1Ev+0x394>)
 80a0ae2:	9500      	str	r5, [sp, #0]
 80a0ae4:	f204 4054 	addw	r0, r4, #1108	; 0x454
 80a0ae8:	f001 f9e4 	bl	80a1eb4 <_ZN9NexButtonC1EhhPKcPv>
 80a0aec:	2204      	movs	r2, #4
 80a0aee:	210b      	movs	r1, #11
 80a0af0:	4b65      	ldr	r3, [pc, #404]	; (80a0c88 <_ZN9HMIScreenC1Ev+0x398>)
 80a0af2:	9500      	str	r5, [sp, #0]
 80a0af4:	f504 608f 	add.w	r0, r4, #1144	; 0x478
 80a0af8:	f001 f9dc 	bl	80a1eb4 <_ZN9NexButtonC1EhhPKcPv>
 80a0afc:	2205      	movs	r2, #5
 80a0afe:	210b      	movs	r1, #11
 80a0b00:	4b62      	ldr	r3, [pc, #392]	; (80a0c8c <_ZN9HMIScreenC1Ev+0x39c>)
 80a0b02:	9500      	str	r5, [sp, #0]
 80a0b04:	f204 409c 	addw	r0, r4, #1180	; 0x49c
 80a0b08:	f001 f9d4 	bl	80a1eb4 <_ZN9NexButtonC1EhhPKcPv>
 80a0b0c:	2206      	movs	r2, #6
 80a0b0e:	210b      	movs	r1, #11
 80a0b10:	4b5f      	ldr	r3, [pc, #380]	; (80a0c90 <_ZN9HMIScreenC1Ev+0x3a0>)
 80a0b12:	9500      	str	r5, [sp, #0]
 80a0b14:	f504 6098 	add.w	r0, r4, #1216	; 0x4c0
 80a0b18:	f001 f9cc 	bl	80a1eb4 <_ZN9NexButtonC1EhhPKcPv>
 80a0b1c:	2207      	movs	r2, #7
 80a0b1e:	210b      	movs	r1, #11
 80a0b20:	4b5c      	ldr	r3, [pc, #368]	; (80a0c94 <_ZN9HMIScreenC1Ev+0x3a4>)
 80a0b22:	9500      	str	r5, [sp, #0]
 80a0b24:	f204 40e4 	addw	r0, r4, #1252	; 0x4e4
 80a0b28:	f001 f9c4 	bl	80a1eb4 <_ZN9NexButtonC1EhhPKcPv>
 80a0b2c:	2208      	movs	r2, #8
 80a0b2e:	210b      	movs	r1, #11
 80a0b30:	4b59      	ldr	r3, [pc, #356]	; (80a0c98 <_ZN9HMIScreenC1Ev+0x3a8>)
 80a0b32:	9500      	str	r5, [sp, #0]
 80a0b34:	f504 60a1 	add.w	r0, r4, #1288	; 0x508
 80a0b38:	f001 f9bc 	bl	80a1eb4 <_ZN9NexButtonC1EhhPKcPv>
 80a0b3c:	2201      	movs	r2, #1
 80a0b3e:	210c      	movs	r1, #12
 80a0b40:	4b56      	ldr	r3, [pc, #344]	; (80a0c9c <_ZN9HMIScreenC1Ev+0x3ac>)
 80a0b42:	9500      	str	r5, [sp, #0]
 80a0b44:	f204 502c 	addw	r0, r4, #1324	; 0x52c
 80a0b48:	f001 f9b4 	bl	80a1eb4 <_ZN9NexButtonC1EhhPKcPv>
 80a0b4c:	2202      	movs	r2, #2
 80a0b4e:	210c      	movs	r1, #12
 80a0b50:	4b53      	ldr	r3, [pc, #332]	; (80a0ca0 <_ZN9HMIScreenC1Ev+0x3b0>)
 80a0b52:	9500      	str	r5, [sp, #0]
 80a0b54:	f504 60aa 	add.w	r0, r4, #1360	; 0x550
 80a0b58:	f001 f9ac 	bl	80a1eb4 <_ZN9NexButtonC1EhhPKcPv>
 80a0b5c:	2203      	movs	r2, #3
 80a0b5e:	210c      	movs	r1, #12
 80a0b60:	4b50      	ldr	r3, [pc, #320]	; (80a0ca4 <_ZN9HMIScreenC1Ev+0x3b4>)
 80a0b62:	9500      	str	r5, [sp, #0]
 80a0b64:	f204 5074 	addw	r0, r4, #1396	; 0x574
 80a0b68:	f001 f9a4 	bl	80a1eb4 <_ZN9NexButtonC1EhhPKcPv>
 80a0b6c:	2204      	movs	r2, #4
 80a0b6e:	210c      	movs	r1, #12
 80a0b70:	4b4d      	ldr	r3, [pc, #308]	; (80a0ca8 <_ZN9HMIScreenC1Ev+0x3b8>)
 80a0b72:	9500      	str	r5, [sp, #0]
 80a0b74:	f504 60b3 	add.w	r0, r4, #1432	; 0x598
 80a0b78:	f001 f99c 	bl	80a1eb4 <_ZN9NexButtonC1EhhPKcPv>
 80a0b7c:	4e4b      	ldr	r6, [pc, #300]	; (80a0cac <_ZN9HMIScreenC1Ev+0x3bc>)
 80a0b7e:	2205      	movs	r2, #5
 80a0b80:	210c      	movs	r1, #12
 80a0b82:	4b4b      	ldr	r3, [pc, #300]	; (80a0cb0 <_ZN9HMIScreenC1Ev+0x3c0>)
 80a0b84:	9500      	str	r5, [sp, #0]
 80a0b86:	f204 50bc 	addw	r0, r4, #1468	; 0x5bc
 80a0b8a:	f001 f993 	bl	80a1eb4 <_ZN9NexButtonC1EhhPKcPv>
 80a0b8e:	2206      	movs	r2, #6
 80a0b90:	210c      	movs	r1, #12
 80a0b92:	4b48      	ldr	r3, [pc, #288]	; (80a0cb4 <_ZN9HMIScreenC1Ev+0x3c4>)
 80a0b94:	9500      	str	r5, [sp, #0]
 80a0b96:	f504 60bc 	add.w	r0, r4, #1504	; 0x5e0
 80a0b9a:	f001 f98b 	bl	80a1eb4 <_ZN9NexButtonC1EhhPKcPv>
 80a0b9e:	4633      	mov	r3, r6
 80a0ba0:	2207      	movs	r2, #7
 80a0ba2:	210c      	movs	r1, #12
 80a0ba4:	9500      	str	r5, [sp, #0]
 80a0ba6:	f204 6004 	addw	r0, r4, #1540	; 0x604
 80a0baa:	f001 f955 	bl	80a1e58 <_ZN9NexSliderC1EhhPKcPv>
 80a0bae:	4633      	mov	r3, r6
 80a0bb0:	2208      	movs	r2, #8
 80a0bb2:	210c      	movs	r1, #12
 80a0bb4:	9500      	str	r5, [sp, #0]
 80a0bb6:	f504 60c5 	add.w	r0, r4, #1576	; 0x628
 80a0bba:	f001 f94d 	bl	80a1e58 <_ZN9NexSliderC1EhhPKcPv>
 80a0bbe:	4633      	mov	r3, r6
 80a0bc0:	2209      	movs	r2, #9
 80a0bc2:	4e3d      	ldr	r6, [pc, #244]	; (80a0cb8 <_ZN9HMIScreenC1Ev+0x3c8>)
 80a0bc4:	210c      	movs	r1, #12
 80a0bc6:	9500      	str	r5, [sp, #0]
 80a0bc8:	f204 604c 	addw	r0, r4, #1612	; 0x64c
 80a0bcc:	f001 f944 	bl	80a1e58 <_ZN9NexSliderC1EhhPKcPv>
 80a0bd0:	2201      	movs	r2, #1
 80a0bd2:	210f      	movs	r1, #15
 80a0bd4:	4b39      	ldr	r3, [pc, #228]	; (80a0cbc <_ZN9HMIScreenC1Ev+0x3cc>)
 80a0bd6:	9500      	str	r5, [sp, #0]
 80a0bd8:	f504 60ce 	add.w	r0, r4, #1648	; 0x670
 80a0bdc:	f001 f982 	bl	80a1ee4 <_ZN8NexGaugeC1EhhPKcPv>
 80a0be0:	4633      	mov	r3, r6
 80a0be2:	2204      	movs	r2, #4
 80a0be4:	210f      	movs	r1, #15
 80a0be6:	9500      	str	r5, [sp, #0]
 80a0be8:	f204 607c 	addw	r0, r4, #1660	; 0x67c
 80a0bec:	f000 ff0f 	bl	80a1a0e <_ZN7NexTextC1EhhPKcPv>
 80a0bf0:	2203      	movs	r2, #3
 80a0bf2:	210f      	movs	r1, #15
 80a0bf4:	4b32      	ldr	r3, [pc, #200]	; (80a0cc0 <_ZN9HMIScreenC1Ev+0x3d0>)
 80a0bf6:	9500      	str	r5, [sp, #0]
 80a0bf8:	f504 60d4 	add.w	r0, r4, #1696	; 0x6a0
 80a0bfc:	f001 f972 	bl	80a1ee4 <_ZN8NexGaugeC1EhhPKcPv>
 80a0c00:	4633      	mov	r3, r6
 80a0c02:	2205      	movs	r2, #5
 80a0c04:	210f      	movs	r1, #15
 80a0c06:	9500      	str	r5, [sp, #0]
 80a0c08:	f204 60ac 	addw	r0, r4, #1708	; 0x6ac
 80a0c0c:	4f2d      	ldr	r7, [pc, #180]	; (80a0cc4 <_ZN9HMIScreenC1Ev+0x3d4>)
 80a0c0e:	f000 fefe 	bl	80a1a0e <_ZN7NexTextC1EhhPKcPv>
 80a0c12:	2202      	movs	r2, #2
 80a0c14:	210f      	movs	r1, #15
 80a0c16:	4b2c      	ldr	r3, [pc, #176]	; (80a0cc8 <_ZN9HMIScreenC1Ev+0x3d8>)
 80a0c18:	9500      	str	r5, [sp, #0]
 80a0c1a:	f504 60da 	add.w	r0, r4, #1744	; 0x6d0
 80a0c1e:	f001 f961 	bl	80a1ee4 <_ZN8NexGaugeC1EhhPKcPv>
 80a0c22:	4633      	mov	r3, r6
 80a0c24:	2206      	movs	r2, #6
 80a0c26:	210f      	movs	r1, #15
 80a0c28:	9500      	str	r5, [sp, #0]
 80a0c2a:	e051      	b.n	80a0cd0 <_ZN9HMIScreenC1Ev+0x3e0>
 80a0c2c:	080a950b 	.word	0x080a950b
 80a0c30:	080a950e 	.word	0x080a950e
 80a0c34:	080a9511 	.word	0x080a9511
 80a0c38:	080a951c 	.word	0x080a951c
 80a0c3c:	080a9529 	.word	0x080a9529
 80a0c40:	080a952c 	.word	0x080a952c
 80a0c44:	080a9534 	.word	0x080a9534
 80a0c48:	080a9537 	.word	0x080a9537
 80a0c4c:	080a953d 	.word	0x080a953d
 80a0c50:	080a9557 	.word	0x080a9557
 80a0c54:	080a9543 	.word	0x080a9543
 80a0c58:	080a9546 	.word	0x080a9546
 80a0c5c:	080a9549 	.word	0x080a9549
 80a0c60:	080a954c 	.word	0x080a954c
 80a0c64:	080a954f 	.word	0x080a954f
 80a0c68:	080a9552 	.word	0x080a9552
 80a0c6c:	080a9556 	.word	0x080a9556
 80a0c70:	080a955a 	.word	0x080a955a
 80a0c74:	080a955d 	.word	0x080a955d
 80a0c78:	080a9561 	.word	0x080a9561
 80a0c7c:	080a9564 	.word	0x080a9564
 80a0c80:	080a956f 	.word	0x080a956f
 80a0c84:	080a957a 	.word	0x080a957a
 80a0c88:	080a9585 	.word	0x080a9585
 80a0c8c:	080a9590 	.word	0x080a9590
 80a0c90:	080a959b 	.word	0x080a959b
 80a0c94:	080a95a6 	.word	0x080a95a6
 80a0c98:	080a95b1 	.word	0x080a95b1
 80a0c9c:	080a95bc 	.word	0x080a95bc
 80a0ca0:	080a95c7 	.word	0x080a95c7
 80a0ca4:	080a95d2 	.word	0x080a95d2
 80a0ca8:	080a95dd 	.word	0x080a95dd
 80a0cac:	080a95fe 	.word	0x080a95fe
 80a0cb0:	080a95e8 	.word	0x080a95e8
 80a0cb4:	080a95f3 	.word	0x080a95f3
 80a0cb8:	080a960d 	.word	0x080a960d
 80a0cbc:	080a960a 	.word	0x080a960a
 80a0cc0:	080a9610 	.word	0x080a9610
 80a0cc4:	080a9616 	.word	0x080a9616
 80a0cc8:	080a9613 	.word	0x080a9613
 80a0ccc:	080a953a 	.word	0x080a953a
 80a0cd0:	f204 60dc 	addw	r0, r4, #1756	; 0x6dc
 80a0cd4:	f000 fe9b 	bl	80a1a0e <_ZN7NexTextC1EhhPKcPv>
 80a0cd8:	463b      	mov	r3, r7
 80a0cda:	2207      	movs	r2, #7
 80a0cdc:	210f      	movs	r1, #15
 80a0cde:	f504 60e0 	add.w	r0, r4, #1792	; 0x700
 80a0ce2:	f001 f8de 	bl	80a1ea2 <_ZN9NexNumberC1EhhPKc>
 80a0ce6:	4633      	mov	r3, r6
 80a0ce8:	2208      	movs	r2, #8
 80a0cea:	210f      	movs	r1, #15
 80a0cec:	9500      	str	r5, [sp, #0]
 80a0cee:	f204 7024 	addw	r0, r4, #1828	; 0x724
 80a0cf2:	f000 fe8c 	bl	80a1a0e <_ZN7NexTextC1EhhPKcPv>
 80a0cf6:	2209      	movs	r2, #9
 80a0cf8:	210f      	movs	r1, #15
 80a0cfa:	4b66      	ldr	r3, [pc, #408]	; (80a0e94 <_ZN9HMIScreenC1Ev+0x5a4>)
 80a0cfc:	f504 60e9 	add.w	r0, r4, #1864	; 0x748
 80a0d00:	f001 f8cf 	bl	80a1ea2 <_ZN9NexNumberC1EhhPKc>
 80a0d04:	4633      	mov	r3, r6
 80a0d06:	220a      	movs	r2, #10
 80a0d08:	210f      	movs	r1, #15
 80a0d0a:	9500      	str	r5, [sp, #0]
 80a0d0c:	f204 706c 	addw	r0, r4, #1900	; 0x76c
 80a0d10:	f000 fe7d 	bl	80a1a0e <_ZN7NexTextC1EhhPKcPv>
 80a0d14:	220b      	movs	r2, #11
 80a0d16:	210f      	movs	r1, #15
 80a0d18:	4b5f      	ldr	r3, [pc, #380]	; (80a0e98 <_ZN9HMIScreenC1Ev+0x5a8>)
 80a0d1a:	f504 60f2 	add.w	r0, r4, #1936	; 0x790
 80a0d1e:	f001 f8c0 	bl	80a1ea2 <_ZN9NexNumberC1EhhPKc>
 80a0d22:	4633      	mov	r3, r6
 80a0d24:	220c      	movs	r2, #12
 80a0d26:	210f      	movs	r1, #15
 80a0d28:	9500      	str	r5, [sp, #0]
 80a0d2a:	f204 70b4 	addw	r0, r4, #1972	; 0x7b4
 80a0d2e:	f000 fe6e 	bl	80a1a0e <_ZN7NexTextC1EhhPKcPv>
 80a0d32:	463b      	mov	r3, r7
 80a0d34:	220b      	movs	r2, #11
 80a0d36:	2110      	movs	r1, #16
 80a0d38:	f504 60fb 	add.w	r0, r4, #2008	; 0x7d8
 80a0d3c:	f001 f8b1 	bl	80a1ea2 <_ZN9NexNumberC1EhhPKc>
 80a0d40:	4633      	mov	r3, r6
 80a0d42:	220c      	movs	r2, #12
 80a0d44:	2110      	movs	r1, #16
 80a0d46:	9500      	str	r5, [sp, #0]
 80a0d48:	f204 70fc 	addw	r0, r4, #2044	; 0x7fc
 80a0d4c:	f000 fe5f 	bl	80a1a0e <_ZN7NexTextC1EhhPKcPv>
 80a0d50:	463b      	mov	r3, r7
 80a0d52:	220d      	movs	r2, #13
 80a0d54:	2110      	movs	r1, #16
 80a0d56:	f504 6002 	add.w	r0, r4, #2080	; 0x820
 80a0d5a:	f001 f8a2 	bl	80a1ea2 <_ZN9NexNumberC1EhhPKc>
 80a0d5e:	4633      	mov	r3, r6
 80a0d60:	220e      	movs	r2, #14
 80a0d62:	2110      	movs	r1, #16
 80a0d64:	9500      	str	r5, [sp, #0]
 80a0d66:	f604 0044 	addw	r0, r4, #2116	; 0x844
 80a0d6a:	f000 fe50 	bl	80a1a0e <_ZN7NexTextC1EhhPKcPv>
 80a0d6e:	463b      	mov	r3, r7
 80a0d70:	220f      	movs	r2, #15
 80a0d72:	2110      	movs	r1, #16
 80a0d74:	f604 0068 	addw	r0, r4, #2152	; 0x868
 80a0d78:	f001 f893 	bl	80a1ea2 <_ZN9NexNumberC1EhhPKc>
 80a0d7c:	2210      	movs	r2, #16
 80a0d7e:	4633      	mov	r3, r6
 80a0d80:	4611      	mov	r1, r2
 80a0d82:	9500      	str	r5, [sp, #0]
 80a0d84:	f604 008c 	addw	r0, r4, #2188	; 0x88c
 80a0d88:	f000 fe41 	bl	80a1a0e <_ZN7NexTextC1EhhPKcPv>
 80a0d8c:	463b      	mov	r3, r7
 80a0d8e:	2211      	movs	r2, #17
 80a0d90:	2110      	movs	r1, #16
 80a0d92:	f504 600b 	add.w	r0, r4, #2224	; 0x8b0
 80a0d96:	f001 f884 	bl	80a1ea2 <_ZN9NexNumberC1EhhPKc>
 80a0d9a:	4633      	mov	r3, r6
 80a0d9c:	2212      	movs	r2, #18
 80a0d9e:	2110      	movs	r1, #16
 80a0da0:	9500      	str	r5, [sp, #0]
 80a0da2:	f604 00d4 	addw	r0, r4, #2260	; 0x8d4
 80a0da6:	f000 fe32 	bl	80a1a0e <_ZN7NexTextC1EhhPKcPv>
 80a0daa:	463b      	mov	r3, r7
 80a0dac:	2213      	movs	r2, #19
 80a0dae:	2110      	movs	r1, #16
 80a0db0:	f604 00f8 	addw	r0, r4, #2296	; 0x8f8
 80a0db4:	f001 f875 	bl	80a1ea2 <_ZN9NexNumberC1EhhPKc>
 80a0db8:	4633      	mov	r3, r6
 80a0dba:	2214      	movs	r2, #20
 80a0dbc:	2110      	movs	r1, #16
 80a0dbe:	9500      	str	r5, [sp, #0]
 80a0dc0:	f604 101c 	addw	r0, r4, #2332	; 0x91c
 80a0dc4:	f000 fe23 	bl	80a1a0e <_ZN7NexTextC1EhhPKcPv>
 80a0dc8:	463b      	mov	r3, r7
 80a0dca:	2215      	movs	r2, #21
 80a0dcc:	2110      	movs	r1, #16
 80a0dce:	f504 6014 	add.w	r0, r4, #2368	; 0x940
 80a0dd2:	f001 f866 	bl	80a1ea2 <_ZN9NexNumberC1EhhPKc>
 80a0dd6:	4633      	mov	r3, r6
 80a0dd8:	2216      	movs	r2, #22
 80a0dda:	2110      	movs	r1, #16
 80a0ddc:	9500      	str	r5, [sp, #0]
 80a0dde:	f604 1064 	addw	r0, r4, #2404	; 0x964
 80a0de2:	f000 fe14 	bl	80a1a0e <_ZN7NexTextC1EhhPKcPv>
 80a0de6:	463b      	mov	r3, r7
 80a0de8:	2201      	movs	r2, #1
 80a0dea:	2110      	movs	r1, #16
 80a0dec:	f604 1088 	addw	r0, r4, #2440	; 0x988
 80a0df0:	f001 f857 	bl	80a1ea2 <_ZN9NexNumberC1EhhPKc>
 80a0df4:	4633      	mov	r3, r6
 80a0df6:	2202      	movs	r2, #2
 80a0df8:	2110      	movs	r1, #16
 80a0dfa:	9500      	str	r5, [sp, #0]
 80a0dfc:	f604 10ac 	addw	r0, r4, #2476	; 0x9ac
 80a0e00:	f000 fe05 	bl	80a1a0e <_ZN7NexTextC1EhhPKcPv>
 80a0e04:	463b      	mov	r3, r7
 80a0e06:	2203      	movs	r2, #3
 80a0e08:	2110      	movs	r1, #16
 80a0e0a:	f504 601d 	add.w	r0, r4, #2512	; 0x9d0
 80a0e0e:	f001 f848 	bl	80a1ea2 <_ZN9NexNumberC1EhhPKc>
 80a0e12:	4633      	mov	r3, r6
 80a0e14:	2204      	movs	r2, #4
 80a0e16:	2110      	movs	r1, #16
 80a0e18:	9500      	str	r5, [sp, #0]
 80a0e1a:	f604 10f4 	addw	r0, r4, #2548	; 0x9f4
 80a0e1e:	f000 fdf6 	bl	80a1a0e <_ZN7NexTextC1EhhPKcPv>
 80a0e22:	463b      	mov	r3, r7
 80a0e24:	2205      	movs	r2, #5
 80a0e26:	2110      	movs	r1, #16
 80a0e28:	f604 2018 	addw	r0, r4, #2584	; 0xa18
 80a0e2c:	f001 f839 	bl	80a1ea2 <_ZN9NexNumberC1EhhPKc>
 80a0e30:	4633      	mov	r3, r6
 80a0e32:	2206      	movs	r2, #6
 80a0e34:	2110      	movs	r1, #16
 80a0e36:	9500      	str	r5, [sp, #0]
 80a0e38:	f604 203c 	addw	r0, r4, #2620	; 0xa3c
 80a0e3c:	f000 fde7 	bl	80a1a0e <_ZN7NexTextC1EhhPKcPv>
 80a0e40:	4620      	mov	r0, r4
 80a0e42:	9b07      	ldr	r3, [sp, #28]
 80a0e44:	f8c4 ba74 	str.w	fp, [r4, #2676]	; 0xa74
 80a0e48:	f8c4 3a60 	str.w	r3, [r4, #2656]	; 0xa60
 80a0e4c:	9b08      	ldr	r3, [sp, #32]
 80a0e4e:	f8c4 aa78 	str.w	sl, [r4, #2680]	; 0xa78
 80a0e52:	f8c4 3a64 	str.w	r3, [r4, #2660]	; 0xa64
 80a0e56:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80a0e58:	f8c4 8a80 	str.w	r8, [r4, #2688]	; 0xa80
 80a0e5c:	f8c4 3a68 	str.w	r3, [r4, #2664]	; 0xa68
 80a0e60:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80a0e62:	f8c4 9a90 	str.w	r9, [r4, #2704]	; 0xa90
 80a0e66:	f8c4 3a6c 	str.w	r3, [r4, #2668]	; 0xa6c
 80a0e6a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80a0e6c:	f8c4 5a94 	str.w	r5, [r4, #2708]	; 0xa94
 80a0e70:	f8c4 3a70 	str.w	r3, [r4, #2672]	; 0xa70
 80a0e74:	9b06      	ldr	r3, [sp, #24]
 80a0e76:	f8c4 3a7c 	str.w	r3, [r4, #2684]	; 0xa7c
 80a0e7a:	9b03      	ldr	r3, [sp, #12]
 80a0e7c:	f8c4 3a84 	str.w	r3, [r4, #2692]	; 0xa84
 80a0e80:	9b04      	ldr	r3, [sp, #16]
 80a0e82:	f8c4 3a88 	str.w	r3, [r4, #2696]	; 0xa88
 80a0e86:	9b05      	ldr	r3, [sp, #20]
 80a0e88:	f8c4 3a8c 	str.w	r3, [r4, #2700]	; 0xa8c
 80a0e8c:	b00d      	add	sp, #52	; 0x34
 80a0e8e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a0e92:	bf00      	nop
 80a0e94:	080a9619 	.word	0x080a9619
 80a0e98:	080a961c 	.word	0x080a961c

080a0e9c <_Z4lockv>:
{
 80a0e9c:	b508      	push	{r3, lr}
    lampLight.setLED(false);
 80a0e9e:	2100      	movs	r1, #0
 80a0ea0:	4807      	ldr	r0, [pc, #28]	; (80a0ec0 <_Z4lockv+0x24>)
 80a0ea2:	f000 fcc6 	bl	80a1832 <_ZN8LEDRelay6setLEDEb>
    notifLight.setStrip(240, 0, 0);
 80a0ea6:	2300      	movs	r3, #0
 80a0ea8:	21f0      	movs	r1, #240	; 0xf0
 80a0eaa:	461a      	mov	r2, r3
 80a0eac:	4805      	ldr	r0, [pc, #20]	; (80a0ec4 <_Z4lockv+0x28>)
 80a0eae:	f000 fcd1 	bl	80a1854 <_ZN17notificationLight8setStripEhhh>
    hmiScreen.lock();
 80a0eb2:	4805      	ldr	r0, [pc, #20]	; (80a0ec8 <_Z4lockv+0x2c>)
 80a0eb4:	f000 fc8e 	bl	80a17d4 <_ZN9HMIScreen4lockEv>
    lockStatus.system_locked = true;
 80a0eb8:	2201      	movs	r2, #1
 80a0eba:	4b04      	ldr	r3, [pc, #16]	; (80a0ecc <_Z4lockv+0x30>)
 80a0ebc:	701a      	strb	r2, [r3, #0]
}
 80a0ebe:	bd08      	pop	{r3, pc}
 80a0ec0:	20000c18 	.word	0x20000c18
 80a0ec4:	20000cc4 	.word	0x20000cc4
 80a0ec8:	20000180 	.word	0x20000180
 80a0ecc:	20000c19 	.word	0x20000c19

080a0ed0 <_Z6unlockv>:
{
 80a0ed0:	b510      	push	{r4, lr}
    hmiScreen.wake();
 80a0ed2:	4c07      	ldr	r4, [pc, #28]	; (80a0ef0 <_Z6unlockv+0x20>)
    notifLight.wakeLEDS();
 80a0ed4:	4807      	ldr	r0, [pc, #28]	; (80a0ef4 <_Z6unlockv+0x24>)
 80a0ed6:	f000 fce2 	bl	80a189e <_ZN17notificationLight8wakeLEDSEv>
    hmiScreen.wake();
 80a0eda:	4620      	mov	r0, r4
 80a0edc:	f000 fc5a 	bl	80a1794 <_ZN9HMIScreen4wakeEv>
    hmiScreen.home();
 80a0ee0:	4620      	mov	r0, r4
 80a0ee2:	f000 fc51 	bl	80a1788 <_ZN9HMIScreen4homeEv>
    lockStatus.system_locked = false;
 80a0ee6:	2200      	movs	r2, #0
 80a0ee8:	4b03      	ldr	r3, [pc, #12]	; (80a0ef8 <_Z6unlockv+0x28>)
 80a0eea:	701a      	strb	r2, [r3, #0]
}
 80a0eec:	bd10      	pop	{r4, pc}
 80a0eee:	bf00      	nop
 80a0ef0:	20000180 	.word	0x20000180
 80a0ef4:	20000cc4 	.word	0x20000cc4
 80a0ef8:	20000c19 	.word	0x20000c19

080a0efc <_Z11ms_100_taskv>:
{
 80a0efc:	b573      	push	{r0, r1, r4, r5, r6, lr}
    if (sleepMode.sleep_mode_enabled == false && lockStatus.system_locked == false)
 80a0efe:	4b3f      	ldr	r3, [pc, #252]	; (80a0ffc <_Z11ms_100_taskv+0x100>)
 80a0f00:	781b      	ldrb	r3, [r3, #0]
 80a0f02:	b92b      	cbnz	r3, 80a0f10 <_Z11ms_100_taskv+0x14>
 80a0f04:	4b3e      	ldr	r3, [pc, #248]	; (80a1000 <_Z11ms_100_taskv+0x104>)
 80a0f06:	781b      	ldrb	r3, [r3, #0]
 80a0f08:	b913      	cbnz	r3, 80a0f10 <_Z11ms_100_taskv+0x14>
        notifLight.playWithLEDS();
 80a0f0a:	483e      	ldr	r0, [pc, #248]	; (80a1004 <_Z11ms_100_taskv+0x108>)
 80a0f0c:	f000 fcd1 	bl	80a18b2 <_ZN17notificationLight12playWithLEDSEv>
    if (Udp.parsePacket() > 0)
 80a0f10:	2100      	movs	r1, #0
 80a0f12:	483d      	ldr	r0, [pc, #244]	; (80a1008 <_Z11ms_100_taskv+0x10c>)
 80a0f14:	f005 ffdf 	bl	80a6ed6 <_ZN3UDP11parsePacketEm>
 80a0f18:	2800      	cmp	r0, #0
 80a0f1a:	dd6c      	ble.n	80a0ff6 <_Z11ms_100_taskv+0xfa>
        for (uint8_t i = 0; i < 4; i++)
 80a0f1c:	2400      	movs	r4, #0
            msg[i] = Udp.read();
 80a0f1e:	4e3a      	ldr	r6, [pc, #232]	; (80a1008 <_Z11ms_100_taskv+0x10c>)
 80a0f20:	ad01      	add	r5, sp, #4
 80a0f22:	4630      	mov	r0, r6
 80a0f24:	f005 fdf9 	bl	80a6b1a <_ZN3UDP4readEv>
        for (uint8_t i = 0; i < 4; i++)
 80a0f28:	3401      	adds	r4, #1
 80a0f2a:	b2e4      	uxtb	r4, r4
 80a0f2c:	2c04      	cmp	r4, #4
            msg[i] = Udp.read();
 80a0f2e:	f805 0b01 	strb.w	r0, [r5], #1
        for (uint8_t i = 0; i < 4; i++)
 80a0f32:	d1f6      	bne.n	80a0f22 <_Z11ms_100_taskv+0x26>
        if (msg[0] == 20 && msg[1] == 20 && msg[2] == 30 && msg[3] == 90){
 80a0f34:	f89d 3004 	ldrb.w	r3, [sp, #4]
 80a0f38:	2b14      	cmp	r3, #20
 80a0f3a:	d158      	bne.n	80a0fee <_Z11ms_100_taskv+0xf2>
 80a0f3c:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a0f40:	2b14      	cmp	r3, #20
 80a0f42:	d158      	bne.n	80a0ff6 <_Z11ms_100_taskv+0xfa>
 80a0f44:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a0f48:	2b1e      	cmp	r3, #30
 80a0f4a:	d105      	bne.n	80a0f58 <_Z11ms_100_taskv+0x5c>
 80a0f4c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80a0f50:	2b5a      	cmp	r3, #90	; 0x5a
 80a0f52:	d101      	bne.n	80a0f58 <_Z11ms_100_taskv+0x5c>
            lock();
 80a0f54:	f7ff ffa2 	bl	80a0e9c <_Z4lockv>
        if (msg[0] == 20 && msg[1] == 20 && msg[2] == 30 && msg[3] == 91){
 80a0f58:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a0f5c:	2b1e      	cmp	r3, #30
 80a0f5e:	d14a      	bne.n	80a0ff6 <_Z11ms_100_taskv+0xfa>
 80a0f60:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80a0f64:	2b5b      	cmp	r3, #91	; 0x5b
 80a0f66:	d146      	bne.n	80a0ff6 <_Z11ms_100_taskv+0xfa>
}
 80a0f68:	b002      	add	sp, #8
 80a0f6a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            unlock();
 80a0f6e:	f7ff bfaf 	b.w	80a0ed0 <_Z6unlockv>
        if (msg[0] == 50 && msg[1] == 50 && msg[2] == 30 && msg[3] == 92){
 80a0f72:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a0f76:	2b32      	cmp	r3, #50	; 0x32
 80a0f78:	d13d      	bne.n	80a0ff6 <_Z11ms_100_taskv+0xfa>
 80a0f7a:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a0f7e:	2b1e      	cmp	r3, #30
 80a0f80:	d106      	bne.n	80a0f90 <_Z11ms_100_taskv+0x94>
 80a0f82:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80a0f86:	2b5c      	cmp	r3, #92	; 0x5c
 80a0f88:	d102      	bne.n	80a0f90 <_Z11ms_100_taskv+0x94>
            lampLight.toggle();
 80a0f8a:	4820      	ldr	r0, [pc, #128]	; (80a100c <_Z11ms_100_taskv+0x110>)
 80a0f8c:	f000 fc4a 	bl	80a1824 <_ZN8LEDRelay6toggleEv>
        if (msg[0] == 50 && msg[1] == 50 && msg[2] == 30 && msg[3] == 91){
 80a0f90:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a0f94:	2b1e      	cmp	r3, #30
 80a0f96:	d107      	bne.n	80a0fa8 <_Z11ms_100_taskv+0xac>
 80a0f98:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80a0f9c:	2b5b      	cmp	r3, #91	; 0x5b
 80a0f9e:	d103      	bne.n	80a0fa8 <_Z11ms_100_taskv+0xac>
            lampLight.setLED(true);
 80a0fa0:	2101      	movs	r1, #1
 80a0fa2:	481a      	ldr	r0, [pc, #104]	; (80a100c <_Z11ms_100_taskv+0x110>)
 80a0fa4:	f000 fc45 	bl	80a1832 <_ZN8LEDRelay6setLEDEb>
        if (msg[0] == 50 && msg[1] == 50 && msg[2] == 30 && msg[3] == 90){
 80a0fa8:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a0fac:	2b1e      	cmp	r3, #30
 80a0fae:	d122      	bne.n	80a0ff6 <_Z11ms_100_taskv+0xfa>
 80a0fb0:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80a0fb4:	2b5a      	cmp	r3, #90	; 0x5a
 80a0fb6:	d11e      	bne.n	80a0ff6 <_Z11ms_100_taskv+0xfa>
            lampLight.setLED(false);
 80a0fb8:	2100      	movs	r1, #0
 80a0fba:	4814      	ldr	r0, [pc, #80]	; (80a100c <_Z11ms_100_taskv+0x110>)
}
 80a0fbc:	b002      	add	sp, #8
 80a0fbe:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            lampLight.setLED(false);
 80a0fc2:	f000 bc36 	b.w	80a1832 <_ZN8LEDRelay6setLEDEb>
        if (msg[0] == 12 && msg[1] == 12 && msg[2] == 12 && msg[3] == 12){
 80a0fc6:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a0fca:	2b0c      	cmp	r3, #12
 80a0fcc:	d113      	bne.n	80a0ff6 <_Z11ms_100_taskv+0xfa>
 80a0fce:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a0fd2:	2b0c      	cmp	r3, #12
 80a0fd4:	d10f      	bne.n	80a0ff6 <_Z11ms_100_taskv+0xfa>
 80a0fd6:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80a0fda:	2b0c      	cmp	r3, #12
 80a0fdc:	d10b      	bne.n	80a0ff6 <_Z11ms_100_taskv+0xfa>
            alarmrelay.beepOnce(300);
 80a0fde:	f44f 7196 	mov.w	r1, #300	; 0x12c
 80a0fe2:	480b      	ldr	r0, [pc, #44]	; (80a1010 <_Z11ms_100_taskv+0x114>)
}
 80a0fe4:	b002      	add	sp, #8
 80a0fe6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
            alarmrelay.beepOnce(300);
 80a0fea:	f7ff ba1c 	b.w	80a0426 <_ZN10alarmRelay8beepOnceEi>
        if (msg[0] == 50 && msg[1] == 50 && msg[2] == 30 && msg[3] == 92){
 80a0fee:	2b32      	cmp	r3, #50	; 0x32
 80a0ff0:	d0bf      	beq.n	80a0f72 <_Z11ms_100_taskv+0x76>
        if (msg[0] == 12 && msg[1] == 12 && msg[2] == 12 && msg[3] == 12){
 80a0ff2:	2b0c      	cmp	r3, #12
 80a0ff4:	d0e7      	beq.n	80a0fc6 <_Z11ms_100_taskv+0xca>
}
 80a0ff6:	b002      	add	sp, #8
 80a0ff8:	bd70      	pop	{r4, r5, r6, pc}
 80a0ffa:	bf00      	nop
 80a0ffc:	20000d30 	.word	0x20000d30
 80a1000:	20000c19 	.word	0x20000c19
 80a1004:	20000cc4 	.word	0x20000cc4
 80a1008:	200000d8 	.word	0x200000d8
 80a100c:	20000c18 	.word	0x20000c18
 80a1010:	20000128 	.word	0x20000128

080a1014 <_Z11ms_300_taskv>:
{
 80a1014:	b508      	push	{r3, lr}
    if (cardReader.readCardID())
 80a1016:	480a      	ldr	r0, [pc, #40]	; (80a1040 <_Z11ms_300_taskv+0x2c>)
 80a1018:	f000 fb66 	bl	80a16e8 <_ZN10rfidReader10readCardIDEv>
 80a101c:	b170      	cbz	r0, 80a103c <_Z11ms_300_taskv+0x28>
        lockStatus.system_locked = !lockStatus.system_locked;
 80a101e:	4b09      	ldr	r3, [pc, #36]	; (80a1044 <_Z11ms_300_taskv+0x30>)
 80a1020:	781a      	ldrb	r2, [r3, #0]
 80a1022:	f082 0201 	eor.w	r2, r2, #1
 80a1026:	701a      	strb	r2, [r3, #0]
        if (lockStatus.system_locked)
 80a1028:	781b      	ldrb	r3, [r3, #0]
 80a102a:	b11b      	cbz	r3, 80a1034 <_Z11ms_300_taskv+0x20>
}
 80a102c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            lock();
 80a1030:	f7ff bf34 	b.w	80a0e9c <_Z4lockv>
}
 80a1034:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
            unlock();
 80a1038:	f7ff bf4a 	b.w	80a0ed0 <_Z6unlockv>
}
 80a103c:	bd08      	pop	{r3, pc}
 80a103e:	bf00      	nop
 80a1040:	20000130 	.word	0x20000130
 80a1044:	20000c19 	.word	0x20000c19

080a1048 <_Z16particleCommandsPKcS0_>:
{
 80a1048:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    String buffer = data;
 80a104a:	4668      	mov	r0, sp
 80a104c:	f006 f95b 	bl	80a7306 <_ZN6StringC1EPKc>
    if (buffer.equals("notifoff"))
 80a1050:	4668      	mov	r0, sp
 80a1052:	4936      	ldr	r1, [pc, #216]	; (80a112c <_Z16particleCommandsPKcS0_+0xe4>)
 80a1054:	f006 f984 	bl	80a7360 <_ZNK6String6equalsEPKc>
 80a1058:	b110      	cbz	r0, 80a1060 <_Z16particleCommandsPKcS0_+0x18>
        notifications.enabled = false;
 80a105a:	2200      	movs	r2, #0
 80a105c:	4b34      	ldr	r3, [pc, #208]	; (80a1130 <_Z16particleCommandsPKcS0_+0xe8>)
 80a105e:	701a      	strb	r2, [r3, #0]
    if (buffer.equals("notifon"))
 80a1060:	4668      	mov	r0, sp
 80a1062:	4934      	ldr	r1, [pc, #208]	; (80a1134 <_Z16particleCommandsPKcS0_+0xec>)
 80a1064:	f006 f97c 	bl	80a7360 <_ZNK6String6equalsEPKc>
 80a1068:	b110      	cbz	r0, 80a1070 <_Z16particleCommandsPKcS0_+0x28>
        notifications.enabled = true;
 80a106a:	2201      	movs	r2, #1
 80a106c:	4b30      	ldr	r3, [pc, #192]	; (80a1130 <_Z16particleCommandsPKcS0_+0xe8>)
 80a106e:	701a      	strb	r2, [r3, #0]
    if (buffer.equals("picoff"))
 80a1070:	4931      	ldr	r1, [pc, #196]	; (80a1138 <_Z16particleCommandsPKcS0_+0xf0>)
 80a1072:	4668      	mov	r0, sp
 80a1074:	f006 f974 	bl	80a7360 <_ZNK6String6equalsEPKc>
    if (buffer.equals("picon"))
 80a1078:	4930      	ldr	r1, [pc, #192]	; (80a113c <_Z16particleCommandsPKcS0_+0xf4>)
 80a107a:	4668      	mov	r0, sp
 80a107c:	f006 f970 	bl	80a7360 <_ZNK6String6equalsEPKc>
    if (buffer.equals("beep"))
 80a1080:	4668      	mov	r0, sp
 80a1082:	492f      	ldr	r1, [pc, #188]	; (80a1140 <_Z16particleCommandsPKcS0_+0xf8>)
 80a1084:	f006 f96c 	bl	80a7360 <_ZNK6String6equalsEPKc>
 80a1088:	b118      	cbz	r0, 80a1092 <_Z16particleCommandsPKcS0_+0x4a>
        alarmrelay.beepOnce(200);
 80a108a:	21c8      	movs	r1, #200	; 0xc8
 80a108c:	482d      	ldr	r0, [pc, #180]	; (80a1144 <_Z16particleCommandsPKcS0_+0xfc>)
 80a108e:	f7ff f9ca 	bl	80a0426 <_ZN10alarmRelay8beepOnceEi>
    if (buffer.equals("toggleLED"))
 80a1092:	4668      	mov	r0, sp
 80a1094:	492c      	ldr	r1, [pc, #176]	; (80a1148 <_Z16particleCommandsPKcS0_+0x100>)
 80a1096:	f006 f963 	bl	80a7360 <_ZNK6String6equalsEPKc>
 80a109a:	b110      	cbz	r0, 80a10a2 <_Z16particleCommandsPKcS0_+0x5a>
        lampLight.toggle();
 80a109c:	482b      	ldr	r0, [pc, #172]	; (80a114c <_Z16particleCommandsPKcS0_+0x104>)
 80a109e:	f000 fbc1 	bl	80a1824 <_ZN8LEDRelay6toggleEv>
    if (buffer.equals("reboot"))
 80a10a2:	4668      	mov	r0, sp
 80a10a4:	492a      	ldr	r1, [pc, #168]	; (80a1150 <_Z16particleCommandsPKcS0_+0x108>)
 80a10a6:	f006 f95b 	bl	80a7360 <_ZNK6String6equalsEPKc>
 80a10aa:	b108      	cbz	r0, 80a10b0 <_Z16particleCommandsPKcS0_+0x68>
        System.reset();
 80a10ac:	f006 f9c8 	bl	80a7440 <_ZN11SystemClass5resetEv>
    if (buffer.equals("sleep"))
 80a10b0:	4668      	mov	r0, sp
 80a10b2:	4928      	ldr	r1, [pc, #160]	; (80a1154 <_Z16particleCommandsPKcS0_+0x10c>)
 80a10b4:	f006 f954 	bl	80a7360 <_ZNK6String6equalsEPKc>
 80a10b8:	b190      	cbz	r0, 80a10e0 <_Z16particleCommandsPKcS0_+0x98>
        sleepMode.sleep_mode_enabled = true;
 80a10ba:	2201      	movs	r2, #1
 80a10bc:	4b26      	ldr	r3, [pc, #152]	; (80a1158 <_Z16particleCommandsPKcS0_+0x110>)
        hmiScreen.sleep();
 80a10be:	4827      	ldr	r0, [pc, #156]	; (80a115c <_Z16particleCommandsPKcS0_+0x114>)
        sleepMode.sleep_mode_enabled = true;
 80a10c0:	701a      	strb	r2, [r3, #0]
        hmiScreen.sleep();
 80a10c2:	f000 fb75 	bl	80a17b0 <_ZN9HMIScreen5sleepEv>
        notifLight.setStrip(0, 0, 0);
 80a10c6:	2300      	movs	r3, #0
 80a10c8:	4825      	ldr	r0, [pc, #148]	; (80a1160 <_Z16particleCommandsPKcS0_+0x118>)
 80a10ca:	4619      	mov	r1, r3
 80a10cc:	461a      	mov	r2, r3
 80a10ce:	f000 fbc1 	bl	80a1854 <_ZN17notificationLight8setStripEhhh>
        lampLight.setLED(false);
 80a10d2:	481e      	ldr	r0, [pc, #120]	; (80a114c <_Z16particleCommandsPKcS0_+0x104>)
 80a10d4:	2100      	movs	r1, #0
 80a10d6:	f000 fbac 	bl	80a1832 <_ZN8LEDRelay6setLEDEb>
        clock_control.sleep();
 80a10da:	4822      	ldr	r0, [pc, #136]	; (80a1164 <_Z16particleCommandsPKcS0_+0x11c>)
 80a10dc:	f7ff f936 	bl	80a034c <_ZN12ClockControl5sleepEv>
    if (buffer.equals("wake"))
 80a10e0:	4668      	mov	r0, sp
 80a10e2:	4921      	ldr	r1, [pc, #132]	; (80a1168 <_Z16particleCommandsPKcS0_+0x120>)
 80a10e4:	f006 f93c 	bl	80a7360 <_ZNK6String6equalsEPKc>
 80a10e8:	b158      	cbz	r0, 80a1102 <_Z16particleCommandsPKcS0_+0xba>
        sleepMode.sleep_mode_enabled = false;
 80a10ea:	2200      	movs	r2, #0
 80a10ec:	4b1a      	ldr	r3, [pc, #104]	; (80a1158 <_Z16particleCommandsPKcS0_+0x110>)
        hmiScreen.home();
 80a10ee:	481b      	ldr	r0, [pc, #108]	; (80a115c <_Z16particleCommandsPKcS0_+0x114>)
        sleepMode.sleep_mode_enabled = false;
 80a10f0:	701a      	strb	r2, [r3, #0]
        hmiScreen.home();
 80a10f2:	f000 fb49 	bl	80a1788 <_ZN9HMIScreen4homeEv>
        hmiScreen.wake();
 80a10f6:	4819      	ldr	r0, [pc, #100]	; (80a115c <_Z16particleCommandsPKcS0_+0x114>)
 80a10f8:	f000 fb4c 	bl	80a1794 <_ZN9HMIScreen4wakeEv>
        clock_control.wake();
 80a10fc:	4819      	ldr	r0, [pc, #100]	; (80a1164 <_Z16particleCommandsPKcS0_+0x11c>)
 80a10fe:	f7ff f907 	bl	80a0310 <_ZN12ClockControl4wakeEv>
    if (buffer.equals("lock"))
 80a1102:	4668      	mov	r0, sp
 80a1104:	4919      	ldr	r1, [pc, #100]	; (80a116c <_Z16particleCommandsPKcS0_+0x124>)
 80a1106:	f006 f92b 	bl	80a7360 <_ZNK6String6equalsEPKc>
 80a110a:	b108      	cbz	r0, 80a1110 <_Z16particleCommandsPKcS0_+0xc8>
        lock();
 80a110c:	f7ff fec6 	bl	80a0e9c <_Z4lockv>
    if (buffer.equals("unlock"))
 80a1110:	4668      	mov	r0, sp
 80a1112:	4917      	ldr	r1, [pc, #92]	; (80a1170 <_Z16particleCommandsPKcS0_+0x128>)
 80a1114:	f006 f924 	bl	80a7360 <_ZNK6String6equalsEPKc>
 80a1118:	b108      	cbz	r0, 80a111e <_Z16particleCommandsPKcS0_+0xd6>
        unlock();
 80a111a:	f7ff fed9 	bl	80a0ed0 <_Z6unlockv>
    String buffer = data;
 80a111e:	4668      	mov	r0, sp
 80a1120:	f006 f8a7 	bl	80a7272 <_ZN6StringD1Ev>
}
 80a1124:	b005      	add	sp, #20
 80a1126:	f85d fb04 	ldr.w	pc, [sp], #4
 80a112a:	bf00      	nop
 80a112c:	080a961f 	.word	0x080a961f
 80a1130:	20000000 	.word	0x20000000
 80a1134:	080a9628 	.word	0x080a9628
 80a1138:	080a9630 	.word	0x080a9630
 80a113c:	080a9637 	.word	0x080a9637
 80a1140:	080a94ca 	.word	0x080a94ca
 80a1144:	20000128 	.word	0x20000128
 80a1148:	080a963d 	.word	0x080a963d
 80a114c:	20000c18 	.word	0x20000c18
 80a1150:	080a9647 	.word	0x080a9647
 80a1154:	080a964e 	.word	0x080a964e
 80a1158:	20000d30 	.word	0x20000d30
 80a115c:	20000180 	.word	0x20000180
 80a1160:	20000cc4 	.word	0x20000cc4
 80a1164:	20000144 	.word	0x20000144
 80a1168:	080a9654 	.word	0x080a9654
 80a116c:	080a965b 	.word	0x080a965b
 80a1170:	080a9659 	.word	0x080a9659

080a1174 <loop>:
{
 80a1174:	b538      	push	{r3, r4, r5, lr}

#ifdef __cplusplus
extern "C" {
#endif

inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
 80a1176:	f004 fb33 	bl	80a57e0 <HAL_Timer_Get_Milli_Seconds>
    counter.ms_per_tick = millis();
 80a117a:	4c1f      	ldr	r4, [pc, #124]	; (80a11f8 <loop+0x84>)
    if (!lockStatus.system_locked)
 80a117c:	4b1f      	ldr	r3, [pc, #124]	; (80a11fc <loop+0x88>)
    counter.ms_per_tick = millis();
 80a117e:	6060      	str	r0, [r4, #4]
    if (!lockStatus.system_locked)
 80a1180:	781b      	ldrb	r3, [r3, #0]
 80a1182:	b913      	cbnz	r3, 80a118a <loop+0x16>
        hmiScreen.run();
 80a1184:	481e      	ldr	r0, [pc, #120]	; (80a1200 <loop+0x8c>)
 80a1186:	f000 fb33 	bl	80a17f0 <_ZN9HMIScreen3runEv>
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
 80a118a:	f004 fb29 	bl	80a57e0 <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
 80a118e:	4b1d      	ldr	r3, [pc, #116]	; (80a1204 <loop+0x90>)
 80a1190:	6018      	str	r0, [r3, #0]
    		spark_process();
 80a1192:	f004 fb9d 	bl	80a58d0 <spark_process>
 80a1196:	f004 fb23 	bl	80a57e0 <HAL_Timer_Get_Milli_Seconds>
    counter.current_ms = millis();
 80a119a:	60a0      	str	r0, [r4, #8]
    counter.loop_tick++;
 80a119c:	8823      	ldrh	r3, [r4, #0]
 80a119e:	3301      	adds	r3, #1
 80a11a0:	b29b      	uxth	r3, r3
 80a11a2:	8023      	strh	r3, [r4, #0]
    if (counter.loop_tick == 1200)
 80a11a4:	8823      	ldrh	r3, [r4, #0]
 80a11a6:	b29b      	uxth	r3, r3
 80a11a8:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
 80a11ac:	d106      	bne.n	80a11bc <loop+0x48>
        if (!counter.stagger_push)
 80a11ae:	7b23      	ldrb	r3, [r4, #12]
 80a11b0:	2500      	movs	r5, #0
 80a11b2:	b9d3      	cbnz	r3, 80a11ea <loop+0x76>
            tftDisplay.updateTimeDisplay();
 80a11b4:	4814      	ldr	r0, [pc, #80]	; (80a1208 <loop+0x94>)
 80a11b6:	f7ff f803 	bl	80a01c0 <_ZN10TFTDisplay17updateTimeDisplayEv>
        counter.loop_tick = 0;
 80a11ba:	8025      	strh	r5, [r4, #0]
    if (counter.loop_tick == 600)
 80a11bc:	8823      	ldrh	r3, [r4, #0]
 80a11be:	b29b      	uxth	r3, r3
 80a11c0:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
 80a11c4:	d104      	bne.n	80a11d0 <loop+0x5c>
        if (!counter.stagger_push)
 80a11c6:	7b23      	ldrb	r3, [r4, #12]
 80a11c8:	b98b      	cbnz	r3, 80a11ee <loop+0x7a>
            tftDisplay.updateTimeDisplay();
 80a11ca:	480f      	ldr	r0, [pc, #60]	; (80a1208 <loop+0x94>)
 80a11cc:	f7fe fff8 	bl	80a01c0 <_ZN10TFTDisplay17updateTimeDisplayEv>
    if ((counter.ms_per_tick + 50) > counter.current_ms)
 80a11d0:	6863      	ldr	r3, [r4, #4]
 80a11d2:	68a2      	ldr	r2, [r4, #8]
 80a11d4:	3332      	adds	r3, #50	; 0x32
 80a11d6:	4293      	cmp	r3, r2
 80a11d8:	d90c      	bls.n	80a11f4 <loop+0x80>
        unsigned long wait_time = 50 - (counter.current_ms - counter.ms_per_tick);
 80a11da:	6863      	ldr	r3, [r4, #4]
 80a11dc:	68a0      	ldr	r0, [r4, #8]
 80a11de:	3332      	adds	r3, #50	; 0x32
        delay(wait_time);
 80a11e0:	1a18      	subs	r0, r3, r0
}
 80a11e2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        delay(wait_time);
 80a11e6:	f005 bb91 	b.w	80a690c <delay>
            counter.stagger_push = false;
 80a11ea:	7325      	strb	r5, [r4, #12]
 80a11ec:	e7e5      	b.n	80a11ba <loop+0x46>
            counter.stagger_push = false;
 80a11ee:	2300      	movs	r3, #0
 80a11f0:	7323      	strb	r3, [r4, #12]
 80a11f2:	e7ed      	b.n	80a11d0 <loop+0x5c>
}
 80a11f4:	bd38      	pop	{r3, r4, r5, pc}
 80a11f6:	bf00      	nop
 80a11f8:	20000170 	.word	0x20000170
 80a11fc:	20000c19 	.word	0x20000c19
 80a1200:	20000180 	.word	0x20000180
 80a1204:	20000ea0 	.word	0x20000ea0
 80a1208:	20000d34 	.word	0x20000d34

080a120c <_Z9hmi_setupv>:
{
 80a120c:	b510      	push	{r4, lr}
    hmiScreen.setup();
 80a120e:	4c26      	ldr	r4, [pc, #152]	; (80a12a8 <_Z9hmi_setupv+0x9c>)
 80a1210:	4620      	mov	r0, r4
 80a1212:	f000 fa91 	bl	80a1738 <_ZN9HMIScreen5setupEv>
    hmiScreen.sleepMode.attachPop(sleepModeCallback, &hmiScreen.sleepMode);            //sleepmode
 80a1216:	1d22      	adds	r2, r4, #4
 80a1218:	4610      	mov	r0, r2
 80a121a:	4924      	ldr	r1, [pc, #144]	; (80a12ac <_Z9hmi_setupv+0xa0>)
 80a121c:	f000 fba7 	bl	80a196e <_ZN8NexTouch9attachPopEPFvPvES0_>
    hmiScreen.getTextKeyboard.attachPop(keyBoardCallback, &hmiScreen.getTextKeyboard); //sleepmode
 80a1220:	f504 720b 	add.w	r2, r4, #556	; 0x22c
 80a1224:	4610      	mov	r0, r2
 80a1226:	4922      	ldr	r1, [pc, #136]	; (80a12b0 <_Z9hmi_setupv+0xa4>)
 80a1228:	f000 fba1 	bl	80a196e <_ZN8NexTouch9attachPopEPFvPvES0_>
    hmiScreen.toggleLEDStrip.attachPush(toggleLEDCallback, &hmiScreen.toggleLEDStrip); //toggle led
 80a122c:	f104 0228 	add.w	r2, r4, #40	; 0x28
 80a1230:	4610      	mov	r0, r2
 80a1232:	4920      	ldr	r1, [pc, #128]	; (80a12b4 <_Z9hmi_setupv+0xa8>)
 80a1234:	f000 fb98 	bl	80a1968 <_ZN8NexTouch10attachPushEPFvPvES0_>
    hmiScreen.toggleWifi.attachPop(toggleWifiCallback, &hmiScreen.toggleWifi);         //turn on/off wifi
 80a1238:	f104 024c 	add.w	r2, r4, #76	; 0x4c
 80a123c:	4610      	mov	r0, r2
 80a123e:	491e      	ldr	r1, [pc, #120]	; (80a12b8 <_Z9hmi_setupv+0xac>)
 80a1240:	f000 fb95 	bl	80a196e <_ZN8NexTouch9attachPopEPFvPvES0_>
    hmiScreen.wakeUpButton.attachPush(wakeUpCallback, &hmiScreen.wakeUpButton);
 80a1244:	f104 0270 	add.w	r2, r4, #112	; 0x70
 80a1248:	4610      	mov	r0, r2
 80a124a:	491c      	ldr	r1, [pc, #112]	; (80a12bc <_Z9hmi_setupv+0xb0>)
 80a124c:	f000 fb8c 	bl	80a1968 <_ZN8NexTouch10attachPushEPFvPvES0_>
    hmiScreen.QuickMessage.attachPop(quickMessageJump, &hmiScreen.QuickMessage);
 80a1250:	f504 727a 	add.w	r2, r4, #1000	; 0x3e8
 80a1254:	4610      	mov	r0, r2
 80a1256:	491a      	ldr	r1, [pc, #104]	; (80a12c0 <_Z9hmi_setupv+0xb4>)
 80a1258:	f000 fb89 	bl	80a196e <_ZN8NexTouch9attachPopEPFvPvES0_>
    hmiScreen.QuickMessage6.attachPop(quickMessage6Function, &hmiScreen.QuickMessage6);
 80a125c:	f504 7202 	add.w	r2, r4, #520	; 0x208
 80a1260:	4610      	mov	r0, r2
 80a1262:	4918      	ldr	r1, [pc, #96]	; (80a12c4 <_Z9hmi_setupv+0xb8>)
 80a1264:	f000 fb83 	bl	80a196e <_ZN8NexTouch9attachPopEPFvPvES0_>
    hmiScreen.QuickMessage5.attachPop(quickMessage5Function, &hmiScreen.QuickMessage5);
 80a1268:	f504 72f2 	add.w	r2, r4, #484	; 0x1e4
 80a126c:	4610      	mov	r0, r2
 80a126e:	4916      	ldr	r1, [pc, #88]	; (80a12c8 <_Z9hmi_setupv+0xbc>)
 80a1270:	f000 fb7d 	bl	80a196e <_ZN8NexTouch9attachPopEPFvPvES0_>
    hmiScreen.QuickMessage4.attachPop(quickMessage4Function, &hmiScreen.QuickMessage4);
 80a1274:	f504 72e0 	add.w	r2, r4, #448	; 0x1c0
 80a1278:	4610      	mov	r0, r2
 80a127a:	4914      	ldr	r1, [pc, #80]	; (80a12cc <_Z9hmi_setupv+0xc0>)
 80a127c:	f000 fb77 	bl	80a196e <_ZN8NexTouch9attachPopEPFvPvES0_>
    hmiScreen.QuickMessage3.attachPop(quickMessage3Function, &hmiScreen.QuickMessage3);
 80a1280:	f504 72ce 	add.w	r2, r4, #412	; 0x19c
 80a1284:	4610      	mov	r0, r2
 80a1286:	4912      	ldr	r1, [pc, #72]	; (80a12d0 <_Z9hmi_setupv+0xc4>)
 80a1288:	f000 fb71 	bl	80a196e <_ZN8NexTouch9attachPopEPFvPvES0_>
    hmiScreen.QuickMessage2.attachPop(quickMessage2Function, &hmiScreen.QuickMessage2);
 80a128c:	f504 72bc 	add.w	r2, r4, #376	; 0x178
 80a1290:	4610      	mov	r0, r2
 80a1292:	4910      	ldr	r1, [pc, #64]	; (80a12d4 <_Z9hmi_setupv+0xc8>)
 80a1294:	f000 fb6b 	bl	80a196e <_ZN8NexTouch9attachPopEPFvPvES0_>
    hmiScreen.QuickMessage1.attachPop(quickMessage1Function, &hmiScreen.QuickMessage1);
 80a1298:	f504 72aa 	add.w	r2, r4, #340	; 0x154
 80a129c:	4610      	mov	r0, r2
}
 80a129e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    hmiScreen.QuickMessage1.attachPop(quickMessage1Function, &hmiScreen.QuickMessage1);
 80a12a2:	490d      	ldr	r1, [pc, #52]	; (80a12d8 <_Z9hmi_setupv+0xcc>)
 80a12a4:	f000 bb63 	b.w	80a196e <_ZN8NexTouch9attachPopEPFvPvES0_>
 80a12a8:	20000180 	.word	0x20000180
 80a12ac:	080a04a9 	.word	0x080a04a9
 80a12b0:	080a0519 	.word	0x080a0519
 80a12b4:	080a046d 	.word	0x080a046d
 80a12b8:	080a04e9 	.word	0x080a04e9
 80a12bc:	080a04ed 	.word	0x080a04ed
 80a12c0:	080a044f 	.word	0x080a044f
 80a12c4:	080a0479 	.word	0x080a0479
 80a12c8:	080a14a5 	.word	0x080a14a5
 80a12cc:	080a14c1 	.word	0x080a14c1
 80a12d0:	080a14dd 	.word	0x080a14dd
 80a12d4:	080a14f9 	.word	0x080a14f9
 80a12d8:	080a1515 	.word	0x080a1515

080a12dc <_Z17peripherals_setupv>:
{
 80a12dc:	b570      	push	{r4, r5, r6, lr}
    Time.zone(-7);
 80a12de:	483e      	ldr	r0, [pc, #248]	; (80a13d8 <_Z17peripherals_setupv+0xfc>)
{
 80a12e0:	b086      	sub	sp, #24
    hmiScreen.setProgressBar(15);
 80a12e2:	4c3e      	ldr	r4, [pc, #248]	; (80a13dc <_Z17peripherals_setupv+0x100>)
    Time.zone(-7);
 80a12e4:	f005 fe80 	bl	80a6fe8 <_ZN9TimeClass4zoneEf>
    notifLight.setupLEDs();
 80a12e8:	4d3d      	ldr	r5, [pc, #244]	; (80a13e0 <_Z17peripherals_setupv+0x104>)
    hmi_setup();
 80a12ea:	f7ff ff8f 	bl	80a120c <_Z9hmi_setupv>
    alarmrelay.setupRelay(DAC);
 80a12ee:	2110      	movs	r1, #16
 80a12f0:	483c      	ldr	r0, [pc, #240]	; (80a13e4 <_Z17peripherals_setupv+0x108>)
 80a12f2:	f7ff f891 	bl	80a0418 <_ZN10alarmRelay10setupRelayEi>
    hmiScreen.setProgressBar(15);
 80a12f6:	210f      	movs	r1, #15
 80a12f8:	4620      	mov	r0, r4
 80a12fa:	f000 fa67 	bl	80a17cc <_ZN9HMIScreen14setProgressBarEi>
    notifLight.setupLEDs();
 80a12fe:	4628      	mov	r0, r5
 80a1300:	f000 fa9b 	bl	80a183a <_ZN17notificationLight9setupLEDsEv>
    notifLight.setStrip(100, 100, 100);
 80a1304:	2364      	movs	r3, #100	; 0x64
 80a1306:	4628      	mov	r0, r5
 80a1308:	461a      	mov	r2, r3
 80a130a:	4619      	mov	r1, r3
    lampLight.setupLEDStrip();
 80a130c:	4d36      	ldr	r5, [pc, #216]	; (80a13e8 <_Z17peripherals_setupv+0x10c>)
    notifLight.setStrip(100, 100, 100);
 80a130e:	f000 faa1 	bl	80a1854 <_ZN17notificationLight8setStripEhhh>
    hmiScreen.setProgressBar(30);
 80a1312:	211e      	movs	r1, #30
 80a1314:	4620      	mov	r0, r4
 80a1316:	f000 fa59 	bl	80a17cc <_ZN9HMIScreen14setProgressBarEi>
    lampLight.setupLEDStrip();
 80a131a:	4628      	mov	r0, r5
 80a131c:	f000 fa6c 	bl	80a17f8 <_ZN8LEDRelay13setupLEDStripEv>
    lampLight.setLED(1);
 80a1320:	2101      	movs	r1, #1
 80a1322:	4628      	mov	r0, r5
 80a1324:	f000 fa85 	bl	80a1832 <_ZN8LEDRelay6setLEDEb>
    delay(500);
 80a1328:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80a132c:	f005 faee 	bl	80a690c <delay>
    lampLight.setLED(0);
 80a1330:	4628      	mov	r0, r5
 80a1332:	2100      	movs	r1, #0
    tftDisplay.setupTFTDisplay();
 80a1334:	4d2d      	ldr	r5, [pc, #180]	; (80a13ec <_Z17peripherals_setupv+0x110>)
    lampLight.setLED(0);
 80a1336:	f000 fa7c 	bl	80a1832 <_ZN8LEDRelay6setLEDEb>
    hmiScreen.setProgressBar(45);
 80a133a:	212d      	movs	r1, #45	; 0x2d
 80a133c:	4620      	mov	r0, r4
 80a133e:	f000 fa45 	bl	80a17cc <_ZN9HMIScreen14setProgressBarEi>
    tftDisplay.printTFT(20, 20, 2, "Setting up...");
 80a1342:	ae02      	add	r6, sp, #8
    tftDisplay.setupTFTDisplay();
 80a1344:	4628      	mov	r0, r5
 80a1346:	f7fe ff10 	bl	80a016a <_ZN10TFTDisplay15setupTFTDisplayEv>
    tftDisplay.printTFT(20, 20, 2, "Setting up...");
 80a134a:	4630      	mov	r0, r6
 80a134c:	4928      	ldr	r1, [pc, #160]	; (80a13f0 <_Z17peripherals_setupv+0x114>)
 80a134e:	f005 ffda 	bl	80a7306 <_ZN6StringC1EPKc>
 80a1352:	2214      	movs	r2, #20
 80a1354:	2302      	movs	r3, #2
 80a1356:	4611      	mov	r1, r2
 80a1358:	4628      	mov	r0, r5
 80a135a:	9600      	str	r6, [sp, #0]
 80a135c:	f7fe fef3 	bl	80a0146 <_ZN10TFTDisplay8printTFTEiii6String>
 80a1360:	4630      	mov	r0, r6
 80a1362:	f005 ff86 	bl	80a7272 <_ZN6StringD1Ev>
    hmiScreen.setProgressBar(70);
 80a1366:	2146      	movs	r1, #70	; 0x46
 80a1368:	4620      	mov	r0, r4
 80a136a:	f000 fa2f 	bl	80a17cc <_ZN9HMIScreen14setProgressBarEi>
    cardReader.setupCardReader();
 80a136e:	4821      	ldr	r0, [pc, #132]	; (80a13f4 <_Z17peripherals_setupv+0x118>)
 80a1370:	f000 f9a8 	bl	80a16c4 <_ZN10rfidReader15setupCardReaderEv>
    hmiScreen.setProgressBar(85);
 80a1374:	2155      	movs	r1, #85	; 0x55
 80a1376:	4620      	mov	r0, r4
 80a1378:	f000 fa28 	bl	80a17cc <_ZN9HMIScreen14setProgressBarEi>
    motionSensor.setupAccel();
 80a137c:	481e      	ldr	r0, [pc, #120]	; (80a13f8 <_Z17peripherals_setupv+0x11c>)
 80a137e:	f000 facb 	bl	80a1918 <_ZN9IMUSensor10setupAccelEv>
    hmiScreen.setProgressBar(90);
 80a1382:	215a      	movs	r1, #90	; 0x5a
 80a1384:	4620      	mov	r0, r4
 80a1386:	f000 fa21 	bl	80a17cc <_ZN9HMIScreen14setProgressBarEi>
    RGB.control(true);
 80a138a:	2001      	movs	r0, #1
 80a138c:	f005 fb72 	bl	80a6a74 <_ZN8RGBClass7controlEb>
    RGB.color(0, 0, 0);
 80a1390:	2200      	movs	r2, #0
 80a1392:	4611      	mov	r1, r2
 80a1394:	4610      	mov	r0, r2
 80a1396:	f005 fb7d 	bl	80a6a94 <_ZN8RGBClass5colorEiii>
    RGB.brightness(0);
 80a139a:	2101      	movs	r1, #1
 80a139c:	2000      	movs	r0, #0
 80a139e:	f005 fb8c 	bl	80a6aba <_ZN8RGBClass10brightnessEhb>
    RGB.control(false);
 80a13a2:	2000      	movs	r0, #0
 80a13a4:	f005 fb66 	bl	80a6a74 <_ZN8RGBClass7controlEb>
    tftDisplay.updateTimeDisplay();
 80a13a8:	4628      	mov	r0, r5
 80a13aa:	f7fe ff09 	bl	80a01c0 <_ZN10TFTDisplay17updateTimeDisplayEv>
    hmiScreen.setProgressBar(100);
 80a13ae:	2164      	movs	r1, #100	; 0x64
 80a13b0:	4620      	mov	r0, r4
 80a13b2:	f000 fa0b 	bl	80a17cc <_ZN9HMIScreen14setProgressBarEi>
    hmiScreen.home();
 80a13b6:	4620      	mov	r0, r4
    Udp.begin(4250);
 80a13b8:	4c10      	ldr	r4, [pc, #64]	; (80a13fc <_Z17peripherals_setupv+0x120>)
    hmiScreen.home();
 80a13ba:	f000 f9e5 	bl	80a1788 <_ZN9HMIScreen4homeEv>
    Udp.begin(4250);
 80a13be:	2200      	movs	r2, #0
 80a13c0:	f241 019a 	movw	r1, #4250	; 0x109a
 80a13c4:	4620      	mov	r0, r4
 80a13c6:	f005 fbd5 	bl	80a6b74 <_ZN3UDP5beginEtm>
    clock_control.setup(&Udp);
 80a13ca:	4621      	mov	r1, r4
 80a13cc:	480c      	ldr	r0, [pc, #48]	; (80a1400 <_Z17peripherals_setupv+0x124>)
 80a13ce:	f7fe ff9c 	bl	80a030a <_ZN12ClockControl5setupEP3UDP>
}
 80a13d2:	b006      	add	sp, #24
 80a13d4:	bd70      	pop	{r4, r5, r6, pc}
 80a13d6:	bf00      	nop
 80a13d8:	c0e00000 	.word	0xc0e00000
 80a13dc:	20000180 	.word	0x20000180
 80a13e0:	20000cc4 	.word	0x20000cc4
 80a13e4:	20000128 	.word	0x20000128
 80a13e8:	20000c18 	.word	0x20000c18
 80a13ec:	20000d34 	.word	0x20000d34
 80a13f0:	080a9660 	.word	0x080a9660
 80a13f4:	20000130 	.word	0x20000130
 80a13f8:	20000c1c 	.word	0x20000c1c
 80a13fc:	200000d8 	.word	0x200000d8
 80a1400:	20000144 	.word	0x20000144

080a1404 <_Z13threads_setupv>:
{
 80a1404:	b508      	push	{r3, lr}
    bool start(unsigned block=default_wait) { return _start(block, false); }
 80a1406:	2200      	movs	r2, #0
 80a1408:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 80a140c:	4804      	ldr	r0, [pc, #16]	; (80a1420 <_Z13threads_setupv+0x1c>)
 80a140e:	f7ff fa2a 	bl	80a0866 <_ZN5Timer6_startEjb>
 80a1412:	2200      	movs	r2, #0
 80a1414:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 80a1418:	4802      	ldr	r0, [pc, #8]	; (80a1424 <_Z13threads_setupv+0x20>)
 80a141a:	f7ff fa24 	bl	80a0866 <_ZN5Timer6_startEjb>
}
 80a141e:	bd08      	pop	{r3, pc}
 80a1420:	20000c88 	.word	0x20000c88
 80a1424:	20000ca4 	.word	0x20000ca4

080a1428 <_Z17initCloudRequestsv>:
{
 80a1428:	b508      	push	{r3, lr}
    Particle.subscribe("push", push, MY_DEVICES);
 80a142a:	4907      	ldr	r1, [pc, #28]	; (80a1448 <_Z17initCloudRequestsv+0x20>)
 80a142c:	4807      	ldr	r0, [pc, #28]	; (80a144c <_Z17initCloudRequestsv+0x24>)
 80a142e:	f7ff f9c7 	bl	80a07c0 <_ZN10CloudClass9subscribeEPKcPFvS1_S1_E32Spark_Subscription_Scope_TypeDef.isra.0.constprop.0>
    Particle.subscribe("loud", pushLoud, MY_DEVICES);
 80a1432:	4907      	ldr	r1, [pc, #28]	; (80a1450 <_Z17initCloudRequestsv+0x28>)
 80a1434:	4807      	ldr	r0, [pc, #28]	; (80a1454 <_Z17initCloudRequestsv+0x2c>)
 80a1436:	f7ff f9c3 	bl	80a07c0 <_ZN10CloudClass9subscribeEPKcPFvS1_S1_E32Spark_Subscription_Scope_TypeDef.isra.0.constprop.0>
}
 80a143a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Particle.subscribe("command", particleCommands, MY_DEVICES);
 80a143e:	4906      	ldr	r1, [pc, #24]	; (80a1458 <_Z17initCloudRequestsv+0x30>)
 80a1440:	4806      	ldr	r0, [pc, #24]	; (80a145c <_Z17initCloudRequestsv+0x34>)
 80a1442:	f7ff b9bd 	b.w	80a07c0 <_ZN10CloudClass9subscribeEPKcPFvS1_S1_E32Spark_Subscription_Scope_TypeDef.isra.0.constprop.0>
 80a1446:	bf00      	nop
 80a1448:	080a06e5 	.word	0x080a06e5
 80a144c:	080a966e 	.word	0x080a966e
 80a1450:	080a07d5 	.word	0x080a07d5
 80a1454:	080a9673 	.word	0x080a9673
 80a1458:	080a1049 	.word	0x080a1049
 80a145c:	080a9678 	.word	0x080a9678

080a1460 <setup>:
{
 80a1460:	b508      	push	{r3, lr}
    peripherals_setup();
 80a1462:	f7ff ff3b 	bl	80a12dc <_Z17peripherals_setupv>
    threads_setup();
 80a1466:	f7ff ffcd 	bl	80a1404 <_Z13threads_setupv>
    lock();
 80a146a:	f7ff fd17 	bl	80a0e9c <_Z4lockv>
}
 80a146e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    initCloudRequests();
 80a1472:	f7ff bfd9 	b.w	80a1428 <_Z17initCloudRequestsv>

080a1476 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>:
      explicit __shared_count(const __weak_count<_Lp>& __r);

      // Does not throw if __r._M_get_use_count() == 0, caller must check.
      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
 80a1476:	b538      	push	{r3, r4, r5, lr}
      {
	if (_M_pi != nullptr)
 80a1478:	6804      	ldr	r4, [r0, #0]
      ~__shared_count() noexcept
 80a147a:	4605      	mov	r5, r0
	if (_M_pi != nullptr)
 80a147c:	b17c      	cbz	r4, 80a149e <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev+0x28>
      if (--_M_use_count == 0)
 80a147e:	6863      	ldr	r3, [r4, #4]
 80a1480:	3b01      	subs	r3, #1
 80a1482:	6063      	str	r3, [r4, #4]
 80a1484:	b95b      	cbnz	r3, 80a149e <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev+0x28>
          _M_dispose();
 80a1486:	6823      	ldr	r3, [r4, #0]
 80a1488:	4620      	mov	r0, r4
 80a148a:	689b      	ldr	r3, [r3, #8]
 80a148c:	4798      	blx	r3
          if (--_M_weak_count == 0)
 80a148e:	68a3      	ldr	r3, [r4, #8]
 80a1490:	3b01      	subs	r3, #1
 80a1492:	60a3      	str	r3, [r4, #8]
 80a1494:	b91b      	cbnz	r3, 80a149e <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev+0x28>
            _M_destroy();
 80a1496:	6823      	ldr	r3, [r4, #0]
 80a1498:	4620      	mov	r0, r4
 80a149a:	68db      	ldr	r3, [r3, #12]
 80a149c:	4798      	blx	r3
	  _M_pi->_M_release();
      }
 80a149e:	4628      	mov	r0, r5
 80a14a0:	bd38      	pop	{r3, r4, r5, pc}
	...

080a14a4 <_Z21quickMessage5FunctionPv>:
{
 80a14a4:	b507      	push	{r0, r1, r2, lr}
    Particle.publish("QuickMessage", "What are you doing?");
 80a14a6:	4905      	ldr	r1, [pc, #20]	; (80a14bc <_Z21quickMessage5FunctionPv+0x18>)
 80a14a8:	4668      	mov	r0, sp
 80a14aa:	f7ff f977 	bl	80a079c <_ZN10CloudClass7publishEPKcS1_.isra.0.constprop.0>
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
 80a14ae:	a801      	add	r0, sp, #4
 80a14b0:	f7ff ffe1 	bl	80a1476 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
}
 80a14b4:	b003      	add	sp, #12
 80a14b6:	f85d fb04 	ldr.w	pc, [sp], #4
 80a14ba:	bf00      	nop
 80a14bc:	080a9680 	.word	0x080a9680

080a14c0 <_Z21quickMessage4FunctionPv>:
{
 80a14c0:	b507      	push	{r0, r1, r2, lr}
    Particle.publish("QuickMessage", "I miss you :(");
 80a14c2:	4905      	ldr	r1, [pc, #20]	; (80a14d8 <_Z21quickMessage4FunctionPv+0x18>)
 80a14c4:	4668      	mov	r0, sp
 80a14c6:	f7ff f969 	bl	80a079c <_ZN10CloudClass7publishEPKcS1_.isra.0.constprop.0>
 80a14ca:	a801      	add	r0, sp, #4
 80a14cc:	f7ff ffd3 	bl	80a1476 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
}
 80a14d0:	b003      	add	sp, #12
 80a14d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80a14d6:	bf00      	nop
 80a14d8:	080a9694 	.word	0x080a9694

080a14dc <_Z21quickMessage3FunctionPv>:
{
 80a14dc:	b507      	push	{r0, r1, r2, lr}
    Particle.publish("QuickMessage", "Are you in your dorm?");
 80a14de:	4905      	ldr	r1, [pc, #20]	; (80a14f4 <_Z21quickMessage3FunctionPv+0x18>)
 80a14e0:	4668      	mov	r0, sp
 80a14e2:	f7ff f95b 	bl	80a079c <_ZN10CloudClass7publishEPKcS1_.isra.0.constprop.0>
 80a14e6:	a801      	add	r0, sp, #4
 80a14e8:	f7ff ffc5 	bl	80a1476 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
}
 80a14ec:	b003      	add	sp, #12
 80a14ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80a14f2:	bf00      	nop
 80a14f4:	080a96a2 	.word	0x080a96a2

080a14f8 <_Z21quickMessage2FunctionPv>:
{
 80a14f8:	b507      	push	{r0, r1, r2, lr}
    Particle.publish("QuickMessage", "How are you doing?");
 80a14fa:	4905      	ldr	r1, [pc, #20]	; (80a1510 <_Z21quickMessage2FunctionPv+0x18>)
 80a14fc:	4668      	mov	r0, sp
 80a14fe:	f7ff f94d 	bl	80a079c <_ZN10CloudClass7publishEPKcS1_.isra.0.constprop.0>
 80a1502:	a801      	add	r0, sp, #4
 80a1504:	f7ff ffb7 	bl	80a1476 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
}
 80a1508:	b003      	add	sp, #12
 80a150a:	f85d fb04 	ldr.w	pc, [sp], #4
 80a150e:	bf00      	nop
 80a1510:	080a96b8 	.word	0x080a96b8

080a1514 <_Z21quickMessage1FunctionPv>:
{
 80a1514:	b507      	push	{r0, r1, r2, lr}
    Particle.publish("QuickMessage", "Hey Babe");
 80a1516:	4905      	ldr	r1, [pc, #20]	; (80a152c <_Z21quickMessage1FunctionPv+0x18>)
 80a1518:	4668      	mov	r0, sp
 80a151a:	f7ff f93f 	bl	80a079c <_ZN10CloudClass7publishEPKcS1_.isra.0.constprop.0>
 80a151e:	a801      	add	r0, sp, #4
 80a1520:	f7ff ffa9 	bl	80a1476 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
}
 80a1524:	b003      	add	sp, #12
 80a1526:	f85d fb04 	ldr.w	pc, [sp], #4
 80a152a:	bf00      	nop
 80a152c:	080a96cb 	.word	0x080a96cb

080a1530 <_GLOBAL__sub_I_alarmrelay>:
returns: none
*/
void sysReset(const char *event, const char *data)
{
    System.reset();
 80a1530:	b5f0      	push	{r4, r5, r6, r7, lr}
        val_(val) {
 80a1532:	2400      	movs	r4, #0

/*
class: notificationLight
description: class that handles controlling the rgb notifcation circle. 
*/
class notificationLight{
 80a1534:	4d4b      	ldr	r5, [pc, #300]	; (80a1664 <_GLOBAL__sub_I_alarmrelay+0x134>)
 80a1536:	4b4c      	ldr	r3, [pc, #304]	; (80a1668 <_GLOBAL__sub_I_alarmrelay+0x138>)
 80a1538:	b089      	sub	sp, #36	; 0x24
 80a153a:	701c      	strb	r4, [r3, #0]
 80a153c:	220a      	movs	r2, #10
 80a153e:	2302      	movs	r3, #2
 80a1540:	2118      	movs	r1, #24
 80a1542:	4628      	mov	r0, r5
 80a1544:	f001 f9af 	bl	80a28a6 <_ZN17Adafruit_NeoPixelC1Ethh>
#define TFT_MOSI D2
#define TFT_MISO D3
#define TFT_CLK D4
#define TFT_RST D7

class TFTDisplay{
 80a1548:	2307      	movs	r3, #7
 80a154a:	2203      	movs	r2, #3
 80a154c:	616c      	str	r4, [r5, #20]
 80a154e:	e9cd 3201 	strd	r3, r2, [sp, #4]
 80a1552:	2304      	movs	r3, #4

// PIN DENOMINATIONS // 
#define SS_PIN SS
#define RST_PIN D2

class rfidReader{
 80a1554:	4d45      	ldr	r5, [pc, #276]	; (80a166c <_GLOBAL__sub_I_alarmrelay+0x13c>)
 80a1556:	9300      	str	r3, [sp, #0]
 80a1558:	2206      	movs	r2, #6
 80a155a:	2302      	movs	r3, #2
 80a155c:	2105      	movs	r1, #5
 80a155e:	4844      	ldr	r0, [pc, #272]	; (80a1670 <_GLOBAL__sub_I_alarmrelay+0x140>)
 80a1560:	f002 ff14 	bl	80a438c <_ZN16Adafruit_ILI9341C1Eaaaaaa>
 80a1564:	2202      	movs	r2, #2
 80a1566:	210c      	movs	r1, #12
 80a1568:	4628      	mov	r0, r5
 80a156a:	f002 fab7 	bl	80a3adc <_ZN7MFRC522C1Ehh>
 80a156e:	f8c5 400e 	str.w	r4, [r5, #14]

#include "Particle.h"
#include <Adafruit_LIS3DH.h>


class IMUSensor{
 80a1572:	4840      	ldr	r0, [pc, #256]	; (80a1674 <_GLOBAL__sub_I_alarmrelay+0x144>)
 80a1574:	f000 fcf2 	bl	80a1f5c <_ZN15Adafruit_LIS3DHC1Ev>
HMIScreen hmiScreen;
 80a1578:	483f      	ldr	r0, [pc, #252]	; (80a1678 <_GLOBAL__sub_I_alarmrelay+0x148>)
 80a157a:	f7ff f9b9 	bl	80a08f0 <_ZN9HMIScreenC1Ev>
USARTSerial &nexSerial = Serial1; //chooses the right serial device
 80a157e:	f004 fd3d 	bl	80a5ffc <_Z22__fetch_global_Serial1v>
 80a1582:	4b3e      	ldr	r3, [pc, #248]	; (80a167c <_GLOBAL__sub_I_alarmrelay+0x14c>)
#ifndef _CLOCKCONTROL_H
#define _CLOCKCONTROL_H

#include "Particle.h"

class ClockControl{
 80a1584:	4d3e      	ldr	r5, [pc, #248]	; (80a1680 <_GLOBAL__sub_I_alarmrelay+0x150>)
 80a1586:	6018      	str	r0, [r3, #0]
 80a1588:	2318      	movs	r3, #24
 80a158a:	22a8      	movs	r2, #168	; 0xa8
 80a158c:	9300      	str	r3, [sp, #0]
 80a158e:	21c0      	movs	r1, #192	; 0xc0
 80a1590:	2301      	movs	r3, #1
 80a1592:	1d28      	adds	r0, r5, #4
 80a1594:	f004 fef0 	bl	80a6378 <_ZN9IPAddressC1Ehhhh>
 80a1598:	f241 0172 	movw	r1, #4210	; 0x1072
 80a159c:	4b39      	ldr	r3, [pc, #228]	; (80a1684 <_GLOBAL__sub_I_alarmrelay+0x154>)
 80a159e:	f885 4024 	strb.w	r4, [r5, #36]	; 0x24
 80a15a2:	e9c5 1307 	strd	r1, r3, [r5, #28]
 80a15a6:	4b38      	ldr	r3, [pc, #224]	; (80a1688 <_GLOBAL__sub_I_alarmrelay+0x158>)
UDP Udp;
 80a15a8:	4838      	ldr	r0, [pc, #224]	; (80a168c <_GLOBAL__sub_I_alarmrelay+0x15c>)
 80a15aa:	681a      	ldr	r2, [r3, #0]
 80a15ac:	791b      	ldrb	r3, [r3, #4]
 80a15ae:	f8c5 2025 	str.w	r2, [r5, #37]	; 0x25
 80a15b2:	f885 3029 	strb.w	r3, [r5, #41]	; 0x29
 80a15b6:	f005 fc27 	bl	80a6e08 <_ZN3UDPC1Ev>
	{ ::new (__functor._M_access()) _Functor(std::move(__f)); }
 80a15ba:	4b35      	ldr	r3, [pc, #212]	; (80a1690 <_GLOBAL__sub_I_alarmrelay+0x160>)
	    _M_invoker = &_My_handler::_M_invoke;
 80a15bc:	4e35      	ldr	r6, [pc, #212]	; (80a1694 <_GLOBAL__sub_I_alarmrelay+0x164>)
	    _M_manager = &_My_handler::_M_manager;
 80a15be:	4d36      	ldr	r5, [pc, #216]	; (80a1698 <_GLOBAL__sub_I_alarmrelay+0x168>)
Timer ms_100_task_handler(100, ms_100_task);
 80a15c0:	aa04      	add	r2, sp, #16
 80a15c2:	2164      	movs	r1, #100	; 0x64
	{ ::new (__functor._M_access()) _Functor(std::move(__f)); }
 80a15c4:	9304      	str	r3, [sp, #16]
 80a15c6:	4835      	ldr	r0, [pc, #212]	; (80a169c <_GLOBAL__sub_I_alarmrelay+0x16c>)
 80a15c8:	4623      	mov	r3, r4
	    _M_invoker = &_My_handler::_M_invoke;
 80a15ca:	9607      	str	r6, [sp, #28]
	    _M_manager = &_My_handler::_M_manager;
 80a15cc:	9506      	str	r5, [sp, #24]
 80a15ce:	f7ff f90b 	bl	80a07e8 <_ZN5TimerC1EjSt8functionIFvvEEb>
    class function<_Res(_ArgTypes...)>
 80a15d2:	a804      	add	r0, sp, #16
 80a15d4:	f7ff f8ff 	bl	80a07d6 <_ZNSt14_Function_baseD1Ev>
	{ ::new (__functor._M_access()) _Functor(std::move(__f)); }
 80a15d8:	4b31      	ldr	r3, [pc, #196]	; (80a16a0 <_GLOBAL__sub_I_alarmrelay+0x170>)
Timer ms_300_task_handler(200, ms_300_task);
 80a15da:	aa04      	add	r2, sp, #16
 80a15dc:	21c8      	movs	r1, #200	; 0xc8
 80a15de:	9304      	str	r3, [sp, #16]
 80a15e0:	4830      	ldr	r0, [pc, #192]	; (80a16a4 <_GLOBAL__sub_I_alarmrelay+0x174>)
 80a15e2:	4623      	mov	r3, r4
	    _M_manager = &_My_handler::_M_manager;
 80a15e4:	e9cd 5606 	strd	r5, r6, [sp, #24]
 80a15e8:	f7ff f8fe 	bl	80a07e8 <_ZN5TimerC1EjSt8functionIFvvEEb>
    class function<_Res(_ArgTypes...)>
 80a15ec:	a804      	add	r0, sp, #16
 80a15ee:	f7ff f8f2 	bl	80a07d6 <_ZNSt14_Function_baseD1Ev>
	{ ::new (__functor._M_access()) _Functor(std::move(__f)); }
 80a15f2:	4b2d      	ldr	r3, [pc, #180]	; (80a16a8 <_GLOBAL__sub_I_alarmrelay+0x178>)
Timer ms_1000_task_handler(1000, ms_1000_task);
 80a15f4:	aa04      	add	r2, sp, #16
 80a15f6:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 80a15fa:	9304      	str	r3, [sp, #16]
 80a15fc:	482b      	ldr	r0, [pc, #172]	; (80a16ac <_GLOBAL__sub_I_alarmrelay+0x17c>)
 80a15fe:	4623      	mov	r3, r4
	    _M_manager = &_My_handler::_M_manager;
 80a1600:	e9cd 5606 	strd	r5, r6, [sp, #24]
 80a1604:	f7ff f8f0 	bl	80a07e8 <_ZN5TimerC1EjSt8functionIFvvEEb>
    class function<_Res(_ArgTypes...)>
 80a1608:	a804      	add	r0, sp, #16
 80a160a:	f7ff f8e4 	bl	80a07d6 <_ZNSt14_Function_baseD1Ev>
	{ ::new (__functor._M_access()) _Functor(std::move(__f)); }
 80a160e:	4b28      	ldr	r3, [pc, #160]	; (80a16b0 <_GLOBAL__sub_I_alarmrelay+0x180>)
Timer s_10_task_handler(10000, s_10_task);
 80a1610:	aa04      	add	r2, sp, #16
 80a1612:	f242 7110 	movw	r1, #10000	; 0x2710
 80a1616:	9304      	str	r3, [sp, #16]
 80a1618:	4826      	ldr	r0, [pc, #152]	; (80a16b4 <_GLOBAL__sub_I_alarmrelay+0x184>)
 80a161a:	4623      	mov	r3, r4
 80a161c:	4f26      	ldr	r7, [pc, #152]	; (80a16b8 <_GLOBAL__sub_I_alarmrelay+0x188>)
	    _M_manager = &_My_handler::_M_manager;
 80a161e:	e9cd 5606 	strd	r5, r6, [sp, #24]
 80a1622:	f7ff f8e1 	bl	80a07e8 <_ZN5TimerC1EjSt8functionIFvvEEb>
    class function<_Res(_ArgTypes...)>
 80a1626:	a804      	add	r0, sp, #16
 80a1628:	f7ff f8d5 	bl	80a07d6 <_ZNSt14_Function_baseD1Ev>
Timer s_30_task_handler(30000, s_30_task);
 80a162c:	4623      	mov	r3, r4
 80a162e:	aa04      	add	r2, sp, #16
 80a1630:	f247 5130 	movw	r1, #30000	; 0x7530
 80a1634:	4821      	ldr	r0, [pc, #132]	; (80a16bc <_GLOBAL__sub_I_alarmrelay+0x18c>)
	    _M_manager = &_My_handler::_M_manager;
 80a1636:	e9cd 5606 	strd	r5, r6, [sp, #24]
	{ ::new (__functor._M_access()) _Functor(std::move(__f)); }
 80a163a:	9704      	str	r7, [sp, #16]
 80a163c:	f7ff f8d4 	bl	80a07e8 <_ZN5TimerC1EjSt8functionIFvvEEb>
    class function<_Res(_ArgTypes...)>
 80a1640:	a804      	add	r0, sp, #16
 80a1642:	f7ff f8c8 	bl	80a07d6 <_ZNSt14_Function_baseD1Ev>
Timer s_60_task_handler(60000, s_30_task);
 80a1646:	4623      	mov	r3, r4
 80a1648:	f64e 2160 	movw	r1, #60000	; 0xea60
 80a164c:	aa04      	add	r2, sp, #16
 80a164e:	481c      	ldr	r0, [pc, #112]	; (80a16c0 <_GLOBAL__sub_I_alarmrelay+0x190>)
	    _M_manager = &_My_handler::_M_manager;
 80a1650:	e9cd 5606 	strd	r5, r6, [sp, #24]
	{ ::new (__functor._M_access()) _Functor(std::move(__f)); }
 80a1654:	9704      	str	r7, [sp, #16]
 80a1656:	f7ff f8c7 	bl	80a07e8 <_ZN5TimerC1EjSt8functionIFvvEEb>
    class function<_Res(_ArgTypes...)>
 80a165a:	a804      	add	r0, sp, #16
 80a165c:	f7ff f8bb 	bl	80a07d6 <_ZNSt14_Function_baseD1Ev>
 80a1660:	b009      	add	sp, #36	; 0x24
 80a1662:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a1664:	20000cc4 	.word	0x20000cc4
 80a1668:	20000124 	.word	0x20000124
 80a166c:	20000130 	.word	0x20000130
 80a1670:	20000d34 	.word	0x20000d34
 80a1674:	20000c1c 	.word	0x20000c1c
 80a1678:	20000180 	.word	0x20000180
 80a167c:	20000cc0 	.word	0x20000cc0
 80a1680:	20000144 	.word	0x20000144
 80a1684:	41322828 	.word	0x41322828
 80a1688:	080a96e8 	.word	0x080a96e8
 80a168c:	200000d8 	.word	0x200000d8
 80a1690:	080a0efd 	.word	0x080a0efd
 80a1694:	080a0451 	.word	0x080a0451
 80a1698:	080a0455 	.word	0x080a0455
 80a169c:	20000c88 	.word	0x20000c88
 80a16a0:	080a1015 	.word	0x080a1015
 80a16a4:	20000ca4 	.word	0x20000ca4
 80a16a8:	080a044d 	.word	0x080a044d
 80a16ac:	20000c6c 	.word	0x20000c6c
 80a16b0:	080a0485 	.word	0x080a0485
 80a16b4:	20000cdc 	.word	0x20000cdc
 80a16b8:	080a0491 	.word	0x080a0491
 80a16bc:	20000cf8 	.word	0x20000cf8
 80a16c0:	20000d14 	.word	0x20000d14

080a16c4 <_ZN10rfidReader15setupCardReaderEv>:
parameters: none
returns: none
*/
void rfidReader::setupCardReader(void){
    //sets the card ID to zero. 
    cardID[0] = 0;
 80a16c4:	2300      	movs	r3, #0
void rfidReader::setupCardReader(void){
 80a16c6:	b510      	push	{r4, lr}
 80a16c8:	4604      	mov	r4, r0
    cardID[0] = 0;
 80a16ca:	7383      	strb	r3, [r0, #14]
    cardID[1] = 0;
 80a16cc:	73c3      	strb	r3, [r0, #15]
    cardID[2] = 0;
 80a16ce:	7403      	strb	r3, [r0, #16]
    cardID[3] = 0;
 80a16d0:	7443      	strb	r3, [r0, #17]
    mfrc522.setSPIConfig();//configures SPI settings. 
 80a16d2:	f002 fdef 	bl	80a42b4 <_ZN7MFRC52212setSPIConfigEv>
    mfrc522.PCD_Init();        // Init MFRC522 card
 80a16d6:	4620      	mov	r0, r4
 80a16d8:	f002 fae9 	bl	80a3cae <_ZN7MFRC5228PCD_InitEv>
    delay(500);//delays the whole program. 
}
 80a16dc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    delay(500);//delays the whole program. 
 80a16e0:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80a16e4:	f005 b912 	b.w	80a690c <delay>

080a16e8 <_ZN10rfidReader10readCardIDEv>:
function: readCardID()
description: Reads for a card, and changes the current buffer with that caerd. 
parameters: none
returns: none
*/
bool rfidReader::readCardID(void){
 80a16e8:	b538      	push	{r3, r4, r5, lr}
 80a16ea:	4604      	mov	r4, r0
    MFRC522::MIFARE_Key key;
    for (byte i = 0; i < 6; i++) {
            key.keyByte[i] = 0xFF;
    }
    // Look for new cards
    if ( ! mfrc522.PICC_IsNewCardPresent()) {
 80a16ec:	f002 fc59 	bl	80a3fa2 <_ZN7MFRC52221PICC_IsNewCardPresentEv>
 80a16f0:	b910      	cbnz	r0, 80a16f8 <_ZN10rfidReader10readCardIDEv+0x10>
            return false ;
 80a16f2:	2500      	movs	r5, #0
    // Stop encryption on PCD
    mfrc522.PCD_StopCrypto1();
    
    // Return boolean status that tells us if our card matched. 
    return cardMatch;
}
 80a16f4:	4628      	mov	r0, r5
 80a16f6:	bd38      	pop	{r3, r4, r5, pc}
    if ( ! mfrc522.PICC_ReadCardSerial()) {
 80a16f8:	4620      	mov	r0, r4
 80a16fa:	f002 fdb0 	bl	80a425e <_ZN7MFRC52219PICC_ReadCardSerialEv>
 80a16fe:	2800      	cmp	r0, #0
 80a1700:	d0f7      	beq.n	80a16f2 <_ZN10rfidReader10readCardIDEv+0xa>
    cardID[0] = mfrc522.uid.uidByte[0];
 80a1702:	7861      	ldrb	r1, [r4, #1]
    cardID[1] = mfrc522.uid.uidByte[1];
 80a1704:	78a2      	ldrb	r2, [r4, #2]
    cardID[2] = mfrc522.uid.uidByte[2];
 80a1706:	78e3      	ldrb	r3, [r4, #3]
    cardID[3] = mfrc522.uid.uidByte[3];
 80a1708:	7925      	ldrb	r5, [r4, #4]
    if(cardID[0] == 228 && cardID[1] == 60 && cardID[2] == 38 && cardID[3] == 235){
 80a170a:	29e4      	cmp	r1, #228	; 0xe4
    cardID[0] = mfrc522.uid.uidByte[0];
 80a170c:	73a1      	strb	r1, [r4, #14]
    cardID[1] = mfrc522.uid.uidByte[1];
 80a170e:	73e2      	strb	r2, [r4, #15]
    cardID[2] = mfrc522.uid.uidByte[2];
 80a1710:	7423      	strb	r3, [r4, #16]
    cardID[3] = mfrc522.uid.uidByte[3];
 80a1712:	7465      	strb	r5, [r4, #17]
    if(cardID[0] == 228 && cardID[1] == 60 && cardID[2] == 38 && cardID[3] == 235){
 80a1714:	d10e      	bne.n	80a1734 <_ZN10rfidReader10readCardIDEv+0x4c>
 80a1716:	2a3c      	cmp	r2, #60	; 0x3c
 80a1718:	d10c      	bne.n	80a1734 <_ZN10rfidReader10readCardIDEv+0x4c>
 80a171a:	2b26      	cmp	r3, #38	; 0x26
 80a171c:	d10a      	bne.n	80a1734 <_ZN10rfidReader10readCardIDEv+0x4c>
 80a171e:	f1a5 03eb 	sub.w	r3, r5, #235	; 0xeb
 80a1722:	425d      	negs	r5, r3
 80a1724:	415d      	adcs	r5, r3
    mfrc522.PICC_HaltA();
 80a1726:	4620      	mov	r0, r4
 80a1728:	f002 fda2 	bl	80a4270 <_ZN7MFRC52210PICC_HaltAEv>
    mfrc522.PCD_StopCrypto1();
 80a172c:	4620      	mov	r0, r4
 80a172e:	f002 fa5a 	bl	80a3be6 <_ZN7MFRC52215PCD_StopCrypto1Ev>
    return cardMatch;
 80a1732:	e7df      	b.n	80a16f4 <_ZN10rfidReader10readCardIDEv+0xc>
    bool cardMatch = false; 
 80a1734:	2500      	movs	r5, #0
 80a1736:	e7f6      	b.n	80a1726 <_ZN10rfidReader10readCardIDEv+0x3e>

080a1738 <_ZN9HMIScreen5setupEv>:
function: setup()
description: set's up whatever possible with the HMI
parameters: none
returns: none
*/
void HMIScreen::setup(void){
 80a1738:	b510      	push	{r4, lr}
    nexInit();//sets up the HMI initialization sequence
 80a173a:	f44f 5016 	mov.w	r0, #9600	; 0x2580
 80a173e:	f000 fa1d 	bl	80a1b7c <_Z7nexInitm>
    setBaudrate(115200);//sets to the fastest baud rate supported by the HMI
 80a1742:	f44f 30e1 	mov.w	r0, #115200	; 0x1c200
 80a1746:	f000 fab9 	bl	80a1cbc <_Z11setBaudratem>
    
    sendCommand("sleep=0");
 80a174a:	480c      	ldr	r0, [pc, #48]	; (80a177c <_ZN9HMIScreen5setupEv+0x44>)
 80a174c:	f000 f9d8 	bl	80a1b00 <_Z11sendCommandPKc>
    delay(100);
 80a1750:	2064      	movs	r0, #100	; 0x64
 80a1752:	f005 f8db 	bl	80a690c <delay>
    sendCommand("dim=60");
    delay(100);
    sendCommand("page 4");
 80a1756:	4c0a      	ldr	r4, [pc, #40]	; (80a1780 <_ZN9HMIScreen5setupEv+0x48>)
    sendCommand("dim=60");
 80a1758:	480a      	ldr	r0, [pc, #40]	; (80a1784 <_ZN9HMIScreen5setupEv+0x4c>)
 80a175a:	f000 f9d1 	bl	80a1b00 <_Z11sendCommandPKc>
    delay(100);
 80a175e:	2064      	movs	r0, #100	; 0x64
 80a1760:	f005 f8d4 	bl	80a690c <delay>
    sendCommand("page 4");
 80a1764:	4620      	mov	r0, r4
 80a1766:	f000 f9cb 	bl	80a1b00 <_Z11sendCommandPKc>
    delay(100);
 80a176a:	2064      	movs	r0, #100	; 0x64
 80a176c:	f005 f8ce 	bl	80a690c <delay>
    sendCommand("page 4");
 80a1770:	4620      	mov	r0, r4
        
}
 80a1772:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    sendCommand("page 4");
 80a1776:	f000 b9c3 	b.w	80a1b00 <_Z11sendCommandPKc>
 80a177a:	bf00      	nop
 80a177c:	080a96ed 	.word	0x080a96ed
 80a1780:	080a96fc 	.word	0x080a96fc
 80a1784:	080a96f5 	.word	0x080a96f5

080a1788 <_ZN9HMIScreen4homeEv>:
description: brings the HMI home!
parameters: none
returns: none
*/
void HMIScreen::home(void){
    sendCommand("page 0");
 80a1788:	4801      	ldr	r0, [pc, #4]	; (80a1790 <_ZN9HMIScreen4homeEv+0x8>)
 80a178a:	f000 b9b9 	b.w	80a1b00 <_Z11sendCommandPKc>
 80a178e:	bf00      	nop
 80a1790:	080a9703 	.word	0x080a9703

080a1794 <_ZN9HMIScreen4wakeEv>:
function: wake()
description: wakes up the HMI!
parameters: none
returns: none
*/
void HMIScreen::wake(void){
 80a1794:	b508      	push	{r3, lr}
    sendCommand("sleep = 0");
 80a1796:	4804      	ldr	r0, [pc, #16]	; (80a17a8 <_ZN9HMIScreen4wakeEv+0x14>)
 80a1798:	f000 f9b2 	bl	80a1b00 <_Z11sendCommandPKc>
    sendCommand("dim = 50");
}
 80a179c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    sendCommand("dim = 50");
 80a17a0:	4802      	ldr	r0, [pc, #8]	; (80a17ac <_ZN9HMIScreen4wakeEv+0x18>)
 80a17a2:	f000 b9ad 	b.w	80a1b00 <_Z11sendCommandPKc>
 80a17a6:	bf00      	nop
 80a17a8:	080a970a 	.word	0x080a970a
 80a17ac:	080a9714 	.word	0x080a9714

080a17b0 <_ZN9HMIScreen5sleepEv>:
function: sleep()
description: sleeps the HMI!
parameters: none
returns: none
*/
void HMIScreen::sleep(void){
 80a17b0:	b508      	push	{r3, lr}
    sendCommand("sleep = 1");
 80a17b2:	4804      	ldr	r0, [pc, #16]	; (80a17c4 <_ZN9HMIScreen5sleepEv+0x14>)
 80a17b4:	f000 f9a4 	bl	80a1b00 <_Z11sendCommandPKc>
    sendCommand("dim = 0");
}
 80a17b8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    sendCommand("dim = 0");
 80a17bc:	4802      	ldr	r0, [pc, #8]	; (80a17c8 <_ZN9HMIScreen5sleepEv+0x18>)
 80a17be:	f000 b99f 	b.w	80a1b00 <_Z11sendCommandPKc>
 80a17c2:	bf00      	nop
 80a17c4:	080a971d 	.word	0x080a971d
 80a17c8:	080a9727 	.word	0x080a9727

080a17cc <_ZN9HMIScreen14setProgressBarEi>:
description: allows us to have a progress bar mode. 
parameters: int x(percentage of the progress bar complete)
returns: none
*/
void HMIScreen::setProgressBar(int x){
    loadingBar.setValue(x);
 80a17cc:	3094      	adds	r0, #148	; 0x94
 80a17ce:	f000 bb83 	b.w	80a1ed8 <_ZN14NexProgressBar8setValueEm>
	...

080a17d4 <_ZN9HMIScreen4lockEv>:
function: lock()
description: set's hmi to lock screen
parameters: none
returns: none
*/
void HMIScreen::lock(void){
 80a17d4:	b508      	push	{r3, lr}
    sendCommand("page 13");
 80a17d6:	4804      	ldr	r0, [pc, #16]	; (80a17e8 <_ZN9HMIScreen4lockEv+0x14>)
 80a17d8:	f000 f992 	bl	80a1b00 <_Z11sendCommandPKc>
    sendCommand("dim=20");
}
 80a17dc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    sendCommand("dim=20");
 80a17e0:	4802      	ldr	r0, [pc, #8]	; (80a17ec <_ZN9HMIScreen4lockEv+0x18>)
 80a17e2:	f000 b98d 	b.w	80a1b00 <_Z11sendCommandPKc>
 80a17e6:	bf00      	nop
 80a17e8:	080a972f 	.word	0x080a972f
 80a17ec:	080a9737 	.word	0x080a9737

080a17f0 <_ZN9HMIScreen3runEv>:
description: used to search and wait for callbacks from the HMI
parameters: none
returns: none
*/
void HMIScreen::run(void){
    nexLoop(this->nex_listen_list);//listens out for events attached to the HMI interface. 
 80a17f0:	f500 6026 	add.w	r0, r0, #2656	; 0xa60
 80a17f4:	f000 b9e4 	b.w	80a1bc0 <_Z7nexLoopPP8NexTouch>

080a17f8 <_ZN8LEDRelay13setupLEDStripEv>:
function: setupLEDStrip()
description: sets the pin definitions and tests the LED strip relay
parameters: none
returns: none
*/
void LEDRelay::setupLEDStrip(void){
 80a17f8:	b538      	push	{r3, r4, r5, lr}
 80a17fa:	4604      	mov	r4, r0
    pinMode(WKP, OUTPUT);//setups WKP pin as an output, rather than a wakeup pin
    this->ledStripStatus = false; //ledStripStatus is disabled. 
 80a17fc:	2500      	movs	r5, #0
    pinMode(WKP, OUTPUT);//setups WKP pin as an output, rather than a wakeup pin
 80a17fe:	2101      	movs	r1, #1
 80a1800:	2011      	movs	r0, #17
 80a1802:	f005 fec9 	bl	80a7598 <pinMode>
    digitalWrite(WKP, HIGH);
 80a1806:	2101      	movs	r1, #1
 80a1808:	2011      	movs	r0, #17
    this->ledStripStatus = false; //ledStripStatus is disabled. 
 80a180a:	7025      	strb	r5, [r4, #0]
    digitalWrite(WKP, HIGH);
 80a180c:	f005 fed5 	bl	80a75ba <digitalWrite>
    delay(500);
 80a1810:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80a1814:	f005 f87a 	bl	80a690c <delay>
    digitalWrite(WKP, LOW);
 80a1818:	4629      	mov	r1, r5
}
 80a181a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    digitalWrite(WKP, LOW);
 80a181e:	2011      	movs	r0, #17
 80a1820:	f005 becb 	b.w	80a75ba <digitalWrite>

080a1824 <_ZN8LEDRelay6toggleEv>:
description: toggles the LED. 
parameters: none
returns: none
*/
void LEDRelay::toggle(void){
    this->ledStripStatus =! this->ledStripStatus; 
 80a1824:	7801      	ldrb	r1, [r0, #0]
 80a1826:	f081 0101 	eor.w	r1, r1, #1
 80a182a:	7001      	strb	r1, [r0, #0]
    digitalWrite(WKP, this->ledStripStatus);
 80a182c:	2011      	movs	r0, #17
 80a182e:	f005 bec4 	b.w	80a75ba <digitalWrite>

080a1832 <_ZN8LEDRelay6setLEDEb>:
description: turns on or off LED
parameters: none
returns: none
*/
void LEDRelay::setLED(bool LED){
    this->ledStripStatus = LED;
 80a1832:	7001      	strb	r1, [r0, #0]
    digitalWrite(WKP, LED);
 80a1834:	2011      	movs	r0, #17
 80a1836:	f005 bec0 	b.w	80a75ba <digitalWrite>

080a183a <_ZN17notificationLight9setupLEDsEv>:
function: setupLEDs()
description: startup sequence for setting up the RGB LED strip on the front of the heart. 
parameters: none
returns: none
*/
void notificationLight::setupLEDs(void){
 80a183a:	b510      	push	{r4, lr}
 80a183c:	4604      	mov	r4, r0
    this->rgb.setBrightness(BRIGHTNESS);
 80a183e:	2128      	movs	r1, #40	; 0x28
 80a1840:	f002 f91d 	bl	80a3a7e <_ZN17Adafruit_NeoPixel13setBrightnessEh>
    this->rgb.begin();
 80a1844:	4620      	mov	r0, r4
 80a1846:	f001 f809 	bl	80a285c <_ZN17Adafruit_NeoPixel5beginEv>
    this->rgb.show(); // Initialize all pixels to 'off'
 80a184a:	4620      	mov	r0, r4
}
 80a184c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    this->rgb.show(); // Initialize all pixels to 'off'
 80a1850:	f001 b83a 	b.w	80a28c8 <_ZN17Adafruit_NeoPixel4showEv>

080a1854 <_ZN17notificationLight8setStripEhhh>:
function: setStrip(int red, int green, int blue)
description: sets the entire strip to a single RGB value
parameters: int red, int green, int blue 
returns: none
*/
void notificationLight::setStrip(uint8_t red, uint8_t green, uint8_t blue){
 80a1854:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 80a1858:	4604      	mov	r4, r0
 80a185a:	460e      	mov	r6, r1
 80a185c:	4617      	mov	r7, r2
 80a185e:	4698      	mov	r8, r3
    for(int i = 0; i < PIXEL_COUNT; i++)
 80a1860:	2500      	movs	r5, #0
    {
        this->rgb.setPixelColor(i, red, green, blue);
 80a1862:	b2a9      	uxth	r1, r5
 80a1864:	463b      	mov	r3, r7
 80a1866:	4632      	mov	r2, r6
 80a1868:	4620      	mov	r0, r4
 80a186a:	f8cd 8000 	str.w	r8, [sp]
    for(int i = 0; i < PIXEL_COUNT; i++)
 80a186e:	3501      	adds	r5, #1
        this->rgb.setPixelColor(i, red, green, blue);
 80a1870:	f002 f8da 	bl	80a3a28 <_ZN17Adafruit_NeoPixel13setPixelColorEthhh>
    for(int i = 0; i < PIXEL_COUNT; i++)
 80a1874:	2d18      	cmp	r5, #24
 80a1876:	d1f4      	bne.n	80a1862 <_ZN17notificationLight8setStripEhhh+0xe>
    }
    this->rgb.show();
 80a1878:	4620      	mov	r0, r4
}
 80a187a:	b002      	add	sp, #8
 80a187c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    this->rgb.show();
 80a1880:	f001 b822 	b.w	80a28c8 <_ZN17Adafruit_NeoPixel4showEv>

080a1884 <_ZN17notificationLight6setLEDEthhh>:
function: setLED(int l, int)
description: set's a specific LED to a specific color
parameters: uint16_t l(position), uint8_t r, uint8_t g, uint8_t b
returns: none
*/
void notificationLight::setLED(uint16_t l, uint8_t r, uint8_t g, uint8_t b){
 80a1884:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a1886:	4604      	mov	r4, r0
 80a1888:	f89d 5018 	ldrb.w	r5, [sp, #24]
    this->rgb.setPixelColor(l, r, g, b);
 80a188c:	9500      	str	r5, [sp, #0]
 80a188e:	f002 f8cb 	bl	80a3a28 <_ZN17Adafruit_NeoPixel13setPixelColorEthhh>
    this->rgb.show();
 80a1892:	4620      	mov	r0, r4
    
}
 80a1894:	b003      	add	sp, #12
 80a1896:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    this->rgb.show();
 80a189a:	f001 b815 	b.w	80a28c8 <_ZN17Adafruit_NeoPixel4showEv>

080a189e <_ZN17notificationLight8wakeLEDSEv>:
function: wakeLEDs()
description: set's the brightness and re-displays whatever content that was on the screen
parameters: none
returns: none
*/
void notificationLight::wakeLEDS(void){
 80a189e:	b510      	push	{r4, lr}
 80a18a0:	4604      	mov	r4, r0
    this->rgb.setBrightness(BRIGHTNESS);
 80a18a2:	2128      	movs	r1, #40	; 0x28
 80a18a4:	f002 f8eb 	bl	80a3a7e <_ZN17Adafruit_NeoPixel13setBrightnessEh>
    this->rgb.show();
 80a18a8:	4620      	mov	r0, r4
}
 80a18aa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    this->rgb.show();
 80a18ae:	f001 b80b 	b.w	80a28c8 <_ZN17Adafruit_NeoPixel4showEv>

080a18b2 <_ZN17notificationLight12playWithLEDSEv>:
description: fills in the LED's to random differnet colors 
parameters: none
returns: none
*/
void notificationLight::playWithLEDS(void)
{
 80a18b2:	b513      	push	{r0, r1, r4, lr}
    if (this->playPixelCursor % 4 == 0)
 80a18b4:	8a83      	ldrh	r3, [r0, #20]
{
 80a18b6:	4604      	mov	r4, r0
    if (this->playPixelCursor % 4 == 0)
 80a18b8:	079b      	lsls	r3, r3, #30
 80a18ba:	d108      	bne.n	80a18ce <_ZN17notificationLight12playWithLEDSEv+0x1c>
        this->playColorCursor = rand() % 3;
 80a18bc:	f007 f840 	bl	80a8940 <rand>
 80a18c0:	2303      	movs	r3, #3
 80a18c2:	fb90 f3f3 	sdiv	r3, r0, r3
 80a18c6:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80a18ca:	1ac0      	subs	r0, r0, r3
 80a18cc:	82e0      	strh	r0, [r4, #22]
   
    switch(playColorCursor){
 80a18ce:	8ae3      	ldrh	r3, [r4, #22]
 80a18d0:	8aa1      	ldrh	r1, [r4, #20]
 80a18d2:	2b01      	cmp	r3, #1
 80a18d4:	d012      	beq.n	80a18fc <_ZN17notificationLight12playWithLEDSEv+0x4a>
 80a18d6:	2b02      	cmp	r3, #2
 80a18d8:	d017      	beq.n	80a190a <_ZN17notificationLight12playWithLEDSEv+0x58>
 80a18da:	b933      	cbnz	r3, 80a18ea <_ZN17notificationLight12playWithLEDSEv+0x38>
        case 0:
            this->setLED(playPixelCursor, 138, 43, 226);
 80a18dc:	23e2      	movs	r3, #226	; 0xe2
 80a18de:	228a      	movs	r2, #138	; 0x8a
 80a18e0:	9300      	str	r3, [sp, #0]
 80a18e2:	4620      	mov	r0, r4
 80a18e4:	232b      	movs	r3, #43	; 0x2b
 80a18e6:	f7ff ffcd 	bl	80a1884 <_ZN17notificationLight6setLEDEthhh>
            break;
        default:
            break;
    }
    
    this->playPixelCursor++;
 80a18ea:	8aa3      	ldrh	r3, [r4, #20]
 80a18ec:	3301      	adds	r3, #1
 80a18ee:	b29b      	uxth	r3, r3
    
    if(this->playPixelCursor > 24)
 80a18f0:	2b18      	cmp	r3, #24
        this->playPixelCursor = 0;
 80a18f2:	bf88      	it	hi
 80a18f4:	2300      	movhi	r3, #0
 80a18f6:	82a3      	strh	r3, [r4, #20]
 80a18f8:	b002      	add	sp, #8
 80a18fa:	bd10      	pop	{r4, pc}
            this->setLED(playPixelCursor, 100, 10, 10);
 80a18fc:	230a      	movs	r3, #10
 80a18fe:	2264      	movs	r2, #100	; 0x64
 80a1900:	4620      	mov	r0, r4
 80a1902:	9300      	str	r3, [sp, #0]
 80a1904:	f7ff ffbe 	bl	80a1884 <_ZN17notificationLight6setLEDEthhh>
            break;
 80a1908:	e7ef      	b.n	80a18ea <_ZN17notificationLight12playWithLEDSEv+0x38>
            this->setLED(playPixelCursor, 100, 80, 100);
 80a190a:	2264      	movs	r2, #100	; 0x64
 80a190c:	2350      	movs	r3, #80	; 0x50
 80a190e:	4620      	mov	r0, r4
 80a1910:	9200      	str	r2, [sp, #0]
 80a1912:	f7ff ffb7 	bl	80a1884 <_ZN17notificationLight6setLEDEthhh>
            break;
 80a1916:	e7e8      	b.n	80a18ea <_ZN17notificationLight12playWithLEDSEv+0x38>

080a1918 <_ZN9IMUSensor10setupAccelEv>:
function: setupAccel()
description: initializes accelerometer sensor on the i2c bus. 
parameters: none
returns: none
*/
void IMUSensor::setupAccel(void){
 80a1918:	b510      	push	{r4, lr}
    if (! this->lis.begin(0x18))
 80a191a:	2118      	movs	r1, #24
void IMUSensor::setupAccel(void){
 80a191c:	4604      	mov	r4, r0
    if (! this->lis.begin(0x18))
 80a191e:	f000 fc3e 	bl	80a219e <_ZN15Adafruit_LIS3DH5beginEh>
 80a1922:	b908      	cbnz	r0, 80a1928 <_ZN9IMUSensor10setupAccelEv+0x10>
        System.reset();
 80a1924:	f005 fd8c 	bl	80a7440 <_ZN11SystemClass5resetEv>
        // If the accelerometer doesn't sync, then the system resets!
    
    // Sets default listening modes.     
    this->lis.setRange(LIS3DH_RANGE_4_G);   // 2, 4, 8 or 16 G!
 80a1928:	4620      	mov	r0, r4
 80a192a:	2101      	movs	r1, #1
 80a192c:	f000 fc0e 	bl	80a214c <_ZN15Adafruit_LIS3DH8setRangeE14lis3dh_range_t>
    delay(20);
}
 80a1930:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    delay(20);
 80a1934:	2014      	movs	r0, #20
 80a1936:	f004 bfe9 	b.w	80a690c <delay>
	...

080a193c <_GLOBAL__sub_I__ZN9IMUSensor10setupAccelEv>:
 80a193c:	2200      	movs	r2, #0
 80a193e:	4b01      	ldr	r3, [pc, #4]	; (80a1944 <_GLOBAL__sub_I__ZN9IMUSensor10setupAccelEv+0x8>)
 80a1940:	701a      	strb	r2, [r3, #0]
void IMUSensor::pushAccelData(const char *event, const char *data){
    this->readAccel();
    String str = String(this->xAccel()) + " " + String(this->yAccel()) + " " + String(this->zAccel());
    delay(40);
    Particle.publish("Accel Data", str);
 80a1942:	4770      	bx	lr
 80a1944:	20000d68 	.word	0x20000d68

080a1948 <_ZN8NexTouchC1EhhPKcPv>:
*/

#include "NexTouch.h"


NexTouch::NexTouch(uint8_t pid, uint8_t cid, const char *name, void *value)
 80a1948:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a194a:	4604      	mov	r4, r0
    :NexObject(pid, cid, name, value)
 80a194c:	9d06      	ldr	r5, [sp, #24]
 80a194e:	9500      	str	r5, [sp, #0]
 80a1950:	f000 fa8b 	bl	80a1e6a <_ZN9NexObjectC1EhhPKcPv>
{
    this->__cb_push = NULL;
 80a1954:	2300      	movs	r3, #0
    this->__cb_pop = NULL;
    this->__cb_value = NULL;
    this->__cbpop_ptr = NULL;
    this->__cbpush_ptr = NULL;
    this->__cbvalue_ptr = NULL;
}
 80a1956:	4620      	mov	r0, r4
    this->__cbpop_ptr = NULL;
 80a1958:	e9c4 3306 	strd	r3, r3, [r4, #24]
    this->__cb_push = NULL;
 80a195c:	60e3      	str	r3, [r4, #12]
    this->__cb_pop = NULL;
 80a195e:	6163      	str	r3, [r4, #20]
    this->__cbpush_ptr = NULL;
 80a1960:	6123      	str	r3, [r4, #16]
    this->__cbvalue_ptr = NULL;
 80a1962:	6223      	str	r3, [r4, #32]
}
 80a1964:	b003      	add	sp, #12
 80a1966:	bd30      	pop	{r4, r5, pc}

080a1968 <_ZN8NexTouch10attachPushEPFvPvES0_>:

void NexTouch::attachPush(NexTouchEventCb push, void *ptr)
{
    this->__cb_push = push;
    this->__cbpush_ptr = ptr;
 80a1968:	e9c0 1203 	strd	r1, r2, [r0, #12]
}
 80a196c:	4770      	bx	lr

080a196e <_ZN8NexTouch9attachPopEPFvPvES0_>:
}

void NexTouch::attachPop(NexTouchEventCb pop, void *ptr)
{
    this->__cb_pop = pop;
    this->__cbpop_ptr = ptr;
 80a196e:	e9c0 1205 	strd	r1, r2, [r0, #20]
}
 80a1972:	4770      	bx	lr

080a1974 <_ZN8NexTouch4pushEv>:
    this->__cbvalue_ptr = NULL;
}

void NexTouch::push(void)
{
    if (__cb_push)
 80a1974:	68c3      	ldr	r3, [r0, #12]
 80a1976:	b10b      	cbz	r3, 80a197c <_ZN8NexTouch4pushEv+0x8>
    {
        __cb_push(__cbpush_ptr);
 80a1978:	6900      	ldr	r0, [r0, #16]
 80a197a:	4718      	bx	r3
    }
}
 80a197c:	4770      	bx	lr

080a197e <_ZN8NexTouch3popEv>:

void NexTouch::pop(void)
{
    if (__cb_pop)
 80a197e:	6943      	ldr	r3, [r0, #20]
 80a1980:	b10b      	cbz	r3, 80a1986 <_ZN8NexTouch3popEv+0x8>
    {
        __cb_pop(__cbpop_ptr);
 80a1982:	6980      	ldr	r0, [r0, #24]
 80a1984:	4718      	bx	r3
    }
}
 80a1986:	4770      	bx	lr

080a1988 <_ZN8NexTouch5valueEhPv>:

void NexTouch::value(uint8_t type, void *value)
{
 80a1988:	b510      	push	{r4, lr}
 80a198a:	4604      	mov	r4, r0
    ((NexObject *)__cbvalue_ptr)->setObjValue(type, value);
 80a198c:	6a00      	ldr	r0, [r0, #32]
 80a198e:	f000 fa73 	bl	80a1e78 <_ZN9NexObject11setObjValueEhPv>

    if (__cb_value)
 80a1992:	69e3      	ldr	r3, [r4, #28]
 80a1994:	b11b      	cbz	r3, 80a199e <_ZN8NexTouch5valueEhPv+0x16>
    {
        __cb_value(__cbvalue_ptr);
 80a1996:	6a20      	ldr	r0, [r4, #32]
    }
}
 80a1998:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        __cb_value(__cbvalue_ptr);
 80a199c:	4718      	bx	r3
}
 80a199e:	bd10      	pop	{r4, pc}

080a19a0 <_ZN8NexTouch7iterateEPPS_hhlPv>:
void NexTouch::iterate(NexTouch **list, uint8_t pid, uint8_t cid, int32_t event, void *value)
{
 80a19a0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80a19a4:	f8dd a020 	ldr.w	sl, [sp, #32]
 80a19a8:	4688      	mov	r8, r1
 80a19aa:	4691      	mov	r9, r2
 80a19ac:	461d      	mov	r5, r3
    NexTouch *e = NULL;
    uint16_t i = 0;

    if (NULL == list)
 80a19ae:	4606      	mov	r6, r0
 80a19b0:	b358      	cbz	r0, 80a1a0a <_ZN8NexTouch7iterateEPPS_hhlPv+0x6a>
 80a19b2:	2700      	movs	r7, #0
    {
        return;
    }
    
    for(i = 0; (e = list[i]) != NULL; i++)
 80a19b4:	b2bb      	uxth	r3, r7
 80a19b6:	f856 4023 	ldr.w	r4, [r6, r3, lsl #2]
 80a19ba:	b334      	cbz	r4, 80a1a0a <_ZN8NexTouch7iterateEPPS_hhlPv+0x6a>
    {
        if (e->getObjPid() == pid && e->getObjCid() == cid)
 80a19bc:	4620      	mov	r0, r4
 80a19be:	f000 fa62 	bl	80a1e86 <_ZN9NexObject9getObjPidEv>
 80a19c2:	4580      	cmp	r8, r0
 80a19c4:	d10e      	bne.n	80a19e4 <_ZN8NexTouch7iterateEPPS_hhlPv+0x44>
 80a19c6:	4620      	mov	r0, r4
 80a19c8:	f000 fa5f 	bl	80a1e8a <_ZN9NexObject9getObjCidEv>
 80a19cc:	4581      	cmp	r9, r0
 80a19ce:	d109      	bne.n	80a19e4 <_ZN8NexTouch7iterateEPPS_hhlPv+0x44>
        {
            e->printObjInfo();
 80a19d0:	4620      	mov	r0, r4
 80a19d2:	f000 fa5c 	bl	80a1e8e <_ZN9NexObject12printObjInfoEv>
            if (NEX_EVENT_PUSH == event)
 80a19d6:	2d01      	cmp	r5, #1
 80a19d8:	d106      	bne.n	80a19e8 <_ZN8NexTouch7iterateEPPS_hhlPv+0x48>
            {
                e->push();
 80a19da:	4620      	mov	r0, r4
            }
            
            break;
        }
    }
}
 80a19dc:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
                e->push();
 80a19e0:	f7ff bfc8 	b.w	80a1974 <_ZN8NexTouch4pushEv>
    for(i = 0; (e = list[i]) != NULL; i++)
 80a19e4:	3701      	adds	r7, #1
 80a19e6:	e7e5      	b.n	80a19b4 <_ZN8NexTouch7iterateEPPS_hhlPv+0x14>
            else if (NEX_EVENT_POP == event)
 80a19e8:	b925      	cbnz	r5, 80a19f4 <_ZN8NexTouch7iterateEPPS_hhlPv+0x54>
                e->pop();
 80a19ea:	4620      	mov	r0, r4
}
 80a19ec:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
                e->pop();
 80a19f0:	f7ff bfc5 	b.w	80a197e <_ZN8NexTouch3popEv>
            else if (NEX_EVENT_VALUE == event)
 80a19f4:	2d02      	cmp	r5, #2
 80a19f6:	d106      	bne.n	80a1a06 <_ZN8NexTouch7iterateEPPS_hhlPv+0x66>
                e->value(NEX_EVENT_STRING, value);
 80a19f8:	4652      	mov	r2, sl
 80a19fa:	4629      	mov	r1, r5
 80a19fc:	4620      	mov	r0, r4
}
 80a19fe:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
                e->value(NEX_EVENT_STRING, value);
 80a1a02:	f7ff bfc1 	b.w	80a1988 <_ZN8NexTouch5valueEhPv>
            else if (NEX_EVENT_STRING == event)
 80a1a06:	2d03      	cmp	r5, #3
 80a1a08:	d0f6      	beq.n	80a19f8 <_ZN8NexTouch7iterateEPPS_hhlPv+0x58>
}
 80a1a0a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

080a1a0e <_ZN7NexTextC1EhhPKcPv>:
* by BSpranger & ScruffR (Dec. 2015)
*/

#include "NexText.h"

NexText::NexText(uint8_t pid, uint8_t cid, const char *name, void *value)
 80a1a0e:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a1a10:	4604      	mov	r4, r0
    :NexTouch(pid, cid, name, value)
 80a1a12:	9d06      	ldr	r5, [sp, #24]
 80a1a14:	9500      	str	r5, [sp, #0]
 80a1a16:	f7ff ff97 	bl	80a1948 <_ZN8NexTouchC1EhhPKcPv>
{
}
 80a1a1a:	4620      	mov	r0, r4
 80a1a1c:	b003      	add	sp, #12
 80a1a1e:	bd30      	pop	{r4, r5, pc}

080a1a20 <_ZN7NexText7getTextEPct>:

uint16_t NexText::getText(char *buffer, uint16_t len)
{
 80a1a20:	4613      	mov	r3, r2
  return NexObject::getString(NexTEXT, buffer, len);
 80a1a22:	460a      	mov	r2, r1
 80a1a24:	4901      	ldr	r1, [pc, #4]	; (80a1a2c <_ZN7NexText7getTextEPct+0xc>)
 80a1a26:	f000 ba36 	b.w	80a1e96 <_ZN9NexObject9getStringEPKcPct>
 80a1a2a:	bf00      	nop
 80a1a2c:	080a973e 	.word	0x080a973e

080a1a30 <_ZN7NexText7setTextEPKc>:
  //sendCommand(cmd);
  //return recvRetString(text, len);
}

bool NexText::setText(const char *buffer)
{
 80a1a30:	460a      	mov	r2, r1
  return NexObject::setString(NexTEXT, buffer);
 80a1a32:	4901      	ldr	r1, [pc, #4]	; (80a1a38 <_ZN7NexText7setTextEPKc+0x8>)
 80a1a34:	f000 ba32 	b.w	80a1e9c <_ZN9NexObject9setStringEPKcS1_>
 80a1a38:	080a973e 	.word	0x080a973e

080a1a3c <_Z13recvRetStringPctm>:
 *
 * @return the length of string buffer.
 *
 */
uint16_t recvRetString(char *buffer, uint16_t len, uint32_t timeout)
{
 80a1a3c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a1a40:	b085      	sub	sp, #20
 80a1a42:	460c      	mov	r4, r1
  uint16_t bufIdx = 0;
  //uint16_t tempIdx = 0;
  //char temp[len];
  //memset(temp, 0, len);

  if (!buffer || len == 0)
 80a1a44:	4606      	mov	r6, r0
{
 80a1a46:	9202      	str	r2, [sp, #8]
  if (!buffer || len == 0)
 80a1a48:	2800      	cmp	r0, #0
 80a1a4a:	d050      	beq.n	80a1aee <_Z13recvRetStringPctm+0xb2>
 80a1a4c:	2900      	cmp	r1, #0
 80a1a4e:	d050      	beq.n	80a1af2 <_Z13recvRetStringPctm+0xb6>
  uint16_t bufIdx = 0;
 80a1a50:	2700      	movs	r7, #0
  {
    goto __return;
  }
  memset(buffer, 0, len);
 80a1a52:	460a      	mov	r2, r1
 80a1a54:	2100      	movs	r1, #0
 80a1a56:	f006 ff47 	bl	80a88e8 <memset>
 80a1a5a:	f003 fec1 	bl	80a57e0 <HAL_Timer_Get_Milli_Seconds>
  bool str_start_flag = false;
 80a1a5e:	46b8      	mov	r8, r7
  uint8_t cnt_0xff = 0;
 80a1a60:	463d      	mov	r5, r7
 80a1a62:	f8df 9094 	ldr.w	r9, [pc, #148]	; 80a1af8 <_Z13recvRetStringPctm+0xbc>
  while (cnt_0xff < 3 && millis() - start <= timeout)
  {
#if defined(SPARK)
    Particle.process();
#endif
    while (nexSerial.available())
 80a1a66:	f8df b094 	ldr.w	fp, [pc, #148]	; 80a1afc <_Z13recvRetStringPctm+0xc0>
 80a1a6a:	9001      	str	r0, [sp, #4]
 80a1a6c:	f003 feb8 	bl	80a57e0 <HAL_Timer_Get_Milli_Seconds>
  while (cnt_0xff < 3 && millis() - start <= timeout)
 80a1a70:	9b01      	ldr	r3, [sp, #4]
 80a1a72:	1ac0      	subs	r0, r0, r3
 80a1a74:	9b02      	ldr	r3, [sp, #8]
 80a1a76:	4283      	cmp	r3, r0
 80a1a78:	d327      	bcc.n	80a1aca <_Z13recvRetStringPctm+0x8e>
		return HAL_Timer_Get_Milli_Seconds();
 80a1a7a:	f003 feb1 	bl	80a57e0 <HAL_Timer_Get_Milli_Seconds>
		last_checkin = current_time();
 80a1a7e:	f8c9 0000 	str.w	r0, [r9]
 80a1a82:	f003 ff25 	bl	80a58d0 <spark_process>
          if (cnt_0xff >= 3)
          {
            break;
          }
        }
        else if ((int)bufIdx < len - 1)
 80a1a86:	1e63      	subs	r3, r4, #1
    while (nexSerial.available())
 80a1a88:	f8db a000 	ldr.w	sl, [fp]
        else if ((int)bufIdx < len - 1)
 80a1a8c:	9303      	str	r3, [sp, #12]
    while (nexSerial.available())
 80a1a8e:	f8da 1000 	ldr.w	r1, [sl]
 80a1a92:	4650      	mov	r0, sl
 80a1a94:	6909      	ldr	r1, [r1, #16]
 80a1a96:	4788      	blx	r1
 80a1a98:	b1a8      	cbz	r0, 80a1ac6 <_Z13recvRetStringPctm+0x8a>
		return HAL_Timer_Get_Milli_Seconds();
 80a1a9a:	f003 fea1 	bl	80a57e0 <HAL_Timer_Get_Milli_Seconds>
		last_checkin = current_time();
 80a1a9e:	f8c9 0000 	str.w	r0, [r9]
 80a1aa2:	f003 ff15 	bl	80a58d0 <spark_process>
      c = nexSerial.read();
 80a1aa6:	f8da 1000 	ldr.w	r1, [sl]
 80a1aaa:	4650      	mov	r0, sl
 80a1aac:	6949      	ldr	r1, [r1, #20]
 80a1aae:	4788      	blx	r1
 80a1ab0:	b2c0      	uxtb	r0, r0
      if (str_start_flag)
 80a1ab2:	f1b8 0f00 	cmp.w	r8, #0
 80a1ab6:	d013      	beq.n	80a1ae0 <_Z13recvRetStringPctm+0xa4>
        if (0xFF == c)
 80a1ab8:	28ff      	cmp	r0, #255	; 0xff
 80a1aba:	d10a      	bne.n	80a1ad2 <_Z13recvRetStringPctm+0x96>
          cnt_0xff++;
 80a1abc:	3501      	adds	r5, #1
 80a1abe:	b2ed      	uxtb	r5, r5
          if (cnt_0xff >= 3)
 80a1ac0:	2d02      	cmp	r5, #2
 80a1ac2:	d9e4      	bls.n	80a1a8e <_Z13recvRetStringPctm+0x52>
 80a1ac4:	e001      	b.n	80a1aca <_Z13recvRetStringPctm+0x8e>
  while (cnt_0xff < 3 && millis() - start <= timeout)
 80a1ac6:	2d02      	cmp	r5, #2
 80a1ac8:	d9d0      	bls.n	80a1a6c <_Z13recvRetStringPctm+0x30>
  dbSerialPrint(",");
  dbSerialPrint(buffer);
  dbSerialPrintln("]");

  return ret;
}
 80a1aca:	4638      	mov	r0, r7
 80a1acc:	b005      	add	sp, #20
 80a1ace:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        else if ((int)bufIdx < len - 1)
 80a1ad2:	9b03      	ldr	r3, [sp, #12]
 80a1ad4:	429f      	cmp	r7, r3
 80a1ad6:	dada      	bge.n	80a1a8e <_Z13recvRetStringPctm+0x52>
          buffer[bufIdx++] = (char)c;
 80a1ad8:	1c79      	adds	r1, r7, #1
 80a1ada:	55f0      	strb	r0, [r6, r7]
 80a1adc:	b28f      	uxth	r7, r1
 80a1ade:	e7d6      	b.n	80a1a8e <_Z13recvRetStringPctm+0x52>
      else if (NEX_RET_STRING_HEAD == c)
 80a1ae0:	f1a0 0370 	sub.w	r3, r0, #112	; 0x70
 80a1ae4:	f1d3 0800 	rsbs	r8, r3, #0
 80a1ae8:	eb48 0803 	adc.w	r8, r8, r3
 80a1aec:	e7cf      	b.n	80a1a8e <_Z13recvRetStringPctm+0x52>
  uint16_t ret = 0;
 80a1aee:	4607      	mov	r7, r0
 80a1af0:	e7eb      	b.n	80a1aca <_Z13recvRetStringPctm+0x8e>
 80a1af2:	460f      	mov	r7, r1
 80a1af4:	e7e9      	b.n	80a1aca <_Z13recvRetStringPctm+0x8e>
 80a1af6:	bf00      	nop
 80a1af8:	20000ea0 	.word	0x20000ea0
 80a1afc:	20000cc0 	.word	0x20000cc0

080a1b00 <_Z11sendCommandPKc>:
 * Send command to Nextion.
 *
 * @param cmd - the string of command.
 */
void sendCommand(const char* cmd)
{
 80a1b00:	b538      	push	{r3, r4, r5, lr}
 80a1b02:	4605      	mov	r5, r0
  while (nexSerial.read() >= 0);  // flush RX buffer only
 80a1b04:	4b08      	ldr	r3, [pc, #32]	; (80a1b28 <_Z11sendCommandPKc+0x28>)
 80a1b06:	681c      	ldr	r4, [r3, #0]
 80a1b08:	6823      	ldr	r3, [r4, #0]
 80a1b0a:	4620      	mov	r0, r4
 80a1b0c:	695b      	ldr	r3, [r3, #20]
 80a1b0e:	4798      	blx	r3
 80a1b10:	2800      	cmp	r0, #0
 80a1b12:	daf9      	bge.n	80a1b08 <_Z11sendCommandPKc+0x8>
  nexSerial.print(cmd);
 80a1b14:	4629      	mov	r1, r5
 80a1b16:	4620      	mov	r0, r4
 80a1b18:	f005 fb4a 	bl	80a71b0 <_ZN5Print5printEPKc>
  nexSerial.print(NexCMDTERM);
 80a1b1c:	4620      	mov	r0, r4
  //nexSerial.write(0xFF);
  //nexSerial.write(0xFF);
  //nexSerial.write(0xFF);
}
 80a1b1e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  nexSerial.print(NexCMDTERM);
 80a1b22:	4902      	ldr	r1, [pc, #8]	; (80a1b2c <_Z11sendCommandPKc+0x2c>)
 80a1b24:	f005 bb44 	b.w	80a71b0 <_ZN5Print5printEPKc>
 80a1b28:	20000cc0 	.word	0x20000cc0
 80a1b2c:	080a9742 	.word	0x080a9742

080a1b30 <_Z22recvRetCommandFinishedm>:
 * @retval true - success.
 * @retval false - failed.
 *
 */
bool recvRetCommandFinished(uint32_t timeout)
{
 80a1b30:	b537      	push	{r0, r1, r2, r4, r5, lr}
  bool ret = false;
  uint8_t temp[4] = "";
 80a1b32:	2400      	movs	r4, #0

  nexSerial.setTimeout(timeout);
 80a1b34:	4b10      	ldr	r3, [pc, #64]	; (80a1b78 <_Z22recvRetCommandFinishedm+0x48>)
{
 80a1b36:	4601      	mov	r1, r0
  nexSerial.setTimeout(timeout);
 80a1b38:	681d      	ldr	r5, [r3, #0]
  uint8_t temp[4] = "";
 80a1b3a:	9401      	str	r4, [sp, #4]
  nexSerial.setTimeout(timeout);
 80a1b3c:	4628      	mov	r0, r5
 80a1b3e:	f005 fafe 	bl	80a713e <_ZN6Stream10setTimeoutEm>
  if (sizeof(temp) != nexSerial.readBytes((char *)temp, sizeof(temp)))
 80a1b42:	2204      	movs	r2, #4
 80a1b44:	4628      	mov	r0, r5
 80a1b46:	eb0d 0102 	add.w	r1, sp, r2
 80a1b4a:	f005 fafa 	bl	80a7142 <_ZN6Stream9readBytesEPcj>
  {
    ret = false;
  }

  if (temp[0] == NEX_RET_CMD_FINISHED
 80a1b4e:	f89d 3004 	ldrb.w	r3, [sp, #4]
 80a1b52:	2b01      	cmp	r3, #1
 80a1b54:	d10d      	bne.n	80a1b72 <_Z22recvRetCommandFinishedm+0x42>
    && temp[1] == 0xFF
    && temp[2] == 0xFF
    && temp[3] == 0xFF
 80a1b56:	f89d 4006 	ldrb.w	r4, [sp, #6]
 80a1b5a:	f89d 0005 	ldrb.w	r0, [sp, #5]
 80a1b5e:	4020      	ands	r0, r4
 80a1b60:	f89d 4007 	ldrb.w	r4, [sp, #7]
 80a1b64:	4020      	ands	r0, r4
 80a1b66:	f1a0 03ff 	sub.w	r3, r0, #255	; 0xff
 80a1b6a:	4258      	negs	r0, r3
 80a1b6c:	4158      	adcs	r0, r3
  {
    dbSerialPrintln("recvRetCommandFinished err");
  }

  return ret;
}
 80a1b6e:	b003      	add	sp, #12
 80a1b70:	bd30      	pop	{r4, r5, pc}
 80a1b72:	4620      	mov	r0, r4
 80a1b74:	e7fb      	b.n	80a1b6e <_Z22recvRetCommandFinishedm+0x3e>
 80a1b76:	bf00      	nop
 80a1b78:	20000cc0 	.word	0x20000cc0

080a1b7c <_Z7nexInitm>:
bool nexInit(uint32_t baudrate)
{
  bool ret1 = false;
  bool ret2 = false;

  nexSerial.begin(baudrate);
 80a1b7c:	4b0c      	ldr	r3, [pc, #48]	; (80a1bb0 <_Z7nexInitm+0x34>)
{
 80a1b7e:	4601      	mov	r1, r0
 80a1b80:	b510      	push	{r4, lr}
  nexSerial.begin(baudrate);
 80a1b82:	6818      	ldr	r0, [r3, #0]
 80a1b84:	f004 fa34 	bl	80a5ff0 <_ZN11USARTSerial5beginEm>

  sendCommand("");
 80a1b88:	480a      	ldr	r0, [pc, #40]	; (80a1bb4 <_Z7nexInitm+0x38>)
 80a1b8a:	f7ff ffb9 	bl	80a1b00 <_Z11sendCommandPKc>
  sendCommand("bkcmd=1");  // only return success results
 80a1b8e:	480a      	ldr	r0, [pc, #40]	; (80a1bb8 <_Z7nexInitm+0x3c>)
 80a1b90:	f7ff ffb6 	bl	80a1b00 <_Z11sendCommandPKc>
  ret1 = recvRetCommandFinished();
 80a1b94:	2064      	movs	r0, #100	; 0x64
 80a1b96:	f7ff ffcb 	bl	80a1b30 <_Z22recvRetCommandFinishedm>
 80a1b9a:	4604      	mov	r4, r0
  sendCommand("page 0");   // show home page
 80a1b9c:	4807      	ldr	r0, [pc, #28]	; (80a1bbc <_Z7nexInitm+0x40>)
 80a1b9e:	f7ff ffaf 	bl	80a1b00 <_Z11sendCommandPKc>
  ret2 = recvRetCommandFinished();
 80a1ba2:	2064      	movs	r0, #100	; 0x64
 80a1ba4:	f7ff ffc4 	bl	80a1b30 <_Z22recvRetCommandFinishedm>
  return ret1 && ret2;
 80a1ba8:	2c00      	cmp	r4, #0
}
 80a1baa:	bf08      	it	eq
 80a1bac:	2000      	moveq	r0, #0
 80a1bae:	bd10      	pop	{r4, pc}
 80a1bb0:	20000cc0 	.word	0x20000cc0
 80a1bb4:	080aa420 	.word	0x080aa420
 80a1bb8:	080a9746 	.word	0x080a9746
 80a1bbc:	080a9703 	.word	0x080a9703

080a1bc0 <_Z7nexLoopPP8NexTouch>:

void nexLoop(NexTouch *nex_listen_list[])
{
 80a1bc0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80a1bc2:	4607      	mov	r7, r0
  static uint8_t __buffer[20];

  uint16_t i;
  uint8_t c;

  while (nexSerial.available())
 80a1bc4:	4b39      	ldr	r3, [pc, #228]	; (80a1cac <_Z7nexLoopPP8NexTouch+0xec>)
    else if (NEX_RET_VALUE_HEAD == c)
    {
      dbSerialPrint("value cmd:");
      if (nexSerial.available() >= 10)
      {
        __buffer[0] = c;
 80a1bc6:	4c3a      	ldr	r4, [pc, #232]	; (80a1cb0 <_Z7nexLoopPP8NexTouch+0xf0>)
  while (nexSerial.available())
 80a1bc8:	681d      	ldr	r5, [r3, #0]
 80a1bca:	682b      	ldr	r3, [r5, #0]
 80a1bcc:	4628      	mov	r0, r5
 80a1bce:	691b      	ldr	r3, [r3, #16]
 80a1bd0:	4798      	blx	r3
 80a1bd2:	2800      	cmp	r0, #0
 80a1bd4:	d068      	beq.n	80a1ca8 <_Z7nexLoopPP8NexTouch+0xe8>
		return HAL_Timer_Get_Milli_Seconds();
 80a1bd6:	f003 fe03 	bl	80a57e0 <HAL_Timer_Get_Milli_Seconds>
		last_checkin = current_time();
 80a1bda:	4b36      	ldr	r3, [pc, #216]	; (80a1cb4 <_Z7nexLoopPP8NexTouch+0xf4>)
 80a1bdc:	6018      	str	r0, [r3, #0]
 80a1bde:	f003 fe77 	bl	80a58d0 <spark_process>
    delay(10); 
 80a1be2:	200a      	movs	r0, #10
 80a1be4:	f004 fe92 	bl	80a690c <delay>
    c = nexSerial.read();
 80a1be8:	682b      	ldr	r3, [r5, #0]
 80a1bea:	4628      	mov	r0, r5
 80a1bec:	695b      	ldr	r3, [r3, #20]
 80a1bee:	4798      	blx	r3
 80a1bf0:	682b      	ldr	r3, [r5, #0]
 80a1bf2:	b2c6      	uxtb	r6, r0
    if (NEX_RET_EVENT_TOUCH_HEAD == c)
 80a1bf4:	2e65      	cmp	r6, #101	; 0x65
      if (nexSerial.available() >= 6)
 80a1bf6:	691b      	ldr	r3, [r3, #16]
    if (NEX_RET_EVENT_TOUCH_HEAD == c)
 80a1bf8:	d11a      	bne.n	80a1c30 <_Z7nexLoopPP8NexTouch+0x70>
      if (nexSerial.available() >= 6)
 80a1bfa:	4628      	mov	r0, r5
 80a1bfc:	4798      	blx	r3
 80a1bfe:	2805      	cmp	r0, #5
 80a1c00:	dde3      	ble.n	80a1bca <_Z7nexLoopPP8NexTouch+0xa>
        __buffer[0] = c;
 80a1c02:	7026      	strb	r6, [r4, #0]
 80a1c04:	2601      	movs	r6, #1
          __buffer[i] = nexSerial.read();
 80a1c06:	682b      	ldr	r3, [r5, #0]
 80a1c08:	4628      	mov	r0, r5
 80a1c0a:	695b      	ldr	r3, [r3, #20]
 80a1c0c:	4798      	blx	r3
 80a1c0e:	55a0      	strb	r0, [r4, r6]
        for (i = 1; i < 7; i++)
 80a1c10:	3601      	adds	r6, #1
 80a1c12:	2e07      	cmp	r6, #7
 80a1c14:	d1f7      	bne.n	80a1c06 <_Z7nexLoopPP8NexTouch+0x46>
        __buffer[i] = 0x00;
 80a1c16:	2200      	movs	r2, #0
        if (0xFF == __buffer[4] && 0xFF == __buffer[5] && 0xFF == __buffer[6])
 80a1c18:	7961      	ldrb	r1, [r4, #5]
 80a1c1a:	7923      	ldrb	r3, [r4, #4]
        __buffer[i] = 0x00;
 80a1c1c:	71e2      	strb	r2, [r4, #7]
        if (0xFF == __buffer[4] && 0xFF == __buffer[5] && 0xFF == __buffer[6])
 80a1c1e:	400b      	ands	r3, r1
 80a1c20:	79a1      	ldrb	r1, [r4, #6]
 80a1c22:	400b      	ands	r3, r1
 80a1c24:	2bff      	cmp	r3, #255	; 0xff
 80a1c26:	d1d0      	bne.n	80a1bca <_Z7nexLoopPP8NexTouch+0xa>
          NexTouch::iterate(nex_listen_list, __buffer[1], __buffer[2], (int32_t)__buffer[3], NULL);
 80a1c28:	9200      	str	r2, [sp, #0]
          dbSerialPrint(" Component:");
          dbSerialPrint(__buffer[2]);
          dbSerialPrint(" Value:");
          i = __buffer[4] | (((unsigned long)__buffer[5]) << 8) | (((unsigned long)__buffer[6]) << 16) | (((unsigned long)__buffer[6]) << 24);
          dbSerialPrintln(i);
          NexTouch::iterate(nex_listen_list, __buffer[1], __buffer[2], (int32_t)__buffer[3], (void *)&(__buffer[4]));
 80a1c2a:	78e3      	ldrb	r3, [r4, #3]
 80a1c2c:	78a2      	ldrb	r2, [r4, #2]
 80a1c2e:	e01a      	b.n	80a1c66 <_Z7nexLoopPP8NexTouch+0xa6>
    else if (NEX_RET_CURRENT_PAGE_ID_HEAD == c)
 80a1c30:	2e66      	cmp	r6, #102	; 0x66
 80a1c32:	d11d      	bne.n	80a1c70 <_Z7nexLoopPP8NexTouch+0xb0>
      if (nexSerial.available() >= 4)
 80a1c34:	4628      	mov	r0, r5
 80a1c36:	4798      	blx	r3
 80a1c38:	2803      	cmp	r0, #3
 80a1c3a:	ddc6      	ble.n	80a1bca <_Z7nexLoopPP8NexTouch+0xa>
        __buffer[0] = c;
 80a1c3c:	7026      	strb	r6, [r4, #0]
 80a1c3e:	2601      	movs	r6, #1
          __buffer[i] = nexSerial.read();
 80a1c40:	682b      	ldr	r3, [r5, #0]
 80a1c42:	4628      	mov	r0, r5
 80a1c44:	695b      	ldr	r3, [r3, #20]
 80a1c46:	4798      	blx	r3
 80a1c48:	55a0      	strb	r0, [r4, r6]
        for (i = 1; i < 5; i++)
 80a1c4a:	3601      	adds	r6, #1
 80a1c4c:	2e05      	cmp	r6, #5
 80a1c4e:	d1f7      	bne.n	80a1c40 <_Z7nexLoopPP8NexTouch+0x80>
        __buffer[i] = 0x00;
 80a1c50:	2200      	movs	r2, #0
        if (0xFF == __buffer[2] && 0xFF == __buffer[3] && 0xFF == __buffer[4])
 80a1c52:	78e1      	ldrb	r1, [r4, #3]
 80a1c54:	78a3      	ldrb	r3, [r4, #2]
        __buffer[i] = 0x00;
 80a1c56:	7162      	strb	r2, [r4, #5]
        if (0xFF == __buffer[2] && 0xFF == __buffer[3] && 0xFF == __buffer[4])
 80a1c58:	400b      	ands	r3, r1
 80a1c5a:	7921      	ldrb	r1, [r4, #4]
 80a1c5c:	400b      	ands	r3, r1
 80a1c5e:	2bff      	cmp	r3, #255	; 0xff
 80a1c60:	d1b3      	bne.n	80a1bca <_Z7nexLoopPP8NexTouch+0xa>
          NexTouch::iterate(nex_listen_list, __buffer[1], 0, (int32_t)NEX_EVENT_PUSH, NULL);
 80a1c62:	2301      	movs	r3, #1
 80a1c64:	9200      	str	r2, [sp, #0]
          NexTouch::iterate(nex_listen_list, __buffer[1], __buffer[2], (int32_t)__buffer[3], (void *)&(__buffer[4]));
 80a1c66:	4638      	mov	r0, r7
 80a1c68:	7861      	ldrb	r1, [r4, #1]
 80a1c6a:	f7ff fe99 	bl	80a19a0 <_ZN8NexTouch7iterateEPPS_hhlPv>
 80a1c6e:	e7ac      	b.n	80a1bca <_Z7nexLoopPP8NexTouch+0xa>
    else if (NEX_RET_VALUE_HEAD == c)
 80a1c70:	2e72      	cmp	r6, #114	; 0x72
 80a1c72:	d1aa      	bne.n	80a1bca <_Z7nexLoopPP8NexTouch+0xa>
      if (nexSerial.available() >= 10)
 80a1c74:	4628      	mov	r0, r5
 80a1c76:	4798      	blx	r3
 80a1c78:	2809      	cmp	r0, #9
 80a1c7a:	dda6      	ble.n	80a1bca <_Z7nexLoopPP8NexTouch+0xa>
        __buffer[0] = c;
 80a1c7c:	7026      	strb	r6, [r4, #0]
 80a1c7e:	2601      	movs	r6, #1
          __buffer[i] = nexSerial.read();
 80a1c80:	682b      	ldr	r3, [r5, #0]
 80a1c82:	4628      	mov	r0, r5
 80a1c84:	695b      	ldr	r3, [r3, #20]
 80a1c86:	4798      	blx	r3
 80a1c88:	55a0      	strb	r0, [r4, r6]
        for (i = 1; i < 12; i++)
 80a1c8a:	3601      	adds	r6, #1
 80a1c8c:	2e0c      	cmp	r6, #12
 80a1c8e:	d1f7      	bne.n	80a1c80 <_Z7nexLoopPP8NexTouch+0xc0>
        __buffer[i] = 0x00;
 80a1c90:	2300      	movs	r3, #0
        if (0xFF == __buffer[i - 1] && 0xFF == __buffer[i - 2] && 0xFF == __buffer[i - 3])
 80a1c92:	7aa2      	ldrb	r2, [r4, #10]
        __buffer[i] = 0x00;
 80a1c94:	7323      	strb	r3, [r4, #12]
        if (0xFF == __buffer[i - 1] && 0xFF == __buffer[i - 2] && 0xFF == __buffer[i - 3])
 80a1c96:	7ae3      	ldrb	r3, [r4, #11]
 80a1c98:	4013      	ands	r3, r2
 80a1c9a:	7a62      	ldrb	r2, [r4, #9]
 80a1c9c:	4013      	ands	r3, r2
 80a1c9e:	2bff      	cmp	r3, #255	; 0xff
 80a1ca0:	d193      	bne.n	80a1bca <_Z7nexLoopPP8NexTouch+0xa>
          NexTouch::iterate(nex_listen_list, __buffer[1], __buffer[2], (int32_t)__buffer[3], (void *)&(__buffer[4]));
 80a1ca2:	4b05      	ldr	r3, [pc, #20]	; (80a1cb8 <_Z7nexLoopPP8NexTouch+0xf8>)
 80a1ca4:	9300      	str	r3, [sp, #0]
 80a1ca6:	e7c0      	b.n	80a1c2a <_Z7nexLoopPP8NexTouch+0x6a>
        }
      }
    }
  }
}
 80a1ca8:	b003      	add	sp, #12
 80a1caa:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a1cac:	20000cc0 	.word	0x20000cc0
 80a1cb0:	20000d69 	.word	0x20000d69
 80a1cb4:	20000ea0 	.word	0x20000ea0
 80a1cb8:	20000d6d 	.word	0x20000d6d

080a1cbc <_Z11setBaudratem>:
*
* @retval true - success.
* @retval false - failed.
*/
bool setBaudrate(uint32_t baudrate)
{
 80a1cbc:	b530      	push	{r4, r5, lr}
  bool ret = false;
  char cmd[16] = "baud=";
 80a1cbe:	4b1a      	ldr	r3, [pc, #104]	; (80a1d28 <_Z11setBaudratem+0x6c>)
{
 80a1cc0:	4605      	mov	r5, r0
  char cmd[16] = "baud=";
 80a1cc2:	f853 0f20 	ldr.w	r0, [r3, #32]!
{
 80a1cc6:	b085      	sub	sp, #20
  char cmd[16] = "baud=";
 80a1cc8:	889b      	ldrh	r3, [r3, #4]
 80a1cca:	9000      	str	r0, [sp, #0]
 80a1ccc:	f8ad 3004 	strh.w	r3, [sp, #4]
 80a1cd0:	2300      	movs	r3, #0

  utoa(baudrate, &cmd[strlen(cmd)], 10);
 80a1cd2:	4668      	mov	r0, sp
  char cmd[16] = "baud=";
 80a1cd4:	f8cd 3006 	str.w	r3, [sp, #6]
 80a1cd8:	f8cd 300a 	str.w	r3, [sp, #10]
 80a1cdc:	f8ad 300e 	strh.w	r3, [sp, #14]
  utoa(baudrate, &cmd[strlen(cmd)], 10);
 80a1ce0:	f006 fe9f 	bl	80a8a22 <strlen>
 80a1ce4:	220a      	movs	r2, #10
 80a1ce6:	eb0d 0100 	add.w	r1, sp, r0
 80a1cea:	4628      	mov	r0, r5
 80a1cec:	f005 fb93 	bl	80a7416 <utoa>
  sendCommand(cmd);           // send in new baudrate using the current baudrate
 80a1cf0:	4668      	mov	r0, sp
 80a1cf2:	f7ff ff05 	bl	80a1b00 <_Z11sendCommandPKc>
  delay(10);
 80a1cf6:	200a      	movs	r0, #10
 80a1cf8:	f004 fe08 	bl	80a690c <delay>

  nexSerial.flush();          // dump all returned data, since not usable with new baudrate
 80a1cfc:	4b0b      	ldr	r3, [pc, #44]	; (80a1d2c <_Z11setBaudratem+0x70>)
 80a1cfe:	681c      	ldr	r4, [r3, #0]
 80a1d00:	6823      	ldr	r3, [r4, #0]
 80a1d02:	4620      	mov	r0, r4
 80a1d04:	69db      	ldr	r3, [r3, #28]
 80a1d06:	4798      	blx	r3
  nexSerial.end();            // close port (or pretend to ;-)
 80a1d08:	4620      	mov	r0, r4
 80a1d0a:	f004 f974 	bl	80a5ff6 <_ZN11USARTSerial3endEv>
  nexSerial.begin(baudrate);  // activate new baudrate on MCU side too
 80a1d0e:	4629      	mov	r1, r5
 80a1d10:	4620      	mov	r0, r4
 80a1d12:	f004 f96d 	bl	80a5ff0 <_ZN11USARTSerial5beginEm>
  sendCommand("");            // trigger test transmission
 80a1d16:	4806      	ldr	r0, [pc, #24]	; (80a1d30 <_Z11setBaudratem+0x74>)
 80a1d18:	f7ff fef2 	bl	80a1b00 <_Z11sendCommandPKc>

  if (recvRetCommandFinished())
 80a1d1c:	2064      	movs	r0, #100	; 0x64
 80a1d1e:	f7ff ff07 	bl	80a1b30 <_Z22recvRetCommandFinishedm>
  {
    dbSerialPrintln("setBaudrate err ");
  }

  return ret;
}
 80a1d22:	b005      	add	sp, #20
 80a1d24:	bd30      	pop	{r4, r5, pc}
 80a1d26:	bf00      	nop
 80a1d28:	080a9753 	.word	0x080a9753
 80a1d2c:	20000cc0 	.word	0x20000cc0
 80a1d30:	080aa420 	.word	0x080aa420

080a1d34 <_Z11NexSetValuePKcS0_m>:
  sendCommand(cmd);
  return recvRetNumber(value);
}

bool NexSetValue(const char* objName, const char* valueType, uint32_t value)
{
 80a1d34:	b530      	push	{r4, r5, lr}
 80a1d36:	460d      	mov	r5, r1
 80a1d38:	b089      	sub	sp, #36	; 0x24
  char cmd[32];
  //snprintf(cmd, sizeof(cmd), "%s.%s=%d", objName, valueType, value);
  strcpy(cmd, objName);
 80a1d3a:	4601      	mov	r1, r0
 80a1d3c:	4668      	mov	r0, sp
{
 80a1d3e:	4614      	mov	r4, r2
  strcpy(cmd, objName);
 80a1d40:	f006 fe4b 	bl	80a89da <strcpy>
  strcat(cmd, ".");
 80a1d44:	4668      	mov	r0, sp
 80a1d46:	490e      	ldr	r1, [pc, #56]	; (80a1d80 <_Z11NexSetValuePKcS0_m+0x4c>)
 80a1d48:	f006 fe2e 	bl	80a89a8 <strcat>
  strcat(cmd, valueType);
 80a1d4c:	4629      	mov	r1, r5
 80a1d4e:	4668      	mov	r0, sp
 80a1d50:	f006 fe2a 	bl	80a89a8 <strcat>
  strcat(cmd, "=");
 80a1d54:	490b      	ldr	r1, [pc, #44]	; (80a1d84 <_Z11NexSetValuePKcS0_m+0x50>)
 80a1d56:	4668      	mov	r0, sp
 80a1d58:	f006 fe26 	bl	80a89a8 <strcat>
  utoa(value, &cmd[strlen(cmd)], 10);
 80a1d5c:	4668      	mov	r0, sp
 80a1d5e:	f006 fe60 	bl	80a8a22 <strlen>
 80a1d62:	220a      	movs	r2, #10
 80a1d64:	eb0d 0100 	add.w	r1, sp, r0
 80a1d68:	4620      	mov	r0, r4
 80a1d6a:	f005 fb54 	bl	80a7416 <utoa>
  sendCommand(cmd);
 80a1d6e:	4668      	mov	r0, sp
 80a1d70:	f7ff fec6 	bl	80a1b00 <_Z11sendCommandPKc>
  return recvRetCommandFinished();
 80a1d74:	2064      	movs	r0, #100	; 0x64
 80a1d76:	f7ff fedb 	bl	80a1b30 <_Z22recvRetCommandFinishedm>
}
 80a1d7a:	b009      	add	sp, #36	; 0x24
 80a1d7c:	bd30      	pop	{r4, r5, pc}
 80a1d7e:	bf00      	nop
 80a1d80:	080a9475 	.word	0x080a9475
 80a1d84:	080a974e 	.word	0x080a974e

080a1d88 <_Z12NexGetStringPKcS0_Pct>:

uint16_t NexGetString(const char* objName, const char* valueType, char* text, uint16_t len)
{
 80a1d88:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a1d8a:	4607      	mov	r7, r0
 80a1d8c:	460e      	mov	r6, r1
 80a1d8e:	4614      	mov	r4, r2
 80a1d90:	461d      	mov	r5, r3
  //char cmd[32];
  //snprintf(cmd, sizeof(cmd), "get %s.%s", objName, valueType);
  char cmd[32] = "get ";
 80a1d92:	4b12      	ldr	r3, [pc, #72]	; (80a1ddc <_Z12NexGetStringPKcS0_Pct+0x54>)
{
 80a1d94:	b089      	sub	sp, #36	; 0x24
  char cmd[32] = "get ";
 80a1d96:	f853 0f30 	ldr.w	r0, [r3, #48]!
 80a1d9a:	221b      	movs	r2, #27
 80a1d9c:	791b      	ldrb	r3, [r3, #4]
 80a1d9e:	9000      	str	r0, [sp, #0]
 80a1da0:	2100      	movs	r1, #0
 80a1da2:	f10d 0005 	add.w	r0, sp, #5
 80a1da6:	f88d 3004 	strb.w	r3, [sp, #4]
 80a1daa:	f006 fd9d 	bl	80a88e8 <memset>
  strcat(cmd, objName);
 80a1dae:	4639      	mov	r1, r7
 80a1db0:	4668      	mov	r0, sp
 80a1db2:	f006 fdf9 	bl	80a89a8 <strcat>
  strcat(cmd, ".");
 80a1db6:	4668      	mov	r0, sp
 80a1db8:	4909      	ldr	r1, [pc, #36]	; (80a1de0 <_Z12NexGetStringPKcS0_Pct+0x58>)
 80a1dba:	f006 fdf5 	bl	80a89a8 <strcat>
  strcat(cmd, valueType);
 80a1dbe:	4631      	mov	r1, r6
 80a1dc0:	4668      	mov	r0, sp
 80a1dc2:	f006 fdf1 	bl	80a89a8 <strcat>
  sendCommand(cmd);
 80a1dc6:	4668      	mov	r0, sp
 80a1dc8:	f7ff fe9a 	bl	80a1b00 <_Z11sendCommandPKc>
  return recvRetString(text, len);
 80a1dcc:	2264      	movs	r2, #100	; 0x64
 80a1dce:	4629      	mov	r1, r5
 80a1dd0:	4620      	mov	r0, r4
 80a1dd2:	f7ff fe33 	bl	80a1a3c <_Z13recvRetStringPctm>
}
 80a1dd6:	b009      	add	sp, #36	; 0x24
 80a1dd8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a1dda:	bf00      	nop
 80a1ddc:	080a9753 	.word	0x080a9753
 80a1de0:	080a9475 	.word	0x080a9475

080a1de4 <_Z12NexSetStringPKcS0_S0_>:

bool NexSetString(const char* objName, const char* valueType, const char* text)
{
 80a1de4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a1de6:	4606      	mov	r6, r0
 80a1de8:	af00      	add	r7, sp, #0
  char cmd[strlen(text) + 32];
 80a1dea:	4610      	mov	r0, r2
{
 80a1dec:	460d      	mov	r5, r1
 80a1dee:	4614      	mov	r4, r2
  char cmd[strlen(text) + 32];
 80a1df0:	f006 fe17 	bl	80a8a22 <strlen>
 80a1df4:	f100 0327 	add.w	r3, r0, #39	; 0x27
 80a1df8:	f023 0307 	bic.w	r3, r3, #7
 80a1dfc:	ebad 0d03 	sub.w	sp, sp, r3
  memset(cmd, 0, sizeof(cmd));
 80a1e00:	f100 0220 	add.w	r2, r0, #32
 80a1e04:	2100      	movs	r1, #0
 80a1e06:	4668      	mov	r0, sp
 80a1e08:	f006 fd6e 	bl	80a88e8 <memset>
  //snprintf(cmd, sizeof(cmd), "%s.%s=\"%s\"", objName, valueType, text);
  strcpy(cmd, objName);
 80a1e0c:	4631      	mov	r1, r6
 80a1e0e:	4668      	mov	r0, sp
 80a1e10:	f006 fde3 	bl	80a89da <strcpy>
  strcat(cmd, ".");
 80a1e14:	4668      	mov	r0, sp
 80a1e16:	490d      	ldr	r1, [pc, #52]	; (80a1e4c <_Z12NexSetStringPKcS0_S0_+0x68>)
 80a1e18:	f006 fdc6 	bl	80a89a8 <strcat>
  strcat(cmd, valueType);
 80a1e1c:	4629      	mov	r1, r5
 80a1e1e:	4668      	mov	r0, sp
 80a1e20:	f006 fdc2 	bl	80a89a8 <strcat>
  strcat(cmd, "=\"");
 80a1e24:	4668      	mov	r0, sp
 80a1e26:	490a      	ldr	r1, [pc, #40]	; (80a1e50 <_Z12NexSetStringPKcS0_S0_+0x6c>)
 80a1e28:	f006 fdbe 	bl	80a89a8 <strcat>
  strcat(cmd, text);
 80a1e2c:	4621      	mov	r1, r4
 80a1e2e:	4668      	mov	r0, sp
 80a1e30:	f006 fdba 	bl	80a89a8 <strcat>
  strcat(cmd, "\"");
 80a1e34:	4907      	ldr	r1, [pc, #28]	; (80a1e54 <_Z12NexSetStringPKcS0_S0_+0x70>)
 80a1e36:	4668      	mov	r0, sp
 80a1e38:	f006 fdb6 	bl	80a89a8 <strcat>
  sendCommand(cmd);
 80a1e3c:	4668      	mov	r0, sp
 80a1e3e:	f7ff fe5f 	bl	80a1b00 <_Z11sendCommandPKc>
  return recvRetCommandFinished();
 80a1e42:	2064      	movs	r0, #100	; 0x64
 80a1e44:	f7ff fe74 	bl	80a1b30 <_Z22recvRetCommandFinishedm>
}
 80a1e48:	46bd      	mov	sp, r7
 80a1e4a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a1e4c:	080a9475 	.word	0x080a9475
 80a1e50:	080a9750 	.word	0x080a9750
 80a1e54:	080a9751 	.word	0x080a9751

080a1e58 <_ZN9NexSliderC1EhhPKcPv>:
* by BSpranger & ScruffR (Dec. 2015)
*/

#include "NexSlider.h"

NexSlider::NexSlider(uint8_t pid, uint8_t cid, const char *name, void *value)
 80a1e58:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a1e5a:	4604      	mov	r4, r0
    :NexTouch(pid, cid, name, value)
 80a1e5c:	9d06      	ldr	r5, [sp, #24]
 80a1e5e:	9500      	str	r5, [sp, #0]
 80a1e60:	f7ff fd72 	bl	80a1948 <_ZN8NexTouchC1EhhPKcPv>
{
}
 80a1e64:	4620      	mov	r0, r4
 80a1e66:	b003      	add	sp, #12
 80a1e68:	bd30      	pop	{r4, r5, pc}

080a1e6a <_ZN9NexObjectC1EhhPKcPv>:
*/

#include "NexObject.h"
#include "NexHardware.h"

NexObject::NexObject(uint8_t pid, uint8_t cid, const char *name, void *value)
 80a1e6a:	b510      	push	{r4, lr}
{
    this->__pid = pid;
    this->__cid = cid;
    this->__name = name;
 80a1e6c:	6043      	str	r3, [r0, #4]
    this->__value = value;
 80a1e6e:	9b02      	ldr	r3, [sp, #8]
    this->__pid = pid;
 80a1e70:	7001      	strb	r1, [r0, #0]
    this->__cid = cid;
 80a1e72:	7042      	strb	r2, [r0, #1]
    this->__value = value;
 80a1e74:	6083      	str	r3, [r0, #8]
}
 80a1e76:	bd10      	pop	{r4, pc}

080a1e78 <_ZN9NexObject11setObjValueEhPv>:

void NexObject::setObjValue(uint8_t type, void *value)
{
    if (__value)
 80a1e78:	6883      	ldr	r3, [r0, #8]
 80a1e7a:	b11b      	cbz	r3, 80a1e84 <_ZN9NexObject11setObjValueEhPv+0xc>
    {
        switch (type)
 80a1e7c:	2902      	cmp	r1, #2
        {
        case NEX_EVENT_VALUE:
           *((unsigned long *)__value) = (((uint8_t *)value)[0]) | (((unsigned long)((uint8_t *)value)[1]) << 8) | (((unsigned long)((uint8_t *)value)[2]) << 16) | (((unsigned long)((uint8_t *)value)[3]) << 24);
 80a1e7e:	bf04      	itt	eq
 80a1e80:	6812      	ldreq	r2, [r2, #0]
 80a1e82:	601a      	streq	r2, [r3, #0]
        default:
        //*(__value) = 0;
        break;
        }
    }
}
 80a1e84:	4770      	bx	lr

080a1e86 <_ZN9NexObject9getObjPidEv>:

uint8_t NexObject::getObjPid(void)
{
    return __pid;
}
 80a1e86:	7800      	ldrb	r0, [r0, #0]
 80a1e88:	4770      	bx	lr

080a1e8a <_ZN9NexObject9getObjCidEv>:

uint8_t NexObject::getObjCid(void)
{
    return __cid;
}
 80a1e8a:	7840      	ldrb	r0, [r0, #1]
 80a1e8c:	4770      	bx	lr

080a1e8e <_ZN9NexObject12printObjInfoEv>:
    else
    {
        dbSerialPrint("(null)");
    }        
    dbSerialPrintln("]");
}
 80a1e8e:	4770      	bx	lr

080a1e90 <_ZN9NexObject8setValueEPKcm>:
  return NexGetValue(getObjName(), valueType, value);
}

bool NexObject::setValue(const char* valueType, uint32_t value)
{
  return NexSetValue(getObjName(), valueType, value);
 80a1e90:	6840      	ldr	r0, [r0, #4]
 80a1e92:	f7ff bf4f 	b.w	80a1d34 <_Z11NexSetValuePKcS0_m>

080a1e96 <_ZN9NexObject9getStringEPKcPct>:
}

uint16_t NexObject::getString(const char* valueType, char* text, uint16_t len)
{
  return NexGetString(getObjName(), valueType, text, len);
 80a1e96:	6840      	ldr	r0, [r0, #4]
 80a1e98:	f7ff bf76 	b.w	80a1d88 <_Z12NexGetStringPKcS0_Pct>

080a1e9c <_ZN9NexObject9setStringEPKcS1_>:
}

bool NexObject::setString(const char* valueType, const char* text)
{
  return NexSetString(getObjName(), valueType, text);
 80a1e9c:	6840      	ldr	r0, [r0, #4]
 80a1e9e:	f7ff bfa1 	b.w	80a1de4 <_Z12NexSetStringPKcS0_S0_>

080a1ea2 <_ZN9NexNumberC1EhhPKc>:
* by ScruffR (Dec. 2015)
*/

#include "NexNumber.h"

NexNumber::NexNumber(uint8_t pid, uint8_t cid, const char *name)
 80a1ea2:	b537      	push	{r0, r1, r2, r4, r5, lr}
    :NexTouch(pid, cid, name)
 80a1ea4:	2500      	movs	r5, #0
NexNumber::NexNumber(uint8_t pid, uint8_t cid, const char *name)
 80a1ea6:	4604      	mov	r4, r0
    :NexTouch(pid, cid, name)
 80a1ea8:	9500      	str	r5, [sp, #0]
 80a1eaa:	f7ff fd4d 	bl	80a1948 <_ZN8NexTouchC1EhhPKcPv>
{
}
 80a1eae:	4620      	mov	r0, r4
 80a1eb0:	b003      	add	sp, #12
 80a1eb2:	bd30      	pop	{r4, r5, pc}

080a1eb4 <_ZN9NexButtonC1EhhPKcPv>:
* by BSpranger & ScruffR (Dec. 2015) 
*/

#include "NexButton.h"

NexButton::NexButton(uint8_t pid, uint8_t cid, const char *name, void *value)
 80a1eb4:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a1eb6:	4604      	mov	r4, r0
    :NexTouch(pid, cid, name, value)
 80a1eb8:	9d06      	ldr	r5, [sp, #24]
 80a1eba:	9500      	str	r5, [sp, #0]
 80a1ebc:	f7ff fd44 	bl	80a1948 <_ZN8NexTouchC1EhhPKcPv>
{
}
 80a1ec0:	4620      	mov	r0, r4
 80a1ec2:	b003      	add	sp, #12
 80a1ec4:	bd30      	pop	{r4, r5, pc}

080a1ec6 <_ZN14NexProgressBarC1EhhPKcPv>:
* by BSpranger & ScruffR (Dec. 2015)
*/

#include "NexProgressBar.h"

NexProgressBar::NexProgressBar(uint8_t pid, uint8_t cid, const char *name, void *value)
 80a1ec6:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a1ec8:	4604      	mov	r4, r0
    :NexObject(pid, cid, name, value)
 80a1eca:	9d06      	ldr	r5, [sp, #24]
 80a1ecc:	9500      	str	r5, [sp, #0]
 80a1ece:	f7ff ffcc 	bl	80a1e6a <_ZN9NexObjectC1EhhPKcPv>
{
}
 80a1ed2:	4620      	mov	r0, r4
 80a1ed4:	b003      	add	sp, #12
 80a1ed6:	bd30      	pop	{r4, r5, pc}

080a1ed8 <_ZN14NexProgressBar8setValueEm>:
{
  return NexObject::getValue("val", number);
}

bool NexProgressBar::setValue(uint32_t number)
{
 80a1ed8:	460a      	mov	r2, r1
  return NexObject::setValue("val", number);
 80a1eda:	4901      	ldr	r1, [pc, #4]	; (80a1ee0 <_ZN14NexProgressBar8setValueEm+0x8>)
 80a1edc:	f7ff bfd8 	b.w	80a1e90 <_ZN9NexObject8setValueEPKcm>
 80a1ee0:	080a97a3 	.word	0x080a97a3

080a1ee4 <_ZN8NexGaugeC1EhhPKcPv>:
* by BSpranger & ScruffR (Dec. 2015)
*/

#include "NexGauge.h"

NexGauge::NexGauge(uint8_t pid, uint8_t cid, const char *name, void *value)
 80a1ee4:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a1ee6:	4604      	mov	r4, r0
    :NexObject(pid, cid, name, value)
 80a1ee8:	9d06      	ldr	r5, [sp, #24]
 80a1eea:	9500      	str	r5, [sp, #0]
 80a1eec:	f7ff ffbd 	bl	80a1e6a <_ZN9NexObjectC1EhhPKcPv>
{
}
 80a1ef0:	4620      	mov	r0, r4
 80a1ef2:	b003      	add	sp, #12
 80a1ef4:	bd30      	pop	{r4, r5, pc}

080a1ef6 <_ZN15Adafruit_Sensor15enableAutoRangeEb>:
  // Constructor(s)
  Adafruit_Sensor() {}
  virtual ~Adafruit_Sensor() {}

  // These must be defined by the subclass
  virtual void enableAutoRange(bool enabled) {};
 80a1ef6:	4770      	bx	lr

080a1ef8 <_ZN15Adafruit_LIS3DHD1Ev>:
  LIS3DH_INT1_SRC_YL = 0x04,
  LIS3DH_INT1_SRC_XH = 0x02,
  LIS3DH_INT1_SRC_XL = 0x01
} list3dh_ctrl_int2_src_t;

class Adafruit_LIS3DH : public Adafruit_Sensor {
 80a1ef8:	4770      	bx	lr
	...

080a1efc <_ZN15Adafruit_LIS3DH9getSensorEP8sensor_t>:
/**************************************************************************/
/*!
    @brief  Gets the sensor_t data
*/
/**************************************************************************/
void Adafruit_LIS3DH::getSensor(sensor_t *sensor) {
 80a1efc:	460b      	mov	r3, r1
 80a1efe:	b510      	push	{r4, lr}
  /* Clear the sensor_t object */
  memset(sensor, 0, sizeof(sensor_t));
 80a1f00:	2228      	movs	r2, #40	; 0x28
void Adafruit_LIS3DH::getSensor(sensor_t *sensor) {
 80a1f02:	4604      	mov	r4, r0
  memset(sensor, 0, sizeof(sensor_t));
 80a1f04:	2100      	movs	r1, #0
 80a1f06:	4618      	mov	r0, r3
 80a1f08:	f006 fcee 	bl	80a88e8 <memset>

  /* Insert the sensor name in the fixed length char array */
  strncpy (sensor->name, "LIS3DH", sizeof(sensor->name) - 1);
 80a1f0c:	220b      	movs	r2, #11
 80a1f0e:	4908      	ldr	r1, [pc, #32]	; (80a1f30 <_ZN15Adafruit_LIS3DH9getSensorEP8sensor_t+0x34>)
 80a1f10:	f006 fda1 	bl	80a8a56 <strncpy>
  sensor->name[sizeof(sensor->name)- 1] = 0;
 80a1f14:	2200      	movs	r2, #0
  sensor->version     = 1;
 80a1f16:	2101      	movs	r1, #1
  strncpy (sensor->name, "LIS3DH", sizeof(sensor->name) - 1);
 80a1f18:	4603      	mov	r3, r0
  sensor->name[sizeof(sensor->name)- 1] = 0;
 80a1f1a:	72c2      	strb	r2, [r0, #11]
  sensor->version     = 1;
 80a1f1c:	60c1      	str	r1, [r0, #12]
  sensor->sensor_id   = _sensorID;
 80a1f1e:	69a0      	ldr	r0, [r4, #24]
  sensor->type        = SENSOR_TYPE_ACCELEROMETER;
  sensor->min_delay   = 0;
 80a1f20:	625a      	str	r2, [r3, #36]	; 0x24
  sensor->max_value   = 0;
 80a1f22:	2200      	movs	r2, #0
  sensor->type        = SENSOR_TYPE_ACCELEROMETER;
 80a1f24:	e9c3 0104 	strd	r0, r1, [r3, #16]
  sensor->max_value   = 0;
 80a1f28:	619a      	str	r2, [r3, #24]
  sensor->min_value   = 0;
 80a1f2a:	61da      	str	r2, [r3, #28]
  sensor->resolution  = 0;
 80a1f2c:	621a      	str	r2, [r3, #32]
}
 80a1f2e:	bd10      	pop	{r4, pc}
 80a1f30:	080a97a7 	.word	0x080a97a7

080a1f34 <_ZN15Adafruit_LIS3DHD0Ev>:
 80a1f34:	b510      	push	{r4, lr}
 80a1f36:	4604      	mov	r4, r0
 80a1f38:	212c      	movs	r1, #44	; 0x2c
 80a1f3a:	f005 fb6a 	bl	80a7612 <_ZdlPvj>
 80a1f3e:	4620      	mov	r0, r4
 80a1f40:	bd10      	pop	{r4, pc}
	...

080a1f44 <__tcf_0>:
        dispose();
    }

    void dispose()
    {
        if (handle_) {
 80a1f44:	4b02      	ldr	r3, [pc, #8]	; (80a1f50 <__tcf_0+0xc>)
 80a1f46:	6898      	ldr	r0, [r3, #8]
 80a1f48:	b108      	cbz	r0, 80a1f4e <__tcf_0+0xa>
            os_mutex_recursive_destroy(handle_);
 80a1f4a:	f003 bc11 	b.w	80a5770 <os_mutex_recursive_destroy>

template <hal_spi_interface_t Interface>
class SpiProxy {
public:
    static SPIClass& instance() {
        static SPIClass instance(Interface);
 80a1f4e:	4770      	bx	lr
 80a1f50:	20000d84 	.word	0x20000d84

080a1f54 <_ZN7TwoWire5writeEi>:
  bool unlock();

  inline size_t write(unsigned long n) { return write((uint8_t)n); }
  inline size_t write(long n) { return write((uint8_t)n); }
  inline size_t write(unsigned int n) { return write((uint8_t)n); }
  inline size_t write(int n) { return write((uint8_t)n); }
 80a1f54:	6803      	ldr	r3, [r0, #0]
 80a1f56:	b2c9      	uxtb	r1, r1
 80a1f58:	689b      	ldr	r3, [r3, #8]
 80a1f5a:	4718      	bx	r3

080a1f5c <_ZN15Adafruit_LIS3DHC1Ev>:
  : _cs(-1), _mosi(-1), _miso(-1), _sck(-1), _sensorID(-1)
 80a1f5c:	4a06      	ldr	r2, [pc, #24]	; (80a1f78 <_ZN15Adafruit_LIS3DHC1Ev+0x1c>)
 80a1f5e:	6002      	str	r2, [r0, #0]
 80a1f60:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80a1f64:	6182      	str	r2, [r0, #24]
 80a1f66:	7742      	strb	r2, [r0, #29]
 80a1f68:	83c2      	strh	r2, [r0, #30]
 80a1f6a:	22ff      	movs	r2, #255	; 0xff
 80a1f6c:	f880 2020 	strb.w	r2, [r0, #32]
 80a1f70:	2211      	movs	r2, #17
 80a1f72:	6242      	str	r2, [r0, #36]	; 0x24
}
 80a1f74:	4770      	bx	lr
 80a1f76:	bf00      	nop
 80a1f78:	080a97b8 	.word	0x080a97b8

080a1f7c <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8instanceEv>:
    static SPIClass& instance() {
 80a1f7c:	b538      	push	{r3, r4, r5, lr}
        static SPIClass instance(Interface);
 80a1f7e:	4d0b      	ldr	r5, [pc, #44]	; (80a1fac <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8instanceEv+0x30>)
 80a1f80:	7829      	ldrb	r1, [r5, #0]
 80a1f82:	f3bf 8f5b 	dmb	ish
 80a1f86:	f011 0401 	ands.w	r4, r1, #1
 80a1f8a:	d10d      	bne.n	80a1fa8 <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8instanceEv+0x2c>
 80a1f8c:	4628      	mov	r0, r5
 80a1f8e:	f7fe f893 	bl	80a00b8 <__cxa_guard_acquire>
 80a1f92:	b148      	cbz	r0, 80a1fa8 <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8instanceEv+0x2c>
 80a1f94:	4621      	mov	r1, r4
 80a1f96:	4806      	ldr	r0, [pc, #24]	; (80a1fb0 <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8instanceEv+0x34>)
 80a1f98:	f003 fe3d 	bl	80a5c16 <_ZN8SPIClassC1E19hal_spi_interface_t>
 80a1f9c:	4628      	mov	r0, r5
 80a1f9e:	f7fe f890 	bl	80a00c2 <__cxa_guard_release>
 80a1fa2:	4804      	ldr	r0, [pc, #16]	; (80a1fb4 <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8instanceEv+0x38>)
 80a1fa4:	f006 fb96 	bl	80a86d4 <atexit>
        return instance;
    }
 80a1fa8:	4801      	ldr	r0, [pc, #4]	; (80a1fb0 <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8instanceEv+0x34>)
 80a1faa:	bd38      	pop	{r3, r4, r5, pc}
 80a1fac:	20000d80 	.word	0x20000d80
 80a1fb0:	20000d84 	.word	0x20000d84
 80a1fb4:	080a1f45 	.word	0x080a1f45

080a1fb8 <_ZN15Adafruit_LIS3DH7spixferEh>:
/*!
    @brief  Low level SPI
*/
/**************************************************************************/

uint8_t Adafruit_LIS3DH::spixfer(uint8_t x) {
 80a1fb8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  #ifndef __AVR_ATtiny85__
  if (_sck == -1)
 80a1fbc:	f990 3020 	ldrsb.w	r3, [r0, #32]
uint8_t Adafruit_LIS3DH::spixfer(uint8_t x) {
 80a1fc0:	4605      	mov	r5, r0
  if (_sck == -1)
 80a1fc2:	3301      	adds	r3, #1
uint8_t Adafruit_LIS3DH::spixfer(uint8_t x) {
 80a1fc4:	460f      	mov	r7, r1
  if (_sck == -1)
 80a1fc6:	d106      	bne.n	80a1fd6 <_ZN15Adafruit_LIS3DH7spixferEh+0x1e>
    }
    static void computeClockDivider(unsigned reference, unsigned targetSpeed, uint8_t& divider, unsigned& clock) {
        instance().computeClockDivider(reference, targetSpeed, divider, clock);
    }
    byte transfer(byte data) {
        return instance().transfer(data);
 80a1fc8:	f7ff ffd8 	bl	80a1f7c <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8instanceEv>
 80a1fcc:	4639      	mov	r1, r7
    if (digitalRead(_miso))
      reply |= 1;
  }
  return reply;
  #endif
}
 80a1fce:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80a1fd2:	f003 bf3d 	b.w	80a5e50 <_ZN8SPIClass8transferEh>
  uint8_t reply = 0;
 80a1fd6:	2400      	movs	r4, #0
  for (int i=7; i>=0; i--) {
 80a1fd8:	2607      	movs	r6, #7
    digitalWrite(_mosi, x & (1<<i));
 80a1fda:	f04f 0801 	mov.w	r8, #1
    digitalWrite(_sck, LOW);
 80a1fde:	f995 0020 	ldrsb.w	r0, [r5, #32]
 80a1fe2:	2100      	movs	r1, #0
 80a1fe4:	b280      	uxth	r0, r0
 80a1fe6:	f005 fae8 	bl	80a75ba <digitalWrite>
    digitalWrite(_mosi, x & (1<<i));
 80a1fea:	f995 001e 	ldrsb.w	r0, [r5, #30]
 80a1fee:	fa08 f106 	lsl.w	r1, r8, r6
 80a1ff2:	4039      	ands	r1, r7
 80a1ff4:	b280      	uxth	r0, r0
 80a1ff6:	f005 fae0 	bl	80a75ba <digitalWrite>
    digitalWrite(_sck, HIGH);
 80a1ffa:	f995 0020 	ldrsb.w	r0, [r5, #32]
 80a1ffe:	2101      	movs	r1, #1
 80a2000:	b280      	uxth	r0, r0
 80a2002:	f005 fada 	bl	80a75ba <digitalWrite>
    if (digitalRead(_miso))
 80a2006:	f995 001f 	ldrsb.w	r0, [r5, #31]
    reply <<= 1;
 80a200a:	0064      	lsls	r4, r4, #1
    if (digitalRead(_miso))
 80a200c:	b280      	uxth	r0, r0
    reply <<= 1;
 80a200e:	b2e4      	uxtb	r4, r4
    if (digitalRead(_miso))
 80a2010:	f005 faec 	bl	80a75ec <digitalRead>
 80a2014:	b108      	cbz	r0, 80a201a <_ZN15Adafruit_LIS3DH7spixferEh+0x62>
      reply |= 1;
 80a2016:	f044 0401 	orr.w	r4, r4, #1
  for (int i=7; i>=0; i--) {
 80a201a:	3e01      	subs	r6, #1
 80a201c:	d2df      	bcs.n	80a1fde <_ZN15Adafruit_LIS3DH7spixferEh+0x26>
}
 80a201e:	4620      	mov	r0, r4
 80a2020:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080a2024 <_ZN15Adafruit_LIS3DH16beginTransactionEv>:
  #endif
  return value;
}


void Adafruit_LIS3DH::beginTransaction() {
 80a2024:	b508      	push	{r3, lr}
        instance().setBitOrder(order);
 80a2026:	f7ff ffa9 	bl	80a1f7c <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8instanceEv>
 80a202a:	2101      	movs	r1, #1
 80a202c:	f003 fe1e 	bl	80a5c6c <_ZN8SPIClass11setBitOrderEh>
        return instance().setClockSpeed(value, scale);
 80a2030:	f7ff ffa4 	bl	80a1f7c <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8instanceEv>
 80a2034:	4905      	ldr	r1, [pc, #20]	; (80a204c <_ZN15Adafruit_LIS3DH16beginTransactionEv+0x28>)
 80a2036:	2201      	movs	r2, #1
 80a2038:	f003 feba 	bl	80a5db0 <_ZN8SPIClass13setClockSpeedEjj>
        instance().setDataMode(mode);
 80a203c:	f7ff ff9e 	bl	80a1f7c <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8instanceEv>
    SPI.setClockSpeed(500000);
    SPI.setDataMode(SPI_MODE0);
#else
  SPI.beginTransaction(SPISettings(500000, MSBFIRST, SPI_MODE0));
#endif
}
 80a2040:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 80a2044:	2100      	movs	r1, #0
 80a2046:	f003 be1f 	b.w	80a5c88 <_ZN8SPIClass11setDataModeEh>
 80a204a:	bf00      	nop
 80a204c:	0007a120 	.word	0x0007a120

080a2050 <_ZN15Adafruit_LIS3DH14writeRegister8Ehh>:
void Adafruit_LIS3DH::writeRegister8(uint8_t reg, uint8_t value) {
 80a2050:	b570      	push	{r4, r5, r6, lr}
  if (_cs == -1) {
 80a2052:	f990 301d 	ldrsb.w	r3, [r0, #29]
void Adafruit_LIS3DH::writeRegister8(uint8_t reg, uint8_t value) {
 80a2056:	4604      	mov	r4, r0
  if (_cs == -1) {
 80a2058:	3301      	adds	r3, #1
void Adafruit_LIS3DH::writeRegister8(uint8_t reg, uint8_t value) {
 80a205a:	460e      	mov	r6, r1
 80a205c:	4615      	mov	r5, r2
  if (_cs == -1) {
 80a205e:	d116      	bne.n	80a208e <_ZN15Adafruit_LIS3DH14writeRegister8Ehh+0x3e>
    Wire.beginTransmission((uint8_t)_i2caddr);
 80a2060:	f005 fa1e 	bl	80a74a0 <_Z19__fetch_global_Wirev>
 80a2064:	7f21      	ldrb	r1, [r4, #28]
 80a2066:	f004 f877 	bl	80a6158 <_ZN7TwoWire17beginTransmissionEh>
    Wire.write((uint8_t)reg);
 80a206a:	f005 fa19 	bl	80a74a0 <_Z19__fetch_global_Wirev>
 80a206e:	6803      	ldr	r3, [r0, #0]
 80a2070:	4631      	mov	r1, r6
 80a2072:	689b      	ldr	r3, [r3, #8]
 80a2074:	4798      	blx	r3
    Wire.write((uint8_t)value);
 80a2076:	f005 fa13 	bl	80a74a0 <_Z19__fetch_global_Wirev>
 80a207a:	6803      	ldr	r3, [r0, #0]
 80a207c:	4629      	mov	r1, r5
 80a207e:	689b      	ldr	r3, [r3, #8]
 80a2080:	4798      	blx	r3
    Wire.endTransmission();
 80a2082:	f005 fa0d 	bl	80a74a0 <_Z19__fetch_global_Wirev>
}
 80a2086:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    Wire.endTransmission();
 80a208a:	f004 b870 	b.w	80a616e <_ZN7TwoWire15endTransmissionEv>
	if (_sck == -1)
 80a208e:	f990 3020 	ldrsb.w	r3, [r0, #32]
 80a2092:	3301      	adds	r3, #1
 80a2094:	d101      	bne.n	80a209a <_ZN15Adafruit_LIS3DH14writeRegister8Ehh+0x4a>
	  beginTransaction();
 80a2096:	f7ff ffc5 	bl	80a2024 <_ZN15Adafruit_LIS3DH16beginTransactionEv>
    digitalWrite(_cs, LOW);
 80a209a:	f994 001d 	ldrsb.w	r0, [r4, #29]
 80a209e:	2100      	movs	r1, #0
 80a20a0:	b280      	uxth	r0, r0
 80a20a2:	f005 fa8a 	bl	80a75ba <digitalWrite>
    spixfer(reg & ~0x80); // write, bit 7 low
 80a20a6:	f006 017f 	and.w	r1, r6, #127	; 0x7f
 80a20aa:	4620      	mov	r0, r4
 80a20ac:	f7ff ff84 	bl	80a1fb8 <_ZN15Adafruit_LIS3DH7spixferEh>
    spixfer(value);
 80a20b0:	4629      	mov	r1, r5
 80a20b2:	4620      	mov	r0, r4
 80a20b4:	f7ff ff80 	bl	80a1fb8 <_ZN15Adafruit_LIS3DH7spixferEh>
    digitalWrite(_cs, HIGH);
 80a20b8:	f994 001d 	ldrsb.w	r0, [r4, #29]
 80a20bc:	2101      	movs	r1, #1
}
 80a20be:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    digitalWrite(_cs, HIGH);
 80a20c2:	b280      	uxth	r0, r0
 80a20c4:	f005 ba79 	b.w	80a75ba <digitalWrite>

080a20c8 <_ZN15Adafruit_LIS3DH13readRegister8Eh>:
uint8_t Adafruit_LIS3DH::readRegister8(uint8_t reg) {
 80a20c8:	b538      	push	{r3, r4, r5, lr}
  if (_cs == -1) {
 80a20ca:	f990 301d 	ldrsb.w	r3, [r0, #29]
uint8_t Adafruit_LIS3DH::readRegister8(uint8_t reg) {
 80a20ce:	4604      	mov	r4, r0
  if (_cs == -1) {
 80a20d0:	3301      	adds	r3, #1
uint8_t Adafruit_LIS3DH::readRegister8(uint8_t reg) {
 80a20d2:	460d      	mov	r5, r1
  if (_cs == -1) {
 80a20d4:	d11d      	bne.n	80a2112 <_ZN15Adafruit_LIS3DH13readRegister8Eh+0x4a>
    Wire.beginTransmission(_i2caddr);
 80a20d6:	f005 f9e3 	bl	80a74a0 <_Z19__fetch_global_Wirev>
 80a20da:	f994 101c 	ldrsb.w	r1, [r4, #28]
 80a20de:	f004 f83f 	bl	80a6160 <_ZN7TwoWire17beginTransmissionEi>
    Wire.write((uint8_t)reg);
 80a20e2:	f005 f9dd 	bl	80a74a0 <_Z19__fetch_global_Wirev>
 80a20e6:	6803      	ldr	r3, [r0, #0]
 80a20e8:	4629      	mov	r1, r5
 80a20ea:	689b      	ldr	r3, [r3, #8]
 80a20ec:	4798      	blx	r3
    Wire.endTransmission();
 80a20ee:	f005 f9d7 	bl	80a74a0 <_Z19__fetch_global_Wirev>
 80a20f2:	f004 f83c 	bl	80a616e <_ZN7TwoWire15endTransmissionEv>
    Wire.requestFrom(_i2caddr, 1);
 80a20f6:	f005 f9d3 	bl	80a74a0 <_Z19__fetch_global_Wirev>
 80a20fa:	2201      	movs	r2, #1
 80a20fc:	7f21      	ldrb	r1, [r4, #28]
 80a20fe:	f004 f828 	bl	80a6152 <_ZN7TwoWire11requestFromEhj>
    value = Wire.read();
 80a2102:	f005 f9cd 	bl	80a74a0 <_Z19__fetch_global_Wirev>
 80a2106:	6803      	ldr	r3, [r0, #0]
 80a2108:	695b      	ldr	r3, [r3, #20]
 80a210a:	4798      	blx	r3
 80a210c:	b2c5      	uxtb	r5, r0
}
 80a210e:	4628      	mov	r0, r5
 80a2110:	bd38      	pop	{r3, r4, r5, pc}
	if (_sck == -1)
 80a2112:	f990 3020 	ldrsb.w	r3, [r0, #32]
 80a2116:	3301      	adds	r3, #1
 80a2118:	d101      	bne.n	80a211e <_ZN15Adafruit_LIS3DH13readRegister8Eh+0x56>
	  beginTransaction();
 80a211a:	f7ff ff83 	bl	80a2024 <_ZN15Adafruit_LIS3DH16beginTransactionEv>
	digitalWrite(_cs, LOW);
 80a211e:	f994 001d 	ldrsb.w	r0, [r4, #29]
 80a2122:	2100      	movs	r1, #0
 80a2124:	b280      	uxth	r0, r0
 80a2126:	f005 fa48 	bl	80a75ba <digitalWrite>
    spixfer(reg | 0x80); // read, bit 7 high
 80a212a:	f045 0180 	orr.w	r1, r5, #128	; 0x80
 80a212e:	4620      	mov	r0, r4
 80a2130:	f7ff ff42 	bl	80a1fb8 <_ZN15Adafruit_LIS3DH7spixferEh>
    value = spixfer(0);
 80a2134:	2100      	movs	r1, #0
 80a2136:	4620      	mov	r0, r4
 80a2138:	f7ff ff3e 	bl	80a1fb8 <_ZN15Adafruit_LIS3DH7spixferEh>
 80a213c:	4605      	mov	r5, r0
    digitalWrite(_cs, HIGH);
 80a213e:	f994 001d 	ldrsb.w	r0, [r4, #29]
 80a2142:	2101      	movs	r1, #1
 80a2144:	b280      	uxth	r0, r0
 80a2146:	f005 fa38 	bl	80a75ba <digitalWrite>
    if (_sck == -1)
 80a214a:	e7e0      	b.n	80a210e <_ZN15Adafruit_LIS3DH13readRegister8Eh+0x46>

080a214c <_ZN15Adafruit_LIS3DH8setRangeE14lis3dh_range_t>:
{
 80a214c:	b538      	push	{r3, r4, r5, lr}
 80a214e:	460d      	mov	r5, r1
  uint8_t r = readRegister8(LIS3DH_REG_CTRL4);
 80a2150:	2123      	movs	r1, #35	; 0x23
{
 80a2152:	4604      	mov	r4, r0
  uint8_t r = readRegister8(LIS3DH_REG_CTRL4);
 80a2154:	f7ff ffb8 	bl	80a20c8 <_ZN15Adafruit_LIS3DH13readRegister8Eh>
  r &= ~(0x30);
 80a2158:	f020 0230 	bic.w	r2, r0, #48	; 0x30
  r |= range << 4;
 80a215c:	ea42 1205 	orr.w	r2, r2, r5, lsl #4
  writeRegister8(LIS3DH_REG_CTRL4, r);
 80a2160:	4620      	mov	r0, r4
}
 80a2162:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  writeRegister8(LIS3DH_REG_CTRL4, r);
 80a2166:	2123      	movs	r1, #35	; 0x23
 80a2168:	b2d2      	uxtb	r2, r2
 80a216a:	f7ff bf71 	b.w	80a2050 <_ZN15Adafruit_LIS3DH14writeRegister8Ehh>

080a216e <_ZN15Adafruit_LIS3DH8getRangeEv>:
  return (lis3dh_range_t)((readRegister8(LIS3DH_REG_CTRL4) >> 4) & 0x03);
 80a216e:	2123      	movs	r1, #35	; 0x23
{
 80a2170:	b508      	push	{r3, lr}
  return (lis3dh_range_t)((readRegister8(LIS3DH_REG_CTRL4) >> 4) & 0x03);
 80a2172:	f7ff ffa9 	bl	80a20c8 <_ZN15Adafruit_LIS3DH13readRegister8Eh>
}
 80a2176:	f3c0 1001 	ubfx	r0, r0, #4, #2
 80a217a:	bd08      	pop	{r3, pc}

080a217c <_ZN15Adafruit_LIS3DH11setDataRateE17lis3dh_dataRate_t>:
{
 80a217c:	b538      	push	{r3, r4, r5, lr}
 80a217e:	460d      	mov	r5, r1
  uint8_t ctl1 = readRegister8(LIS3DH_REG_CTRL1);
 80a2180:	2120      	movs	r1, #32
{
 80a2182:	4604      	mov	r4, r0
  uint8_t ctl1 = readRegister8(LIS3DH_REG_CTRL1);
 80a2184:	f7ff ffa0 	bl	80a20c8 <_ZN15Adafruit_LIS3DH13readRegister8Eh>
  ctl1 &= ~(0xF0); // mask off bits
 80a2188:	f000 020f 	and.w	r2, r0, #15
  ctl1 |= (dataRate << 4);
 80a218c:	ea42 1205 	orr.w	r2, r2, r5, lsl #4
  writeRegister8(LIS3DH_REG_CTRL1, ctl1);
 80a2190:	4620      	mov	r0, r4
}
 80a2192:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  writeRegister8(LIS3DH_REG_CTRL1, ctl1);
 80a2196:	2120      	movs	r1, #32
 80a2198:	b2d2      	uxtb	r2, r2
 80a219a:	f7ff bf59 	b.w	80a2050 <_ZN15Adafruit_LIS3DH14writeRegister8Ehh>

080a219e <_ZN15Adafruit_LIS3DH5beginEh>:
bool Adafruit_LIS3DH::begin(uint8_t i2caddr) {
 80a219e:	b510      	push	{r4, lr}
 80a21a0:	4604      	mov	r4, r0
  _i2caddr = i2caddr;
 80a21a2:	7701      	strb	r1, [r0, #28]
  if (_cs == -1) {
 80a21a4:	f990 001d 	ldrsb.w	r0, [r0, #29]
 80a21a8:	1c42      	adds	r2, r0, #1
 80a21aa:	d123      	bne.n	80a21f4 <_ZN15Adafruit_LIS3DH5beginEh+0x56>
    Wire.begin();
 80a21ac:	f005 f978 	bl	80a74a0 <_Z19__fetch_global_Wirev>
 80a21b0:	f003 ffa0 	bl	80a60f4 <_ZN7TwoWire5beginEv>
  uint8_t deviceid = readRegister8(LIS3DH_REG_WHOAMI);
 80a21b4:	210f      	movs	r1, #15
 80a21b6:	4620      	mov	r0, r4
 80a21b8:	f7ff ff86 	bl	80a20c8 <_ZN15Adafruit_LIS3DH13readRegister8Eh>
  if (deviceid != 0x33)
 80a21bc:	2833      	cmp	r0, #51	; 0x33
 80a21be:	d13d      	bne.n	80a223c <_ZN15Adafruit_LIS3DH5beginEh+0x9e>
  writeRegister8(LIS3DH_REG_CTRL1, 0x07);
 80a21c0:	2207      	movs	r2, #7
 80a21c2:	2120      	movs	r1, #32
 80a21c4:	4620      	mov	r0, r4
 80a21c6:	f7ff ff43 	bl	80a2050 <_ZN15Adafruit_LIS3DH14writeRegister8Ehh>
  setDataRate(LIS3DH_DATARATE_400_HZ);
 80a21ca:	2107      	movs	r1, #7
 80a21cc:	4620      	mov	r0, r4
 80a21ce:	f7ff ffd5 	bl	80a217c <_ZN15Adafruit_LIS3DH11setDataRateE17lis3dh_dataRate_t>
  writeRegister8(LIS3DH_REG_CTRL4, 0x88);
 80a21d2:	2288      	movs	r2, #136	; 0x88
 80a21d4:	2123      	movs	r1, #35	; 0x23
 80a21d6:	4620      	mov	r0, r4
 80a21d8:	f7ff ff3a 	bl	80a2050 <_ZN15Adafruit_LIS3DH14writeRegister8Ehh>
  writeRegister8(LIS3DH_REG_CTRL3, 0x10);
 80a21dc:	2210      	movs	r2, #16
 80a21de:	2122      	movs	r1, #34	; 0x22
 80a21e0:	4620      	mov	r0, r4
 80a21e2:	f7ff ff35 	bl	80a2050 <_ZN15Adafruit_LIS3DH14writeRegister8Ehh>
  writeRegister8(LIS3DH_REG_TEMPCFG, 0x80);
 80a21e6:	4620      	mov	r0, r4
 80a21e8:	2280      	movs	r2, #128	; 0x80
 80a21ea:	211f      	movs	r1, #31
 80a21ec:	f7ff ff30 	bl	80a2050 <_ZN15Adafruit_LIS3DH14writeRegister8Ehh>
  return true;
 80a21f0:	2001      	movs	r0, #1
}
 80a21f2:	bd10      	pop	{r4, pc}
    digitalWrite(_cs, HIGH);
 80a21f4:	2101      	movs	r1, #1
 80a21f6:	b280      	uxth	r0, r0
 80a21f8:	f005 f9df 	bl	80a75ba <digitalWrite>
    pinMode(_cs, OUTPUT);
 80a21fc:	f994 001d 	ldrsb.w	r0, [r4, #29]
 80a2200:	2101      	movs	r1, #1
 80a2202:	b280      	uxth	r0, r0
 80a2204:	f005 f9c8 	bl	80a7598 <pinMode>
    if (_sck == -1) {
 80a2208:	f994 0020 	ldrsb.w	r0, [r4, #32]
 80a220c:	1c43      	adds	r3, r0, #1
 80a220e:	d104      	bne.n	80a221a <_ZN15Adafruit_LIS3DH5beginEh+0x7c>
        instance().begin();
 80a2210:	f7ff feb4 	bl	80a1f7c <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8instanceEv>
 80a2214:	f003 fd0e 	bl	80a5c34 <_ZN8SPIClass5beginEv>
    }
 80a2218:	e7cc      	b.n	80a21b4 <_ZN15Adafruit_LIS3DH5beginEh+0x16>
      pinMode(_sck, OUTPUT);
 80a221a:	2101      	movs	r1, #1
 80a221c:	b280      	uxth	r0, r0
 80a221e:	f005 f9bb 	bl	80a7598 <pinMode>
      pinMode(_mosi, OUTPUT);
 80a2222:	f994 001e 	ldrsb.w	r0, [r4, #30]
 80a2226:	2101      	movs	r1, #1
 80a2228:	b280      	uxth	r0, r0
 80a222a:	f005 f9b5 	bl	80a7598 <pinMode>
      pinMode(_miso, INPUT);
 80a222e:	f994 001f 	ldrsb.w	r0, [r4, #31]
 80a2232:	2100      	movs	r1, #0
 80a2234:	b280      	uxth	r0, r0
 80a2236:	f005 f9af 	bl	80a7598 <pinMode>
 80a223a:	e7bb      	b.n	80a21b4 <_ZN15Adafruit_LIS3DH5beginEh+0x16>
    return false;
 80a223c:	2000      	movs	r0, #0
 80a223e:	e7d8      	b.n	80a21f2 <_ZN15Adafruit_LIS3DH5beginEh+0x54>

080a2240 <_ZN15Adafruit_LIS3DH4readEv>:
void Adafruit_LIS3DH::read(void) {
 80a2240:	b538      	push	{r3, r4, r5, lr}
  if (_cs == -1) {
 80a2242:	f990 301d 	ldrsb.w	r3, [r0, #29]
void Adafruit_LIS3DH::read(void) {
 80a2246:	4604      	mov	r4, r0
  if (_cs == -1) {
 80a2248:	3301      	adds	r3, #1
 80a224a:	d16f      	bne.n	80a232c <_ZN15Adafruit_LIS3DH4readEv+0xec>
    Wire.beginTransmission(_i2caddr);
 80a224c:	f005 f928 	bl	80a74a0 <_Z19__fetch_global_Wirev>
 80a2250:	f994 101c 	ldrsb.w	r1, [r4, #28]
 80a2254:	f003 ff84 	bl	80a6160 <_ZN7TwoWire17beginTransmissionEi>
    Wire.write(LIS3DH_REG_OUT_X_L | 0x80); // 0x80 for autoincrement
 80a2258:	f005 f922 	bl	80a74a0 <_Z19__fetch_global_Wirev>
 80a225c:	21a8      	movs	r1, #168	; 0xa8
 80a225e:	f7ff fe79 	bl	80a1f54 <_ZN7TwoWire5writeEi>
    Wire.endTransmission();
 80a2262:	f005 f91d 	bl	80a74a0 <_Z19__fetch_global_Wirev>
 80a2266:	f003 ff82 	bl	80a616e <_ZN7TwoWire15endTransmissionEv>
    Wire.requestFrom(_i2caddr, 6);
 80a226a:	f005 f919 	bl	80a74a0 <_Z19__fetch_global_Wirev>
 80a226e:	2206      	movs	r2, #6
 80a2270:	7f21      	ldrb	r1, [r4, #28]
 80a2272:	f003 ff6e 	bl	80a6152 <_ZN7TwoWire11requestFromEhj>
    x = Wire.read(); x |= ((uint16_t)Wire.read()) << 8;
 80a2276:	f005 f913 	bl	80a74a0 <_Z19__fetch_global_Wirev>
 80a227a:	6803      	ldr	r3, [r0, #0]
 80a227c:	4d4f      	ldr	r5, [pc, #316]	; (80a23bc <_ZN15Adafruit_LIS3DH4readEv+0x17c>)
 80a227e:	695b      	ldr	r3, [r3, #20]
 80a2280:	4798      	blx	r3
 80a2282:	80e0      	strh	r0, [r4, #6]
 80a2284:	f005 f90c 	bl	80a74a0 <_Z19__fetch_global_Wirev>
 80a2288:	6803      	ldr	r3, [r0, #0]
 80a228a:	695b      	ldr	r3, [r3, #20]
 80a228c:	4798      	blx	r3
 80a228e:	88e3      	ldrh	r3, [r4, #6]
 80a2290:	ea05 2000 	and.w	r0, r5, r0, lsl #8
 80a2294:	4318      	orrs	r0, r3
 80a2296:	80e0      	strh	r0, [r4, #6]
    y = Wire.read(); y |= ((uint16_t)Wire.read()) << 8;
 80a2298:	f005 f902 	bl	80a74a0 <_Z19__fetch_global_Wirev>
 80a229c:	6803      	ldr	r3, [r0, #0]
 80a229e:	695b      	ldr	r3, [r3, #20]
 80a22a0:	4798      	blx	r3
 80a22a2:	8120      	strh	r0, [r4, #8]
 80a22a4:	f005 f8fc 	bl	80a74a0 <_Z19__fetch_global_Wirev>
 80a22a8:	6803      	ldr	r3, [r0, #0]
 80a22aa:	695b      	ldr	r3, [r3, #20]
 80a22ac:	4798      	blx	r3
 80a22ae:	8923      	ldrh	r3, [r4, #8]
 80a22b0:	ea05 2000 	and.w	r0, r5, r0, lsl #8
 80a22b4:	4318      	orrs	r0, r3
 80a22b6:	8120      	strh	r0, [r4, #8]
    z = Wire.read(); z |= ((uint16_t)Wire.read()) << 8;
 80a22b8:	f005 f8f2 	bl	80a74a0 <_Z19__fetch_global_Wirev>
 80a22bc:	6803      	ldr	r3, [r0, #0]
 80a22be:	695b      	ldr	r3, [r3, #20]
 80a22c0:	4798      	blx	r3
 80a22c2:	8160      	strh	r0, [r4, #10]
 80a22c4:	f005 f8ec 	bl	80a74a0 <_Z19__fetch_global_Wirev>
 80a22c8:	6803      	ldr	r3, [r0, #0]
 80a22ca:	695b      	ldr	r3, [r3, #20]
 80a22cc:	4798      	blx	r3
 80a22ce:	ea05 2500 	and.w	r5, r5, r0, lsl #8
 80a22d2:	8960      	ldrh	r0, [r4, #10]
 80a22d4:	4305      	orrs	r5, r0
 80a22d6:	8165      	strh	r5, [r4, #10]
  uint8_t range = getRange();
 80a22d8:	4620      	mov	r0, r4
 80a22da:	f7ff ff48 	bl	80a216e <_ZN15Adafruit_LIS3DH8getRangeEv>
  if (range == LIS3DH_RANGE_16_G) divider = 2048;
 80a22de:	2803      	cmp	r0, #3
 80a22e0:	d062      	beq.n	80a23a8 <_ZN15Adafruit_LIS3DH4readEv+0x168>
  if (range == LIS3DH_RANGE_8_G) divider = 4096;
 80a22e2:	2802      	cmp	r0, #2
 80a22e4:	d063      	beq.n	80a23ae <_ZN15Adafruit_LIS3DH4readEv+0x16e>
  if (range == LIS3DH_RANGE_4_G) divider = 8190;
 80a22e6:	2801      	cmp	r0, #1
 80a22e8:	d064      	beq.n	80a23b4 <_ZN15Adafruit_LIS3DH4readEv+0x174>
  if (range == LIS3DH_RANGE_2_G) divider = 16380;
 80a22ea:	2800      	cmp	r0, #0
 80a22ec:	f643 70fc 	movw	r0, #16380	; 0x3ffc
 80a22f0:	bf18      	it	ne
 80a22f2:	2001      	movne	r0, #1
  x_g = (float)x / divider;
 80a22f4:	f005 fe3c 	bl	80a7f70 <__aeabi_i2f>
 80a22f8:	4605      	mov	r5, r0
 80a22fa:	f9b4 0006 	ldrsh.w	r0, [r4, #6]
 80a22fe:	f005 fe37 	bl	80a7f70 <__aeabi_i2f>
 80a2302:	4629      	mov	r1, r5
 80a2304:	f005 ff3c 	bl	80a8180 <__aeabi_fdiv>
 80a2308:	60e0      	str	r0, [r4, #12]
  y_g = (float)y / divider;
 80a230a:	f9b4 0008 	ldrsh.w	r0, [r4, #8]
 80a230e:	f005 fe2f 	bl	80a7f70 <__aeabi_i2f>
 80a2312:	4629      	mov	r1, r5
 80a2314:	f005 ff34 	bl	80a8180 <__aeabi_fdiv>
 80a2318:	6120      	str	r0, [r4, #16]
  z_g = (float)z / divider;
 80a231a:	f9b4 000a 	ldrsh.w	r0, [r4, #10]
 80a231e:	f005 fe27 	bl	80a7f70 <__aeabi_i2f>
 80a2322:	4629      	mov	r1, r5
 80a2324:	f005 ff2c 	bl	80a8180 <__aeabi_fdiv>
 80a2328:	6160      	str	r0, [r4, #20]
}
 80a232a:	bd38      	pop	{r3, r4, r5, pc}
    if (_sck == -1)
 80a232c:	f990 3020 	ldrsb.w	r3, [r0, #32]
 80a2330:	3301      	adds	r3, #1
 80a2332:	d101      	bne.n	80a2338 <_ZN15Adafruit_LIS3DH4readEv+0xf8>
      beginTransaction();
 80a2334:	f7ff fe76 	bl	80a2024 <_ZN15Adafruit_LIS3DH16beginTransactionEv>
    digitalWrite(_cs, LOW);
 80a2338:	f994 001d 	ldrsb.w	r0, [r4, #29]
 80a233c:	2100      	movs	r1, #0
 80a233e:	b280      	uxth	r0, r0
 80a2340:	f005 f93b 	bl	80a75ba <digitalWrite>
    spixfer(LIS3DH_REG_OUT_X_L | 0x80 | 0x40); // read multiple, bit 7&6 high
 80a2344:	21e8      	movs	r1, #232	; 0xe8
 80a2346:	4620      	mov	r0, r4
 80a2348:	f7ff fe36 	bl	80a1fb8 <_ZN15Adafruit_LIS3DH7spixferEh>
    x = spixfer(); x |= ((uint16_t)spixfer()) << 8;
 80a234c:	21ff      	movs	r1, #255	; 0xff
 80a234e:	4620      	mov	r0, r4
 80a2350:	f7ff fe32 	bl	80a1fb8 <_ZN15Adafruit_LIS3DH7spixferEh>
 80a2354:	21ff      	movs	r1, #255	; 0xff
 80a2356:	80e0      	strh	r0, [r4, #6]
 80a2358:	4620      	mov	r0, r4
 80a235a:	f7ff fe2d 	bl	80a1fb8 <_ZN15Adafruit_LIS3DH7spixferEh>
 80a235e:	88e3      	ldrh	r3, [r4, #6]
    y = spixfer(); y |= ((uint16_t)spixfer()) << 8;
 80a2360:	21ff      	movs	r1, #255	; 0xff
    x = spixfer(); x |= ((uint16_t)spixfer()) << 8;
 80a2362:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 80a2366:	80e3      	strh	r3, [r4, #6]
    y = spixfer(); y |= ((uint16_t)spixfer()) << 8;
 80a2368:	4620      	mov	r0, r4
 80a236a:	f7ff fe25 	bl	80a1fb8 <_ZN15Adafruit_LIS3DH7spixferEh>
 80a236e:	21ff      	movs	r1, #255	; 0xff
 80a2370:	8120      	strh	r0, [r4, #8]
 80a2372:	4620      	mov	r0, r4
 80a2374:	f7ff fe20 	bl	80a1fb8 <_ZN15Adafruit_LIS3DH7spixferEh>
 80a2378:	8923      	ldrh	r3, [r4, #8]
    z = spixfer(); z |= ((uint16_t)spixfer()) << 8;
 80a237a:	21ff      	movs	r1, #255	; 0xff
    y = spixfer(); y |= ((uint16_t)spixfer()) << 8;
 80a237c:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 80a2380:	8123      	strh	r3, [r4, #8]
    z = spixfer(); z |= ((uint16_t)spixfer()) << 8;
 80a2382:	4620      	mov	r0, r4
 80a2384:	f7ff fe18 	bl	80a1fb8 <_ZN15Adafruit_LIS3DH7spixferEh>
 80a2388:	21ff      	movs	r1, #255	; 0xff
 80a238a:	8160      	strh	r0, [r4, #10]
 80a238c:	4620      	mov	r0, r4
 80a238e:	f7ff fe13 	bl	80a1fb8 <_ZN15Adafruit_LIS3DH7spixferEh>
 80a2392:	8963      	ldrh	r3, [r4, #10]
    digitalWrite(_cs, HIGH);
 80a2394:	2101      	movs	r1, #1
    z = spixfer(); z |= ((uint16_t)spixfer()) << 8;
 80a2396:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
    digitalWrite(_cs, HIGH);
 80a239a:	f994 001d 	ldrsb.w	r0, [r4, #29]
    z = spixfer(); z |= ((uint16_t)spixfer()) << 8;
 80a239e:	8163      	strh	r3, [r4, #10]
    digitalWrite(_cs, HIGH);
 80a23a0:	b280      	uxth	r0, r0
 80a23a2:	f005 f90a 	bl	80a75ba <digitalWrite>
    if (_sck == -1)
 80a23a6:	e797      	b.n	80a22d8 <_ZN15Adafruit_LIS3DH4readEv+0x98>
  if (range == LIS3DH_RANGE_16_G) divider = 2048;
 80a23a8:	f44f 6000 	mov.w	r0, #2048	; 0x800
 80a23ac:	e7a2      	b.n	80a22f4 <_ZN15Adafruit_LIS3DH4readEv+0xb4>
  if (range == LIS3DH_RANGE_8_G) divider = 4096;
 80a23ae:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 80a23b2:	e79f      	b.n	80a22f4 <_ZN15Adafruit_LIS3DH4readEv+0xb4>
  if (range == LIS3DH_RANGE_4_G) divider = 8190;
 80a23b4:	f641 70fe 	movw	r0, #8190	; 0x1ffe
 80a23b8:	e79c      	b.n	80a22f4 <_ZN15Adafruit_LIS3DH4readEv+0xb4>
 80a23ba:	bf00      	nop
 80a23bc:	00ffff00 	.word	0x00ffff00

080a23c0 <_ZN15Adafruit_LIS3DH8getEventEP15sensors_event_t>:
bool Adafruit_LIS3DH::getEvent(sensors_event_t *event) {
 80a23c0:	b570      	push	{r4, r5, r6, lr}
 80a23c2:	460c      	mov	r4, r1
 80a23c4:	4605      	mov	r5, r0
  memset(event, 0, sizeof(sensors_event_t));
 80a23c6:	2220      	movs	r2, #32
 80a23c8:	2100      	movs	r1, #0
 80a23ca:	1d20      	adds	r0, r4, #4
 80a23cc:	f006 fa8c 	bl	80a88e8 <memset>
  event->version   = sizeof(sensors_event_t);
 80a23d0:	2324      	movs	r3, #36	; 0x24
 80a23d2:	6023      	str	r3, [r4, #0]
  event->sensor_id = _sensorID;
 80a23d4:	69ab      	ldr	r3, [r5, #24]
  event->type      = SENSOR_TYPE_ACCELEROMETER;
 80a23d6:	2601      	movs	r6, #1
  event->sensor_id = _sensorID;
 80a23d8:	6063      	str	r3, [r4, #4]
  event->timestamp = 0;
 80a23da:	2300      	movs	r3, #0
  read();
 80a23dc:	4628      	mov	r0, r5
  event->timestamp = 0;
 80a23de:	6123      	str	r3, [r4, #16]
  event->type      = SENSOR_TYPE_ACCELEROMETER;
 80a23e0:	60a6      	str	r6, [r4, #8]
  read();
 80a23e2:	f7ff ff2d 	bl	80a2240 <_ZN15Adafruit_LIS3DH4readEv>
  event->acceleration.x = x_g;
 80a23e6:	68eb      	ldr	r3, [r5, #12]
}
 80a23e8:	4630      	mov	r0, r6
  event->acceleration.x = x_g;
 80a23ea:	6163      	str	r3, [r4, #20]
  event->acceleration.y = y_g;
 80a23ec:	692b      	ldr	r3, [r5, #16]
 80a23ee:	61a3      	str	r3, [r4, #24]
  event->acceleration.z = z_g;
 80a23f0:	696b      	ldr	r3, [r5, #20]
 80a23f2:	61e3      	str	r3, [r4, #28]
}
 80a23f4:	bd70      	pop	{r4, r5, r6, pc}

080a23f6 <_ZN12Adafruit_GFX8drawLineEsssst>:
}

// Bresenham's algorithm - thx wikpedia
void Adafruit_GFX::drawLine(int16_t x0, int16_t y0,
			    int16_t x1, int16_t y1,
			    uint16_t color) {
 80a23f6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a23fa:	461f      	mov	r7, r3
 80a23fc:	b085      	sub	sp, #20
 80a23fe:	f9bd 8038 	ldrsh.w	r8, [sp, #56]	; 0x38
  int16_t steep = abs(y1 - y0) > abs(x1 - x0);
 80a2402:	eba7 0a01 	sub.w	sl, r7, r1
 80a2406:	eba8 0902 	sub.w	r9, r8, r2
 80a240a:	f1b9 0f00 	cmp.w	r9, #0
 80a240e:	bfb8      	it	lt
 80a2410:	f1c9 0900 	rsblt	r9, r9, #0
 80a2414:	f1ba 0f00 	cmp.w	sl, #0
 80a2418:	bfb8      	it	lt
 80a241a:	f1ca 0a00 	rsblt	sl, sl, #0
  if (steep) {
 80a241e:	45d1      	cmp	r9, sl
			    uint16_t color) {
 80a2420:	4683      	mov	fp, r0
 80a2422:	460c      	mov	r4, r1
 80a2424:	4616      	mov	r6, r2
 80a2426:	f8bd 303c 	ldrh.w	r3, [sp, #60]	; 0x3c
  if (steep) {
 80a242a:	dd04      	ble.n	80a2436 <_ZN12Adafruit_GFX8drawLineEsssst+0x40>
 80a242c:	463a      	mov	r2, r7
    swap(x0, y0);
 80a242e:	4634      	mov	r4, r6
    swap(x1, y1);
 80a2430:	4647      	mov	r7, r8
    swap(x0, y0);
 80a2432:	460e      	mov	r6, r1
    swap(x1, y1);
 80a2434:	4690      	mov	r8, r2
  }

  if (x0 > x1) {
 80a2436:	42bc      	cmp	r4, r7
 80a2438:	dd05      	ble.n	80a2446 <_ZN12Adafruit_GFX8drawLineEsssst+0x50>
 80a243a:	4632      	mov	r2, r6
    swap(x0, x1);
    swap(y0, y1);
 80a243c:	4646      	mov	r6, r8
 80a243e:	4690      	mov	r8, r2
  if (x0 > x1) {
 80a2440:	4622      	mov	r2, r4
 80a2442:	463c      	mov	r4, r7
 80a2444:	4617      	mov	r7, r2
  }

  int16_t dx, dy;
  dx = x1 - x0;
 80a2446:	1b3a      	subs	r2, r7, r4
 80a2448:	b291      	uxth	r1, r2
 80a244a:	9100      	str	r1, [sp, #0]
  dy = abs(y1 - y0);
 80a244c:	eba8 0106 	sub.w	r1, r8, r6
 80a2450:	2900      	cmp	r1, #0
 80a2452:	bfb8      	it	lt
 80a2454:	4249      	neglt	r1, r1

  int16_t err = dx / 2;
 80a2456:	f3c2 35c0 	ubfx	r5, r2, #15, #1
  dy = abs(y1 - y0);
 80a245a:	9101      	str	r1, [sp, #4]
  int16_t err = dx / 2;
 80a245c:	b211      	sxth	r1, r2
  int16_t ystep;

  if (y0 < y1) {
    ystep = 1;
  } else {
    ystep = -1;
 80a245e:	4546      	cmp	r6, r8
 80a2460:	bfb4      	ite	lt
 80a2462:	2201      	movlt	r2, #1
 80a2464:	f04f 32ff 	movge.w	r2, #4294967295	; 0xffffffff
  int16_t err = dx / 2;
 80a2468:	440d      	add	r5, r1
 80a246a:	106d      	asrs	r5, r5, #1
    ystep = -1;
 80a246c:	9202      	str	r2, [sp, #8]
  }

  for (; x0<=x1; x0++) {
 80a246e:	42bc      	cmp	r4, r7
 80a2470:	dc1c      	bgt.n	80a24ac <_ZN12Adafruit_GFX8drawLineEsssst+0xb6>
    if (steep) {
 80a2472:	f8db 2000 	ldr.w	r2, [fp]
 80a2476:	45d1      	cmp	r9, sl
      drawPixel(y0, x0, color);
 80a2478:	f8d2 8010 	ldr.w	r8, [r2, #16]
 80a247c:	bfc7      	ittee	gt
 80a247e:	4631      	movgt	r1, r6
 80a2480:	4622      	movgt	r2, r4
    } else {
      drawPixel(x0, y0, color);
 80a2482:	4632      	movle	r2, r6
 80a2484:	4621      	movle	r1, r4
      drawPixel(y0, x0, color);
 80a2486:	9303      	str	r3, [sp, #12]
      drawPixel(x0, y0, color);
 80a2488:	4658      	mov	r0, fp
 80a248a:	47c0      	blx	r8
    }
    err -= dy;
 80a248c:	9a01      	ldr	r2, [sp, #4]
      drawPixel(x0, y0, color);
 80a248e:	9b03      	ldr	r3, [sp, #12]
    err -= dy;
 80a2490:	1aad      	subs	r5, r5, r2
 80a2492:	b2a9      	uxth	r1, r5
 80a2494:	b22d      	sxth	r5, r5
    if (err < 0) {
 80a2496:	2d00      	cmp	r5, #0
 80a2498:	da05      	bge.n	80a24a6 <_ZN12Adafruit_GFX8drawLineEsssst+0xb0>
      y0 += ystep;
 80a249a:	9a02      	ldr	r2, [sp, #8]
 80a249c:	4416      	add	r6, r2
      err += dx;
 80a249e:	9a00      	ldr	r2, [sp, #0]
      y0 += ystep;
 80a24a0:	b236      	sxth	r6, r6
      err += dx;
 80a24a2:	1855      	adds	r5, r2, r1
 80a24a4:	b22d      	sxth	r5, r5
  for (; x0<=x1; x0++) {
 80a24a6:	3401      	adds	r4, #1
 80a24a8:	b224      	sxth	r4, r4
 80a24aa:	e7e0      	b.n	80a246e <_ZN12Adafruit_GFX8drawLineEsssst+0x78>
    }
  }
}
 80a24ac:	b005      	add	sp, #20
 80a24ae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080a24b2 <_ZN12Adafruit_GFX8drawRectEsssst>:

// Draw a rectangle
void Adafruit_GFX::drawRect(int16_t x, int16_t y,
			    int16_t w, int16_t h,
			    uint16_t color) {
 80a24b2:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 80a24b6:	4604      	mov	r4, r0
 80a24b8:	4616      	mov	r6, r2
 80a24ba:	468a      	mov	sl, r1
 80a24bc:	461d      	mov	r5, r3
 80a24be:	f8bd 802c 	ldrh.w	r8, [sp, #44]	; 0x2c
  drawFastHLine(x, y, w, color);
 80a24c2:	6807      	ldr	r7, [r0, #0]
			    uint16_t color) {
 80a24c4:	f9bd 9028 	ldrsh.w	r9, [sp, #40]	; 0x28
  drawFastHLine(x, y, w, color);
 80a24c8:	f8cd 8000 	str.w	r8, [sp]
 80a24cc:	69ff      	ldr	r7, [r7, #28]
 80a24ce:	47b8      	blx	r7
  drawFastHLine(x, y+h-1, w, color);
 80a24d0:	6823      	ldr	r3, [r4, #0]
 80a24d2:	f109 32ff 	add.w	r2, r9, #4294967295	; 0xffffffff
 80a24d6:	f8cd 8000 	str.w	r8, [sp]
 80a24da:	4432      	add	r2, r6
 80a24dc:	4651      	mov	r1, sl
 80a24de:	4620      	mov	r0, r4
 80a24e0:	69df      	ldr	r7, [r3, #28]
 80a24e2:	b212      	sxth	r2, r2
 80a24e4:	462b      	mov	r3, r5
 80a24e6:	47b8      	blx	r7
  drawFastVLine(x, y, h, color);
 80a24e8:	6823      	ldr	r3, [r4, #0]
 80a24ea:	f8cd 8000 	str.w	r8, [sp]
 80a24ee:	4632      	mov	r2, r6
 80a24f0:	4651      	mov	r1, sl
 80a24f2:	4620      	mov	r0, r4
 80a24f4:	699f      	ldr	r7, [r3, #24]
 80a24f6:	464b      	mov	r3, r9
 80a24f8:	47b8      	blx	r7
  drawFastVLine(x+w-1, y, h, color);
 80a24fa:	6823      	ldr	r3, [r4, #0]
 80a24fc:	3d01      	subs	r5, #1
 80a24fe:	f8cd 8028 	str.w	r8, [sp, #40]	; 0x28
 80a2502:	eb05 010a 	add.w	r1, r5, sl
 80a2506:	699d      	ldr	r5, [r3, #24]
 80a2508:	4632      	mov	r2, r6
 80a250a:	464b      	mov	r3, r9
 80a250c:	4620      	mov	r0, r4
 80a250e:	46ac      	mov	ip, r5
 80a2510:	b209      	sxth	r1, r1
}
 80a2512:	b002      	add	sp, #8
 80a2514:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  drawFastVLine(x+w-1, y, h, color);
 80a2518:	4760      	bx	ip

080a251a <_ZN12Adafruit_GFX13drawFastVLineEssst>:

void Adafruit_GFX::drawFastVLine(int16_t x, int16_t y,
				 int16_t h, uint16_t color) {
 80a251a:	b537      	push	{r0, r1, r2, r4, r5, lr}
  // Update in subclasses if desired!
  drawLine(x, y, x, y+h-1, color);
 80a251c:	3b01      	subs	r3, #1
 80a251e:	f8bd 5018 	ldrh.w	r5, [sp, #24]
 80a2522:	4413      	add	r3, r2
 80a2524:	6804      	ldr	r4, [r0, #0]
 80a2526:	b21b      	sxth	r3, r3
 80a2528:	9300      	str	r3, [sp, #0]
 80a252a:	9501      	str	r5, [sp, #4]
 80a252c:	460b      	mov	r3, r1
 80a252e:	6964      	ldr	r4, [r4, #20]
 80a2530:	47a0      	blx	r4
}
 80a2532:	b003      	add	sp, #12
 80a2534:	bd30      	pop	{r4, r5, pc}

080a2536 <_ZN12Adafruit_GFX13drawFastHLineEssst>:

void Adafruit_GFX::drawFastHLine(int16_t x, int16_t y,
				 int16_t w, uint16_t color) {
 80a2536:	b537      	push	{r0, r1, r2, r4, r5, lr}
  // Update in subclasses if desired!
  drawLine(x, y, x+w-1, y, color);
 80a2538:	f8bd 5018 	ldrh.w	r5, [sp, #24]
 80a253c:	6804      	ldr	r4, [r0, #0]
 80a253e:	e9cd 2500 	strd	r2, r5, [sp]
 80a2542:	3b01      	subs	r3, #1
 80a2544:	440b      	add	r3, r1
 80a2546:	6964      	ldr	r4, [r4, #20]
 80a2548:	b21b      	sxth	r3, r3
 80a254a:	47a0      	blx	r4
}
 80a254c:	b003      	add	sp, #12
 80a254e:	bd30      	pop	{r4, r5, pc}

080a2550 <_ZN12Adafruit_GFX8fillRectEsssst>:

void Adafruit_GFX::fillRect(int16_t x, int16_t y, int16_t w, int16_t h,
			    uint16_t color) {
 80a2550:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 80a2554:	4605      	mov	r5, r0
 80a2556:	4616      	mov	r6, r2
  // Update in subclasses if desired!
  for (int16_t i=x; i<x+w; i++) {
 80a2558:	460c      	mov	r4, r1
			    uint16_t color) {
 80a255a:	f9bd a028 	ldrsh.w	sl, [sp, #40]	; 0x28
 80a255e:	f8bd 902c 	ldrh.w	r9, [sp, #44]	; 0x2c
  for (int16_t i=x; i<x+w; i++) {
 80a2562:	18cf      	adds	r7, r1, r3
 80a2564:	42bc      	cmp	r4, r7
 80a2566:	da0c      	bge.n	80a2582 <_ZN12Adafruit_GFX8fillRectEsssst+0x32>
    drawFastVLine(i, y, h, color);
 80a2568:	682b      	ldr	r3, [r5, #0]
 80a256a:	f8cd 9000 	str.w	r9, [sp]
 80a256e:	4621      	mov	r1, r4
 80a2570:	f8d3 8018 	ldr.w	r8, [r3, #24]
 80a2574:	4632      	mov	r2, r6
 80a2576:	4653      	mov	r3, sl
 80a2578:	4628      	mov	r0, r5
 80a257a:	3401      	adds	r4, #1
 80a257c:	47c0      	blx	r8
  for (int16_t i=x; i<x+w; i++) {
 80a257e:	b224      	sxth	r4, r4
 80a2580:	e7f0      	b.n	80a2564 <_ZN12Adafruit_GFX8fillRectEsssst+0x14>
  }
}
 80a2582:	b002      	add	sp, #8
 80a2584:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

080a2588 <_ZN12Adafruit_GFX10fillScreenEt>:

void Adafruit_GFX::fillScreen(uint16_t color) {
 80a2588:	b513      	push	{r0, r1, r4, lr}
  fillRect(0, 0, _width, _height, color);
 80a258a:	9101      	str	r1, [sp, #4]
 80a258c:	f9b0 100e 	ldrsh.w	r1, [r0, #14]
 80a2590:	6802      	ldr	r2, [r0, #0]
 80a2592:	9100      	str	r1, [sp, #0]
 80a2594:	6a54      	ldr	r4, [r2, #36]	; 0x24
 80a2596:	2200      	movs	r2, #0
 80a2598:	f9b0 300c 	ldrsh.w	r3, [r0, #12]
 80a259c:	4611      	mov	r1, r2
 80a259e:	47a0      	blx	r4
}
 80a25a0:	b002      	add	sp, #8
 80a25a2:	bd10      	pop	{r4, pc}

080a25a4 <_ZN12Adafruit_GFX13invertDisplayEb>:
  return _height;
}

void Adafruit_GFX::invertDisplay(boolean i) {
  // Do nothing, must be subclassed if supported
}
 80a25a4:	4770      	bx	lr

080a25a6 <_ZN12Adafruit_GFX5writeEh>:
  if (c == '\n') {
 80a25a6:	290a      	cmp	r1, #10
size_t Adafruit_GFX::write(uint8_t c) {
 80a25a8:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 80a25ac:	4604      	mov	r4, r0
 80a25ae:	460d      	mov	r5, r1
  if (c == '\n') {
 80a25b0:	d10c      	bne.n	80a25cc <_ZN12Adafruit_GFX5writeEh+0x26>
    cursor_y += textsize*fontDesc[0].height;	//all chars are same height so use height of space char
 80a25b2:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80a25b4:	8a42      	ldrh	r2, [r0, #18]
 80a25b6:	7859      	ldrb	r1, [r3, #1]
 80a25b8:	7e03      	ldrb	r3, [r0, #24]
 80a25ba:	fb01 2303 	mla	r3, r1, r3, r2
 80a25be:	8243      	strh	r3, [r0, #18]
      cursor_x = 0;
 80a25c0:	2300      	movs	r3, #0
 80a25c2:	8223      	strh	r3, [r4, #16]
}
 80a25c4:	2001      	movs	r0, #1
 80a25c6:	b004      	add	sp, #16
 80a25c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  } else if (c == '\r') {
 80a25cc:	290d      	cmp	r1, #13
 80a25ce:	d0f9      	beq.n	80a25c4 <_ZN12Adafruit_GFX5writeEh+0x1e>
    drawFastChar(cursor_x, cursor_y, c, textcolor, textbgcolor, textsize);
 80a25d0:	7e02      	ldrb	r2, [r0, #24]
 80a25d2:	6803      	ldr	r3, [r0, #0]
 80a25d4:	9202      	str	r2, [sp, #8]
 80a25d6:	8ac2      	ldrh	r2, [r0, #22]
 80a25d8:	9201      	str	r2, [sp, #4]
 80a25da:	8a82      	ldrh	r2, [r0, #20]
 80a25dc:	9200      	str	r2, [sp, #0]
 80a25de:	6b1e      	ldr	r6, [r3, #48]	; 0x30
 80a25e0:	f9b0 2012 	ldrsh.w	r2, [r0, #18]
 80a25e4:	460b      	mov	r3, r1
 80a25e6:	f9b0 1010 	ldrsh.w	r1, [r0, #16]
 80a25ea:	47b0      	blx	r6
	uint16_t w = fontDesc[c-fontStart].width;
 80a25ec:	7ee3      	ldrb	r3, [r4, #27]
    if (fontKern > 0 && textcolor != textbgcolor) {
 80a25ee:	f994 701d 	ldrsb.w	r7, [r4, #29]
	uint16_t w = fontDesc[c-fontStart].width;
 80a25f2:	1aed      	subs	r5, r5, r3
 80a25f4:	6a63      	ldr	r3, [r4, #36]	; 0x24
    if (fontKern > 0 && textcolor != textbgcolor) {
 80a25f6:	2f00      	cmp	r7, #0
	uint16_t w = fontDesc[c-fontStart].width;
 80a25f8:	eb03 0285 	add.w	r2, r3, r5, lsl #2
 80a25fc:	f813 6025 	ldrb.w	r6, [r3, r5, lsl #2]
	uint16_t h = fontDesc[c-fontStart].height;
 80a2600:	7855      	ldrb	r5, [r2, #1]
    if (fontKern > 0 && textcolor != textbgcolor) {
 80a2602:	dd15      	ble.n	80a2630 <_ZN12Adafruit_GFX5writeEh+0x8a>
 80a2604:	8ae2      	ldrh	r2, [r4, #22]
 80a2606:	8aa3      	ldrh	r3, [r4, #20]
 80a2608:	4293      	cmp	r3, r2
 80a260a:	d011      	beq.n	80a2630 <_ZN12Adafruit_GFX5writeEh+0x8a>
 80a260c:	7e23      	ldrb	r3, [r4, #24]
      fillRect(cursor_x+w*textsize,cursor_y,fontKern*textsize,h*textsize,textbgcolor);
 80a260e:	9201      	str	r2, [sp, #4]
 80a2610:	8a21      	ldrh	r1, [r4, #16]
 80a2612:	fb03 f205 	mul.w	r2, r3, r5
 80a2616:	fb06 1103 	mla	r1, r6, r3, r1
 80a261a:	6820      	ldr	r0, [r4, #0]
 80a261c:	b212      	sxth	r2, r2
 80a261e:	9200      	str	r2, [sp, #0]
 80a2620:	f8d0 8024 	ldr.w	r8, [r0, #36]	; 0x24
 80a2624:	437b      	muls	r3, r7
 80a2626:	4620      	mov	r0, r4
 80a2628:	f9b4 2012 	ldrsh.w	r2, [r4, #18]
 80a262c:	b209      	sxth	r1, r1
 80a262e:	47c0      	blx	r8
    cursor_x += textsize*(w+fontKern);
 80a2630:	f994 301d 	ldrsb.w	r3, [r4, #29]
 80a2634:	8a20      	ldrh	r0, [r4, #16]
 80a2636:	7e22      	ldrb	r2, [r4, #24]
 80a2638:	4433      	add	r3, r6
 80a263a:	fb03 0302 	mla	r3, r3, r2, r0
    if (wrap && (cursor_x > (_width - textsize*w))) {
 80a263e:	f894 0028 	ldrb.w	r0, [r4, #40]	; 0x28
    cursor_x += textsize*(w+fontKern);
 80a2642:	b21b      	sxth	r3, r3
 80a2644:	4611      	mov	r1, r2
 80a2646:	8223      	strh	r3, [r4, #16]
    if (wrap && (cursor_x > (_width - textsize*w))) {
 80a2648:	2800      	cmp	r0, #0
 80a264a:	d0bb      	beq.n	80a25c4 <_ZN12Adafruit_GFX5writeEh+0x1e>
 80a264c:	f9b4 000c 	ldrsh.w	r0, [r4, #12]
 80a2650:	fb06 0212 	mls	r2, r6, r2, r0
 80a2654:	4293      	cmp	r3, r2
 80a2656:	ddb5      	ble.n	80a25c4 <_ZN12Adafruit_GFX5writeEh+0x1e>
      cursor_y += textsize*h;
 80a2658:	8a63      	ldrh	r3, [r4, #18]
 80a265a:	fb01 3505 	mla	r5, r1, r5, r3
 80a265e:	8265      	strh	r5, [r4, #18]
 80a2660:	e7ae      	b.n	80a25c0 <_ZN12Adafruit_GFX5writeEh+0x1a>
	...

080a2664 <_ZN12Adafruit_GFX7setFontEh>:
      font = GLCDFONT;
 80a2664:	2304      	movs	r3, #4
	  fontDesc = glcdfontDescriptors;
 80a2666:	4a06      	ldr	r2, [pc, #24]	; (80a2680 <_ZN12Adafruit_GFX7setFontEh+0x1c>)
      font = GLCDFONT;
 80a2668:	7683      	strb	r3, [r0, #26]
	  fontDesc = glcdfontDescriptors;
 80a266a:	6242      	str	r2, [r0, #36]	; 0x24
      fontKern = 1;
 80a266c:	2201      	movs	r2, #1
      fontData = glcdfontBitmaps;
 80a266e:	4b05      	ldr	r3, [pc, #20]	; (80a2684 <_ZN12Adafruit_GFX7setFontEh+0x20>)
      fontKern = 1;
 80a2670:	7742      	strb	r2, [r0, #29]
      fontData = glcdfontBitmaps;
 80a2672:	6203      	str	r3, [r0, #32]
  fontStart = pgm_read_byte(fontData+FONT_START);
 80a2674:	781a      	ldrb	r2, [r3, #0]
 80a2676:	76c2      	strb	r2, [r0, #27]
  fontEnd = pgm_read_byte(fontData+FONT_END);
 80a2678:	785b      	ldrb	r3, [r3, #1]
 80a267a:	7703      	strb	r3, [r0, #28]
}
 80a267c:	4770      	bx	lr
 80a267e:	bf00      	nop
 80a2680:	080aa002 	.word	0x080aa002
 80a2684:	080a9808 	.word	0x080a9808

080a2688 <_ZN12Adafruit_GFXC1Ess>:
Adafruit_GFX::Adafruit_GFX(int16_t w, int16_t h):
 80a2688:	b538      	push	{r3, r4, r5, lr}
    Print() : write_error(0) {}
 80a268a:	2300      	movs	r3, #0
 80a268c:	6043      	str	r3, [r0, #4]
  cursor_y  = cursor_x    = 0;
 80a268e:	6103      	str	r3, [r0, #16]
  textcolor = textbgcolor = 0xFFFF;
 80a2690:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80a2694:	6143      	str	r3, [r0, #20]
  textsize  = 1;
 80a2696:	2301      	movs	r3, #1
  WIDTH(w), HEIGHT(h)
 80a2698:	4d06      	ldr	r5, [pc, #24]	; (80a26b4 <_ZN12Adafruit_GFXC1Ess+0x2c>)
 80a269a:	8101      	strh	r1, [r0, #8]
  _width    = WIDTH;
 80a269c:	8181      	strh	r1, [r0, #12]
  WIDTH(w), HEIGHT(h)
 80a269e:	6005      	str	r5, [r0, #0]
  setFont(GLCDFONT);		// May also be set to TIMESNR_8, CENTURY_8, COMICS_8 or TEST (for testing candidate fonts)
 80a26a0:	2104      	movs	r1, #4
  WIDTH(w), HEIGHT(h)
 80a26a2:	8142      	strh	r2, [r0, #10]
  _height   = HEIGHT;
 80a26a4:	81c2      	strh	r2, [r0, #14]
  textsize  = 1;
 80a26a6:	8303      	strh	r3, [r0, #24]
  wrap      = true;
 80a26a8:	f880 3028 	strb.w	r3, [r0, #40]	; 0x28
  setFont(GLCDFONT);		// May also be set to TIMESNR_8, CENTURY_8, COMICS_8 or TEST (for testing candidate fonts)
 80a26ac:	f7ff ffda 	bl	80a2664 <_ZN12Adafruit_GFX7setFontEh>
 }
 80a26b0:	bd38      	pop	{r3, r4, r5, pc}
 80a26b2:	bf00      	nop
 80a26b4:	080a97d4 	.word	0x080a97d4

080a26b8 <_ZN12Adafruit_GFX8drawCharEsshtth>:
			    uint16_t color, uint16_t bg, uint8_t size) {
 80a26b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a26bc:	b08b      	sub	sp, #44	; 0x2c
 80a26be:	9205      	str	r2, [sp, #20]
 80a26c0:	f8bd 2050 	ldrh.w	r2, [sp, #80]	; 0x50
 80a26c4:	4681      	mov	r9, r0
 80a26c6:	9206      	str	r2, [sp, #24]
 80a26c8:	f8bd 2054 	ldrh.w	r2, [sp, #84]	; 0x54
 80a26cc:	2600      	movs	r6, #0
 80a26ce:	9207      	str	r2, [sp, #28]
  if (c < fontStart || c > fontEnd) {
 80a26d0:	7ec2      	ldrb	r2, [r0, #27]
			    uint16_t color, uint16_t bg, uint8_t size) {
 80a26d2:	f89d 7058 	ldrb.w	r7, [sp, #88]	; 0x58
  if (c < fontStart || c > fontEnd) {
 80a26d6:	429a      	cmp	r2, r3
 80a26d8:	d865      	bhi.n	80a27a6 <_ZN12Adafruit_GFX8drawCharEsshtth+0xee>
 80a26da:	7f04      	ldrb	r4, [r0, #28]
 80a26dc:	429c      	cmp	r4, r3
 80a26de:	d362      	bcc.n	80a27a6 <_ZN12Adafruit_GFX8drawCharEsshtth+0xee>
    c -= fontStart;
 80a26e0:	1a9b      	subs	r3, r3, r2
 80a26e2:	b2db      	uxtb	r3, r3
  if((x >= _width)            || // Clip right
 80a26e4:	f9b9 200c 	ldrsh.w	r2, [r9, #12]
 80a26e8:	428a      	cmp	r2, r1
 80a26ea:	f340 8083 	ble.w	80a27f4 <_ZN12Adafruit_GFX8drawCharEsshtth+0x13c>
 80a26ee:	f9b9 200e 	ldrsh.w	r2, [r9, #14]
 80a26f2:	9805      	ldr	r0, [sp, #20]
 80a26f4:	4282      	cmp	r2, r0
 80a26f6:	dd7d      	ble.n	80a27f4 <_ZN12Adafruit_GFX8drawCharEsshtth+0x13c>
     ((x + (fontDesc[c].width * size) - 1) < 0) || // Clip left
 80a26f8:	f8d9 4024 	ldr.w	r4, [r9, #36]	; 0x24
 80a26fc:	009a      	lsls	r2, r3, #2
 80a26fe:	9209      	str	r2, [sp, #36]	; 0x24
 80a2700:	eb04 0283 	add.w	r2, r4, r3, lsl #2
 80a2704:	f814 3023 	ldrb.w	r3, [r4, r3, lsl #2]
 80a2708:	fb07 1303 	mla	r3, r7, r3, r1
     (y >= _height)           || // Clip bottom
 80a270c:	2b00      	cmp	r3, #0
 80a270e:	dd71      	ble.n	80a27f4 <_ZN12Adafruit_GFX8drawCharEsshtth+0x13c>
     ((y + (fontDesc[c].height * size) - 1) < 0))   // Clip top
 80a2710:	7853      	ldrb	r3, [r2, #1]
 80a2712:	fb07 0303 	mla	r3, r7, r3, r0
     ((x + (fontDesc[c].width * size) - 1) < 0) || // Clip left
 80a2716:	2b00      	cmp	r3, #0
 80a2718:	dd6c      	ble.n	80a27f4 <_ZN12Adafruit_GFX8drawCharEsshtth+0x13c>
  	uint16_t fontIndex = fontDesc[c].offset + 2; //((fontDesc + c)->offset) + 2;
 80a271a:	8853      	ldrh	r3, [r2, #2]
 80a271c:	b28c      	uxth	r4, r1
 80a271e:	3302      	adds	r3, #2
 80a2720:	b29b      	uxth	r3, r3
 80a2722:	9303      	str	r3, [sp, #12]
 80a2724:	2300      	movs	r3, #0
 80a2726:	9304      	str	r3, [sp, #16]
          fillRect(x+j*size, y+i*size, size, size, bg);
 80a2728:	b2bb      	uxth	r3, r7
 80a272a:	9308      	str	r3, [sp, #32]
  for (int8_t i=0; i<fontDesc[c].height; i++ ) {	// i<fontHeight
 80a272c:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 80a2730:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80a2732:	f99d 5010 	ldrsb.w	r5, [sp, #16]
 80a2736:	4413      	add	r3, r2
 80a2738:	785b      	ldrb	r3, [r3, #1]
 80a273a:	429d      	cmp	r5, r3
 80a273c:	da5a      	bge.n	80a27f4 <_ZN12Adafruit_GFX8drawCharEsshtth+0x13c>
          fillRect(x+j*size, y+i*size, size, size, bg);
 80a273e:	f04f 0800 	mov.w	r8, #0
 80a2742:	f8bd 3014 	ldrh.w	r3, [sp, #20]
 80a2746:	9a08      	ldr	r2, [sp, #32]
 80a2748:	b2ad      	uxth	r5, r5
 80a274a:	fb05 3202 	mla	r2, r5, r2, r3
          drawPixel(x+j, y+i, bg);
 80a274e:	441d      	add	r5, r3
          fillRect(x+j*size, y+i*size, size, size, bg);
 80a2750:	fa0f fa82 	sxth.w	sl, r2
          drawPixel(x+j, y+i, bg);
 80a2754:	b22d      	sxth	r5, r5
    for (int8_t j = 0; j<fontDesc[c].width; j++) {			//j<fontWidth
 80a2756:	f8d9 2024 	ldr.w	r2, [r9, #36]	; 0x24
 80a275a:	9809      	ldr	r0, [sp, #36]	; 0x24
 80a275c:	fa4f f188 	sxtb.w	r1, r8
 80a2760:	5c12      	ldrb	r2, [r2, r0]
 80a2762:	fa5f f388 	uxtb.w	r3, r8
 80a2766:	4291      	cmp	r1, r2
 80a2768:	da40      	bge.n	80a27ec <_ZN12Adafruit_GFX8drawCharEsshtth+0x134>
      if (bitCount++%8 == 0) {
 80a276a:	075a      	lsls	r2, r3, #29
 80a276c:	d107      	bne.n	80a277e <_ZN12Adafruit_GFX8drawCharEsshtth+0xc6>
        line = pgm_read_byte(fontData+fontIndex++);
 80a276e:	9b03      	ldr	r3, [sp, #12]
 80a2770:	9803      	ldr	r0, [sp, #12]
 80a2772:	f8d9 2020 	ldr.w	r2, [r9, #32]
 80a2776:	3301      	adds	r3, #1
 80a2778:	b29b      	uxth	r3, r3
 80a277a:	5c16      	ldrb	r6, [r2, r0]
 80a277c:	9303      	str	r3, [sp, #12]
      if (line & 0x80) {
 80a277e:	0633      	lsls	r3, r6, #24
 80a2780:	d521      	bpl.n	80a27c6 <_ZN12Adafruit_GFX8drawCharEsshtth+0x10e>
        if (size == 1) {// default sizeFast
 80a2782:	2f01      	cmp	r7, #1
 80a2784:	f8d9 2000 	ldr.w	r2, [r9]
 80a2788:	b289      	uxth	r1, r1
 80a278a:	d10e      	bne.n	80a27aa <_ZN12Adafruit_GFX8drawCharEsshtth+0xf2>
          drawPixel(x+j, y+i, color);
 80a278c:	f8d2 b010 	ldr.w	fp, [r2, #16]
 80a2790:	9b06      	ldr	r3, [sp, #24]
 80a2792:	4421      	add	r1, r4
          drawPixel(x+j, y+i, bg);
 80a2794:	462a      	mov	r2, r5
 80a2796:	4648      	mov	r0, r9
 80a2798:	b209      	sxth	r1, r1
 80a279a:	47d8      	blx	fp
      line <<= 1;
 80a279c:	0076      	lsls	r6, r6, #1
 80a279e:	b2f6      	uxtb	r6, r6
    for (int8_t j = 0; j<fontDesc[c].width; j++) {			//j<fontWidth
 80a27a0:	f108 0801 	add.w	r8, r8, #1
 80a27a4:	e7d7      	b.n	80a2756 <_ZN12Adafruit_GFX8drawCharEsshtth+0x9e>
    c = 0;
 80a27a6:	4633      	mov	r3, r6
 80a27a8:	e79c      	b.n	80a26e4 <_ZN12Adafruit_GFX8drawCharEsshtth+0x2c>
          fillRect(x+(j*size), y+(i*size), size, size, color);
 80a27aa:	9808      	ldr	r0, [sp, #32]
 80a27ac:	b23b      	sxth	r3, r7
 80a27ae:	fb01 4100 	mla	r1, r1, r0, r4
 80a27b2:	9806      	ldr	r0, [sp, #24]
          fillRect(x+j*size, y+i*size, size, size, bg);
 80a27b4:	e9cd 3000 	strd	r3, r0, [sp]
 80a27b8:	b209      	sxth	r1, r1
 80a27ba:	f8d2 b024 	ldr.w	fp, [r2, #36]	; 0x24
 80a27be:	4648      	mov	r0, r9
 80a27c0:	4652      	mov	r2, sl
 80a27c2:	47d8      	blx	fp
 80a27c4:	e7ea      	b.n	80a279c <_ZN12Adafruit_GFX8drawCharEsshtth+0xe4>
      } else if (bg != color) {
 80a27c6:	e9dd 2306 	ldrd	r2, r3, [sp, #24]
 80a27ca:	4293      	cmp	r3, r2
 80a27cc:	d0e6      	beq.n	80a279c <_ZN12Adafruit_GFX8drawCharEsshtth+0xe4>
        if (size == 1) // default size
 80a27ce:	2f01      	cmp	r7, #1
 80a27d0:	f8d9 2000 	ldr.w	r2, [r9]
 80a27d4:	b289      	uxth	r1, r1
 80a27d6:	d103      	bne.n	80a27e0 <_ZN12Adafruit_GFX8drawCharEsshtth+0x128>
          drawPixel(x+j, y+i, bg);
 80a27d8:	f8d2 b010 	ldr.w	fp, [r2, #16]
 80a27dc:	4421      	add	r1, r4
 80a27de:	e7d9      	b.n	80a2794 <_ZN12Adafruit_GFX8drawCharEsshtth+0xdc>
          fillRect(x+j*size, y+i*size, size, size, bg);
 80a27e0:	9808      	ldr	r0, [sp, #32]
 80a27e2:	b23b      	sxth	r3, r7
 80a27e4:	fb01 4100 	mla	r1, r1, r0, r4
 80a27e8:	9807      	ldr	r0, [sp, #28]
 80a27ea:	e7e3      	b.n	80a27b4 <_ZN12Adafruit_GFX8drawCharEsshtth+0xfc>
  for (int8_t i=0; i<fontDesc[c].height; i++ ) {	// i<fontHeight
 80a27ec:	9b04      	ldr	r3, [sp, #16]
 80a27ee:	3301      	adds	r3, #1
 80a27f0:	9304      	str	r3, [sp, #16]
 80a27f2:	e79b      	b.n	80a272c <_ZN12Adafruit_GFX8drawCharEsshtth+0x74>
}
 80a27f4:	b00b      	add	sp, #44	; 0x2c
 80a27f6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080a27fa <_ZN12Adafruit_GFX12drawFastCharEsshtth>:
                                    uint16_t color, uint16_t bg, uint8_t size) {
 80a27fa:	b470      	push	{r4, r5, r6}
 80a27fc:	f8bd 400c 	ldrh.w	r4, [sp, #12]
 80a2800:	f8bd 5010 	ldrh.w	r5, [sp, #16]
 80a2804:	f89d 6014 	ldrb.w	r6, [sp, #20]
  drawChar(x,y,c,color,bg,size);
 80a2808:	9403      	str	r4, [sp, #12]
 80a280a:	e9cd 5604 	strd	r5, r6, [sp, #16]
}
 80a280e:	bc70      	pop	{r4, r5, r6}
  drawChar(x,y,c,color,bg,size);
 80a2810:	f7ff bf52 	b.w	80a26b8 <_ZN12Adafruit_GFX8drawCharEsshtth>

080a2814 <_ZN12Adafruit_GFX9setCursorEss>:
  cursor_x = x;
 80a2814:	8201      	strh	r1, [r0, #16]
  cursor_y = y;
 80a2816:	8242      	strh	r2, [r0, #18]
}
 80a2818:	4770      	bx	lr

080a281a <_ZN12Adafruit_GFX11setTextSizeEh>:
  textsize = (s > 0) ? s : 1;
 80a281a:	2901      	cmp	r1, #1
 80a281c:	bf38      	it	cc
 80a281e:	2101      	movcc	r1, #1
 80a2820:	7601      	strb	r1, [r0, #24]
}
 80a2822:	4770      	bx	lr

080a2824 <_ZN17Adafruit_NeoPixel12updateLengthEt>:
Adafruit_NeoPixel::~Adafruit_NeoPixel() {
  if (pixels) free(pixels);
  if (begun) pinMode(pin, INPUT);
}

void Adafruit_NeoPixel::updateLength(uint16_t n) {
 80a2824:	b538      	push	{r3, r4, r5, lr}
 80a2826:	4604      	mov	r4, r0
  if (pixels) free(pixels); // Free existing data (if any)
 80a2828:	68c0      	ldr	r0, [r0, #12]
void Adafruit_NeoPixel::updateLength(uint16_t n) {
 80a282a:	460d      	mov	r5, r1
  if (pixels) free(pixels); // Free existing data (if any)
 80a282c:	b108      	cbz	r0, 80a2832 <_ZN17Adafruit_NeoPixel12updateLengthEt+0xe>
 80a282e:	f003 f93d 	bl	80a5aac <free>

  // Allocate new data -- note: ALL PIXELS ARE CLEARED
  numBytes = n * ((type == SK6812RGBW) ? 4 : 3);
 80a2832:	79a3      	ldrb	r3, [r4, #6]
 80a2834:	2b06      	cmp	r3, #6
 80a2836:	bf0c      	ite	eq
 80a2838:	2004      	moveq	r0, #4
 80a283a:	2003      	movne	r0, #3
 80a283c:	4368      	muls	r0, r5
 80a283e:	b280      	uxth	r0, r0
 80a2840:	80a0      	strh	r0, [r4, #4]
  if ((pixels = (uint8_t *)malloc(numBytes))) {
 80a2842:	f003 f92b 	bl	80a5a9c <malloc>
 80a2846:	60e0      	str	r0, [r4, #12]
 80a2848:	b128      	cbz	r0, 80a2856 <_ZN17Adafruit_NeoPixel12updateLengthEt+0x32>
    memset(pixels, 0, numBytes);
 80a284a:	2100      	movs	r1, #0
 80a284c:	88a2      	ldrh	r2, [r4, #4]
 80a284e:	f006 f84b 	bl	80a88e8 <memset>
    numLEDs = n;
 80a2852:	8065      	strh	r5, [r4, #2]
  } else {
    numLEDs = numBytes = 0;
  }
}
 80a2854:	bd38      	pop	{r3, r4, r5, pc}
    numLEDs = numBytes = 0;
 80a2856:	80a0      	strh	r0, [r4, #4]
 80a2858:	8060      	strh	r0, [r4, #2]
}
 80a285a:	e7fb      	b.n	80a2854 <_ZN17Adafruit_NeoPixel12updateLengthEt+0x30>

080a285c <_ZN17Adafruit_NeoPixel5beginEv>:

void Adafruit_NeoPixel::begin(void) {
 80a285c:	b510      	push	{r4, lr}
 80a285e:	4604      	mov	r4, r0
  pinMode(pin, OUTPUT);
 80a2860:	2101      	movs	r1, #1
 80a2862:	79c0      	ldrb	r0, [r0, #7]
 80a2864:	f004 fe98 	bl	80a7598 <pinMode>
  digitalWrite(pin, LOW);
 80a2868:	2100      	movs	r1, #0
 80a286a:	79e0      	ldrb	r0, [r4, #7]
 80a286c:	f004 fea5 	bl	80a75ba <digitalWrite>
  begun = true;
 80a2870:	2301      	movs	r3, #1
 80a2872:	7023      	strb	r3, [r4, #0]
}
 80a2874:	bd10      	pop	{r4, pc}

080a2876 <_ZN17Adafruit_NeoPixel6setPinEh>:

// Set the output pin number
void Adafruit_NeoPixel::setPin(uint8_t p) {
 80a2876:	b538      	push	{r3, r4, r5, lr}
    if (begun) {
 80a2878:	7803      	ldrb	r3, [r0, #0]
void Adafruit_NeoPixel::setPin(uint8_t p) {
 80a287a:	4605      	mov	r5, r0
 80a287c:	460c      	mov	r4, r1
    if (begun) {
 80a287e:	b11b      	cbz	r3, 80a2888 <_ZN17Adafruit_NeoPixel6setPinEh+0x12>
        pinMode(pin, INPUT);
 80a2880:	2100      	movs	r1, #0
 80a2882:	79c0      	ldrb	r0, [r0, #7]
 80a2884:	f004 fe88 	bl	80a7598 <pinMode>
    }
    pin = p;
    if (begun) {
 80a2888:	782b      	ldrb	r3, [r5, #0]
    pin = p;
 80a288a:	71ec      	strb	r4, [r5, #7]
    if (begun) {
 80a288c:	b153      	cbz	r3, 80a28a4 <_ZN17Adafruit_NeoPixel6setPinEh+0x2e>
        pinMode(p, OUTPUT);
 80a288e:	b2a4      	uxth	r4, r4
 80a2890:	4620      	mov	r0, r4
 80a2892:	2101      	movs	r1, #1
 80a2894:	f004 fe80 	bl	80a7598 <pinMode>
        digitalWrite(p, LOW);
 80a2898:	4620      	mov	r0, r4
    }
}
 80a289a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
        digitalWrite(p, LOW);
 80a289e:	2100      	movs	r1, #0
 80a28a0:	f004 be8b 	b.w	80a75ba <digitalWrite>
}
 80a28a4:	bd38      	pop	{r3, r4, r5, pc}

080a28a6 <_ZN17Adafruit_NeoPixelC1Ethh>:
Adafruit_NeoPixel::Adafruit_NeoPixel(uint16_t n, uint8_t p, uint8_t t) :
 80a28a6:	b570      	push	{r4, r5, r6, lr}
  begun(false), type(t), brightness(0), pixels(NULL), endTime(0)
 80a28a8:	2500      	movs	r5, #0
Adafruit_NeoPixel::Adafruit_NeoPixel(uint16_t n, uint8_t p, uint8_t t) :
 80a28aa:	4604      	mov	r4, r0
 80a28ac:	4616      	mov	r6, r2
  begun(false), type(t), brightness(0), pixels(NULL), endTime(0)
 80a28ae:	7183      	strb	r3, [r0, #6]
 80a28b0:	e9c0 5503 	strd	r5, r5, [r0, #12]
 80a28b4:	7005      	strb	r5, [r0, #0]
 80a28b6:	7205      	strb	r5, [r0, #8]
  updateLength(n);
 80a28b8:	f7ff ffb4 	bl	80a2824 <_ZN17Adafruit_NeoPixel12updateLengthEt>
  setPin(p);
 80a28bc:	4620      	mov	r0, r4
 80a28be:	4631      	mov	r1, r6
 80a28c0:	f7ff ffd9 	bl	80a2876 <_ZN17Adafruit_NeoPixel6setPinEh>
}
 80a28c4:	4620      	mov	r0, r4
 80a28c6:	bd70      	pop	{r4, r5, r6, pc}

080a28c8 <_ZN17Adafruit_NeoPixel4showEv>:

void Adafruit_NeoPixel::show(void) {
  if(!pixels) return;
 80a28c8:	68c3      	ldr	r3, [r0, #12]
 80a28ca:	2b00      	cmp	r3, #0
 80a28cc:	f000 8441 	beq.w	80a3152 <_ZN17Adafruit_NeoPixel4showEv+0x88a>
void Adafruit_NeoPixel::show(void) {
 80a28d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a28d2:	7983      	ldrb	r3, [r0, #6]
 80a28d4:	4604      	mov	r4, r0
  // the function will simply hold off (if needed) on issuing the
  // subsequent round of data until the latch time has elapsed.  This
  // allows the mainline code to start generating the next frame of data
  // rather than stalling for the latch.
  uint32_t wait_time; // wait time in microseconds.
  switch(type) {
 80a28d6:	3b02      	subs	r3, #2
 80a28d8:	b2db      	uxtb	r3, r3
 80a28da:	2b04      	cmp	r3, #4
 80a28dc:	bf8c      	ite	hi
 80a28de:	2532      	movhi	r5, #50	; 0x32
 80a28e0:	4a28      	ldrls	r2, [pc, #160]	; (80a2984 <_ZN17Adafruit_NeoPixel4showEv+0xbc>)
void Adafruit_NeoPixel::show(void) {
 80a28e2:	b087      	sub	sp, #28
 80a28e4:	bf98      	it	ls
 80a28e6:	f852 5023 	ldrls.w	r5, [r2, r3, lsl #2]
inline unsigned long micros(void) { return HAL_Timer_Get_Micro_Seconds(); }
 80a28ea:	f002 ff71 	bl	80a57d0 <HAL_Timer_Get_Micro_Seconds>
    case WS2812B2_FAST:
    default: {   // default = 50us reset pulse
        wait_time = 50L;
      } break;
  }
  while((micros() - endTime) < wait_time);
 80a28ee:	6923      	ldr	r3, [r4, #16]
 80a28f0:	1ac0      	subs	r0, r0, r3
 80a28f2:	42a8      	cmp	r0, r5
 80a28f4:	d3f9      	bcc.n	80a28ea <_ZN17Adafruit_NeoPixel4showEv+0x22>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i");
 80a28f6:	b672      	cpsid	i
  __disable_irq(); // Need 100% focus on instruction timing

  volatile uint32_t
    c,    // 24-bit/32-bit pixel color
    mask; // 1-bit mask
  volatile uint16_t i = numBytes; // Output loop counter
 80a28f8:	88a3      	ldrh	r3, [r4, #4]
    g,              // Current green byte value
    r,              // Current red byte value
    b,              // Current blue byte value
    w;              // Current white byte value

  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
 80a28fa:	79a5      	ldrb	r5, [r4, #6]
  volatile uint16_t i = numBytes; // Output loop counter
 80a28fc:	f8ad 300a 	strh.w	r3, [sp, #10]
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a2900:	f8bd 300a 	ldrh.w	r3, [sp, #10]
  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
 80a2904:	2d02      	cmp	r5, #2
   *ptr = pixels,   // Pointer to next byte
 80a2906:	68e1      	ldr	r1, [r4, #12]
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a2908:	b29b      	uxth	r3, r3
  if(type == WS2812B || type == WS2812B_FAST) { // Same as WS2812 & WS2813, 800 KHz bitstream
 80a290a:	f000 826e 	beq.w	80a2dea <_ZN17Adafruit_NeoPixel4showEv+0x522>
 80a290e:	2d07      	cmp	r5, #7
 80a2910:	f000 826b 	beq.w	80a2dea <_ZN17Adafruit_NeoPixel4showEv+0x522>
        }
        mask >>= 1;
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else if(type == SK6812RGBW) { // similar to WS2812, 800 KHz bitstream but with RGB+W components
 80a2914:	2d06      	cmp	r5, #6
 80a2916:	f000 841d 	beq.w	80a3154 <_ZN17Adafruit_NeoPixel4showEv+0x88c>
        }
        mask >>= 1;
      } while ( ++j < 32 ); // ... pixel done
    } // end while(i) ... no more pixels
  }
  else if(type == WS2812B2 || type == WS2812B2_FAST) { // WS2812B with DWT timer
 80a291a:	2d05      	cmp	r5, #5
 80a291c:	f000 83a1 	beq.w	80a3062 <_ZN17Adafruit_NeoPixel4showEv+0x79a>
 80a2920:	2d08      	cmp	r5, #8
 80a2922:	f000 839e 	beq.w	80a3062 <_ZN17Adafruit_NeoPixel4showEv+0x79a>
        mask >>= 1;
      } while ( ++j < 24 ); // ... pixel done
    } // end while(i) ... no more pixels
#endif
  }
  else if(type == WS2811) { // WS2811, 400 KHz bitstream
 80a2926:	2d00      	cmp	r5, #0
 80a2928:	f040 854f 	bne.w	80a33ca <_ZN17Adafruit_NeoPixel4showEv+0xb02>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a292c:	2b00      	cmp	r3, #0
 80a292e:	f000 8392 	beq.w	80a3056 <_ZN17Adafruit_NeoPixel4showEv+0x78e>
      mask = 0x800000; // reset the mask
 80a2932:	f44f 0600 	mov.w	r6, #8388608	; 0x800000
 80a2936:	4a14      	ldr	r2, [pc, #80]	; (80a2988 <_ZN17Adafruit_NeoPixel4showEv+0xc0>)
 80a2938:	9604      	str	r6, [sp, #16]
      i = i-3;      // decrement bytes remaining
 80a293a:	f8bd 300a 	ldrh.w	r3, [sp, #10]
      r = *ptr++;   // Next red byte value
      g = *ptr++;   // Next green byte value
      b = *ptr++;   // Next blue byte value
 80a293e:	3103      	adds	r1, #3
      i = i-3;      // decrement bytes remaining
 80a2940:	3b03      	subs	r3, #3
 80a2942:	b29b      	uxth	r3, r3
 80a2944:	f8ad 300a 	strh.w	r3, [sp, #10]
      r = *ptr++;   // Next red byte value
 80a2948:	f811 3c03 	ldrb.w	r3, [r1, #-3]
 80a294c:	b2db      	uxtb	r3, r3
 80a294e:	f88d 3007 	strb.w	r3, [sp, #7]
      g = *ptr++;   // Next green byte value
 80a2952:	f811 3c02 	ldrb.w	r3, [r1, #-2]
 80a2956:	b2db      	uxtb	r3, r3
 80a2958:	f88d 3006 	strb.w	r3, [sp, #6]
      b = *ptr++;   // Next blue byte value
 80a295c:	f811 3c01 	ldrb.w	r3, [r1, #-1]
 80a2960:	b2db      	uxtb	r3, r3
 80a2962:	f88d 3008 	strb.w	r3, [sp, #8]
      c = ((uint32_t)r << 16) | ((uint32_t)g <<  8) | b; // Pack the next 3 bytes to keep timing tight
 80a2966:	f89d 7007 	ldrb.w	r7, [sp, #7]
 80a296a:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a296e:	f89d 0008 	ldrb.w	r0, [sp, #8]
 80a2972:	021b      	lsls	r3, r3, #8
 80a2974:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 80a2978:	4303      	orrs	r3, r0
 80a297a:	9303      	str	r3, [sp, #12]
      j = 0;        // reset the 24-bit counter
 80a297c:	f88d 5005 	strb.w	r5, [sp, #5]
 80a2980:	e11b      	b.n	80a2bba <_ZN17Adafruit_NeoPixel4showEv+0x2f2>
 80a2982:	bf00      	nop
 80a2984:	080aa404 	.word	0x080aa404
 80a2988:	20000d90 	.word	0x20000d90
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a298c:	4600      	mov	r0, r0
 80a298e:	bf00      	nop
 80a2990:	bf00      	nop
 80a2992:	bf00      	nop
 80a2994:	bf00      	nop
 80a2996:	bf00      	nop
 80a2998:	bf00      	nop
 80a299a:	bf00      	nop
 80a299c:	bf00      	nop
 80a299e:	bf00      	nop
 80a29a0:	bf00      	nop
 80a29a2:	bf00      	nop
 80a29a4:	bf00      	nop
 80a29a6:	bf00      	nop
 80a29a8:	bf00      	nop
 80a29aa:	bf00      	nop
 80a29ac:	bf00      	nop
 80a29ae:	bf00      	nop
 80a29b0:	bf00      	nop
 80a29b2:	bf00      	nop
 80a29b4:	bf00      	nop
 80a29b6:	bf00      	nop
 80a29b8:	bf00      	nop
 80a29ba:	bf00      	nop
 80a29bc:	bf00      	nop
 80a29be:	bf00      	nop
 80a29c0:	bf00      	nop
 80a29c2:	bf00      	nop
 80a29c4:	bf00      	nop
 80a29c6:	bf00      	nop
 80a29c8:	bf00      	nop
 80a29ca:	bf00      	nop
 80a29cc:	bf00      	nop
 80a29ce:	bf00      	nop
 80a29d0:	bf00      	nop
 80a29d2:	bf00      	nop
 80a29d4:	bf00      	nop
 80a29d6:	bf00      	nop
 80a29d8:	bf00      	nop
 80a29da:	bf00      	nop
 80a29dc:	bf00      	nop
 80a29de:	bf00      	nop
 80a29e0:	bf00      	nop
 80a29e2:	bf00      	nop
 80a29e4:	bf00      	nop
 80a29e6:	bf00      	nop
 80a29e8:	bf00      	nop
 80a29ea:	bf00      	nop
 80a29ec:	bf00      	nop
 80a29ee:	bf00      	nop
 80a29f0:	bf00      	nop
 80a29f2:	bf00      	nop
 80a29f4:	bf00      	nop
 80a29f6:	bf00      	nop
 80a29f8:	bf00      	nop
 80a29fa:	bf00      	nop
 80a29fc:	bf00      	nop
 80a29fe:	bf00      	nop
 80a2a00:	bf00      	nop
 80a2a02:	bf00      	nop
 80a2a04:	bf00      	nop
 80a2a06:	bf00      	nop
 80a2a08:	bf00      	nop
 80a2a0a:	bf00      	nop
 80a2a0c:	bf00      	nop
 80a2a0e:	bf00      	nop
 80a2a10:	bf00      	nop
 80a2a12:	bf00      	nop
 80a2a14:	bf00      	nop
 80a2a16:	bf00      	nop
 80a2a18:	bf00      	nop
 80a2a1a:	bf00      	nop
 80a2a1c:	bf00      	nop
 80a2a1e:	bf00      	nop
 80a2a20:	bf00      	nop
 80a2a22:	bf00      	nop
 80a2a24:	bf00      	nop
 80a2a26:	bf00      	nop
 80a2a28:	bf00      	nop
 80a2a2a:	bf00      	nop
 80a2a2c:	bf00      	nop
 80a2a2e:	bf00      	nop
 80a2a30:	bf00      	nop
 80a2a32:	bf00      	nop
 80a2a34:	bf00      	nop
 80a2a36:	bf00      	nop
 80a2a38:	bf00      	nop
 80a2a3a:	bf00      	nop
 80a2a3c:	bf00      	nop
 80a2a3e:	bf00      	nop
 80a2a40:	bf00      	nop
 80a2a42:	bf00      	nop
 80a2a44:	bf00      	nop
 80a2a46:	bf00      	nop
 80a2a48:	bf00      	nop
 80a2a4a:	bf00      	nop
 80a2a4c:	bf00      	nop
 80a2a4e:	bf00      	nop
 80a2a50:	bf00      	nop
 80a2a52:	bf00      	nop
 80a2a54:	bf00      	nop
 80a2a56:	bf00      	nop
 80a2a58:	bf00      	nop
 80a2a5a:	bf00      	nop
 80a2a5c:	bf00      	nop
 80a2a5e:	bf00      	nop
 80a2a60:	bf00      	nop
 80a2a62:	bf00      	nop
 80a2a64:	bf00      	nop
 80a2a66:	bf00      	nop
 80a2a68:	bf00      	nop
 80a2a6a:	bf00      	nop
 80a2a6c:	bf00      	nop
 80a2a6e:	bf00      	nop
 80a2a70:	bf00      	nop
 80a2a72:	bf00      	nop
 80a2a74:	bf00      	nop
 80a2a76:	bf00      	nop
 80a2a78:	bf00      	nop
 80a2a7a:	bf00      	nop
 80a2a7c:	bf00      	nop
 80a2a7e:	bf00      	nop
 80a2a80:	bf00      	nop
 80a2a82:	bf00      	nop
 80a2a84:	bf00      	nop
 80a2a86:	bf00      	nop
 80a2a88:	bf00      	nop
 80a2a8a:	bf00      	nop
 80a2a8c:	bf00      	nop
 80a2a8e:	bf00      	nop
 80a2a90:	bf00      	nop
 80a2a92:	bf00      	nop
          // WS2811 spec             1.30us LOW
          // Adafruit on Arduino    (meas. 1.25us)
          // This lib on Spark Core (meas. 1.24us)
          // This lib on Photon     (meas. 1.24us)
          pinSet(pin, LOW); // LOW
 80a2a94:	79e3      	ldrb	r3, [r4, #7]
 80a2a96:	6810      	ldr	r0, [r2, #0]
 80a2a98:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a2a9c:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a2aa0:	88bf      	ldrh	r7, [r7, #4]
 80a2aa2:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a2aa6:	835f      	strh	r7, [r3, #26]
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
 80a2aa8:	4600      	mov	r0, r0
 80a2aaa:	bf00      	nop
 80a2aac:	bf00      	nop
 80a2aae:	bf00      	nop
 80a2ab0:	bf00      	nop
 80a2ab2:	bf00      	nop
 80a2ab4:	bf00      	nop
 80a2ab6:	bf00      	nop
 80a2ab8:	bf00      	nop
 80a2aba:	bf00      	nop
 80a2abc:	bf00      	nop
 80a2abe:	bf00      	nop
 80a2ac0:	bf00      	nop
 80a2ac2:	bf00      	nop
 80a2ac4:	bf00      	nop
 80a2ac6:	bf00      	nop
 80a2ac8:	bf00      	nop
 80a2aca:	bf00      	nop
 80a2acc:	bf00      	nop
 80a2ace:	bf00      	nop
 80a2ad0:	bf00      	nop
 80a2ad2:	bf00      	nop
 80a2ad4:	bf00      	nop
 80a2ad6:	bf00      	nop
 80a2ad8:	bf00      	nop
 80a2ada:	bf00      	nop
 80a2adc:	bf00      	nop
 80a2ade:	bf00      	nop
 80a2ae0:	bf00      	nop
 80a2ae2:	bf00      	nop
 80a2ae4:	bf00      	nop
 80a2ae6:	bf00      	nop
 80a2ae8:	bf00      	nop
 80a2aea:	bf00      	nop
 80a2aec:	bf00      	nop
 80a2aee:	bf00      	nop
 80a2af0:	bf00      	nop
 80a2af2:	bf00      	nop
 80a2af4:	bf00      	nop
 80a2af6:	bf00      	nop
 80a2af8:	bf00      	nop
 80a2afa:	bf00      	nop
 80a2afc:	bf00      	nop
 80a2afe:	bf00      	nop
 80a2b00:	bf00      	nop
 80a2b02:	bf00      	nop
 80a2b04:	bf00      	nop
 80a2b06:	bf00      	nop
 80a2b08:	bf00      	nop
 80a2b0a:	bf00      	nop
 80a2b0c:	bf00      	nop
 80a2b0e:	bf00      	nop
 80a2b10:	bf00      	nop
 80a2b12:	bf00      	nop
 80a2b14:	bf00      	nop
 80a2b16:	bf00      	nop
 80a2b18:	bf00      	nop
 80a2b1a:	bf00      	nop
 80a2b1c:	bf00      	nop
 80a2b1e:	bf00      	nop
 80a2b20:	bf00      	nop
 80a2b22:	bf00      	nop
 80a2b24:	bf00      	nop
 80a2b26:	bf00      	nop
 80a2b28:	bf00      	nop
 80a2b2a:	bf00      	nop
 80a2b2c:	bf00      	nop
 80a2b2e:	bf00      	nop
 80a2b30:	bf00      	nop
 80a2b32:	bf00      	nop
 80a2b34:	bf00      	nop
 80a2b36:	bf00      	nop
 80a2b38:	bf00      	nop
 80a2b3a:	bf00      	nop
 80a2b3c:	bf00      	nop
 80a2b3e:	bf00      	nop
 80a2b40:	bf00      	nop
 80a2b42:	bf00      	nop
 80a2b44:	bf00      	nop
 80a2b46:	bf00      	nop
 80a2b48:	bf00      	nop
 80a2b4a:	bf00      	nop
 80a2b4c:	bf00      	nop
 80a2b4e:	bf00      	nop
 80a2b50:	bf00      	nop
 80a2b52:	bf00      	nop
 80a2b54:	bf00      	nop
 80a2b56:	bf00      	nop
 80a2b58:	bf00      	nop
 80a2b5a:	bf00      	nop
 80a2b5c:	bf00      	nop
 80a2b5e:	bf00      	nop
 80a2b60:	bf00      	nop
 80a2b62:	bf00      	nop
 80a2b64:	bf00      	nop
 80a2b66:	bf00      	nop
 80a2b68:	bf00      	nop
 80a2b6a:	bf00      	nop
 80a2b6c:	bf00      	nop
 80a2b6e:	bf00      	nop
 80a2b70:	bf00      	nop
 80a2b72:	bf00      	nop
 80a2b74:	bf00      	nop
 80a2b76:	bf00      	nop
 80a2b78:	bf00      	nop
 80a2b7a:	bf00      	nop
 80a2b7c:	bf00      	nop
 80a2b7e:	bf00      	nop
 80a2b80:	bf00      	nop
 80a2b82:	bf00      	nop
 80a2b84:	bf00      	nop
 80a2b86:	bf00      	nop
 80a2b88:	bf00      	nop
 80a2b8a:	bf00      	nop
 80a2b8c:	bf00      	nop
 80a2b8e:	bf00      	nop
 80a2b90:	bf00      	nop
 80a2b92:	bf00      	nop
 80a2b94:	bf00      	nop
 80a2b96:	bf00      	nop
 80a2b98:	bf00      	nop
 80a2b9a:	bf00      	nop
 80a2b9c:	bf00      	nop
 80a2b9e:	bf00      	nop
 80a2ba0:	bf00      	nop
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
            "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t" "nop" "\n\t"
#endif
            ::: "r0", "cc", "memory");
        }
        mask >>= 1;
 80a2ba2:	9b04      	ldr	r3, [sp, #16]
 80a2ba4:	085b      	lsrs	r3, r3, #1
 80a2ba6:	9304      	str	r3, [sp, #16]
      } while ( ++j < 24 ); // ... pixel done
 80a2ba8:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a2bac:	3301      	adds	r3, #1
 80a2bae:	b2db      	uxtb	r3, r3
 80a2bb0:	2b17      	cmp	r3, #23
 80a2bb2:	f88d 3005 	strb.w	r3, [sp, #5]
 80a2bb6:	f200 8727 	bhi.w	80a3a08 <_ZN17Adafruit_NeoPixel4showEv+0x1140>
        pinSet(pin, HIGH); // HIGH
 80a2bba:	79e3      	ldrb	r3, [r4, #7]
 80a2bbc:	6810      	ldr	r0, [r2, #0]
 80a2bbe:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a2bc2:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a2bc6:	88bf      	ldrh	r7, [r7, #4]
 80a2bc8:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a2bcc:	831f      	strh	r7, [r3, #24]
        if (c & mask) { // if masked bit is high
 80a2bce:	9803      	ldr	r0, [sp, #12]
 80a2bd0:	9b04      	ldr	r3, [sp, #16]
 80a2bd2:	4218      	tst	r0, r3
 80a2bd4:	f47f aeda 	bne.w	80a298c <_ZN17Adafruit_NeoPixel4showEv+0xc4>
            ::: "r0", "cc", "memory");
 80a2bd8:	4600      	mov	r0, r0
 80a2bda:	bf00      	nop
 80a2bdc:	bf00      	nop
 80a2bde:	bf00      	nop
 80a2be0:	bf00      	nop
 80a2be2:	bf00      	nop
 80a2be4:	bf00      	nop
 80a2be6:	bf00      	nop
 80a2be8:	bf00      	nop
 80a2bea:	bf00      	nop
 80a2bec:	bf00      	nop
 80a2bee:	bf00      	nop
 80a2bf0:	bf00      	nop
 80a2bf2:	bf00      	nop
 80a2bf4:	bf00      	nop
 80a2bf6:	bf00      	nop
 80a2bf8:	bf00      	nop
 80a2bfa:	bf00      	nop
 80a2bfc:	bf00      	nop
 80a2bfe:	bf00      	nop
 80a2c00:	bf00      	nop
 80a2c02:	bf00      	nop
 80a2c04:	bf00      	nop
 80a2c06:	bf00      	nop
 80a2c08:	bf00      	nop
 80a2c0a:	bf00      	nop
 80a2c0c:	bf00      	nop
 80a2c0e:	bf00      	nop
 80a2c10:	bf00      	nop
 80a2c12:	bf00      	nop
 80a2c14:	bf00      	nop
 80a2c16:	bf00      	nop
 80a2c18:	bf00      	nop
 80a2c1a:	bf00      	nop
 80a2c1c:	bf00      	nop
 80a2c1e:	bf00      	nop
 80a2c20:	bf00      	nop
 80a2c22:	bf00      	nop
 80a2c24:	bf00      	nop
 80a2c26:	bf00      	nop
 80a2c28:	bf00      	nop
          pinSet(pin, LOW); // LOW
 80a2c2a:	79e3      	ldrb	r3, [r4, #7]
 80a2c2c:	6810      	ldr	r0, [r2, #0]
 80a2c2e:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a2c32:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a2c36:	88bf      	ldrh	r7, [r7, #4]
 80a2c38:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a2c3c:	835f      	strh	r7, [r3, #26]
            ::: "r0", "cc", "memory");
 80a2c3e:	4600      	mov	r0, r0
 80a2c40:	bf00      	nop
 80a2c42:	bf00      	nop
 80a2c44:	bf00      	nop
 80a2c46:	bf00      	nop
 80a2c48:	bf00      	nop
 80a2c4a:	bf00      	nop
 80a2c4c:	bf00      	nop
 80a2c4e:	bf00      	nop
 80a2c50:	bf00      	nop
 80a2c52:	bf00      	nop
 80a2c54:	bf00      	nop
 80a2c56:	bf00      	nop
 80a2c58:	bf00      	nop
 80a2c5a:	bf00      	nop
 80a2c5c:	bf00      	nop
 80a2c5e:	bf00      	nop
 80a2c60:	bf00      	nop
 80a2c62:	bf00      	nop
 80a2c64:	bf00      	nop
 80a2c66:	bf00      	nop
 80a2c68:	bf00      	nop
 80a2c6a:	bf00      	nop
 80a2c6c:	bf00      	nop
 80a2c6e:	bf00      	nop
 80a2c70:	bf00      	nop
 80a2c72:	bf00      	nop
 80a2c74:	bf00      	nop
 80a2c76:	bf00      	nop
 80a2c78:	bf00      	nop
 80a2c7a:	bf00      	nop
 80a2c7c:	bf00      	nop
 80a2c7e:	bf00      	nop
 80a2c80:	bf00      	nop
 80a2c82:	bf00      	nop
 80a2c84:	bf00      	nop
 80a2c86:	bf00      	nop
 80a2c88:	bf00      	nop
 80a2c8a:	bf00      	nop
 80a2c8c:	bf00      	nop
 80a2c8e:	bf00      	nop
 80a2c90:	bf00      	nop
 80a2c92:	bf00      	nop
 80a2c94:	bf00      	nop
 80a2c96:	bf00      	nop
 80a2c98:	bf00      	nop
 80a2c9a:	bf00      	nop
 80a2c9c:	bf00      	nop
 80a2c9e:	bf00      	nop
 80a2ca0:	bf00      	nop
 80a2ca2:	bf00      	nop
 80a2ca4:	bf00      	nop
 80a2ca6:	bf00      	nop
 80a2ca8:	bf00      	nop
 80a2caa:	bf00      	nop
 80a2cac:	bf00      	nop
 80a2cae:	bf00      	nop
 80a2cb0:	bf00      	nop
 80a2cb2:	bf00      	nop
 80a2cb4:	bf00      	nop
 80a2cb6:	bf00      	nop
 80a2cb8:	bf00      	nop
 80a2cba:	bf00      	nop
 80a2cbc:	bf00      	nop
 80a2cbe:	bf00      	nop
 80a2cc0:	bf00      	nop
 80a2cc2:	bf00      	nop
 80a2cc4:	bf00      	nop
 80a2cc6:	bf00      	nop
 80a2cc8:	bf00      	nop
 80a2cca:	bf00      	nop
 80a2ccc:	bf00      	nop
 80a2cce:	bf00      	nop
 80a2cd0:	bf00      	nop
 80a2cd2:	bf00      	nop
 80a2cd4:	bf00      	nop
 80a2cd6:	bf00      	nop
 80a2cd8:	bf00      	nop
 80a2cda:	bf00      	nop
 80a2cdc:	bf00      	nop
 80a2cde:	bf00      	nop
 80a2ce0:	bf00      	nop
 80a2ce2:	bf00      	nop
 80a2ce4:	bf00      	nop
 80a2ce6:	bf00      	nop
 80a2ce8:	bf00      	nop
 80a2cea:	bf00      	nop
 80a2cec:	bf00      	nop
 80a2cee:	bf00      	nop
 80a2cf0:	bf00      	nop
 80a2cf2:	bf00      	nop
 80a2cf4:	bf00      	nop
 80a2cf6:	bf00      	nop
 80a2cf8:	bf00      	nop
 80a2cfa:	bf00      	nop
 80a2cfc:	bf00      	nop
 80a2cfe:	bf00      	nop
 80a2d00:	bf00      	nop
 80a2d02:	bf00      	nop
 80a2d04:	bf00      	nop
 80a2d06:	bf00      	nop
 80a2d08:	bf00      	nop
 80a2d0a:	bf00      	nop
 80a2d0c:	bf00      	nop
 80a2d0e:	bf00      	nop
 80a2d10:	bf00      	nop
 80a2d12:	bf00      	nop
 80a2d14:	bf00      	nop
 80a2d16:	bf00      	nop
 80a2d18:	bf00      	nop
 80a2d1a:	bf00      	nop
 80a2d1c:	bf00      	nop
 80a2d1e:	bf00      	nop
 80a2d20:	bf00      	nop
 80a2d22:	bf00      	nop
 80a2d24:	bf00      	nop
 80a2d26:	bf00      	nop
 80a2d28:	bf00      	nop
 80a2d2a:	bf00      	nop
 80a2d2c:	bf00      	nop
 80a2d2e:	bf00      	nop
 80a2d30:	bf00      	nop
 80a2d32:	bf00      	nop
 80a2d34:	bf00      	nop
 80a2d36:	bf00      	nop
 80a2d38:	bf00      	nop
 80a2d3a:	bf00      	nop
 80a2d3c:	bf00      	nop
 80a2d3e:	bf00      	nop
 80a2d40:	bf00      	nop
 80a2d42:	bf00      	nop
 80a2d44:	bf00      	nop
 80a2d46:	bf00      	nop
 80a2d48:	bf00      	nop
 80a2d4a:	bf00      	nop
 80a2d4c:	bf00      	nop
 80a2d4e:	bf00      	nop
 80a2d50:	bf00      	nop
 80a2d52:	bf00      	nop
 80a2d54:	bf00      	nop
 80a2d56:	bf00      	nop
 80a2d58:	bf00      	nop
 80a2d5a:	bf00      	nop
 80a2d5c:	bf00      	nop
 80a2d5e:	bf00      	nop
 80a2d60:	bf00      	nop
 80a2d62:	bf00      	nop
 80a2d64:	bf00      	nop
 80a2d66:	bf00      	nop
 80a2d68:	bf00      	nop
 80a2d6a:	bf00      	nop
 80a2d6c:	bf00      	nop
 80a2d6e:	bf00      	nop
 80a2d70:	bf00      	nop
 80a2d72:	bf00      	nop
 80a2d74:	bf00      	nop
 80a2d76:	bf00      	nop
 80a2d78:	bf00      	nop
 80a2d7a:	bf00      	nop
 80a2d7c:	bf00      	nop
 80a2d7e:	bf00      	nop
 80a2d80:	bf00      	nop
 80a2d82:	bf00      	nop
 80a2d84:	bf00      	nop
 80a2d86:	bf00      	nop
 80a2d88:	bf00      	nop
 80a2d8a:	bf00      	nop
 80a2d8c:	bf00      	nop
 80a2d8e:	bf00      	nop
 80a2d90:	bf00      	nop
 80a2d92:	bf00      	nop
 80a2d94:	bf00      	nop
 80a2d96:	bf00      	nop
 80a2d98:	bf00      	nop
 80a2d9a:	bf00      	nop
 80a2d9c:	bf00      	nop
 80a2d9e:	bf00      	nop
 80a2da0:	bf00      	nop
 80a2da2:	bf00      	nop
 80a2da4:	bf00      	nop
 80a2da6:	bf00      	nop
 80a2da8:	bf00      	nop
 80a2daa:	bf00      	nop
 80a2dac:	bf00      	nop
 80a2dae:	bf00      	nop
 80a2db0:	bf00      	nop
 80a2db2:	bf00      	nop
 80a2db4:	bf00      	nop
 80a2db6:	bf00      	nop
 80a2db8:	bf00      	nop
 80a2dba:	bf00      	nop
 80a2dbc:	bf00      	nop
 80a2dbe:	bf00      	nop
 80a2dc0:	bf00      	nop
 80a2dc2:	bf00      	nop
 80a2dc4:	bf00      	nop
 80a2dc6:	bf00      	nop
 80a2dc8:	bf00      	nop
 80a2dca:	bf00      	nop
 80a2dcc:	bf00      	nop
 80a2dce:	bf00      	nop
 80a2dd0:	bf00      	nop
 80a2dd2:	bf00      	nop
 80a2dd4:	bf00      	nop
 80a2dd6:	bf00      	nop
 80a2dd8:	bf00      	nop
 80a2dda:	bf00      	nop
 80a2ddc:	bf00      	nop
 80a2dde:	bf00      	nop
 80a2de0:	bf00      	nop
 80a2de2:	bf00      	nop
 80a2de4:	bf00      	nop
 80a2de6:	bf00      	nop
 80a2de8:	e6db      	b.n	80a2ba2 <_ZN17Adafruit_NeoPixel4showEv+0x2da>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a2dea:	2b00      	cmp	r3, #0
 80a2dec:	f000 8133 	beq.w	80a3056 <_ZN17Adafruit_NeoPixel4showEv+0x78e>
      mask = 0x800000; // reset the mask
 80a2df0:	f44f 0500 	mov.w	r5, #8388608	; 0x800000
      j = 0;        // reset the 24-bit counter
 80a2df4:	2600      	movs	r6, #0
 80a2df6:	4a13      	ldr	r2, [pc, #76]	; (80a2e44 <_ZN17Adafruit_NeoPixel4showEv+0x57c>)
      mask = 0x800000; // reset the mask
 80a2df8:	9504      	str	r5, [sp, #16]
      i = i-3;      // decrement bytes remaining
 80a2dfa:	f8bd 300a 	ldrh.w	r3, [sp, #10]
      b = *ptr++;   // Next blue byte value
 80a2dfe:	3103      	adds	r1, #3
      i = i-3;      // decrement bytes remaining
 80a2e00:	3b03      	subs	r3, #3
 80a2e02:	b29b      	uxth	r3, r3
 80a2e04:	f8ad 300a 	strh.w	r3, [sp, #10]
      g = *ptr++;   // Next green byte value
 80a2e08:	f811 3c03 	ldrb.w	r3, [r1, #-3]
 80a2e0c:	b2db      	uxtb	r3, r3
 80a2e0e:	f88d 3006 	strb.w	r3, [sp, #6]
      r = *ptr++;   // Next red byte value
 80a2e12:	f811 3c02 	ldrb.w	r3, [r1, #-2]
 80a2e16:	b2db      	uxtb	r3, r3
 80a2e18:	f88d 3007 	strb.w	r3, [sp, #7]
      b = *ptr++;   // Next blue byte value
 80a2e1c:	f811 3c01 	ldrb.w	r3, [r1, #-1]
 80a2e20:	b2db      	uxtb	r3, r3
 80a2e22:	f88d 3008 	strb.w	r3, [sp, #8]
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
 80a2e26:	f89d 7006 	ldrb.w	r7, [sp, #6]
 80a2e2a:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80a2e2e:	f89d 0008 	ldrb.w	r0, [sp, #8]
 80a2e32:	021b      	lsls	r3, r3, #8
 80a2e34:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 80a2e38:	4303      	orrs	r3, r0
 80a2e3a:	9303      	str	r3, [sp, #12]
      j = 0;        // reset the 24-bit counter
 80a2e3c:	f88d 6005 	strb.w	r6, [sp, #5]
 80a2e40:	e080      	b.n	80a2f44 <_ZN17Adafruit_NeoPixel4showEv+0x67c>
 80a2e42:	bf00      	nop
 80a2e44:	20000d90 	.word	0x20000d90
            ::: "r0", "cc", "memory");
 80a2e48:	4600      	mov	r0, r0
 80a2e4a:	bf00      	nop
 80a2e4c:	bf00      	nop
 80a2e4e:	bf00      	nop
 80a2e50:	bf00      	nop
 80a2e52:	bf00      	nop
 80a2e54:	bf00      	nop
 80a2e56:	bf00      	nop
 80a2e58:	bf00      	nop
 80a2e5a:	bf00      	nop
 80a2e5c:	bf00      	nop
 80a2e5e:	bf00      	nop
 80a2e60:	bf00      	nop
 80a2e62:	bf00      	nop
 80a2e64:	bf00      	nop
 80a2e66:	bf00      	nop
 80a2e68:	bf00      	nop
 80a2e6a:	bf00      	nop
 80a2e6c:	bf00      	nop
 80a2e6e:	bf00      	nop
 80a2e70:	bf00      	nop
 80a2e72:	bf00      	nop
 80a2e74:	bf00      	nop
 80a2e76:	bf00      	nop
 80a2e78:	bf00      	nop
 80a2e7a:	bf00      	nop
 80a2e7c:	bf00      	nop
 80a2e7e:	bf00      	nop
 80a2e80:	bf00      	nop
 80a2e82:	bf00      	nop
 80a2e84:	bf00      	nop
 80a2e86:	bf00      	nop
 80a2e88:	bf00      	nop
 80a2e8a:	bf00      	nop
 80a2e8c:	bf00      	nop
 80a2e8e:	bf00      	nop
 80a2e90:	bf00      	nop
 80a2e92:	bf00      	nop
 80a2e94:	bf00      	nop
 80a2e96:	bf00      	nop
 80a2e98:	bf00      	nop
 80a2e9a:	bf00      	nop
 80a2e9c:	bf00      	nop
 80a2e9e:	bf00      	nop
 80a2ea0:	bf00      	nop
 80a2ea2:	bf00      	nop
 80a2ea4:	bf00      	nop
 80a2ea6:	bf00      	nop
 80a2ea8:	bf00      	nop
 80a2eaa:	bf00      	nop
 80a2eac:	bf00      	nop
 80a2eae:	bf00      	nop
 80a2eb0:	bf00      	nop
 80a2eb2:	bf00      	nop
 80a2eb4:	bf00      	nop
 80a2eb6:	bf00      	nop
 80a2eb8:	bf00      	nop
 80a2eba:	bf00      	nop
 80a2ebc:	bf00      	nop
 80a2ebe:	bf00      	nop
 80a2ec0:	bf00      	nop
 80a2ec2:	bf00      	nop
 80a2ec4:	bf00      	nop
 80a2ec6:	bf00      	nop
 80a2ec8:	bf00      	nop
 80a2eca:	bf00      	nop
 80a2ecc:	bf00      	nop
 80a2ece:	bf00      	nop
 80a2ed0:	bf00      	nop
 80a2ed2:	bf00      	nop
 80a2ed4:	bf00      	nop
 80a2ed6:	bf00      	nop
 80a2ed8:	bf00      	nop
 80a2eda:	bf00      	nop
 80a2edc:	bf00      	nop
 80a2ede:	bf00      	nop
 80a2ee0:	bf00      	nop
          pinSet(pin, LOW); // LOW
 80a2ee2:	79e3      	ldrb	r3, [r4, #7]
 80a2ee4:	6810      	ldr	r0, [r2, #0]
 80a2ee6:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a2eea:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a2eee:	88bf      	ldrh	r7, [r7, #4]
 80a2ef0:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a2ef4:	835f      	strh	r7, [r3, #26]
            ::: "r0", "cc", "memory");
 80a2ef6:	4600      	mov	r0, r0
 80a2ef8:	bf00      	nop
 80a2efa:	bf00      	nop
 80a2efc:	bf00      	nop
 80a2efe:	bf00      	nop
 80a2f00:	bf00      	nop
 80a2f02:	bf00      	nop
 80a2f04:	bf00      	nop
 80a2f06:	bf00      	nop
 80a2f08:	bf00      	nop
 80a2f0a:	bf00      	nop
 80a2f0c:	bf00      	nop
 80a2f0e:	bf00      	nop
 80a2f10:	bf00      	nop
 80a2f12:	bf00      	nop
 80a2f14:	bf00      	nop
 80a2f16:	bf00      	nop
 80a2f18:	bf00      	nop
 80a2f1a:	bf00      	nop
 80a2f1c:	bf00      	nop
 80a2f1e:	bf00      	nop
 80a2f20:	bf00      	nop
 80a2f22:	bf00      	nop
 80a2f24:	bf00      	nop
 80a2f26:	bf00      	nop
 80a2f28:	bf00      	nop
 80a2f2a:	bf00      	nop
        mask >>= 1;
 80a2f2c:	9b04      	ldr	r3, [sp, #16]
 80a2f2e:	085b      	lsrs	r3, r3, #1
 80a2f30:	9304      	str	r3, [sp, #16]
      } while ( ++j < 24 ); // ... pixel done
 80a2f32:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a2f36:	3301      	adds	r3, #1
 80a2f38:	b2db      	uxtb	r3, r3
 80a2f3a:	2b17      	cmp	r3, #23
 80a2f3c:	f88d 3005 	strb.w	r3, [sp, #5]
 80a2f40:	f200 8083 	bhi.w	80a304a <_ZN17Adafruit_NeoPixel4showEv+0x782>
        pinSet(pin, HIGH); // HIGH
 80a2f44:	79e3      	ldrb	r3, [r4, #7]
 80a2f46:	6810      	ldr	r0, [r2, #0]
 80a2f48:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a2f4c:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a2f50:	88bf      	ldrh	r7, [r7, #4]
 80a2f52:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a2f56:	831f      	strh	r7, [r3, #24]
        if (c & mask) { // if masked bit is high
 80a2f58:	9803      	ldr	r0, [sp, #12]
 80a2f5a:	9b04      	ldr	r3, [sp, #16]
 80a2f5c:	4218      	tst	r0, r3
 80a2f5e:	f47f af73 	bne.w	80a2e48 <_ZN17Adafruit_NeoPixel4showEv+0x580>
            ::: "r0", "cc", "memory");
 80a2f62:	4600      	mov	r0, r0
 80a2f64:	bf00      	nop
 80a2f66:	bf00      	nop
 80a2f68:	bf00      	nop
 80a2f6a:	bf00      	nop
 80a2f6c:	bf00      	nop
 80a2f6e:	bf00      	nop
 80a2f70:	bf00      	nop
 80a2f72:	bf00      	nop
 80a2f74:	bf00      	nop
 80a2f76:	bf00      	nop
 80a2f78:	bf00      	nop
 80a2f7a:	bf00      	nop
 80a2f7c:	bf00      	nop
 80a2f7e:	bf00      	nop
 80a2f80:	bf00      	nop
 80a2f82:	bf00      	nop
 80a2f84:	bf00      	nop
 80a2f86:	bf00      	nop
 80a2f88:	bf00      	nop
          pinSet(pin, LOW); // LOW
 80a2f8a:	79e3      	ldrb	r3, [r4, #7]
 80a2f8c:	6810      	ldr	r0, [r2, #0]
 80a2f8e:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a2f92:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a2f96:	88bf      	ldrh	r7, [r7, #4]
 80a2f98:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a2f9c:	835f      	strh	r7, [r3, #26]
            ::: "r0", "cc", "memory");
 80a2f9e:	4600      	mov	r0, r0
 80a2fa0:	bf00      	nop
 80a2fa2:	bf00      	nop
 80a2fa4:	bf00      	nop
 80a2fa6:	bf00      	nop
 80a2fa8:	bf00      	nop
 80a2faa:	bf00      	nop
 80a2fac:	bf00      	nop
 80a2fae:	bf00      	nop
 80a2fb0:	bf00      	nop
 80a2fb2:	bf00      	nop
 80a2fb4:	bf00      	nop
 80a2fb6:	bf00      	nop
 80a2fb8:	bf00      	nop
 80a2fba:	bf00      	nop
 80a2fbc:	bf00      	nop
 80a2fbe:	bf00      	nop
 80a2fc0:	bf00      	nop
 80a2fc2:	bf00      	nop
 80a2fc4:	bf00      	nop
 80a2fc6:	bf00      	nop
 80a2fc8:	bf00      	nop
 80a2fca:	bf00      	nop
 80a2fcc:	bf00      	nop
 80a2fce:	bf00      	nop
 80a2fd0:	bf00      	nop
 80a2fd2:	bf00      	nop
 80a2fd4:	bf00      	nop
 80a2fd6:	bf00      	nop
 80a2fd8:	bf00      	nop
 80a2fda:	bf00      	nop
 80a2fdc:	bf00      	nop
 80a2fde:	bf00      	nop
 80a2fe0:	bf00      	nop
 80a2fe2:	bf00      	nop
 80a2fe4:	bf00      	nop
 80a2fe6:	bf00      	nop
 80a2fe8:	bf00      	nop
 80a2fea:	bf00      	nop
 80a2fec:	bf00      	nop
 80a2fee:	bf00      	nop
 80a2ff0:	bf00      	nop
 80a2ff2:	bf00      	nop
 80a2ff4:	bf00      	nop
 80a2ff6:	bf00      	nop
 80a2ff8:	bf00      	nop
 80a2ffa:	bf00      	nop
 80a2ffc:	bf00      	nop
 80a2ffe:	bf00      	nop
 80a3000:	bf00      	nop
 80a3002:	bf00      	nop
 80a3004:	bf00      	nop
 80a3006:	bf00      	nop
 80a3008:	bf00      	nop
 80a300a:	bf00      	nop
 80a300c:	bf00      	nop
 80a300e:	bf00      	nop
 80a3010:	bf00      	nop
 80a3012:	bf00      	nop
 80a3014:	bf00      	nop
 80a3016:	bf00      	nop
 80a3018:	bf00      	nop
 80a301a:	bf00      	nop
 80a301c:	bf00      	nop
 80a301e:	bf00      	nop
 80a3020:	bf00      	nop
 80a3022:	bf00      	nop
 80a3024:	bf00      	nop
 80a3026:	bf00      	nop
 80a3028:	bf00      	nop
 80a302a:	bf00      	nop
 80a302c:	bf00      	nop
 80a302e:	bf00      	nop
 80a3030:	bf00      	nop
 80a3032:	bf00      	nop
 80a3034:	bf00      	nop
 80a3036:	bf00      	nop
 80a3038:	bf00      	nop
 80a303a:	bf00      	nop
 80a303c:	bf00      	nop
 80a303e:	bf00      	nop
 80a3040:	bf00      	nop
 80a3042:	bf00      	nop
 80a3044:	bf00      	nop
 80a3046:	bf00      	nop
 80a3048:	e770      	b.n	80a2f2c <_ZN17Adafruit_NeoPixel4showEv+0x664>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a304a:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a304e:	b29b      	uxth	r3, r3
 80a3050:	2b00      	cmp	r3, #0
 80a3052:	f47f aed1 	bne.w	80a2df8 <_ZN17Adafruit_NeoPixel4showEv+0x530>
  __ASM volatile ("cpsie i");
 80a3056:	b662      	cpsie	i
 80a3058:	f002 fbba 	bl	80a57d0 <HAL_Timer_Get_Micro_Seconds>
  }
// END of NRF52 implementation


#endif
  endTime = micros(); // Save EOD time for latch on next call
 80a305c:	6120      	str	r0, [r4, #16]
}
 80a305e:	b007      	add	sp, #28
 80a3060:	bdf0      	pop	{r4, r5, r6, r7, pc}
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a3062:	2b00      	cmp	r3, #0
 80a3064:	d0f7      	beq.n	80a3056 <_ZN17Adafruit_NeoPixel4showEv+0x78e>
      mask = 0x800000; // reset the mask
 80a3066:	f44f 0e00 	mov.w	lr, #8388608	; 0x800000
      j = 0;        // reset the 24-bit counter
 80a306a:	2600      	movs	r6, #0
        pinSet(pin, HIGH); // HIGH
 80a306c:	4b54      	ldr	r3, [pc, #336]	; (80a31c0 <_ZN17Adafruit_NeoPixel4showEv+0x8f8>)
 80a306e:	6818      	ldr	r0, [r3, #0]
        cyc = DWT->CYCCNT;
 80a3070:	4b54      	ldr	r3, [pc, #336]	; (80a31c4 <_ZN17Adafruit_NeoPixel4showEv+0x8fc>)
      mask = 0x800000; // reset the mask
 80a3072:	f8cd e010 	str.w	lr, [sp, #16]
      i = i-3;      // decrement bytes remaining
 80a3076:	f8bd 200a 	ldrh.w	r2, [sp, #10]
      b = *ptr++;   // Next blue byte value
 80a307a:	3103      	adds	r1, #3
      i = i-3;      // decrement bytes remaining
 80a307c:	3a03      	subs	r2, #3
 80a307e:	b292      	uxth	r2, r2
 80a3080:	f8ad 200a 	strh.w	r2, [sp, #10]
      g = *ptr++;   // Next green byte value
 80a3084:	f811 2c03 	ldrb.w	r2, [r1, #-3]
 80a3088:	b2d2      	uxtb	r2, r2
 80a308a:	f88d 2006 	strb.w	r2, [sp, #6]
      r = *ptr++;   // Next red byte value
 80a308e:	f811 2c02 	ldrb.w	r2, [r1, #-2]
 80a3092:	b2d2      	uxtb	r2, r2
 80a3094:	f88d 2007 	strb.w	r2, [sp, #7]
      b = *ptr++;   // Next blue byte value
 80a3098:	f811 2c01 	ldrb.w	r2, [r1, #-1]
 80a309c:	b2d2      	uxtb	r2, r2
 80a309e:	f88d 2008 	strb.w	r2, [sp, #8]
      c = ((uint32_t)g << 16) | ((uint32_t)r <<  8) | b; // Pack the next 3 bytes to keep timing tight
 80a30a2:	f89d c006 	ldrb.w	ip, [sp, #6]
 80a30a6:	f89d 2007 	ldrb.w	r2, [sp, #7]
 80a30aa:	f89d 7008 	ldrb.w	r7, [sp, #8]
 80a30ae:	0212      	lsls	r2, r2, #8
 80a30b0:	ea42 420c 	orr.w	r2, r2, ip, lsl #16
 80a30b4:	433a      	orrs	r2, r7
 80a30b6:	9203      	str	r2, [sp, #12]
      j = 0;        // reset the 24-bit counter
 80a30b8:	f88d 6005 	strb.w	r6, [sp, #5]
        pinSet(pin, HIGH); // HIGH
 80a30bc:	79e2      	ldrb	r2, [r4, #7]
        cyc = DWT->CYCCNT;
 80a30be:	685d      	ldr	r5, [r3, #4]
        pinSet(pin, HIGH); // HIGH
 80a30c0:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 80a30c4:	eb00 0782 	add.w	r7, r0, r2, lsl #2
 80a30c8:	88bf      	ldrh	r7, [r7, #4]
 80a30ca:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
        cyc = DWT->CYCCNT;
 80a30ce:	9505      	str	r5, [sp, #20]
        pinSet(pin, HIGH); // HIGH
 80a30d0:	8317      	strh	r7, [r2, #24]
        if (c & mask) { // if masked bit is high
 80a30d2:	9f03      	ldr	r7, [sp, #12]
 80a30d4:	9a04      	ldr	r2, [sp, #16]
 80a30d6:	4217      	tst	r7, r2
 80a30d8:	d025      	beq.n	80a3126 <_ZN17Adafruit_NeoPixel4showEv+0x85e>
          while(DWT->CYCCNT - cyc < CYCLES_800_T1H);
 80a30da:	685a      	ldr	r2, [r3, #4]
 80a30dc:	9f05      	ldr	r7, [sp, #20]
 80a30de:	1bd2      	subs	r2, r2, r7
 80a30e0:	2a4f      	cmp	r2, #79	; 0x4f
 80a30e2:	d9fa      	bls.n	80a30da <_ZN17Adafruit_NeoPixel4showEv+0x812>
          pinSet(pin, LOW);
 80a30e4:	79e2      	ldrb	r2, [r4, #7]
 80a30e6:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 80a30ea:	eb00 0782 	add.w	r7, r0, r2, lsl #2
 80a30ee:	88bf      	ldrh	r7, [r7, #4]
 80a30f0:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
 80a30f4:	8357      	strh	r7, [r2, #26]
          cyc = DWT->CYCCNT;
 80a30f6:	685a      	ldr	r2, [r3, #4]
 80a30f8:	9205      	str	r2, [sp, #20]
          while(DWT->CYCCNT - cyc < CYCLES_800_T1L);
 80a30fa:	685a      	ldr	r2, [r3, #4]
 80a30fc:	9f05      	ldr	r7, [sp, #20]
 80a30fe:	1bd2      	subs	r2, r2, r7
 80a3100:	2a07      	cmp	r2, #7
 80a3102:	d9fa      	bls.n	80a30fa <_ZN17Adafruit_NeoPixel4showEv+0x832>
        mask >>= 1;
 80a3104:	9a04      	ldr	r2, [sp, #16]
 80a3106:	0852      	lsrs	r2, r2, #1
 80a3108:	9204      	str	r2, [sp, #16]
      } while ( ++j < 24 ); // ... pixel done
 80a310a:	f89d 2005 	ldrb.w	r2, [sp, #5]
 80a310e:	3201      	adds	r2, #1
 80a3110:	b2d2      	uxtb	r2, r2
 80a3112:	2a17      	cmp	r2, #23
 80a3114:	f88d 2005 	strb.w	r2, [sp, #5]
 80a3118:	d9d0      	bls.n	80a30bc <_ZN17Adafruit_NeoPixel4showEv+0x7f4>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a311a:	f8bd 200a 	ldrh.w	r2, [sp, #10]
 80a311e:	b292      	uxth	r2, r2
 80a3120:	2a00      	cmp	r2, #0
 80a3122:	d1a6      	bne.n	80a3072 <_ZN17Adafruit_NeoPixel4showEv+0x7aa>
 80a3124:	e797      	b.n	80a3056 <_ZN17Adafruit_NeoPixel4showEv+0x78e>
          while(DWT->CYCCNT - cyc < CYCLES_800_T0H);
 80a3126:	685a      	ldr	r2, [r3, #4]
 80a3128:	9f05      	ldr	r7, [sp, #20]
 80a312a:	1bd2      	subs	r2, r2, r7
 80a312c:	2a18      	cmp	r2, #24
 80a312e:	d9fa      	bls.n	80a3126 <_ZN17Adafruit_NeoPixel4showEv+0x85e>
          pinSet(pin, LOW);
 80a3130:	79e2      	ldrb	r2, [r4, #7]
 80a3132:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 80a3136:	eb00 0782 	add.w	r7, r0, r2, lsl #2
 80a313a:	88bf      	ldrh	r7, [r7, #4]
 80a313c:	f850 2022 	ldr.w	r2, [r0, r2, lsl #2]
 80a3140:	8357      	strh	r7, [r2, #26]
          cyc = DWT->CYCCNT;
 80a3142:	685a      	ldr	r2, [r3, #4]
 80a3144:	9205      	str	r2, [sp, #20]
          while(DWT->CYCCNT - cyc < CYCLES_800_T0L);
 80a3146:	685a      	ldr	r2, [r3, #4]
 80a3148:	9f05      	ldr	r7, [sp, #20]
 80a314a:	1bd2      	subs	r2, r2, r7
 80a314c:	2a45      	cmp	r2, #69	; 0x45
 80a314e:	d9fa      	bls.n	80a3146 <_ZN17Adafruit_NeoPixel4showEv+0x87e>
 80a3150:	e7d8      	b.n	80a3104 <_ZN17Adafruit_NeoPixel4showEv+0x83c>
 80a3152:	4770      	bx	lr
    while(i) { // While bytes left... (4 bytes = 1 pixel)
 80a3154:	2b00      	cmp	r3, #0
 80a3156:	f43f af7e 	beq.w	80a3056 <_ZN17Adafruit_NeoPixel4showEv+0x78e>
      mask = 0x80000000; // reset the mask
 80a315a:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
      j = 0;        // reset the 32-bit counter
 80a315e:	2600      	movs	r6, #0
 80a3160:	4a17      	ldr	r2, [pc, #92]	; (80a31c0 <_ZN17Adafruit_NeoPixel4showEv+0x8f8>)
      mask = 0x80000000; // reset the mask
 80a3162:	9504      	str	r5, [sp, #16]
      i = i-4;      // decrement bytes remaining
 80a3164:	f8bd 300a 	ldrh.w	r3, [sp, #10]
      w = *ptr++;   // Next white byte value
 80a3168:	3104      	adds	r1, #4
      i = i-4;      // decrement bytes remaining
 80a316a:	3b04      	subs	r3, #4
 80a316c:	b29b      	uxth	r3, r3
 80a316e:	f8ad 300a 	strh.w	r3, [sp, #10]
      r = *ptr++;   // Next red byte value
 80a3172:	f811 3c04 	ldrb.w	r3, [r1, #-4]
 80a3176:	b2db      	uxtb	r3, r3
 80a3178:	f88d 3007 	strb.w	r3, [sp, #7]
      g = *ptr++;   // Next green byte value
 80a317c:	f811 3c03 	ldrb.w	r3, [r1, #-3]
 80a3180:	b2db      	uxtb	r3, r3
 80a3182:	f88d 3006 	strb.w	r3, [sp, #6]
      b = *ptr++;   // Next blue byte value
 80a3186:	f811 3c02 	ldrb.w	r3, [r1, #-2]
 80a318a:	b2db      	uxtb	r3, r3
 80a318c:	f88d 3008 	strb.w	r3, [sp, #8]
      w = *ptr++;   // Next white byte value
 80a3190:	f811 3c01 	ldrb.w	r3, [r1, #-1]
 80a3194:	b2db      	uxtb	r3, r3
 80a3196:	f88d 3009 	strb.w	r3, [sp, #9]
      c = ((uint32_t)r << 24) | ((uint32_t)g << 16) | ((uint32_t)b <<  8) | w; // Pack the next 4 bytes to keep timing tight
 80a319a:	f89d c007 	ldrb.w	ip, [sp, #7]
 80a319e:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a31a2:	f89d 0008 	ldrb.w	r0, [sp, #8]
 80a31a6:	041b      	lsls	r3, r3, #16
 80a31a8:	f89d 7009 	ldrb.w	r7, [sp, #9]
 80a31ac:	ea43 630c 	orr.w	r3, r3, ip, lsl #24
 80a31b0:	433b      	orrs	r3, r7
 80a31b2:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 80a31b6:	9303      	str	r3, [sp, #12]
      j = 0;        // reset the 32-bit counter
 80a31b8:	f88d 6005 	strb.w	r6, [sp, #5]
 80a31bc:	e07f      	b.n	80a32be <_ZN17Adafruit_NeoPixel4showEv+0x9f6>
 80a31be:	bf00      	nop
 80a31c0:	20000d90 	.word	0x20000d90
 80a31c4:	e0001000 	.word	0xe0001000
            ::: "r0", "cc", "memory");
 80a31c8:	4600      	mov	r0, r0
 80a31ca:	bf00      	nop
 80a31cc:	bf00      	nop
 80a31ce:	bf00      	nop
 80a31d0:	bf00      	nop
 80a31d2:	bf00      	nop
 80a31d4:	bf00      	nop
 80a31d6:	bf00      	nop
 80a31d8:	bf00      	nop
 80a31da:	bf00      	nop
 80a31dc:	bf00      	nop
 80a31de:	bf00      	nop
 80a31e0:	bf00      	nop
 80a31e2:	bf00      	nop
 80a31e4:	bf00      	nop
 80a31e6:	bf00      	nop
 80a31e8:	bf00      	nop
 80a31ea:	bf00      	nop
 80a31ec:	bf00      	nop
 80a31ee:	bf00      	nop
 80a31f0:	bf00      	nop
 80a31f2:	bf00      	nop
 80a31f4:	bf00      	nop
 80a31f6:	bf00      	nop
 80a31f8:	bf00      	nop
 80a31fa:	bf00      	nop
 80a31fc:	bf00      	nop
 80a31fe:	bf00      	nop
 80a3200:	bf00      	nop
 80a3202:	bf00      	nop
 80a3204:	bf00      	nop
 80a3206:	bf00      	nop
 80a3208:	bf00      	nop
 80a320a:	bf00      	nop
 80a320c:	bf00      	nop
 80a320e:	bf00      	nop
 80a3210:	bf00      	nop
 80a3212:	bf00      	nop
 80a3214:	bf00      	nop
 80a3216:	bf00      	nop
 80a3218:	bf00      	nop
 80a321a:	bf00      	nop
 80a321c:	bf00      	nop
 80a321e:	bf00      	nop
 80a3220:	bf00      	nop
 80a3222:	bf00      	nop
 80a3224:	bf00      	nop
 80a3226:	bf00      	nop
 80a3228:	bf00      	nop
 80a322a:	bf00      	nop
 80a322c:	bf00      	nop
 80a322e:	bf00      	nop
 80a3230:	bf00      	nop
 80a3232:	bf00      	nop
 80a3234:	bf00      	nop
          pinSet(pin, LOW); // LOW
 80a3236:	79e3      	ldrb	r3, [r4, #7]
 80a3238:	6810      	ldr	r0, [r2, #0]
 80a323a:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a323e:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a3242:	88bf      	ldrh	r7, [r7, #4]
 80a3244:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a3248:	835f      	strh	r7, [r3, #26]
            ::: "r0", "cc", "memory");
 80a324a:	4600      	mov	r0, r0
 80a324c:	bf00      	nop
 80a324e:	bf00      	nop
 80a3250:	bf00      	nop
 80a3252:	bf00      	nop
 80a3254:	bf00      	nop
 80a3256:	bf00      	nop
 80a3258:	bf00      	nop
 80a325a:	bf00      	nop
 80a325c:	bf00      	nop
 80a325e:	bf00      	nop
 80a3260:	bf00      	nop
 80a3262:	bf00      	nop
 80a3264:	bf00      	nop
 80a3266:	bf00      	nop
 80a3268:	bf00      	nop
 80a326a:	bf00      	nop
 80a326c:	bf00      	nop
 80a326e:	bf00      	nop
 80a3270:	bf00      	nop
 80a3272:	bf00      	nop
 80a3274:	bf00      	nop
 80a3276:	bf00      	nop
 80a3278:	bf00      	nop
 80a327a:	bf00      	nop
 80a327c:	bf00      	nop
 80a327e:	bf00      	nop
 80a3280:	bf00      	nop
 80a3282:	bf00      	nop
 80a3284:	bf00      	nop
 80a3286:	bf00      	nop
 80a3288:	bf00      	nop
 80a328a:	bf00      	nop
 80a328c:	bf00      	nop
 80a328e:	bf00      	nop
 80a3290:	bf00      	nop
 80a3292:	bf00      	nop
 80a3294:	bf00      	nop
 80a3296:	bf00      	nop
 80a3298:	bf00      	nop
 80a329a:	bf00      	nop
 80a329c:	bf00      	nop
 80a329e:	bf00      	nop
 80a32a0:	bf00      	nop
 80a32a2:	bf00      	nop
 80a32a4:	bf00      	nop
 80a32a6:	bf00      	nop
        mask >>= 1;
 80a32a8:	9b04      	ldr	r3, [sp, #16]
 80a32aa:	085b      	lsrs	r3, r3, #1
 80a32ac:	9304      	str	r3, [sp, #16]
      } while ( ++j < 32 ); // ... pixel done
 80a32ae:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a32b2:	3301      	adds	r3, #1
 80a32b4:	b2db      	uxtb	r3, r3
 80a32b6:	2b1f      	cmp	r3, #31
 80a32b8:	f88d 3005 	strb.w	r3, [sp, #5]
 80a32bc:	d87e      	bhi.n	80a33bc <_ZN17Adafruit_NeoPixel4showEv+0xaf4>
        pinSet(pin, HIGH); // HIGH
 80a32be:	79e3      	ldrb	r3, [r4, #7]
 80a32c0:	6810      	ldr	r0, [r2, #0]
 80a32c2:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a32c6:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a32ca:	88bf      	ldrh	r7, [r7, #4]
 80a32cc:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a32d0:	831f      	strh	r7, [r3, #24]
        if (c & mask) { // if masked bit is high
 80a32d2:	9803      	ldr	r0, [sp, #12]
 80a32d4:	9b04      	ldr	r3, [sp, #16]
 80a32d6:	4218      	tst	r0, r3
 80a32d8:	f47f af76 	bne.w	80a31c8 <_ZN17Adafruit_NeoPixel4showEv+0x900>
            ::: "r0", "cc", "memory");
 80a32dc:	4600      	mov	r0, r0
 80a32de:	bf00      	nop
 80a32e0:	bf00      	nop
 80a32e2:	bf00      	nop
 80a32e4:	bf00      	nop
 80a32e6:	bf00      	nop
 80a32e8:	bf00      	nop
 80a32ea:	bf00      	nop
 80a32ec:	bf00      	nop
 80a32ee:	bf00      	nop
 80a32f0:	bf00      	nop
 80a32f2:	bf00      	nop
 80a32f4:	bf00      	nop
 80a32f6:	bf00      	nop
 80a32f8:	bf00      	nop
 80a32fa:	bf00      	nop
 80a32fc:	bf00      	nop
 80a32fe:	bf00      	nop
 80a3300:	bf00      	nop
 80a3302:	bf00      	nop
          pinSet(pin, LOW); // LOW
 80a3304:	79e3      	ldrb	r3, [r4, #7]
 80a3306:	6810      	ldr	r0, [r2, #0]
 80a3308:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a330c:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a3310:	88bf      	ldrh	r7, [r7, #4]
 80a3312:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a3316:	835f      	strh	r7, [r3, #26]
            ::: "r0", "cc", "memory");
 80a3318:	4600      	mov	r0, r0
 80a331a:	bf00      	nop
 80a331c:	bf00      	nop
 80a331e:	bf00      	nop
 80a3320:	bf00      	nop
 80a3322:	bf00      	nop
 80a3324:	bf00      	nop
 80a3326:	bf00      	nop
 80a3328:	bf00      	nop
 80a332a:	bf00      	nop
 80a332c:	bf00      	nop
 80a332e:	bf00      	nop
 80a3330:	bf00      	nop
 80a3332:	bf00      	nop
 80a3334:	bf00      	nop
 80a3336:	bf00      	nop
 80a3338:	bf00      	nop
 80a333a:	bf00      	nop
 80a333c:	bf00      	nop
 80a333e:	bf00      	nop
 80a3340:	bf00      	nop
 80a3342:	bf00      	nop
 80a3344:	bf00      	nop
 80a3346:	bf00      	nop
 80a3348:	bf00      	nop
 80a334a:	bf00      	nop
 80a334c:	bf00      	nop
 80a334e:	bf00      	nop
 80a3350:	bf00      	nop
 80a3352:	bf00      	nop
 80a3354:	bf00      	nop
 80a3356:	bf00      	nop
 80a3358:	bf00      	nop
 80a335a:	bf00      	nop
 80a335c:	bf00      	nop
 80a335e:	bf00      	nop
 80a3360:	bf00      	nop
 80a3362:	bf00      	nop
 80a3364:	bf00      	nop
 80a3366:	bf00      	nop
 80a3368:	bf00      	nop
 80a336a:	bf00      	nop
 80a336c:	bf00      	nop
 80a336e:	bf00      	nop
 80a3370:	bf00      	nop
 80a3372:	bf00      	nop
 80a3374:	bf00      	nop
 80a3376:	bf00      	nop
 80a3378:	bf00      	nop
 80a337a:	bf00      	nop
 80a337c:	bf00      	nop
 80a337e:	bf00      	nop
 80a3380:	bf00      	nop
 80a3382:	bf00      	nop
 80a3384:	bf00      	nop
 80a3386:	bf00      	nop
 80a3388:	bf00      	nop
 80a338a:	bf00      	nop
 80a338c:	bf00      	nop
 80a338e:	bf00      	nop
 80a3390:	bf00      	nop
 80a3392:	bf00      	nop
 80a3394:	bf00      	nop
 80a3396:	bf00      	nop
 80a3398:	bf00      	nop
 80a339a:	bf00      	nop
 80a339c:	bf00      	nop
 80a339e:	bf00      	nop
 80a33a0:	bf00      	nop
 80a33a2:	bf00      	nop
 80a33a4:	bf00      	nop
 80a33a6:	bf00      	nop
 80a33a8:	bf00      	nop
 80a33aa:	bf00      	nop
 80a33ac:	bf00      	nop
 80a33ae:	bf00      	nop
 80a33b0:	bf00      	nop
 80a33b2:	bf00      	nop
 80a33b4:	bf00      	nop
 80a33b6:	bf00      	nop
 80a33b8:	bf00      	nop
 80a33ba:	e775      	b.n	80a32a8 <_ZN17Adafruit_NeoPixel4showEv+0x9e0>
    while(i) { // While bytes left... (4 bytes = 1 pixel)
 80a33bc:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a33c0:	b29b      	uxth	r3, r3
 80a33c2:	2b00      	cmp	r3, #0
 80a33c4:	f47f aecd 	bne.w	80a3162 <_ZN17Adafruit_NeoPixel4showEv+0x89a>
 80a33c8:	e645      	b.n	80a3056 <_ZN17Adafruit_NeoPixel4showEv+0x78e>
  else if(type == TM1803) { // TM1803 (Radio Shack Tri-Color Strip), 400 KHz bitstream
 80a33ca:	2d03      	cmp	r5, #3
 80a33cc:	f000 812b 	beq.w	80a3626 <_ZN17Adafruit_NeoPixel4showEv+0xd5e>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a33d0:	2b00      	cmp	r3, #0
 80a33d2:	f43f ae40 	beq.w	80a3056 <_ZN17Adafruit_NeoPixel4showEv+0x78e>
      mask = 0x800000; // reset the mask
 80a33d6:	f44f 0500 	mov.w	r5, #8388608	; 0x800000
      j = 0;        // reset the 24-bit counter
 80a33da:	2600      	movs	r6, #0
 80a33dc:	4a17      	ldr	r2, [pc, #92]	; (80a343c <_ZN17Adafruit_NeoPixel4showEv+0xb74>)
      mask = 0x800000; // reset the mask
 80a33de:	9504      	str	r5, [sp, #16]
      i = i-3;      // decrement bytes remaining
 80a33e0:	f8bd 300a 	ldrh.w	r3, [sp, #10]
      pinSet(pin, LOW); // LOW
 80a33e4:	79e0      	ldrb	r0, [r4, #7]
      i = i-3;      // decrement bytes remaining
 80a33e6:	3b03      	subs	r3, #3
 80a33e8:	b29b      	uxth	r3, r3
 80a33ea:	f8ad 300a 	strh.w	r3, [sp, #10]
      r = *ptr++;   // Next red byte value
 80a33ee:	780b      	ldrb	r3, [r1, #0]
      pinSet(pin, LOW); // LOW
 80a33f0:	6817      	ldr	r7, [r2, #0]
      r = *ptr++;   // Next red byte value
 80a33f2:	b2db      	uxtb	r3, r3
 80a33f4:	f88d 3007 	strb.w	r3, [sp, #7]
      b = *ptr++;   // Next blue byte value
 80a33f8:	784b      	ldrb	r3, [r1, #1]
      pinSet(pin, LOW); // LOW
 80a33fa:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
      b = *ptr++;   // Next blue byte value
 80a33fe:	b2db      	uxtb	r3, r3
 80a3400:	f88d 3008 	strb.w	r3, [sp, #8]
      g = *ptr++;   // Next green byte value
 80a3404:	788b      	ldrb	r3, [r1, #2]
      pinSet(pin, LOW); // LOW
 80a3406:	eb07 0c80 	add.w	ip, r7, r0, lsl #2
      g = *ptr++;   // Next green byte value
 80a340a:	b2db      	uxtb	r3, r3
 80a340c:	f88d 3006 	strb.w	r3, [sp, #6]
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
 80a3410:	f89d e007 	ldrb.w	lr, [sp, #7]
 80a3414:	f89d 3008 	ldrb.w	r3, [sp, #8]
      pinSet(pin, LOW); // LOW
 80a3418:	f8bc c004 	ldrh.w	ip, [ip, #4]
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
 80a341c:	021b      	lsls	r3, r3, #8
 80a341e:	ea43 430e 	orr.w	r3, r3, lr, lsl #16
 80a3422:	f89d e006 	ldrb.w	lr, [sp, #6]
      pinSet(pin, LOW); // LOW
 80a3426:	f857 0020 	ldr.w	r0, [r7, r0, lsl #2]
      c = ((uint32_t)r << 16) | ((uint32_t)b <<  8) | g; // Pack the next 3 bytes to keep timing tight
 80a342a:	ea43 030e 	orr.w	r3, r3, lr
 80a342e:	9303      	str	r3, [sp, #12]
      g = *ptr++;   // Next green byte value
 80a3430:	3103      	adds	r1, #3
      j = 0;        // reset the 24-bit counter
 80a3432:	f88d 6005 	strb.w	r6, [sp, #5]
      pinSet(pin, LOW); // LOW
 80a3436:	f8a0 c01a 	strh.w	ip, [r0, #26]
 80a343a:	e07c      	b.n	80a3536 <_ZN17Adafruit_NeoPixel4showEv+0xc6e>
 80a343c:	20000d90 	.word	0x20000d90
          mask >>= 1; // Do this task during the long delay of this bit
 80a3440:	9b04      	ldr	r3, [sp, #16]
 80a3442:	085b      	lsrs	r3, r3, #1
 80a3444:	9304      	str	r3, [sp, #16]
            ::: "r0", "cc", "memory");
 80a3446:	4600      	mov	r0, r0
 80a3448:	bf00      	nop
 80a344a:	bf00      	nop
 80a344c:	bf00      	nop
 80a344e:	bf00      	nop
 80a3450:	bf00      	nop
 80a3452:	bf00      	nop
 80a3454:	bf00      	nop
 80a3456:	bf00      	nop
 80a3458:	bf00      	nop
 80a345a:	bf00      	nop
 80a345c:	bf00      	nop
 80a345e:	bf00      	nop
 80a3460:	bf00      	nop
 80a3462:	bf00      	nop
 80a3464:	bf00      	nop
 80a3466:	bf00      	nop
 80a3468:	bf00      	nop
 80a346a:	bf00      	nop
 80a346c:	bf00      	nop
 80a346e:	bf00      	nop
 80a3470:	bf00      	nop
 80a3472:	bf00      	nop
 80a3474:	bf00      	nop
 80a3476:	bf00      	nop
 80a3478:	bf00      	nop
 80a347a:	bf00      	nop
 80a347c:	bf00      	nop
 80a347e:	bf00      	nop
 80a3480:	bf00      	nop
 80a3482:	bf00      	nop
 80a3484:	bf00      	nop
 80a3486:	bf00      	nop
 80a3488:	bf00      	nop
 80a348a:	bf00      	nop
 80a348c:	bf00      	nop
 80a348e:	bf00      	nop
 80a3490:	bf00      	nop
 80a3492:	bf00      	nop
 80a3494:	bf00      	nop
 80a3496:	bf00      	nop
 80a3498:	bf00      	nop
 80a349a:	bf00      	nop
 80a349c:	bf00      	nop
 80a349e:	bf00      	nop
 80a34a0:	bf00      	nop
 80a34a2:	bf00      	nop
 80a34a4:	bf00      	nop
 80a34a6:	bf00      	nop
 80a34a8:	bf00      	nop
 80a34aa:	bf00      	nop
 80a34ac:	bf00      	nop
 80a34ae:	bf00      	nop
 80a34b0:	bf00      	nop
 80a34b2:	bf00      	nop
 80a34b4:	bf00      	nop
 80a34b6:	bf00      	nop
 80a34b8:	bf00      	nop
 80a34ba:	bf00      	nop
 80a34bc:	bf00      	nop
 80a34be:	bf00      	nop
 80a34c0:	bf00      	nop
 80a34c2:	bf00      	nop
 80a34c4:	bf00      	nop
 80a34c6:	bf00      	nop
 80a34c8:	bf00      	nop
 80a34ca:	bf00      	nop
          pinSet(pin, HIGH); // HIGH
 80a34cc:	79e0      	ldrb	r0, [r4, #7]
 80a34ce:	6817      	ldr	r7, [r2, #0]
          j++;
 80a34d0:	f89d 3005 	ldrb.w	r3, [sp, #5]
          pinSet(pin, HIGH); // HIGH
 80a34d4:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 80a34d8:	eb07 0c80 	add.w	ip, r7, r0, lsl #2
 80a34dc:	f8bc c004 	ldrh.w	ip, [ip, #4]
 80a34e0:	f857 0020 	ldr.w	r0, [r7, r0, lsl #2]
          j++;
 80a34e4:	3301      	adds	r3, #1
 80a34e6:	b2db      	uxtb	r3, r3
 80a34e8:	f88d 3005 	strb.w	r3, [sp, #5]
          pinSet(pin, HIGH); // HIGH
 80a34ec:	f8a0 c018 	strh.w	ip, [r0, #24]
            ::: "r0", "cc", "memory");
 80a34f0:	4600      	mov	r0, r0
 80a34f2:	bf00      	nop
 80a34f4:	bf00      	nop
 80a34f6:	bf00      	nop
 80a34f8:	bf00      	nop
 80a34fa:	bf00      	nop
 80a34fc:	bf00      	nop
 80a34fe:	bf00      	nop
 80a3500:	bf00      	nop
 80a3502:	bf00      	nop
 80a3504:	bf00      	nop
 80a3506:	bf00      	nop
 80a3508:	bf00      	nop
 80a350a:	bf00      	nop
 80a350c:	bf00      	nop
 80a350e:	bf00      	nop
 80a3510:	bf00      	nop
 80a3512:	bf00      	nop
 80a3514:	bf00      	nop
 80a3516:	bf00      	nop
 80a3518:	bf00      	nop
          if(j==24) break;
 80a351a:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a351e:	2b18      	cmp	r3, #24
 80a3520:	d07a      	beq.n	80a3618 <_ZN17Adafruit_NeoPixel4showEv+0xd50>
          pinSet(pin, LOW); // LOW
 80a3522:	79e3      	ldrb	r3, [r4, #7]
 80a3524:	6810      	ldr	r0, [r2, #0]
 80a3526:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a352a:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a352e:	88bf      	ldrh	r7, [r7, #4]
 80a3530:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a3534:	835f      	strh	r7, [r3, #26]
        if (c & mask) { // if masked bit is high
 80a3536:	9803      	ldr	r0, [sp, #12]
 80a3538:	9b04      	ldr	r3, [sp, #16]
 80a353a:	4218      	tst	r0, r3
 80a353c:	d180      	bne.n	80a3440 <_ZN17Adafruit_NeoPixel4showEv+0xb78>
            ::: "r0", "cc", "memory");
 80a353e:	4600      	mov	r0, r0
 80a3540:	bf00      	nop
 80a3542:	bf00      	nop
 80a3544:	bf00      	nop
 80a3546:	bf00      	nop
 80a3548:	bf00      	nop
 80a354a:	bf00      	nop
 80a354c:	bf00      	nop
 80a354e:	bf00      	nop
 80a3550:	bf00      	nop
 80a3552:	bf00      	nop
 80a3554:	bf00      	nop
 80a3556:	bf00      	nop
 80a3558:	bf00      	nop
 80a355a:	bf00      	nop
 80a355c:	bf00      	nop
 80a355e:	bf00      	nop
          pinSet(pin, HIGH); // HIGH
 80a3560:	79e3      	ldrb	r3, [r4, #7]
 80a3562:	6810      	ldr	r0, [r2, #0]
 80a3564:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a3568:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a356c:	88bf      	ldrh	r7, [r7, #4]
 80a356e:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a3572:	831f      	strh	r7, [r3, #24]
          j++;
 80a3574:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a3578:	3301      	adds	r3, #1
 80a357a:	b2db      	uxtb	r3, r3
 80a357c:	f88d 3005 	strb.w	r3, [sp, #5]
          mask >>= 1; // Do this task during the long delay of this bit
 80a3580:	9b04      	ldr	r3, [sp, #16]
 80a3582:	085b      	lsrs	r3, r3, #1
 80a3584:	9304      	str	r3, [sp, #16]
            ::: "r0", "cc", "memory");
 80a3586:	4600      	mov	r0, r0
 80a3588:	bf00      	nop
 80a358a:	bf00      	nop
 80a358c:	bf00      	nop
 80a358e:	bf00      	nop
 80a3590:	bf00      	nop
 80a3592:	bf00      	nop
 80a3594:	bf00      	nop
 80a3596:	bf00      	nop
 80a3598:	bf00      	nop
 80a359a:	bf00      	nop
 80a359c:	bf00      	nop
 80a359e:	bf00      	nop
 80a35a0:	bf00      	nop
 80a35a2:	bf00      	nop
 80a35a4:	bf00      	nop
 80a35a6:	bf00      	nop
 80a35a8:	bf00      	nop
 80a35aa:	bf00      	nop
 80a35ac:	bf00      	nop
 80a35ae:	bf00      	nop
 80a35b0:	bf00      	nop
 80a35b2:	bf00      	nop
 80a35b4:	bf00      	nop
 80a35b6:	bf00      	nop
 80a35b8:	bf00      	nop
 80a35ba:	bf00      	nop
 80a35bc:	bf00      	nop
 80a35be:	bf00      	nop
 80a35c0:	bf00      	nop
 80a35c2:	bf00      	nop
 80a35c4:	bf00      	nop
 80a35c6:	bf00      	nop
 80a35c8:	bf00      	nop
 80a35ca:	bf00      	nop
 80a35cc:	bf00      	nop
 80a35ce:	bf00      	nop
 80a35d0:	bf00      	nop
 80a35d2:	bf00      	nop
 80a35d4:	bf00      	nop
 80a35d6:	bf00      	nop
 80a35d8:	bf00      	nop
 80a35da:	bf00      	nop
 80a35dc:	bf00      	nop
 80a35de:	bf00      	nop
 80a35e0:	bf00      	nop
 80a35e2:	bf00      	nop
 80a35e4:	bf00      	nop
 80a35e6:	bf00      	nop
 80a35e8:	bf00      	nop
 80a35ea:	bf00      	nop
 80a35ec:	bf00      	nop
 80a35ee:	bf00      	nop
 80a35f0:	bf00      	nop
 80a35f2:	bf00      	nop
 80a35f4:	bf00      	nop
 80a35f6:	bf00      	nop
 80a35f8:	bf00      	nop
 80a35fa:	bf00      	nop
 80a35fc:	bf00      	nop
 80a35fe:	bf00      	nop
 80a3600:	bf00      	nop
 80a3602:	bf00      	nop
 80a3604:	bf00      	nop
 80a3606:	bf00      	nop
 80a3608:	bf00      	nop
 80a360a:	bf00      	nop
 80a360c:	bf00      	nop
 80a360e:	bf00      	nop
          if(j==24) break;
 80a3610:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a3614:	2b18      	cmp	r3, #24
 80a3616:	d184      	bne.n	80a3522 <_ZN17Adafruit_NeoPixel4showEv+0xc5a>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a3618:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a361c:	b29b      	uxth	r3, r3
 80a361e:	2b00      	cmp	r3, #0
 80a3620:	f47f aedd 	bne.w	80a33de <_ZN17Adafruit_NeoPixel4showEv+0xb16>
 80a3624:	e517      	b.n	80a3056 <_ZN17Adafruit_NeoPixel4showEv+0x78e>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a3626:	2b00      	cmp	r3, #0
 80a3628:	f43f ad15 	beq.w	80a3056 <_ZN17Adafruit_NeoPixel4showEv+0x78e>
      mask = 0x800000; // reset the mask
 80a362c:	f44f 0500 	mov.w	r5, #8388608	; 0x800000
      j = 0;        // reset the 24-bit counter
 80a3630:	2600      	movs	r6, #0
 80a3632:	4a13      	ldr	r2, [pc, #76]	; (80a3680 <_ZN17Adafruit_NeoPixel4showEv+0xdb8>)
      mask = 0x800000; // reset the mask
 80a3634:	9504      	str	r5, [sp, #16]
      i = i-3;      // decrement bytes remaining
 80a3636:	f8bd 300a 	ldrh.w	r3, [sp, #10]
      b = *ptr++;   // Next green byte value
 80a363a:	3103      	adds	r1, #3
      i = i-3;      // decrement bytes remaining
 80a363c:	3b03      	subs	r3, #3
 80a363e:	b29b      	uxth	r3, r3
 80a3640:	f8ad 300a 	strh.w	r3, [sp, #10]
      r = *ptr++;   // Next red byte value
 80a3644:	f811 3c03 	ldrb.w	r3, [r1, #-3]
 80a3648:	b2db      	uxtb	r3, r3
 80a364a:	f88d 3007 	strb.w	r3, [sp, #7]
      g = *ptr++;   // Next blue byte value
 80a364e:	f811 3c02 	ldrb.w	r3, [r1, #-2]
 80a3652:	b2db      	uxtb	r3, r3
 80a3654:	f88d 3006 	strb.w	r3, [sp, #6]
      b = *ptr++;   // Next green byte value
 80a3658:	f811 3c01 	ldrb.w	r3, [r1, #-1]
 80a365c:	b2db      	uxtb	r3, r3
 80a365e:	f88d 3008 	strb.w	r3, [sp, #8]
      c = ((uint32_t)r << 16) | ((uint32_t)g <<  8) | b; // Pack the next 3 bytes to keep timing tight
 80a3662:	f89d 7007 	ldrb.w	r7, [sp, #7]
 80a3666:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a366a:	f89d 0008 	ldrb.w	r0, [sp, #8]
 80a366e:	021b      	lsls	r3, r3, #8
 80a3670:	ea43 4307 	orr.w	r3, r3, r7, lsl #16
 80a3674:	4303      	orrs	r3, r0
 80a3676:	9303      	str	r3, [sp, #12]
      j = 0;        // reset the 24-bit counter
 80a3678:	f88d 6005 	strb.w	r6, [sp, #5]
 80a367c:	e0e1      	b.n	80a3842 <_ZN17Adafruit_NeoPixel4showEv+0xf7a>
 80a367e:	bf00      	nop
 80a3680:	20000d90 	.word	0x20000d90
            ::: "r0", "cc", "memory");
 80a3684:	4600      	mov	r0, r0
 80a3686:	bf00      	nop
 80a3688:	bf00      	nop
 80a368a:	bf00      	nop
 80a368c:	bf00      	nop
 80a368e:	bf00      	nop
 80a3690:	bf00      	nop
 80a3692:	bf00      	nop
 80a3694:	bf00      	nop
 80a3696:	bf00      	nop
 80a3698:	bf00      	nop
 80a369a:	bf00      	nop
 80a369c:	bf00      	nop
 80a369e:	bf00      	nop
 80a36a0:	bf00      	nop
 80a36a2:	bf00      	nop
 80a36a4:	bf00      	nop
 80a36a6:	bf00      	nop
 80a36a8:	bf00      	nop
 80a36aa:	bf00      	nop
 80a36ac:	bf00      	nop
 80a36ae:	bf00      	nop
 80a36b0:	bf00      	nop
 80a36b2:	bf00      	nop
 80a36b4:	bf00      	nop
 80a36b6:	bf00      	nop
 80a36b8:	bf00      	nop
 80a36ba:	bf00      	nop
 80a36bc:	bf00      	nop
 80a36be:	bf00      	nop
 80a36c0:	bf00      	nop
 80a36c2:	bf00      	nop
 80a36c4:	bf00      	nop
 80a36c6:	bf00      	nop
 80a36c8:	bf00      	nop
 80a36ca:	bf00      	nop
 80a36cc:	bf00      	nop
 80a36ce:	bf00      	nop
 80a36d0:	bf00      	nop
 80a36d2:	bf00      	nop
 80a36d4:	bf00      	nop
 80a36d6:	bf00      	nop
 80a36d8:	bf00      	nop
 80a36da:	bf00      	nop
 80a36dc:	bf00      	nop
 80a36de:	bf00      	nop
 80a36e0:	bf00      	nop
 80a36e2:	bf00      	nop
 80a36e4:	bf00      	nop
 80a36e6:	bf00      	nop
 80a36e8:	bf00      	nop
 80a36ea:	bf00      	nop
 80a36ec:	bf00      	nop
 80a36ee:	bf00      	nop
 80a36f0:	bf00      	nop
 80a36f2:	bf00      	nop
 80a36f4:	bf00      	nop
 80a36f6:	bf00      	nop
 80a36f8:	bf00      	nop
 80a36fa:	bf00      	nop
 80a36fc:	bf00      	nop
 80a36fe:	bf00      	nop
 80a3700:	bf00      	nop
 80a3702:	bf00      	nop
 80a3704:	bf00      	nop
 80a3706:	bf00      	nop
 80a3708:	bf00      	nop
 80a370a:	bf00      	nop
 80a370c:	bf00      	nop
 80a370e:	bf00      	nop
 80a3710:	bf00      	nop
 80a3712:	bf00      	nop
 80a3714:	bf00      	nop
 80a3716:	bf00      	nop
 80a3718:	bf00      	nop
 80a371a:	bf00      	nop
 80a371c:	bf00      	nop
 80a371e:	bf00      	nop
 80a3720:	bf00      	nop
 80a3722:	bf00      	nop
 80a3724:	bf00      	nop
 80a3726:	bf00      	nop
 80a3728:	bf00      	nop
 80a372a:	bf00      	nop
 80a372c:	bf00      	nop
 80a372e:	bf00      	nop
 80a3730:	bf00      	nop
 80a3732:	bf00      	nop
 80a3734:	bf00      	nop
 80a3736:	bf00      	nop
 80a3738:	bf00      	nop
 80a373a:	bf00      	nop
 80a373c:	bf00      	nop
 80a373e:	bf00      	nop
 80a3740:	bf00      	nop
 80a3742:	bf00      	nop
 80a3744:	bf00      	nop
 80a3746:	bf00      	nop
 80a3748:	bf00      	nop
 80a374a:	bf00      	nop
 80a374c:	bf00      	nop
 80a374e:	bf00      	nop
 80a3750:	bf00      	nop
 80a3752:	bf00      	nop
 80a3754:	bf00      	nop
 80a3756:	bf00      	nop
 80a3758:	bf00      	nop
 80a375a:	bf00      	nop
 80a375c:	bf00      	nop
 80a375e:	bf00      	nop
 80a3760:	bf00      	nop
 80a3762:	bf00      	nop
 80a3764:	bf00      	nop
 80a3766:	bf00      	nop
 80a3768:	bf00      	nop
 80a376a:	bf00      	nop
 80a376c:	bf00      	nop
 80a376e:	bf00      	nop
 80a3770:	bf00      	nop
 80a3772:	bf00      	nop
 80a3774:	bf00      	nop
 80a3776:	bf00      	nop
 80a3778:	bf00      	nop
 80a377a:	bf00      	nop
 80a377c:	bf00      	nop
 80a377e:	bf00      	nop
 80a3780:	bf00      	nop
 80a3782:	bf00      	nop
 80a3784:	bf00      	nop
 80a3786:	bf00      	nop
 80a3788:	bf00      	nop
 80a378a:	bf00      	nop
 80a378c:	bf00      	nop
 80a378e:	bf00      	nop
 80a3790:	bf00      	nop
 80a3792:	bf00      	nop
 80a3794:	bf00      	nop
 80a3796:	bf00      	nop
 80a3798:	bf00      	nop
 80a379a:	bf00      	nop
 80a379c:	bf00      	nop
 80a379e:	bf00      	nop
 80a37a0:	bf00      	nop
 80a37a2:	bf00      	nop
 80a37a4:	bf00      	nop
          pinSet(pin, LOW); // LOW
 80a37a6:	79e3      	ldrb	r3, [r4, #7]
 80a37a8:	6810      	ldr	r0, [r2, #0]
 80a37aa:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a37ae:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a37b2:	88bf      	ldrh	r7, [r7, #4]
 80a37b4:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a37b8:	835f      	strh	r7, [r3, #26]
            ::: "r0", "cc", "memory");
 80a37ba:	4600      	mov	r0, r0
 80a37bc:	bf00      	nop
 80a37be:	bf00      	nop
 80a37c0:	bf00      	nop
 80a37c2:	bf00      	nop
 80a37c4:	bf00      	nop
 80a37c6:	bf00      	nop
 80a37c8:	bf00      	nop
 80a37ca:	bf00      	nop
 80a37cc:	bf00      	nop
 80a37ce:	bf00      	nop
 80a37d0:	bf00      	nop
 80a37d2:	bf00      	nop
 80a37d4:	bf00      	nop
 80a37d6:	bf00      	nop
 80a37d8:	bf00      	nop
 80a37da:	bf00      	nop
 80a37dc:	bf00      	nop
 80a37de:	bf00      	nop
 80a37e0:	bf00      	nop
 80a37e2:	bf00      	nop
 80a37e4:	bf00      	nop
 80a37e6:	bf00      	nop
 80a37e8:	bf00      	nop
 80a37ea:	bf00      	nop
 80a37ec:	bf00      	nop
 80a37ee:	bf00      	nop
 80a37f0:	bf00      	nop
 80a37f2:	bf00      	nop
 80a37f4:	bf00      	nop
 80a37f6:	bf00      	nop
 80a37f8:	bf00      	nop
 80a37fa:	bf00      	nop
 80a37fc:	bf00      	nop
 80a37fe:	bf00      	nop
 80a3800:	bf00      	nop
 80a3802:	bf00      	nop
 80a3804:	bf00      	nop
 80a3806:	bf00      	nop
 80a3808:	bf00      	nop
 80a380a:	bf00      	nop
 80a380c:	bf00      	nop
 80a380e:	bf00      	nop
 80a3810:	bf00      	nop
 80a3812:	bf00      	nop
 80a3814:	bf00      	nop
 80a3816:	bf00      	nop
 80a3818:	bf00      	nop
 80a381a:	bf00      	nop
 80a381c:	bf00      	nop
 80a381e:	bf00      	nop
 80a3820:	bf00      	nop
 80a3822:	bf00      	nop
 80a3824:	bf00      	nop
 80a3826:	bf00      	nop
 80a3828:	bf00      	nop
        mask >>= 1;
 80a382a:	9b04      	ldr	r3, [sp, #16]
 80a382c:	085b      	lsrs	r3, r3, #1
 80a382e:	9304      	str	r3, [sp, #16]
      } while ( ++j < 24 ); // ... pixel done
 80a3830:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a3834:	3301      	adds	r3, #1
 80a3836:	b2db      	uxtb	r3, r3
 80a3838:	2b17      	cmp	r3, #23
 80a383a:	f88d 3005 	strb.w	r3, [sp, #5]
 80a383e:	f200 80eb 	bhi.w	80a3a18 <_ZN17Adafruit_NeoPixel4showEv+0x1150>
        pinSet(pin, HIGH); // HIGH
 80a3842:	79e3      	ldrb	r3, [r4, #7]
 80a3844:	6810      	ldr	r0, [r2, #0]
 80a3846:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a384a:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a384e:	88bf      	ldrh	r7, [r7, #4]
 80a3850:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a3854:	831f      	strh	r7, [r3, #24]
        if (c & mask) { // if masked bit is high
 80a3856:	9803      	ldr	r0, [sp, #12]
 80a3858:	9b04      	ldr	r3, [sp, #16]
 80a385a:	4218      	tst	r0, r3
 80a385c:	f47f af12 	bne.w	80a3684 <_ZN17Adafruit_NeoPixel4showEv+0xdbc>
            ::: "r0", "cc", "memory");
 80a3860:	4600      	mov	r0, r0
 80a3862:	bf00      	nop
 80a3864:	bf00      	nop
 80a3866:	bf00      	nop
 80a3868:	bf00      	nop
 80a386a:	bf00      	nop
 80a386c:	bf00      	nop
 80a386e:	bf00      	nop
 80a3870:	bf00      	nop
 80a3872:	bf00      	nop
 80a3874:	bf00      	nop
 80a3876:	bf00      	nop
 80a3878:	bf00      	nop
 80a387a:	bf00      	nop
 80a387c:	bf00      	nop
 80a387e:	bf00      	nop
 80a3880:	bf00      	nop
 80a3882:	bf00      	nop
 80a3884:	bf00      	nop
 80a3886:	bf00      	nop
 80a3888:	bf00      	nop
 80a388a:	bf00      	nop
 80a388c:	bf00      	nop
 80a388e:	bf00      	nop
 80a3890:	bf00      	nop
 80a3892:	bf00      	nop
 80a3894:	bf00      	nop
 80a3896:	bf00      	nop
 80a3898:	bf00      	nop
 80a389a:	bf00      	nop
 80a389c:	bf00      	nop
 80a389e:	bf00      	nop
 80a38a0:	bf00      	nop
 80a38a2:	bf00      	nop
 80a38a4:	bf00      	nop
 80a38a6:	bf00      	nop
 80a38a8:	bf00      	nop
 80a38aa:	bf00      	nop
 80a38ac:	bf00      	nop
 80a38ae:	bf00      	nop
 80a38b0:	bf00      	nop
 80a38b2:	bf00      	nop
 80a38b4:	bf00      	nop
 80a38b6:	bf00      	nop
 80a38b8:	bf00      	nop
 80a38ba:	bf00      	nop
 80a38bc:	bf00      	nop
 80a38be:	bf00      	nop
 80a38c0:	bf00      	nop
 80a38c2:	bf00      	nop
 80a38c4:	bf00      	nop
 80a38c6:	bf00      	nop
 80a38c8:	bf00      	nop
 80a38ca:	bf00      	nop
 80a38cc:	bf00      	nop
 80a38ce:	bf00      	nop
 80a38d0:	bf00      	nop
 80a38d2:	bf00      	nop
 80a38d4:	bf00      	nop
 80a38d6:	bf00      	nop
 80a38d8:	bf00      	nop
 80a38da:	bf00      	nop
 80a38dc:	bf00      	nop
 80a38de:	bf00      	nop
 80a38e0:	bf00      	nop
          pinSet(pin, LOW); // LOW
 80a38e2:	79e3      	ldrb	r3, [r4, #7]
 80a38e4:	6810      	ldr	r0, [r2, #0]
 80a38e6:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a38ea:	eb00 0783 	add.w	r7, r0, r3, lsl #2
 80a38ee:	88bf      	ldrh	r7, [r7, #4]
 80a38f0:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
 80a38f4:	835f      	strh	r7, [r3, #26]
            ::: "r0", "cc", "memory");
 80a38f6:	4600      	mov	r0, r0
 80a38f8:	bf00      	nop
 80a38fa:	bf00      	nop
 80a38fc:	bf00      	nop
 80a38fe:	bf00      	nop
 80a3900:	bf00      	nop
 80a3902:	bf00      	nop
 80a3904:	bf00      	nop
 80a3906:	bf00      	nop
 80a3908:	bf00      	nop
 80a390a:	bf00      	nop
 80a390c:	bf00      	nop
 80a390e:	bf00      	nop
 80a3910:	bf00      	nop
 80a3912:	bf00      	nop
 80a3914:	bf00      	nop
 80a3916:	bf00      	nop
 80a3918:	bf00      	nop
 80a391a:	bf00      	nop
 80a391c:	bf00      	nop
 80a391e:	bf00      	nop
 80a3920:	bf00      	nop
 80a3922:	bf00      	nop
 80a3924:	bf00      	nop
 80a3926:	bf00      	nop
 80a3928:	bf00      	nop
 80a392a:	bf00      	nop
 80a392c:	bf00      	nop
 80a392e:	bf00      	nop
 80a3930:	bf00      	nop
 80a3932:	bf00      	nop
 80a3934:	bf00      	nop
 80a3936:	bf00      	nop
 80a3938:	bf00      	nop
 80a393a:	bf00      	nop
 80a393c:	bf00      	nop
 80a393e:	bf00      	nop
 80a3940:	bf00      	nop
 80a3942:	bf00      	nop
 80a3944:	bf00      	nop
 80a3946:	bf00      	nop
 80a3948:	bf00      	nop
 80a394a:	bf00      	nop
 80a394c:	bf00      	nop
 80a394e:	bf00      	nop
 80a3950:	bf00      	nop
 80a3952:	bf00      	nop
 80a3954:	bf00      	nop
 80a3956:	bf00      	nop
 80a3958:	bf00      	nop
 80a395a:	bf00      	nop
 80a395c:	bf00      	nop
 80a395e:	bf00      	nop
 80a3960:	bf00      	nop
 80a3962:	bf00      	nop
 80a3964:	bf00      	nop
 80a3966:	bf00      	nop
 80a3968:	bf00      	nop
 80a396a:	bf00      	nop
 80a396c:	bf00      	nop
 80a396e:	bf00      	nop
 80a3970:	bf00      	nop
 80a3972:	bf00      	nop
 80a3974:	bf00      	nop
 80a3976:	bf00      	nop
 80a3978:	bf00      	nop
 80a397a:	bf00      	nop
 80a397c:	bf00      	nop
 80a397e:	bf00      	nop
 80a3980:	bf00      	nop
 80a3982:	bf00      	nop
 80a3984:	bf00      	nop
 80a3986:	bf00      	nop
 80a3988:	bf00      	nop
 80a398a:	bf00      	nop
 80a398c:	bf00      	nop
 80a398e:	bf00      	nop
 80a3990:	bf00      	nop
 80a3992:	bf00      	nop
 80a3994:	bf00      	nop
 80a3996:	bf00      	nop
 80a3998:	bf00      	nop
 80a399a:	bf00      	nop
 80a399c:	bf00      	nop
 80a399e:	bf00      	nop
 80a39a0:	bf00      	nop
 80a39a2:	bf00      	nop
 80a39a4:	bf00      	nop
 80a39a6:	bf00      	nop
 80a39a8:	bf00      	nop
 80a39aa:	bf00      	nop
 80a39ac:	bf00      	nop
 80a39ae:	bf00      	nop
 80a39b0:	bf00      	nop
 80a39b2:	bf00      	nop
 80a39b4:	bf00      	nop
 80a39b6:	bf00      	nop
 80a39b8:	bf00      	nop
 80a39ba:	bf00      	nop
 80a39bc:	bf00      	nop
 80a39be:	bf00      	nop
 80a39c0:	bf00      	nop
 80a39c2:	bf00      	nop
 80a39c4:	bf00      	nop
 80a39c6:	bf00      	nop
 80a39c8:	bf00      	nop
 80a39ca:	bf00      	nop
 80a39cc:	bf00      	nop
 80a39ce:	bf00      	nop
 80a39d0:	bf00      	nop
 80a39d2:	bf00      	nop
 80a39d4:	bf00      	nop
 80a39d6:	bf00      	nop
 80a39d8:	bf00      	nop
 80a39da:	bf00      	nop
 80a39dc:	bf00      	nop
 80a39de:	bf00      	nop
 80a39e0:	bf00      	nop
 80a39e2:	bf00      	nop
 80a39e4:	bf00      	nop
 80a39e6:	bf00      	nop
 80a39e8:	bf00      	nop
 80a39ea:	bf00      	nop
 80a39ec:	bf00      	nop
 80a39ee:	bf00      	nop
 80a39f0:	bf00      	nop
 80a39f2:	bf00      	nop
 80a39f4:	bf00      	nop
 80a39f6:	bf00      	nop
 80a39f8:	bf00      	nop
 80a39fa:	bf00      	nop
 80a39fc:	bf00      	nop
 80a39fe:	bf00      	nop
 80a3a00:	bf00      	nop
 80a3a02:	bf00      	nop
 80a3a04:	bf00      	nop
 80a3a06:	e710      	b.n	80a382a <_ZN17Adafruit_NeoPixel4showEv+0xf62>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a3a08:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a3a0c:	b29b      	uxth	r3, r3
 80a3a0e:	2b00      	cmp	r3, #0
 80a3a10:	f47e af92 	bne.w	80a2938 <_ZN17Adafruit_NeoPixel4showEv+0x70>
 80a3a14:	f7ff bb1f 	b.w	80a3056 <_ZN17Adafruit_NeoPixel4showEv+0x78e>
    while(i) { // While bytes left... (3 bytes = 1 pixel)
 80a3a18:	f8bd 300a 	ldrh.w	r3, [sp, #10]
 80a3a1c:	b29b      	uxth	r3, r3
 80a3a1e:	2b00      	cmp	r3, #0
 80a3a20:	f47f ae08 	bne.w	80a3634 <_ZN17Adafruit_NeoPixel4showEv+0xd6c>
 80a3a24:	f7ff bb17 	b.w	80a3056 <_ZN17Adafruit_NeoPixel4showEv+0x78e>

080a3a28 <_ZN17Adafruit_NeoPixel13setPixelColorEthhh>:

// Set pixel color from separate R,G,B components:
void Adafruit_NeoPixel::setPixelColor(
  uint16_t n, uint8_t r, uint8_t g, uint8_t b) {
 80a3a28:	b570      	push	{r4, r5, r6, lr}
  if(n < numLEDs) {
 80a3a2a:	8844      	ldrh	r4, [r0, #2]
  uint16_t n, uint8_t r, uint8_t g, uint8_t b) {
 80a3a2c:	f89d 5010 	ldrb.w	r5, [sp, #16]
  if(n < numLEDs) {
 80a3a30:	428c      	cmp	r4, r1
 80a3a32:	d918      	bls.n	80a3a66 <_ZN17Adafruit_NeoPixel13setPixelColorEthhh+0x3e>
    if(brightness) { // See notes in setBrightness()
 80a3a34:	7a04      	ldrb	r4, [r0, #8]
 80a3a36:	b12c      	cbz	r4, 80a3a44 <_ZN17Adafruit_NeoPixel13setPixelColorEthhh+0x1c>
      r = (r * brightness) >> 8;
 80a3a38:	4362      	muls	r2, r4
      g = (g * brightness) >> 8;
 80a3a3a:	4363      	muls	r3, r4
      b = (b * brightness) >> 8;
 80a3a3c:	436c      	muls	r4, r5
      r = (r * brightness) >> 8;
 80a3a3e:	0a12      	lsrs	r2, r2, #8
      g = (g * brightness) >> 8;
 80a3a40:	0a1b      	lsrs	r3, r3, #8
      b = (b * brightness) >> 8;
 80a3a42:	0a25      	lsrs	r5, r4, #8
    }
    uint8_t *p = &pixels[n * 3];
 80a3a44:	68c6      	ldr	r6, [r0, #12]
 80a3a46:	7980      	ldrb	r0, [r0, #6]
 80a3a48:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 80a3a4c:	3802      	subs	r0, #2
 80a3a4e:	1874      	adds	r4, r6, r1
    switch(type) {
 80a3a50:	2806      	cmp	r0, #6
 80a3a52:	d810      	bhi.n	80a3a76 <_ZN17Adafruit_NeoPixel13setPixelColorEthhh+0x4e>
 80a3a54:	e8df f000 	tbb	[pc, r0]
 80a3a58:	04080f04 	.word	0x04080f04
 80a3a5c:	040f      	.short	0x040f
 80a3a5e:	04          	.byte	0x04
 80a3a5f:	00          	.byte	0x00
      case WS2812B: // WS2812, WS2812B & WS2813 is GRB order.
      case WS2812B_FAST:
      case WS2812B2:
      case WS2812B2_FAST: {
          *p++ = g;
 80a3a60:	5473      	strb	r3, [r6, r1]
          *p++ = r;
 80a3a62:	7062      	strb	r2, [r4, #1]
          *p = b;
 80a3a64:	70a5      	strb	r5, [r4, #2]
          *p++ = g;
          *p = b;
        } break;
    }
  }
}
 80a3a66:	bd70      	pop	{r4, r5, r6, pc}
          *p++ = r;
 80a3a68:	2afe      	cmp	r2, #254	; 0xfe
 80a3a6a:	bf28      	it	cs
 80a3a6c:	22fe      	movcs	r2, #254	; 0xfe
 80a3a6e:	5472      	strb	r2, [r6, r1]
          *p++ = b;
 80a3a70:	7065      	strb	r5, [r4, #1]
          *p = g;
 80a3a72:	70a3      	strb	r3, [r4, #2]
        } break;
 80a3a74:	e7f7      	b.n	80a3a66 <_ZN17Adafruit_NeoPixel13setPixelColorEthhh+0x3e>
          *p++ = r;
 80a3a76:	5472      	strb	r2, [r6, r1]
          *p++ = g;
 80a3a78:	7063      	strb	r3, [r4, #1]
          *p = b;
 80a3a7a:	70a5      	strb	r5, [r4, #2]
}
 80a3a7c:	e7f3      	b.n	80a3a66 <_ZN17Adafruit_NeoPixel13setPixelColorEthhh+0x3e>

080a3a7e <_ZN17Adafruit_NeoPixel13setBrightnessEh>:
  // 8x8-bit multiply and taking the MSB.  'brightness' is a uint8_t,
  // adding 1 here may (intentionally) roll over...so 0 = max brightness
  // (color values are interpreted literally; no scaling), 1 = min
  // brightness (off), 255 = just below max brightness.
  uint8_t newBrightness = b + 1;
  if(newBrightness != brightness) { // Compare against prior value
 80a3a7e:	7a03      	ldrb	r3, [r0, #8]
  uint8_t newBrightness = b + 1;
 80a3a80:	1c4a      	adds	r2, r1, #1
 80a3a82:	b2d2      	uxtb	r2, r2
  if(newBrightness != brightness) { // Compare against prior value
 80a3a84:	4293      	cmp	r3, r2
void Adafruit_NeoPixel::setBrightness(uint8_t b) {
 80a3a86:	b570      	push	{r4, r5, r6, lr}
  if(newBrightness != brightness) { // Compare against prior value
 80a3a88:	d01e      	beq.n	80a3ac8 <_ZN17Adafruit_NeoPixel13setBrightnessEh+0x4a>
    // Brightness has changed -- re-scale existing data in RAM
    uint8_t  c,
            *ptr           = pixels,
             oldBrightness = brightness - 1; // De-wrap old brightness value
 80a3a8a:	3b01      	subs	r3, #1
    uint16_t scale;
    if(oldBrightness == 0) scale = 0; // Avoid /0
 80a3a8c:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
            *ptr           = pixels,
 80a3a90:	68c4      	ldr	r4, [r0, #12]
    if(oldBrightness == 0) scale = 0; // Avoid /0
 80a3a92:	d00c      	beq.n	80a3aae <_ZN17Adafruit_NeoPixel13setBrightnessEh+0x30>
    else if(b == 255) scale = 65535 / oldBrightness;
 80a3a94:	29ff      	cmp	r1, #255	; 0xff
 80a3a96:	bf0f      	iteee	eq
 80a3a98:	f64f 71ff 	movweq	r1, #65535	; 0xffff
    else scale = (((uint16_t)newBrightness << 8) - 1) / oldBrightness;
 80a3a9c:	0211      	lslne	r1, r2, #8
 80a3a9e:	f101 31ff 	addne.w	r1, r1, #4294967295	; 0xffffffff
 80a3aa2:	fbb1 f3f3 	udivne	r3, r1, r3
    else if(b == 255) scale = 65535 / oldBrightness;
 80a3aa6:	bf0c      	ite	eq
 80a3aa8:	fbb1 f3f3 	udiveq	r3, r1, r3
    else scale = (((uint16_t)newBrightness << 8) - 1) / oldBrightness;
 80a3aac:	b29b      	uxthne	r3, r3
            *ptr           = pixels,
 80a3aae:	4625      	mov	r5, r4
    for(uint16_t i=0; i<numBytes; i++) {
 80a3ab0:	8886      	ldrh	r6, [r0, #4]
 80a3ab2:	1b29      	subs	r1, r5, r4
 80a3ab4:	b289      	uxth	r1, r1
 80a3ab6:	428e      	cmp	r6, r1
 80a3ab8:	d905      	bls.n	80a3ac6 <_ZN17Adafruit_NeoPixel13setBrightnessEh+0x48>
      c      = *ptr;
      *ptr++ = (c * scale) >> 8;
 80a3aba:	7829      	ldrb	r1, [r5, #0]
 80a3abc:	4359      	muls	r1, r3
 80a3abe:	1209      	asrs	r1, r1, #8
 80a3ac0:	f805 1b01 	strb.w	r1, [r5], #1
    for(uint16_t i=0; i<numBytes; i++) {
 80a3ac4:	e7f4      	b.n	80a3ab0 <_ZN17Adafruit_NeoPixel13setBrightnessEh+0x32>
    }
    brightness = newBrightness;
 80a3ac6:	7202      	strb	r2, [r0, #8]
  }
}
 80a3ac8:	bd70      	pop	{r4, r5, r6, pc}
	...

080a3acc <_GLOBAL__sub_I_PIN_MAP2>:
  return brightness - 1;
}

void Adafruit_NeoPixel::clear(void) {
  memset(pixels, 0, numBytes);
}
 80a3acc:	b508      	push	{r3, lr}
  STM32_Pin_Info* PIN_MAP2 = HAL_Pin_Map(); // Pointer required for highest access speed
 80a3ace:	f001 fe9f 	bl	80a5810 <HAL_Pin_Map>
 80a3ad2:	4b01      	ldr	r3, [pc, #4]	; (80a3ad8 <_GLOBAL__sub_I_PIN_MAP2+0xc>)
 80a3ad4:	6018      	str	r0, [r3, #0]
}
 80a3ad6:	bd08      	pop	{r3, pc}
 80a3ad8:	20000d90 	.word	0x20000d90

080a3adc <_ZN7MFRC522C1Ehh>:

/**
 * Constructor.
 * Prepares the output pins.
 */
MFRC522::MFRC522(	byte chipSelectPin,		///< Arduino pin connected to MFRC522's SPI slave select input (Pin 24, NSS, active low)
 80a3adc:	b538      	push	{r3, r4, r5, lr}
 80a3ade:	4604      	mov	r4, r0
 80a3ae0:	4615      	mov	r5, r2
 80a3ae2:	4608      	mov	r0, r1
					byte resetPowerDownPin	///< Arduino pin connected to MFRC522's reset and power down input (Pin 6, NRSTPD, active low)
				) {
	// Set the chipSelectPin as digital output, do not select the slave yet
	_chipSelectPin = chipSelectPin;
 80a3ae4:	7321      	strb	r1, [r4, #12]
	pinMode(_chipSelectPin, OUTPUT);
 80a3ae6:	2101      	movs	r1, #1
 80a3ae8:	f003 fd56 	bl	80a7598 <pinMode>
	digitalWrite(_chipSelectPin, HIGH);
 80a3aec:	7b20      	ldrb	r0, [r4, #12]
 80a3aee:	2101      	movs	r1, #1
 80a3af0:	f003 fd63 	bl	80a75ba <digitalWrite>
	
	// Set the resetPowerDownPin as digital output, do not reset or power down.
	_resetPowerDownPin = resetPowerDownPin;
	pinMode(_resetPowerDownPin, OUTPUT);
 80a3af4:	4628      	mov	r0, r5
 80a3af6:	2101      	movs	r1, #1
	_resetPowerDownPin = resetPowerDownPin;
 80a3af8:	7365      	strb	r5, [r4, #13]
	pinMode(_resetPowerDownPin, OUTPUT);
 80a3afa:	f003 fd4d 	bl	80a7598 <pinMode>
	digitalWrite(_resetPowerDownPin, LOW);
 80a3afe:	7b60      	ldrb	r0, [r4, #13]
 80a3b00:	2100      	movs	r1, #0
 80a3b02:	f003 fd5a 	bl	80a75ba <digitalWrite>
	
	// Set SPI bus to work with MFRC522 chip.
	//setSPIConfig();
} // End constructor
 80a3b06:	4620      	mov	r0, r4
 80a3b08:	bd38      	pop	{r3, r4, r5, pc}

080a3b0a <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8transferEh.isra.0>:
    byte transfer(byte data) {
 80a3b0a:	b510      	push	{r4, lr}
 80a3b0c:	4604      	mov	r4, r0
        return instance().transfer(data);
 80a3b0e:	f7fe fa35 	bl	80a1f7c <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8instanceEv>
 80a3b12:	4621      	mov	r1, r4
    }
 80a3b14:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        return instance().transfer(data);
 80a3b18:	f002 b99a 	b.w	80a5e50 <_ZN8SPIClass8transferEh>

080a3b1c <_ZN7MFRC52217PCD_WriteRegisterEhh>:
 * Writes a byte to the specified register in the MFRC522 chip.
 * The interface is described in the datasheet section 8.1.2.
 */
void MFRC522::PCD_WriteRegister(	byte reg,		///< The register to write to. One of the PCD_Register enums.
									byte value		///< The value to write.
								) {
 80a3b1c:	b570      	push	{r4, r5, r6, lr}
 80a3b1e:	460e      	mov	r6, r1
 80a3b20:	4615      	mov	r5, r2
 80a3b22:	4604      	mov	r4, r0
	digitalWrite(_chipSelectPin, LOW);		// Select slave
 80a3b24:	2100      	movs	r1, #0
 80a3b26:	7b00      	ldrb	r0, [r0, #12]
 80a3b28:	f003 fd47 	bl	80a75ba <digitalWrite>
	SPI.transfer(reg & 0x7E);					// MSB == 0 is for writing. LSB is not used in address. Datasheet section 8.1.2.3.
 80a3b2c:	f006 007e 	and.w	r0, r6, #126	; 0x7e
 80a3b30:	f7ff ffeb 	bl	80a3b0a <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8transferEh.isra.0>
	SPI.transfer(value);
 80a3b34:	4628      	mov	r0, r5
 80a3b36:	f7ff ffe8 	bl	80a3b0a <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8transferEh.isra.0>
	digitalWrite(_chipSelectPin, HIGH);		// Release slave again
 80a3b3a:	7b20      	ldrb	r0, [r4, #12]
 80a3b3c:	2101      	movs	r1, #1
} // End PCD_WriteRegister()
 80a3b3e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	digitalWrite(_chipSelectPin, HIGH);		// Release slave again
 80a3b42:	f003 bd3a 	b.w	80a75ba <digitalWrite>

080a3b46 <_ZN7MFRC52217PCD_WriteRegisterEhhPh>:
 * The interface is described in the datasheet section 8.1.2.
 */
void MFRC522::PCD_WriteRegister(	byte reg,		///< The register to write to. One of the PCD_Register enums.
									byte count,		///< The number of bytes to write to the register
									byte *values	///< The values to write. Byte array.
								) {
 80a3b46:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a3b48:	460f      	mov	r7, r1
 80a3b4a:	4606      	mov	r6, r0
	digitalWrite(_chipSelectPin, LOW);		// Select slave
 80a3b4c:	2100      	movs	r1, #0
 80a3b4e:	7b00      	ldrb	r0, [r0, #12]
								) {
 80a3b50:	4615      	mov	r5, r2
 80a3b52:	461c      	mov	r4, r3
	digitalWrite(_chipSelectPin, LOW);		// Select slave
 80a3b54:	f003 fd31 	bl	80a75ba <digitalWrite>
	SPI.transfer(reg & 0x7E);				// MSB == 0 is for writing. LSB is not used in address. Datasheet section 8.1.2.3.
 80a3b58:	f007 007e 	and.w	r0, r7, #126	; 0x7e
 80a3b5c:	f7ff ffd5 	bl	80a3b0a <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8transferEh.isra.0>
	for (byte index = 0; index < count; index++) {
 80a3b60:	4425      	add	r5, r4
 80a3b62:	42ac      	cmp	r4, r5
 80a3b64:	d004      	beq.n	80a3b70 <_ZN7MFRC52217PCD_WriteRegisterEhhPh+0x2a>
		SPI.transfer(values[index]);
 80a3b66:	f814 0b01 	ldrb.w	r0, [r4], #1
 80a3b6a:	f7ff ffce 	bl	80a3b0a <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8transferEh.isra.0>
	for (byte index = 0; index < count; index++) {
 80a3b6e:	e7f8      	b.n	80a3b62 <_ZN7MFRC52217PCD_WriteRegisterEhhPh+0x1c>
	}
	digitalWrite(_chipSelectPin, HIGH);		// Release slave again
 80a3b70:	7b30      	ldrb	r0, [r6, #12]
 80a3b72:	2101      	movs	r1, #1
} // End PCD_WriteRegister()
 80a3b74:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	digitalWrite(_chipSelectPin, HIGH);		// Release slave again
 80a3b78:	f003 bd1f 	b.w	80a75ba <digitalWrite>

080a3b7c <_ZN7MFRC52216PCD_ReadRegisterEh>:
/**
 * Reads a byte from the specified register in the MFRC522 chip.
 * The interface is described in the datasheet section 8.1.2.
 */
byte MFRC522::PCD_ReadRegister(	byte reg	///< The register to read from. One of the PCD_Register enums.
								) {
 80a3b7c:	b538      	push	{r3, r4, r5, lr}
 80a3b7e:	460c      	mov	r4, r1
 80a3b80:	4605      	mov	r5, r0
	byte value;
	digitalWrite(_chipSelectPin, LOW);			// Select slave
 80a3b82:	2100      	movs	r1, #0
 80a3b84:	7b00      	ldrb	r0, [r0, #12]
	SPI.transfer(0x80 | (reg & 0x7E));			// MSB == 1 is for reading. LSB is not used in address. Datasheet section 8.1.2.3.
 80a3b86:	f004 047e 	and.w	r4, r4, #126	; 0x7e
	digitalWrite(_chipSelectPin, LOW);			// Select slave
 80a3b8a:	f003 fd16 	bl	80a75ba <digitalWrite>
	SPI.transfer(0x80 | (reg & 0x7E));			// MSB == 1 is for reading. LSB is not used in address. Datasheet section 8.1.2.3.
 80a3b8e:	f044 0080 	orr.w	r0, r4, #128	; 0x80
 80a3b92:	f7ff ffba 	bl	80a3b0a <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8transferEh.isra.0>
	value = SPI.transfer(0);					// Read the value back. Send 0 to stop reading.
 80a3b96:	2000      	movs	r0, #0
 80a3b98:	f7ff ffb7 	bl	80a3b0a <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8transferEh.isra.0>
 80a3b9c:	4604      	mov	r4, r0
	digitalWrite(_chipSelectPin, HIGH);			// Release slave again
 80a3b9e:	2101      	movs	r1, #1
 80a3ba0:	7b28      	ldrb	r0, [r5, #12]
 80a3ba2:	f003 fd0a 	bl	80a75ba <digitalWrite>
	return value;
} // End PCD_ReadRegister()
 80a3ba6:	4620      	mov	r0, r4
 80a3ba8:	bd38      	pop	{r3, r4, r5, pc}

080a3baa <_ZN7MFRC52222PCD_SetRegisterBitMaskEhh>:
/**
 * Sets the bits given in mask in register reg.
 */
void MFRC522::PCD_SetRegisterBitMask(	byte reg,	///< The register to update. One of the PCD_Register enums.
										byte mask	///< The bits to set.
									) { 
 80a3baa:	b570      	push	{r4, r5, r6, lr}
 80a3bac:	4604      	mov	r4, r0
 80a3bae:	460d      	mov	r5, r1
 80a3bb0:	4616      	mov	r6, r2
	byte tmp;
	tmp = PCD_ReadRegister(reg);
 80a3bb2:	f7ff ffe3 	bl	80a3b7c <_ZN7MFRC52216PCD_ReadRegisterEh>
	PCD_WriteRegister(reg, tmp | mask);			// set bit mask
 80a3bb6:	ea40 0206 	orr.w	r2, r0, r6
 80a3bba:	4629      	mov	r1, r5
 80a3bbc:	4620      	mov	r0, r4
} // End PCD_SetRegisterBitMask()
 80a3bbe:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	PCD_WriteRegister(reg, tmp | mask);			// set bit mask
 80a3bc2:	b2d2      	uxtb	r2, r2
 80a3bc4:	f7ff bfaa 	b.w	80a3b1c <_ZN7MFRC52217PCD_WriteRegisterEhh>

080a3bc8 <_ZN7MFRC52224PCD_ClearRegisterBitMaskEhh>:
/**
 * Clears the bits given in mask from register reg.
 */
void MFRC522::PCD_ClearRegisterBitMask(	byte reg,	///< The register to update. One of the PCD_Register enums.
										byte mask	///< The bits to clear.
									  ) {
 80a3bc8:	b570      	push	{r4, r5, r6, lr}
 80a3bca:	4604      	mov	r4, r0
 80a3bcc:	460d      	mov	r5, r1
 80a3bce:	4616      	mov	r6, r2
	byte tmp;
	tmp = PCD_ReadRegister(reg);
 80a3bd0:	f7ff ffd4 	bl	80a3b7c <_ZN7MFRC52216PCD_ReadRegisterEh>
	PCD_WriteRegister(reg, tmp & (~mask));		// clear bit mask
 80a3bd4:	ea20 0206 	bic.w	r2, r0, r6
 80a3bd8:	4629      	mov	r1, r5
 80a3bda:	4620      	mov	r0, r4
} // End PCD_ClearRegisterBitMask()
 80a3bdc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	PCD_WriteRegister(reg, tmp & (~mask));		// clear bit mask
 80a3be0:	b2d2      	uxtb	r2, r2
 80a3be2:	f7ff bf9b 	b.w	80a3b1c <_ZN7MFRC52217PCD_WriteRegisterEhh>

080a3be6 <_ZN7MFRC52215PCD_StopCrypto1Ev>:
 * Used to exit the PCD from its authenticated state.
 * Remember to call this function after communicating with an authenticated PICC - otherwise no new communications can start.
 */
void MFRC522::PCD_StopCrypto1() {
	// Clear MFCrypto1On bit
	PCD_ClearRegisterBitMask(Status2Reg, 0x08); // Status2Reg[7..0] bits are: TempSensClear I2CForceHS reserved reserved   MFCrypto1On ModemState[2:0]
 80a3be6:	2208      	movs	r2, #8
 80a3be8:	2110      	movs	r1, #16
 80a3bea:	f7ff bfed 	b.w	80a3bc8 <_ZN7MFRC52224PCD_ClearRegisterBitMaskEhh>

080a3bee <_ZN7MFRC52216PCD_CalculateCRCEPhhS0_>:
					 ) {
 80a3bee:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a3bf0:	4604      	mov	r4, r0
 80a3bf2:	4615      	mov	r5, r2
 80a3bf4:	460f      	mov	r7, r1
	PCD_WriteRegister(CommandReg, PCD_Idle);			// Stop any active command.
 80a3bf6:	2200      	movs	r2, #0
 80a3bf8:	2102      	movs	r1, #2
					 ) {
 80a3bfa:	461e      	mov	r6, r3
	PCD_WriteRegister(CommandReg, PCD_Idle);			// Stop any active command.
 80a3bfc:	f7ff ff8e 	bl	80a3b1c <_ZN7MFRC52217PCD_WriteRegisterEhh>
	PCD_WriteRegister(DivIrqReg, 0x04);					// Clear the CRCIRq interrupt request bit
 80a3c00:	2204      	movs	r2, #4
 80a3c02:	210a      	movs	r1, #10
 80a3c04:	4620      	mov	r0, r4
 80a3c06:	f7ff ff89 	bl	80a3b1c <_ZN7MFRC52217PCD_WriteRegisterEhh>
	PCD_SetRegisterBitMask(FIFOLevelReg, 0x80);		// FlushBuffer = 1, FIFO initialization
 80a3c0a:	2280      	movs	r2, #128	; 0x80
 80a3c0c:	2114      	movs	r1, #20
 80a3c0e:	4620      	mov	r0, r4
 80a3c10:	f7ff ffcb 	bl	80a3baa <_ZN7MFRC52222PCD_SetRegisterBitMaskEhh>
	PCD_WriteRegister(FIFODataReg, length, data);		// Write data to the FIFO
 80a3c14:	462a      	mov	r2, r5
 80a3c16:	463b      	mov	r3, r7
 80a3c18:	2112      	movs	r1, #18
 80a3c1a:	4620      	mov	r0, r4
 80a3c1c:	f7ff ff93 	bl	80a3b46 <_ZN7MFRC52217PCD_WriteRegisterEhhPh>
	PCD_WriteRegister(CommandReg, PCD_CalcCRC);		// Start the calculation
 80a3c20:	2203      	movs	r2, #3
 80a3c22:	2102      	movs	r1, #2
 80a3c24:	4620      	mov	r0, r4
 80a3c26:	f7ff ff79 	bl	80a3b1c <_ZN7MFRC52217PCD_WriteRegisterEhh>
 80a3c2a:	f241 3588 	movw	r5, #5000	; 0x1388
		n = PCD_ReadRegister(DivIrqReg);	// DivIrqReg[7..0] bits are: Set2 reserved reserved MfinActIRq   reserved CRCIRq reserved reserved
 80a3c2e:	210a      	movs	r1, #10
 80a3c30:	4620      	mov	r0, r4
 80a3c32:	f7ff ffa3 	bl	80a3b7c <_ZN7MFRC52216PCD_ReadRegisterEh>
		if (n & 0x04) {						// CRCIRq bit set - calculation done
 80a3c36:	0743      	lsls	r3, r0, #29
 80a3c38:	d405      	bmi.n	80a3c46 <_ZN7MFRC52216PCD_CalculateCRCEPhhS0_+0x58>
		if (--i == 0) {						// The emergency break. We will eventually terminate on this one after 89ms. Communication with the MFRC522 might be down.
 80a3c3a:	3d01      	subs	r5, #1
 80a3c3c:	b2ad      	uxth	r5, r5
 80a3c3e:	2d00      	cmp	r5, #0
 80a3c40:	d1f5      	bne.n	80a3c2e <_ZN7MFRC52216PCD_CalculateCRCEPhhS0_+0x40>
			return STATUS_TIMEOUT;
 80a3c42:	2004      	movs	r0, #4
 80a3c44:	e00f      	b.n	80a3c66 <_ZN7MFRC52216PCD_CalculateCRCEPhhS0_+0x78>
	PCD_WriteRegister(CommandReg, PCD_Idle);			// Stop calculating CRC for new content in the FIFO.
 80a3c46:	2200      	movs	r2, #0
 80a3c48:	2102      	movs	r1, #2
 80a3c4a:	4620      	mov	r0, r4
 80a3c4c:	f7ff ff66 	bl	80a3b1c <_ZN7MFRC52217PCD_WriteRegisterEhh>
	result[0] = PCD_ReadRegister(CRCResultRegL);
 80a3c50:	2144      	movs	r1, #68	; 0x44
 80a3c52:	4620      	mov	r0, r4
 80a3c54:	f7ff ff92 	bl	80a3b7c <_ZN7MFRC52216PCD_ReadRegisterEh>
	result[1] = PCD_ReadRegister(CRCResultRegH);
 80a3c58:	2142      	movs	r1, #66	; 0x42
	result[0] = PCD_ReadRegister(CRCResultRegL);
 80a3c5a:	7030      	strb	r0, [r6, #0]
	result[1] = PCD_ReadRegister(CRCResultRegH);
 80a3c5c:	4620      	mov	r0, r4
 80a3c5e:	f7ff ff8d 	bl	80a3b7c <_ZN7MFRC52216PCD_ReadRegisterEh>
 80a3c62:	7070      	strb	r0, [r6, #1]
	return STATUS_OK;
 80a3c64:	2001      	movs	r0, #1
} // End PCD_CalculateCRC()
 80a3c66:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a3c68 <_ZN7MFRC5229PCD_ResetEv>:
void MFRC522::PCD_Reset() {
 80a3c68:	b510      	push	{r4, lr}
	PCD_WriteRegister(CommandReg, PCD_SoftReset);	// Issue the SoftReset command.
 80a3c6a:	220f      	movs	r2, #15
 80a3c6c:	2102      	movs	r1, #2
void MFRC522::PCD_Reset() {
 80a3c6e:	4604      	mov	r4, r0
	PCD_WriteRegister(CommandReg, PCD_SoftReset);	// Issue the SoftReset command.
 80a3c70:	f7ff ff54 	bl	80a3b1c <_ZN7MFRC52217PCD_WriteRegisterEhh>
	delay(50);
 80a3c74:	2032      	movs	r0, #50	; 0x32
 80a3c76:	f002 fe49 	bl	80a690c <delay>
	while (PCD_ReadRegister(CommandReg) & (1<<4)) {
 80a3c7a:	2102      	movs	r1, #2
 80a3c7c:	4620      	mov	r0, r4
 80a3c7e:	f7ff ff7d 	bl	80a3b7c <_ZN7MFRC52216PCD_ReadRegisterEh>
 80a3c82:	06c3      	lsls	r3, r0, #27
 80a3c84:	d4f9      	bmi.n	80a3c7a <_ZN7MFRC5229PCD_ResetEv+0x12>
} // End PCD_Reset()
 80a3c86:	bd10      	pop	{r4, pc}

080a3c88 <_ZN7MFRC52213PCD_AntennaOnEv>:
void MFRC522::PCD_AntennaOn() {
 80a3c88:	b510      	push	{r4, lr}
	byte value = PCD_ReadRegister(TxControlReg);
 80a3c8a:	2128      	movs	r1, #40	; 0x28
void MFRC522::PCD_AntennaOn() {
 80a3c8c:	4604      	mov	r4, r0
	byte value = PCD_ReadRegister(TxControlReg);
 80a3c8e:	f7ff ff75 	bl	80a3b7c <_ZN7MFRC52216PCD_ReadRegisterEh>
	if ((value & 0x03) != 0x03) {
 80a3c92:	f000 0303 	and.w	r3, r0, #3
 80a3c96:	2b03      	cmp	r3, #3
 80a3c98:	d008      	beq.n	80a3cac <_ZN7MFRC52213PCD_AntennaOnEv+0x24>
		PCD_WriteRegister(TxControlReg, value | 0x03);
 80a3c9a:	f040 0203 	orr.w	r2, r0, #3
 80a3c9e:	2128      	movs	r1, #40	; 0x28
 80a3ca0:	4620      	mov	r0, r4
} // End PCD_AntennaOn()
 80a3ca2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		PCD_WriteRegister(TxControlReg, value | 0x03);
 80a3ca6:	b2d2      	uxtb	r2, r2
 80a3ca8:	f7ff bf38 	b.w	80a3b1c <_ZN7MFRC52217PCD_WriteRegisterEhh>
} // End PCD_AntennaOn()
 80a3cac:	bd10      	pop	{r4, pc}

080a3cae <_ZN7MFRC5228PCD_InitEv>:
void MFRC522::PCD_Init() {
 80a3cae:	b510      	push	{r4, lr}
 80a3cb0:	4604      	mov	r4, r0
	if (digitalRead(_resetPowerDownPin) == LOW) { //The MFRC522 chip is in power down mode.
 80a3cb2:	7b40      	ldrb	r0, [r0, #13]
 80a3cb4:	f003 fc9a 	bl	80a75ec <digitalRead>
 80a3cb8:	bb48      	cbnz	r0, 80a3d0e <_ZN7MFRC5228PCD_InitEv+0x60>
		digitalWrite(_resetPowerDownPin, HIGH);	// Exit power down mode. This triggers a hard reset.
 80a3cba:	7b60      	ldrb	r0, [r4, #13]
 80a3cbc:	2101      	movs	r1, #1
 80a3cbe:	f003 fc7c 	bl	80a75ba <digitalWrite>
		delay(50);
 80a3cc2:	2032      	movs	r0, #50	; 0x32
 80a3cc4:	f002 fe22 	bl	80a690c <delay>
    PCD_WriteRegister(TModeReg, 0x80);			// TAuto=1; timer starts automatically at the end of the transmission in all communication modes at all speeds
 80a3cc8:	4620      	mov	r0, r4
 80a3cca:	2280      	movs	r2, #128	; 0x80
 80a3ccc:	2154      	movs	r1, #84	; 0x54
 80a3cce:	f7ff ff25 	bl	80a3b1c <_ZN7MFRC52217PCD_WriteRegisterEhh>
    PCD_WriteRegister(TPrescalerReg, 0xA9);	// TPreScaler = TModeReg[3..0]:TPrescalerReg, ie 0x0A9 = 169 => f_timer=40kHz, ie a timer period of 25s.
 80a3cd2:	4620      	mov	r0, r4
 80a3cd4:	22a9      	movs	r2, #169	; 0xa9
 80a3cd6:	2156      	movs	r1, #86	; 0x56
 80a3cd8:	f7ff ff20 	bl	80a3b1c <_ZN7MFRC52217PCD_WriteRegisterEhh>
    PCD_WriteRegister(TReloadRegH, 0x03);		// Reload timer with 0x3E8 = 1000, ie 25ms before timeout.
 80a3cdc:	4620      	mov	r0, r4
 80a3cde:	2203      	movs	r2, #3
 80a3ce0:	2158      	movs	r1, #88	; 0x58
 80a3ce2:	f7ff ff1b 	bl	80a3b1c <_ZN7MFRC52217PCD_WriteRegisterEhh>
    PCD_WriteRegister(TReloadRegL, 0xE8);
 80a3ce6:	4620      	mov	r0, r4
 80a3ce8:	22e8      	movs	r2, #232	; 0xe8
 80a3cea:	215a      	movs	r1, #90	; 0x5a
 80a3cec:	f7ff ff16 	bl	80a3b1c <_ZN7MFRC52217PCD_WriteRegisterEhh>
	PCD_WriteRegister(TxASKReg, 0x40);		// Default 0x00. Force a 100 % ASK modulation independent of the ModGsPReg register setting
 80a3cf0:	4620      	mov	r0, r4
 80a3cf2:	2240      	movs	r2, #64	; 0x40
 80a3cf4:	212a      	movs	r1, #42	; 0x2a
 80a3cf6:	f7ff ff11 	bl	80a3b1c <_ZN7MFRC52217PCD_WriteRegisterEhh>
	PCD_WriteRegister(ModeReg, 0x3D);		// Default 0x3F. Set the preset value for the CRC coprocessor for the CalcCRC command to 0x6363 (ISO 14443-3 part 6.2.4)
 80a3cfa:	4620      	mov	r0, r4
 80a3cfc:	223d      	movs	r2, #61	; 0x3d
 80a3cfe:	2122      	movs	r1, #34	; 0x22
 80a3d00:	f7ff ff0c 	bl	80a3b1c <_ZN7MFRC52217PCD_WriteRegisterEhh>
	PCD_AntennaOn();						// Enable the antenna driver pins TX1 and TX2 (they were disabled by the reset)
 80a3d04:	4620      	mov	r0, r4
} // End PCD_Init()
 80a3d06:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	PCD_AntennaOn();						// Enable the antenna driver pins TX1 and TX2 (they were disabled by the reset)
 80a3d0a:	f7ff bfbd 	b.w	80a3c88 <_ZN7MFRC52213PCD_AntennaOnEv>
		PCD_Reset();
 80a3d0e:	4620      	mov	r0, r4
 80a3d10:	f7ff ffaa 	bl	80a3c68 <_ZN7MFRC5229PCD_ResetEv>
 80a3d14:	e7d8      	b.n	80a3cc8 <_ZN7MFRC5228PCD_InitEv+0x1a>

080a3d16 <_ZN7MFRC52216PCD_ReadRegisterEhhPhh>:
								) {
 80a3d16:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a3d1a:	4607      	mov	r7, r0
 80a3d1c:	461e      	mov	r6, r3
	if (count == 0) {
 80a3d1e:	4615      	mov	r5, r2
								) {
 80a3d20:	f89d 8030 	ldrb.w	r8, [sp, #48]	; 0x30
	if (count == 0) {
 80a3d24:	2a00      	cmp	r2, #0
 80a3d26:	d042      	beq.n	80a3dae <_ZN7MFRC52216PCD_ReadRegisterEhhPhh+0x98>
	byte address = 0x80 | (reg & 0x7E);		// MSB == 1 is for reading. LSB is not used in address. Datasheet section 8.1.2.3.
 80a3d28:	f001 017e 	and.w	r1, r1, #126	; 0x7e
	digitalWrite(_chipSelectPin, LOW);		// Select slave
 80a3d2c:	7b00      	ldrb	r0, [r0, #12]
	byte address = 0x80 | (reg & 0x7E);		// MSB == 1 is for reading. LSB is not used in address. Datasheet section 8.1.2.3.
 80a3d2e:	f041 0980 	orr.w	r9, r1, #128	; 0x80
	digitalWrite(_chipSelectPin, LOW);		// Select slave
 80a3d32:	2100      	movs	r1, #0
 80a3d34:	f003 fc41 	bl	80a75ba <digitalWrite>
	SPI.transfer(address);					// Tell MFRC522 which address we want to read
 80a3d38:	4648      	mov	r0, r9
 80a3d3a:	f7ff fee6 	bl	80a3b0a <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8transferEh.isra.0>
 80a3d3e:	f04f 0b00 	mov.w	fp, #0
				mask |= (1 << i);
 80a3d42:	f04f 0a01 	mov.w	sl, #1
	count--;								// One read is performed outside of the loop
 80a3d46:	3d01      	subs	r5, #1
 80a3d48:	b2ed      	uxtb	r5, r5
	while (index < count) {
 80a3d4a:	fa5f f48b 	uxtb.w	r4, fp
 80a3d4e:	42a5      	cmp	r5, r4
 80a3d50:	d922      	bls.n	80a3d98 <_ZN7MFRC52216PCD_ReadRegisterEhhPhh+0x82>
		if (index == 0 && rxAlign) { // Only update bit positions rxAlign..7 in values[0]
 80a3d52:	b9dc      	cbnz	r4, 80a3d8c <_ZN7MFRC52216PCD_ReadRegisterEhhPhh+0x76>
 80a3d54:	f1b8 0f00 	cmp.w	r8, #0
 80a3d58:	d018      	beq.n	80a3d8c <_ZN7MFRC52216PCD_ReadRegisterEhhPhh+0x76>
 80a3d5a:	4642      	mov	r2, r8
			for (byte i = rxAlign; i <= 7; i++) {
 80a3d5c:	b2d3      	uxtb	r3, r2
 80a3d5e:	2b07      	cmp	r3, #7
 80a3d60:	b261      	sxtb	r1, r4
 80a3d62:	d805      	bhi.n	80a3d70 <_ZN7MFRC52216PCD_ReadRegisterEhhPhh+0x5a>
				mask |= (1 << i);
 80a3d64:	fa0a f402 	lsl.w	r4, sl, r2
 80a3d68:	430c      	orrs	r4, r1
 80a3d6a:	b2e4      	uxtb	r4, r4
			for (byte i = rxAlign; i <= 7; i++) {
 80a3d6c:	3201      	adds	r2, #1
 80a3d6e:	e7f5      	b.n	80a3d5c <_ZN7MFRC52216PCD_ReadRegisterEhhPhh+0x46>
			byte value = SPI.transfer(address);	
 80a3d70:	4648      	mov	r0, r9
 80a3d72:	9101      	str	r1, [sp, #4]
 80a3d74:	f7ff fec9 	bl	80a3b0a <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8transferEh.isra.0>
			values[0] = (values[index] & ~mask) | (value & mask);
 80a3d78:	7833      	ldrb	r3, [r6, #0]
 80a3d7a:	9901      	ldr	r1, [sp, #4]
 80a3d7c:	4004      	ands	r4, r0
 80a3d7e:	ea23 0301 	bic.w	r3, r3, r1
 80a3d82:	431c      	orrs	r4, r3
 80a3d84:	7034      	strb	r4, [r6, #0]
		index++;
 80a3d86:	f10b 0b01 	add.w	fp, fp, #1
	while (index < count) {
 80a3d8a:	e7de      	b.n	80a3d4a <_ZN7MFRC52216PCD_ReadRegisterEhhPhh+0x34>
			values[index] = SPI.transfer(address);	// Read value and tell that we want to read the same address again.
 80a3d8c:	4648      	mov	r0, r9
 80a3d8e:	f7ff febc 	bl	80a3b0a <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8transferEh.isra.0>
 80a3d92:	f806 000b 	strb.w	r0, [r6, fp]
 80a3d96:	e7f6      	b.n	80a3d86 <_ZN7MFRC52216PCD_ReadRegisterEhhPhh+0x70>
	values[index] = SPI.transfer(0);			// Read the final byte. Send 0 to stop reading.
 80a3d98:	2000      	movs	r0, #0
 80a3d9a:	f7ff feb6 	bl	80a3b0a <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8transferEh.isra.0>
	digitalWrite(_chipSelectPin, HIGH);			// Release slave again
 80a3d9e:	2101      	movs	r1, #1
	values[index] = SPI.transfer(0);			// Read the final byte. Send 0 to stop reading.
 80a3da0:	5570      	strb	r0, [r6, r5]
	digitalWrite(_chipSelectPin, HIGH);			// Release slave again
 80a3da2:	7b38      	ldrb	r0, [r7, #12]
} // End PCD_ReadRegister()
 80a3da4:	b003      	add	sp, #12
 80a3da6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	digitalWrite(_chipSelectPin, HIGH);			// Release slave again
 80a3daa:	f003 bc06 	b.w	80a75ba <digitalWrite>
} // End PCD_ReadRegister()
 80a3dae:	b003      	add	sp, #12
 80a3db0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080a3db4 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb>:
									 ) {
 80a3db4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a3db8:	b089      	sub	sp, #36	; 0x24
 80a3dba:	9203      	str	r2, [sp, #12]
 80a3dbc:	f8dd 9054 	ldr.w	r9, [sp, #84]	; 0x54
 80a3dc0:	f89d 205c 	ldrb.w	r2, [sp, #92]	; 0x5c
 80a3dc4:	4604      	mov	r4, r0
 80a3dc6:	e9dd 5613 	ldrd	r5, r6, [sp, #76]	; 0x4c
 80a3dca:	468a      	mov	sl, r1
 80a3dcc:	2700      	movs	r7, #0
 80a3dce:	f89d b058 	ldrb.w	fp, [sp, #88]	; 0x58
 80a3dd2:	9204      	str	r2, [sp, #16]
	byte txLastBits = validBits ? *validBits : 0;
 80a3dd4:	f1b9 0f00 	cmp.w	r9, #0
 80a3dd8:	d03e      	beq.n	80a3e58 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0xa4>
 80a3dda:	f899 8000 	ldrb.w	r8, [r9]
	PCD_WriteRegister(CommandReg, PCD_Idle);			// Stop any active command.
 80a3dde:	2200      	movs	r2, #0
 80a3de0:	2102      	movs	r1, #2
 80a3de2:	4620      	mov	r0, r4
 80a3de4:	9305      	str	r3, [sp, #20]
 80a3de6:	f7ff fe99 	bl	80a3b1c <_ZN7MFRC52217PCD_WriteRegisterEhh>
	PCD_WriteRegister(ComIrqReg, 0x7F);					// Clear all seven interrupt request bits
 80a3dea:	227f      	movs	r2, #127	; 0x7f
 80a3dec:	2108      	movs	r1, #8
 80a3dee:	4620      	mov	r0, r4
 80a3df0:	f7ff fe94 	bl	80a3b1c <_ZN7MFRC52217PCD_WriteRegisterEhh>
	byte bitFraming	= (rxAlign << 4) + txLastBits;		// RxAlign = BitFramingReg[6..4]. TxLastBits = BitFramingReg[2..0]
 80a3df4:	eb08 180b 	add.w	r8, r8, fp, lsl #4
	PCD_SetRegisterBitMask(FIFOLevelReg, 0x80);		// FlushBuffer = 1, FIFO initialization
 80a3df8:	2280      	movs	r2, #128	; 0x80
 80a3dfa:	2114      	movs	r1, #20
 80a3dfc:	4620      	mov	r0, r4
 80a3dfe:	f7ff fed4 	bl	80a3baa <_ZN7MFRC52222PCD_SetRegisterBitMaskEhh>
	byte bitFraming	= (rxAlign << 4) + txLastBits;		// RxAlign = BitFramingReg[6..4]. TxLastBits = BitFramingReg[2..0]
 80a3e02:	fa5f f888 	uxtb.w	r8, r8
	PCD_WriteRegister(FIFODataReg, sendLen, sendData);	// Write sendData to the FIFO
 80a3e06:	9b05      	ldr	r3, [sp, #20]
 80a3e08:	2112      	movs	r1, #18
 80a3e0a:	4620      	mov	r0, r4
 80a3e0c:	f89d 2048 	ldrb.w	r2, [sp, #72]	; 0x48
 80a3e10:	f7ff fe99 	bl	80a3b46 <_ZN7MFRC52217PCD_WriteRegisterEhhPh>
	PCD_WriteRegister(BitFramingReg, bitFraming);		// Bit adjustments
 80a3e14:	4642      	mov	r2, r8
 80a3e16:	211a      	movs	r1, #26
 80a3e18:	4620      	mov	r0, r4
 80a3e1a:	f7ff fe7f 	bl	80a3b1c <_ZN7MFRC52217PCD_WriteRegisterEhh>
	PCD_WriteRegister(CommandReg, command);			// Execute the command
 80a3e1e:	4652      	mov	r2, sl
 80a3e20:	2102      	movs	r1, #2
 80a3e22:	4620      	mov	r0, r4
 80a3e24:	f7ff fe7a 	bl	80a3b1c <_ZN7MFRC52217PCD_WriteRegisterEhh>
	if (command == PCD_Transceive) 	{
 80a3e28:	f1ba 0f0c 	cmp.w	sl, #12
 80a3e2c:	d104      	bne.n	80a3e38 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x84>
		PCD_SetRegisterBitMask(BitFramingReg, 0x80);	// StartSend=1, transmission of data starts
 80a3e2e:	2280      	movs	r2, #128	; 0x80
 80a3e30:	211a      	movs	r1, #26
 80a3e32:	4620      	mov	r0, r4
 80a3e34:	f7ff feb9 	bl	80a3baa <_ZN7MFRC52222PCD_SetRegisterBitMaskEhh>
	byte txLastBits = validBits ? *validBits : 0;
 80a3e38:	f44f 68fa 	mov.w	r8, #2000	; 0x7d0
		n = PCD_ReadRegister(ComIrqReg);	// ComIrqReg[7..0] bits are: Set1 TxIRq RxIRq IdleIRq   HiAlertIRq LoAlertIRq ErrIRq TimerIRq
 80a3e3c:	2108      	movs	r1, #8
 80a3e3e:	4620      	mov	r0, r4
 80a3e40:	f7ff fe9c 	bl	80a3b7c <_ZN7MFRC52216PCD_ReadRegisterEh>
		if (n & waitIRq) {					// One of the interrupts that signal success has been set.
 80a3e44:	9b03      	ldr	r3, [sp, #12]
 80a3e46:	4218      	tst	r0, r3
 80a3e48:	d108      	bne.n	80a3e5c <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0xa8>
		if (n & 0x01) {						// Timer interrupt - nothing received in 25ms
 80a3e4a:	07c3      	lsls	r3, r0, #31
 80a3e4c:	d402      	bmi.n	80a3e54 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0xa0>
		if (--i == 0) {						// The emergency break. If all other condions fail we will eventually terminate on this one after 35.7ms. Communication with the MFRC522 might be down.
 80a3e4e:	f1b8 0801 	subs.w	r8, r8, #1
 80a3e52:	d1f3      	bne.n	80a3e3c <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x88>
			return STATUS_TIMEOUT;
 80a3e54:	2004      	movs	r0, #4
 80a3e56:	e04d      	b.n	80a3ef4 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x140>
	byte txLastBits = validBits ? *validBits : 0;
 80a3e58:	46c8      	mov	r8, r9
 80a3e5a:	e7c0      	b.n	80a3dde <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x2a>
	byte errorRegValue = PCD_ReadRegister(ErrorReg); // ErrorReg[7..0] bits are: WrErr TempErr reserved BufferOvfl   CollErr CRCErr ParityErr ProtocolErr
 80a3e5c:	210c      	movs	r1, #12
 80a3e5e:	4620      	mov	r0, r4
 80a3e60:	f7ff fe8c 	bl	80a3b7c <_ZN7MFRC52216PCD_ReadRegisterEh>
	if (errorRegValue & 0x13) {	 // BufferOvfl ParityErr ProtocolErr
 80a3e64:	f010 0f13 	tst.w	r0, #19
	byte errorRegValue = PCD_ReadRegister(ErrorReg); // ErrorReg[7..0] bits are: WrErr TempErr reserved BufferOvfl   CollErr CRCErr ParityErr ProtocolErr
 80a3e68:	4680      	mov	r8, r0
	if (errorRegValue & 0x13) {	 // BufferOvfl ParityErr ProtocolErr
 80a3e6a:	d146      	bne.n	80a3efa <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x146>
	if (backData && backLen) {
 80a3e6c:	b1dd      	cbz	r5, 80a3ea6 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0xf2>
 80a3e6e:	b1d6      	cbz	r6, 80a3ea6 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0xf2>
		n = PCD_ReadRegister(FIFOLevelReg);						// Number of bytes in the FIFO
 80a3e70:	2114      	movs	r1, #20
 80a3e72:	4620      	mov	r0, r4
 80a3e74:	f7ff fe82 	bl	80a3b7c <_ZN7MFRC52216PCD_ReadRegisterEh>
		if (n > *backLen) {
 80a3e78:	7833      	ldrb	r3, [r6, #0]
		n = PCD_ReadRegister(FIFOLevelReg);						// Number of bytes in the FIFO
 80a3e7a:	4602      	mov	r2, r0
		if (n > *backLen) {
 80a3e7c:	4283      	cmp	r3, r0
 80a3e7e:	d33e      	bcc.n	80a3efe <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x14a>
		*backLen = n;												// Number of bytes returned
 80a3e80:	7030      	strb	r0, [r6, #0]
		PCD_ReadRegister(FIFODataReg, n, backData, rxAlign);		// Get received data from FIFO
 80a3e82:	462b      	mov	r3, r5
 80a3e84:	2112      	movs	r1, #18
 80a3e86:	4620      	mov	r0, r4
 80a3e88:	f8cd b000 	str.w	fp, [sp]
 80a3e8c:	f7ff ff43 	bl	80a3d16 <_ZN7MFRC52216PCD_ReadRegisterEhhPhh>
		_validBits = PCD_ReadRegister(ControlReg) & 0x07;	// RxLastBits[2:0] indicates the number of valid bits in the last received byte. If this value is 000b, the whole byte is valid.
 80a3e90:	2118      	movs	r1, #24
 80a3e92:	4620      	mov	r0, r4
 80a3e94:	f7ff fe72 	bl	80a3b7c <_ZN7MFRC52216PCD_ReadRegisterEh>
 80a3e98:	f000 0707 	and.w	r7, r0, #7
		if (validBits) {
 80a3e9c:	f1b9 0f00 	cmp.w	r9, #0
 80a3ea0:	d001      	beq.n	80a3ea6 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0xf2>
			*validBits = _validBits;
 80a3ea2:	f889 7000 	strb.w	r7, [r9]
	if (errorRegValue & 0x08) { // CollErr
 80a3ea6:	f018 0f08 	tst.w	r8, #8
 80a3eaa:	d12a      	bne.n	80a3f02 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x14e>
	if (backData && backLen && checkCRC) {
 80a3eac:	b35d      	cbz	r5, 80a3f06 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x152>
 80a3eae:	b356      	cbz	r6, 80a3f06 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x152>
 80a3eb0:	9b04      	ldr	r3, [sp, #16]
 80a3eb2:	b343      	cbz	r3, 80a3f06 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x152>
		if (*backLen == 1 && _validBits == 4) {
 80a3eb4:	7832      	ldrb	r2, [r6, #0]
 80a3eb6:	2a01      	cmp	r2, #1
 80a3eb8:	d103      	bne.n	80a3ec2 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x10e>
 80a3eba:	2f04      	cmp	r7, #4
 80a3ebc:	d125      	bne.n	80a3f0a <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x156>
			return STATUS_MIFARE_NACK;
 80a3ebe:	2009      	movs	r0, #9
 80a3ec0:	e018      	b.n	80a3ef4 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x140>
		if (*backLen < 2 || _validBits != 0) {
 80a3ec2:	d922      	bls.n	80a3f0a <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x156>
 80a3ec4:	bb0f      	cbnz	r7, 80a3f0a <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x156>
		n = PCD_CalculateCRC(&backData[0], *backLen - 2, &controlBuffer[0]);
 80a3ec6:	3a02      	subs	r2, #2
 80a3ec8:	4629      	mov	r1, r5
 80a3eca:	4620      	mov	r0, r4
 80a3ecc:	ab07      	add	r3, sp, #28
 80a3ece:	b2d2      	uxtb	r2, r2
 80a3ed0:	f7ff fe8d 	bl	80a3bee <_ZN7MFRC52216PCD_CalculateCRCEPhhS0_>
		if (n != STATUS_OK) {
 80a3ed4:	2801      	cmp	r0, #1
 80a3ed6:	d10d      	bne.n	80a3ef4 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x140>
		if ((backData[*backLen - 2] != controlBuffer[0]) || (backData[*backLen - 1] != controlBuffer[1])) {
 80a3ed8:	7833      	ldrb	r3, [r6, #0]
 80a3eda:	441d      	add	r5, r3
 80a3edc:	f815 2c02 	ldrb.w	r2, [r5, #-2]
 80a3ee0:	f89d 301c 	ldrb.w	r3, [sp, #28]
 80a3ee4:	429a      	cmp	r2, r3
 80a3ee6:	d110      	bne.n	80a3f0a <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x156>
 80a3ee8:	f815 2c01 	ldrb.w	r2, [r5, #-1]
 80a3eec:	f89d 301d 	ldrb.w	r3, [sp, #29]
 80a3ef0:	429a      	cmp	r2, r3
 80a3ef2:	d10a      	bne.n	80a3f0a <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x156>
} // End PCD_CommunicateWithPICC()
 80a3ef4:	b009      	add	sp, #36	; 0x24
 80a3ef6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return STATUS_ERROR;
 80a3efa:	2002      	movs	r0, #2
 80a3efc:	e7fa      	b.n	80a3ef4 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x140>
			return STATUS_NO_ROOM;
 80a3efe:	2005      	movs	r0, #5
 80a3f00:	e7f8      	b.n	80a3ef4 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x140>
		return STATUS_COLLISION;
 80a3f02:	2003      	movs	r0, #3
 80a3f04:	e7f6      	b.n	80a3ef4 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x140>
	return STATUS_OK;
 80a3f06:	2001      	movs	r0, #1
 80a3f08:	e7f4      	b.n	80a3ef4 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x140>
			return STATUS_CRC_WRONG;
 80a3f0a:	2008      	movs	r0, #8
 80a3f0c:	e7f2      	b.n	80a3ef4 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb+0x140>

080a3f0e <_ZN7MFRC52218PCD_TransceiveDataEPhhS0_S0_S0_hb>:
								 ) {
 80a3f0e:	b510      	push	{r4, lr}
 80a3f10:	b086      	sub	sp, #24
	return PCD_CommunicateWithPICC(PCD_Transceive, waitIRq, sendData, sendLen, backData, backLen, validBits, rxAlign, checkCRC);
 80a3f12:	f89d 402c 	ldrb.w	r4, [sp, #44]	; 0x2c
 80a3f16:	9200      	str	r2, [sp, #0]
 80a3f18:	9405      	str	r4, [sp, #20]
 80a3f1a:	f89d 4028 	ldrb.w	r4, [sp, #40]	; 0x28
 80a3f1e:	2230      	movs	r2, #48	; 0x30
 80a3f20:	9404      	str	r4, [sp, #16]
 80a3f22:	9c09      	ldr	r4, [sp, #36]	; 0x24
 80a3f24:	9403      	str	r4, [sp, #12]
 80a3f26:	9c08      	ldr	r4, [sp, #32]
 80a3f28:	e9cd 3401 	strd	r3, r4, [sp, #4]
 80a3f2c:	460b      	mov	r3, r1
 80a3f2e:	210c      	movs	r1, #12
 80a3f30:	f7ff ff40 	bl	80a3db4 <_ZN7MFRC52223PCD_CommunicateWithPICCEhhPhhS0_S0_S0_hb>
} // End PCD_TransceiveData()
 80a3f34:	b006      	add	sp, #24
 80a3f36:	bd10      	pop	{r4, pc}

080a3f38 <_ZN7MFRC52217PICC_REQA_or_WUPAEhPhS0_>:
							   ) {
 80a3f38:	b570      	push	{r4, r5, r6, lr}
 80a3f3a:	b088      	sub	sp, #32
 80a3f3c:	4606      	mov	r6, r0
 80a3f3e:	461c      	mov	r4, r3
	if (bufferATQA == NULL || *bufferSize < 2) {	// The ATQA response is 2 bytes long.
 80a3f40:	4615      	mov	r5, r2
							   ) {
 80a3f42:	f88d 1017 	strb.w	r1, [sp, #23]
	if (bufferATQA == NULL || *bufferSize < 2) {	// The ATQA response is 2 bytes long.
 80a3f46:	b31a      	cbz	r2, 80a3f90 <_ZN7MFRC52217PICC_REQA_or_WUPAEhPhS0_+0x58>
 80a3f48:	781b      	ldrb	r3, [r3, #0]
 80a3f4a:	2b01      	cmp	r3, #1
 80a3f4c:	d920      	bls.n	80a3f90 <_ZN7MFRC52217PICC_REQA_or_WUPAEhPhS0_+0x58>
	PCD_ClearRegisterBitMask(CollReg, 0x80);			// ValuesAfterColl=1 => Bits received after collision are cleared.
 80a3f4e:	2280      	movs	r2, #128	; 0x80
 80a3f50:	211c      	movs	r1, #28
 80a3f52:	f7ff fe39 	bl	80a3bc8 <_ZN7MFRC52224PCD_ClearRegisterBitMaskEhh>
	validBits = 7;										// For REQA and WUPA we need the short frame format - transmit only 7 bits of the last (and only) byte. TxLastBits = BitFramingReg[2..0]
 80a3f56:	2307      	movs	r3, #7
 80a3f58:	f88d 301f 	strb.w	r3, [sp, #31]
	status = PCD_TransceiveData(&command, 1, bufferATQA, bufferSize, &validBits);
 80a3f5c:	2300      	movs	r3, #0
 80a3f5e:	e9cd 3302 	strd	r3, r3, [sp, #8]
 80a3f62:	f10d 031f 	add.w	r3, sp, #31
 80a3f66:	e9cd 4300 	strd	r4, r3, [sp]
 80a3f6a:	2201      	movs	r2, #1
 80a3f6c:	462b      	mov	r3, r5
 80a3f6e:	4630      	mov	r0, r6
 80a3f70:	f10d 0117 	add.w	r1, sp, #23
 80a3f74:	f7ff ffcb 	bl	80a3f0e <_ZN7MFRC52218PCD_TransceiveDataEPhhS0_S0_S0_hb>
	if (status != STATUS_OK) {
 80a3f78:	2801      	cmp	r0, #1
 80a3f7a:	d107      	bne.n	80a3f8c <_ZN7MFRC52217PICC_REQA_or_WUPAEhPhS0_+0x54>
	if (*bufferSize != 2 || validBits != 0) {		// ATQA must be exactly 16 bits.
 80a3f7c:	7823      	ldrb	r3, [r4, #0]
 80a3f7e:	2b02      	cmp	r3, #2
 80a3f80:	d108      	bne.n	80a3f94 <_ZN7MFRC52217PICC_REQA_or_WUPAEhPhS0_+0x5c>
 80a3f82:	f89d 301f 	ldrb.w	r3, [sp, #31]
 80a3f86:	2b00      	cmp	r3, #0
		return STATUS_ERROR;
 80a3f88:	bf18      	it	ne
 80a3f8a:	2002      	movne	r0, #2
} // End PICC_REQA_or_WUPA()
 80a3f8c:	b008      	add	sp, #32
 80a3f8e:	bd70      	pop	{r4, r5, r6, pc}
		return STATUS_NO_ROOM;
 80a3f90:	2005      	movs	r0, #5
 80a3f92:	e7fb      	b.n	80a3f8c <_ZN7MFRC52217PICC_REQA_or_WUPAEhPhS0_+0x54>
		return STATUS_ERROR;
 80a3f94:	2002      	movs	r0, #2
 80a3f96:	e7f9      	b.n	80a3f8c <_ZN7MFRC52217PICC_REQA_or_WUPAEhPhS0_+0x54>

080a3f98 <_ZN7MFRC52213PICC_RequestAEPhS0_>:
							) {
 80a3f98:	4613      	mov	r3, r2
	return PICC_REQA_or_WUPA(PICC_CMD_REQA, bufferATQA, bufferSize);
 80a3f9a:	460a      	mov	r2, r1
 80a3f9c:	2126      	movs	r1, #38	; 0x26
 80a3f9e:	f7ff bfcb 	b.w	80a3f38 <_ZN7MFRC52217PICC_REQA_or_WUPAEhPhS0_>

080a3fa2 <_ZN7MFRC52221PICC_IsNewCardPresentEv>:
 * 
 * @return bool
 */
bool MFRC522::PICC_IsNewCardPresent() {
	byte bufferATQA[2];
	byte bufferSize = sizeof(bufferATQA);
 80a3fa2:	2302      	movs	r3, #2
bool MFRC522::PICC_IsNewCardPresent() {
 80a3fa4:	b507      	push	{r0, r1, r2, lr}
	byte result = PICC_RequestA(bufferATQA, &bufferSize);
 80a3fa6:	f10d 0203 	add.w	r2, sp, #3
 80a3faa:	a901      	add	r1, sp, #4
	byte bufferSize = sizeof(bufferATQA);
 80a3fac:	f88d 3003 	strb.w	r3, [sp, #3]
	byte result = PICC_RequestA(bufferATQA, &bufferSize);
 80a3fb0:	f7ff fff2 	bl	80a3f98 <_ZN7MFRC52213PICC_RequestAEPhS0_>
	return (result == STATUS_OK || result == STATUS_COLLISION);
 80a3fb4:	f000 00fd 	and.w	r0, r0, #253	; 0xfd
} // End PICC_IsNewCardPresent()
 80a3fb8:	1e43      	subs	r3, r0, #1
 80a3fba:	4258      	negs	r0, r3
 80a3fbc:	4158      	adcs	r0, r3
 80a3fbe:	b003      	add	sp, #12
 80a3fc0:	f85d fb04 	ldr.w	pc, [sp], #4

080a3fc4 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh>:
						 ) {
 80a3fc4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (validBits > 80) {
 80a3fc8:	2a50      	cmp	r2, #80	; 0x50
						 ) {
 80a3fca:	4682      	mov	sl, r0
 80a3fcc:	460f      	mov	r7, r1
 80a3fce:	4690      	mov	r8, r2
 80a3fd0:	b08b      	sub	sp, #44	; 0x2c
	if (validBits > 80) {
 80a3fd2:	f200 813b 	bhi.w	80a424c <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x288>
	PCD_ClearRegisterBitMask(CollReg, 0x80);			// ValuesAfterColl=1 => Bits received after collision are cleared.
 80a3fd6:	2280      	movs	r2, #128	; 0x80
 80a3fd8:	211c      	movs	r1, #28
 80a3fda:	f7ff fdf5 	bl	80a3bc8 <_ZN7MFRC52224PCD_ClearRegisterBitMaskEhh>
				buffer[0] = PICC_CMD_SEL_CL1;
 80a3fde:	2393      	movs	r3, #147	; 0x93
 80a3fe0:	f88d 301c 	strb.w	r3, [sp, #28]
				useCascadeTag = validBits && uid->size > 4;	// When we know that the UID has more than 4 bytes
 80a3fe4:	f1b8 0f00 	cmp.w	r8, #0
 80a3fe8:	f000 80b9 	beq.w	80a415e <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x19a>
 80a3fec:	783c      	ldrb	r4, [r7, #0]
 80a3fee:	2c04      	cmp	r4, #4
 80a3ff0:	bf94      	ite	ls
 80a3ff2:	2300      	movls	r3, #0
 80a3ff4:	2301      	movhi	r3, #1
				useCascadeTag = validBits && uid->size > 7;	// When we know that the UID has more than 7 bytes
 80a3ff6:	2501      	movs	r5, #1
 80a3ff8:	2600      	movs	r6, #0
 80a3ffa:	e00b      	b.n	80a4014 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x50>
				buffer[0] = PICC_CMD_SEL_CL2;
 80a3ffc:	2395      	movs	r3, #149	; 0x95
 80a3ffe:	f88d 301c 	strb.w	r3, [sp, #28]
				useCascadeTag = validBits && uid->size > 7;	// When we know that the UID has more than 7 bytes
 80a4002:	f1b8 0f00 	cmp.w	r8, #0
 80a4006:	f000 80ac 	beq.w	80a4162 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x19e>
 80a400a:	783c      	ldrb	r4, [r7, #0]
 80a400c:	2c07      	cmp	r4, #7
 80a400e:	bf94      	ite	ls
 80a4010:	2300      	movls	r3, #0
 80a4012:	2301      	movhi	r3, #1
		currentLevelKnownBits = validBits - (8 * uidIndex);
 80a4014:	eba8 04c6 	sub.w	r4, r8, r6, lsl #3
 80a4018:	b264      	sxtb	r4, r4
		if (currentLevelKnownBits < 0) {
 80a401a:	ea24 74e4 	bic.w	r4, r4, r4, asr #31
		if (useCascadeTag) {
 80a401e:	2b00      	cmp	r3, #0
 80a4020:	f000 80a1 	beq.w	80a4166 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x1a2>
			buffer[index++] = PICC_CMD_CT;
 80a4024:	2288      	movs	r2, #136	; 0x88
 80a4026:	2103      	movs	r1, #3
 80a4028:	f88d 201e 	strb.w	r2, [sp, #30]
		byte bytesToCopy = currentLevelKnownBits / 8 + (currentLevelKnownBits % 8 ? 1 : 0); // The number of bytes needed to represent the known bits for this level.
 80a402c:	f014 0207 	ands.w	r2, r4, #7
 80a4030:	bf18      	it	ne
 80a4032:	2201      	movne	r2, #1
 80a4034:	eb02 02e4 	add.w	r2, r2, r4, asr #3
		if (bytesToCopy) {
 80a4038:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
		byte bytesToCopy = currentLevelKnownBits / 8 + (currentLevelKnownBits % 8 ? 1 : 0); // The number of bytes needed to represent the known bits for this level.
 80a403c:	b2e0      	uxtb	r0, r4
		if (bytesToCopy) {
 80a403e:	d01a      	beq.n	80a4076 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0xb2>
			byte maxBytes = useCascadeTag ? 3 : 4; // Max 4 bytes in each Cascade Level. Only 3 left if we use the Cascade Tag
 80a4040:	2b00      	cmp	r3, #0
 80a4042:	bf14      	ite	ne
 80a4044:	f04f 0c03 	movne.w	ip, #3
 80a4048:	f04f 0c04 	moveq.w	ip, #4
			for (count = 0; count < bytesToCopy; count++) {
 80a404c:	4594      	cmp	ip, r2
 80a404e:	bf94      	ite	ls
 80a4050:	eb01 020c 	addls.w	r2, r1, ip
 80a4054:	188a      	addhi	r2, r1, r2
 80a4056:	f106 0e01 	add.w	lr, r6, #1
 80a405a:	44be      	add	lr, r7
 80a405c:	b2d2      	uxtb	r2, r2
				buffer[index++] = uid->uidByte[uidIndex + count];
 80a405e:	468c      	mov	ip, r1
 80a4060:	3101      	adds	r1, #1
 80a4062:	f81e 9b01 	ldrb.w	r9, [lr], #1
 80a4066:	b2c9      	uxtb	r1, r1
 80a4068:	f10d 0b28 	add.w	fp, sp, #40	; 0x28
 80a406c:	44dc      	add	ip, fp
			for (count = 0; count < bytesToCopy; count++) {
 80a406e:	4291      	cmp	r1, r2
				buffer[index++] = uid->uidByte[uidIndex + count];
 80a4070:	f80c 9c0c 	strb.w	r9, [ip, #-12]
			for (count = 0; count < bytesToCopy; count++) {
 80a4074:	d1f3      	bne.n	80a405e <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x9a>
		if (useCascadeTag) {
 80a4076:	b113      	cbz	r3, 80a407e <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0xba>
			currentLevelKnownBits += 8;
 80a4078:	f100 0408 	add.w	r4, r0, #8
 80a407c:	b264      	sxtb	r4, r4
			if (currentLevelKnownBits >= 32) { // All UID bits in this Cascade Level are known. This is a SELECT.
 80a407e:	2c1f      	cmp	r4, #31
 80a4080:	dd73      	ble.n	80a416a <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x1a6>
				buffer[1] = 0x70; // NVB - Number of Valid Bits: Seven whole bytes
 80a4082:	f04f 0370 	mov.w	r3, #112	; 0x70
				buffer[6] = buffer[2] ^ buffer[3] ^ buffer[4] ^ buffer[5];
 80a4086:	f89d 201f 	ldrb.w	r2, [sp, #31]
				buffer[1] = 0x70; // NVB - Number of Valid Bits: Seven whole bytes
 80a408a:	f88d 301d 	strb.w	r3, [sp, #29]
				buffer[6] = buffer[2] ^ buffer[3] ^ buffer[4] ^ buffer[5];
 80a408e:	f89d 301e 	ldrb.w	r3, [sp, #30]
				result = PCD_CalculateCRC(buffer, 7, &buffer[7]);
 80a4092:	4650      	mov	r0, sl
				buffer[6] = buffer[2] ^ buffer[3] ^ buffer[4] ^ buffer[5];
 80a4094:	4053      	eors	r3, r2
 80a4096:	f89d 2020 	ldrb.w	r2, [sp, #32]
				result = PCD_CalculateCRC(buffer, 7, &buffer[7]);
 80a409a:	a907      	add	r1, sp, #28
				buffer[6] = buffer[2] ^ buffer[3] ^ buffer[4] ^ buffer[5];
 80a409c:	4053      	eors	r3, r2
 80a409e:	f89d 2021 	ldrb.w	r2, [sp, #33]	; 0x21
 80a40a2:	4053      	eors	r3, r2
 80a40a4:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
				result = PCD_CalculateCRC(buffer, 7, &buffer[7]);
 80a40a8:	2207      	movs	r2, #7
 80a40aa:	f10d 0323 	add.w	r3, sp, #35	; 0x23
 80a40ae:	f7ff fd9e 	bl	80a3bee <_ZN7MFRC52216PCD_CalculateCRCEPhhS0_>
				if (result != STATUS_OK) {
 80a40b2:	2801      	cmp	r0, #1
				result = PCD_CalculateCRC(buffer, 7, &buffer[7]);
 80a40b4:	4681      	mov	r9, r0
				if (result != STATUS_OK) {
 80a40b6:	f040 80c5 	bne.w	80a4244 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x280>
				txLastBits		= 0; // 0 => All 8 bits are valid.
 80a40ba:	2300      	movs	r3, #0
 80a40bc:	f88d 301a 	strb.w	r3, [sp, #26]
				responseLength	= 3;
 80a40c0:	2303      	movs	r3, #3
				bufferUsed		= 9;
 80a40c2:	f04f 0909 	mov.w	r9, #9
				responseLength	= 3;
 80a40c6:	f88d 301b 	strb.w	r3, [sp, #27]
 80a40ca:	9404      	str	r4, [sp, #16]
				responseBuffer	= &buffer[6];
 80a40cc:	f10d 0b22 	add.w	fp, sp, #34	; 0x22
			rxAlign = txLastBits;											// Having a seperate variable is overkill. But it makes the next line easier to read.
 80a40d0:	f89d 301a 	ldrb.w	r3, [sp, #26]
			PCD_WriteRegister(BitFramingReg, (rxAlign << 4) + txLastBits);	// RxAlign = BitFramingReg[6..4]. TxLastBits = BitFramingReg[2..0]
 80a40d4:	211a      	movs	r1, #26
 80a40d6:	eb03 1203 	add.w	r2, r3, r3, lsl #4
 80a40da:	4650      	mov	r0, sl
 80a40dc:	b2d2      	uxtb	r2, r2
 80a40de:	9305      	str	r3, [sp, #20]
 80a40e0:	f7ff fd1c 	bl	80a3b1c <_ZN7MFRC52217PCD_WriteRegisterEhh>
			result = PCD_TransceiveData(buffer, bufferUsed, responseBuffer, &responseLength, &txLastBits, rxAlign);			
 80a40e4:	2200      	movs	r2, #0
 80a40e6:	9b05      	ldr	r3, [sp, #20]
 80a40e8:	9203      	str	r2, [sp, #12]
 80a40ea:	9302      	str	r3, [sp, #8]
 80a40ec:	f10d 031a 	add.w	r3, sp, #26
 80a40f0:	9301      	str	r3, [sp, #4]
 80a40f2:	f10d 031b 	add.w	r3, sp, #27
 80a40f6:	464a      	mov	r2, r9
 80a40f8:	9300      	str	r3, [sp, #0]
 80a40fa:	4650      	mov	r0, sl
 80a40fc:	465b      	mov	r3, fp
 80a40fe:	a907      	add	r1, sp, #28
 80a4100:	f7ff ff05 	bl	80a3f0e <_ZN7MFRC52218PCD_TransceiveDataEPhhS0_S0_S0_hb>
			if (result == STATUS_COLLISION) { // More than one PICC in the field => collision.
 80a4104:	2803      	cmp	r0, #3
			result = PCD_TransceiveData(buffer, bufferUsed, responseBuffer, &responseLength, &txLastBits, rxAlign);			
 80a4106:	4681      	mov	r9, r0
			if (result == STATUS_COLLISION) { // More than one PICC in the field => collision.
 80a4108:	d14b      	bne.n	80a41a2 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x1de>
				result = PCD_ReadRegister(CollReg); // CollReg[7..0] bits are: ValuesAfterColl reserved CollPosNotValid CollPos[4:0]
 80a410a:	211c      	movs	r1, #28
 80a410c:	4650      	mov	r0, sl
 80a410e:	f7ff fd35 	bl	80a3b7c <_ZN7MFRC52216PCD_ReadRegisterEh>
				if (result & 0x20) { // CollPosNotValid
 80a4112:	0681      	lsls	r1, r0, #26
 80a4114:	f100 8096 	bmi.w	80a4244 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x280>
					collisionPos = 32;
 80a4118:	f010 001f 	ands.w	r0, r0, #31
 80a411c:	bf08      	it	eq
 80a411e:	2020      	moveq	r0, #32
				if (collisionPos <= currentLevelKnownBits) { // No progress - should not happen 
 80a4120:	42a0      	cmp	r0, r4
 80a4122:	f340 8084 	ble.w	80a422e <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x26a>
				count			= (currentLevelKnownBits - 1) % 8; // The bit to modify
 80a4126:	1e43      	subs	r3, r0, #1
				index			= 1 + (currentLevelKnownBits / 8) + (count ? 1 : 0); // First byte is index 0.
 80a4128:	f003 0207 	and.w	r2, r3, #7
 80a412c:	f013 0307 	ands.w	r3, r3, #7
 80a4130:	bf18      	it	ne
 80a4132:	2301      	movne	r3, #1
				currentLevelKnownBits = collisionPos;
 80a4134:	b244      	sxtb	r4, r0
				index			= 1 + (currentLevelKnownBits / 8) + (count ? 1 : 0); // First byte is index 0.
 80a4136:	08c0      	lsrs	r0, r0, #3
 80a4138:	3001      	adds	r0, #1
				buffer[index]	|= (1 << count); 
 80a413a:	4418      	add	r0, r3
 80a413c:	ab0a      	add	r3, sp, #40	; 0x28
 80a413e:	4418      	add	r0, r3
 80a4140:	2301      	movs	r3, #1
 80a4142:	fa03 f202 	lsl.w	r2, r3, r2
 80a4146:	f810 3c0c 	ldrb.w	r3, [r0, #-12]
 80a414a:	4313      	orrs	r3, r2
 80a414c:	f800 3c0c 	strb.w	r3, [r0, #-12]
		while ( ! selectDone) {
 80a4150:	e795      	b.n	80a407e <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0xba>
				buffer[0] = PICC_CMD_SEL_CL3;
 80a4152:	2397      	movs	r3, #151	; 0x97
				uidIndex = 6;
 80a4154:	2606      	movs	r6, #6
				buffer[0] = PICC_CMD_SEL_CL3;
 80a4156:	f88d 301c 	strb.w	r3, [sp, #28]
				useCascadeTag = false;						// Never used in CL3.
 80a415a:	4623      	mov	r3, r4
				break;
 80a415c:	e75a      	b.n	80a4014 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x50>
				useCascadeTag = validBits && uid->size > 4;	// When we know that the UID has more than 4 bytes
 80a415e:	4643      	mov	r3, r8
 80a4160:	e749      	b.n	80a3ff6 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x32>
				useCascadeTag = validBits && uid->size > 7;	// When we know that the UID has more than 7 bytes
 80a4162:	4643      	mov	r3, r8
 80a4164:	e756      	b.n	80a4014 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x50>
		index = 2; // destination index in buffer[]
 80a4166:	2102      	movs	r1, #2
 80a4168:	e760      	b.n	80a402c <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x68>
				bufferUsed		= index + (txLastBits ? 1 : 0);
 80a416a:	f014 0907 	ands.w	r9, r4, #7
 80a416e:	bf18      	it	ne
 80a4170:	f04f 0901 	movne.w	r9, #1
				count			= currentLevelKnownBits / 8;	// Number of whole bytes in the UID part.
 80a4174:	10e3      	asrs	r3, r4, #3
				index			= 2 + count;					// Number of whole bytes: SEL + NVB + UIDs
 80a4176:	3302      	adds	r3, #2
 80a4178:	b2db      	uxtb	r3, r3
				txLastBits		= currentLevelKnownBits % 8;
 80a417a:	f004 0207 	and.w	r2, r4, #7
 80a417e:	f88d 201a 	strb.w	r2, [sp, #26]
				buffer[1]		= (index << 4) + txLastBits;	// NVB - Number of Valid Bits
 80a4182:	eb02 1203 	add.w	r2, r2, r3, lsl #4
 80a4186:	f88d 201d 	strb.w	r2, [sp, #29]
				responseBuffer	= &buffer[index];
 80a418a:	aa07      	add	r2, sp, #28
				bufferUsed		= index + (txLastBits ? 1 : 0);
 80a418c:	4499      	add	r9, r3
				responseBuffer	= &buffer[index];
 80a418e:	eb02 0b03 	add.w	fp, r2, r3
				responseLength	= sizeof(buffer) - index;
 80a4192:	f1c3 0309 	rsb	r3, r3, #9
				bufferUsed		= index + (txLastBits ? 1 : 0);
 80a4196:	fa5f f989 	uxtb.w	r9, r9
				responseLength	= sizeof(buffer) - index;
 80a419a:	f88d 301b 	strb.w	r3, [sp, #27]
 80a419e:	9404      	str	r4, [sp, #16]
 80a41a0:	e796      	b.n	80a40d0 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x10c>
			else if (result != STATUS_OK) {
 80a41a2:	2801      	cmp	r0, #1
 80a41a4:	d14e      	bne.n	80a4244 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x280>
				if (currentLevelKnownBits >= 32) { // This was a SELECT.
 80a41a6:	9b04      	ldr	r3, [sp, #16]
					currentLevelKnownBits = 32;
 80a41a8:	2420      	movs	r4, #32
				if (currentLevelKnownBits >= 32) { // This was a SELECT.
 80a41aa:	2b1f      	cmp	r3, #31
 80a41ac:	f77f af69 	ble.w	80a4082 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0xbe>
		index			= (buffer[2] == PICC_CMD_CT) ? 3 : 2; // source index in buffer[]
 80a41b0:	f89d 301e 	ldrb.w	r3, [sp, #30]
 80a41b4:	2b88      	cmp	r3, #136	; 0x88
 80a41b6:	d13d      	bne.n	80a4234 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x270>
 80a41b8:	2303      	movs	r3, #3
		bytesToCopy		= (buffer[2] == PICC_CMD_CT) ? 3 : 4;
 80a41ba:	461a      	mov	r2, r3
		for (count = 0; count < bytesToCopy; count++) {
 80a41bc:	3601      	adds	r6, #1
 80a41be:	441a      	add	r2, r3
 80a41c0:	443e      	add	r6, r7
 80a41c2:	b2d2      	uxtb	r2, r2
			uid->uidByte[uidIndex + count] = buffer[index++];
 80a41c4:	4619      	mov	r1, r3
 80a41c6:	a80a      	add	r0, sp, #40	; 0x28
 80a41c8:	3301      	adds	r3, #1
 80a41ca:	4401      	add	r1, r0
 80a41cc:	f811 1c0c 	ldrb.w	r1, [r1, #-12]
 80a41d0:	b2db      	uxtb	r3, r3
		for (count = 0; count < bytesToCopy; count++) {
 80a41d2:	4293      	cmp	r3, r2
			uid->uidByte[uidIndex + count] = buffer[index++];
 80a41d4:	f806 1b01 	strb.w	r1, [r6], #1
		for (count = 0; count < bytesToCopy; count++) {
 80a41d8:	d1f4      	bne.n	80a41c4 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x200>
		if (responseLength != 3 || txLastBits != 0) {		// SAK must be exactly 24 bits (1 byte + CRC_A).
 80a41da:	f89d 601b 	ldrb.w	r6, [sp, #27]
 80a41de:	2e03      	cmp	r6, #3
 80a41e0:	d137      	bne.n	80a4252 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x28e>
 80a41e2:	f89d 401a 	ldrb.w	r4, [sp, #26]
 80a41e6:	bba4      	cbnz	r4, 80a4252 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x28e>
		result = PCD_CalculateCRC(responseBuffer, 1, &buffer[2]);
 80a41e8:	2201      	movs	r2, #1
 80a41ea:	4659      	mov	r1, fp
 80a41ec:	4650      	mov	r0, sl
 80a41ee:	f10d 031e 	add.w	r3, sp, #30
 80a41f2:	f7ff fcfc 	bl	80a3bee <_ZN7MFRC52216PCD_CalculateCRCEPhhS0_>
		if (result != STATUS_OK) {
 80a41f6:	2801      	cmp	r0, #1
		result = PCD_CalculateCRC(responseBuffer, 1, &buffer[2]);
 80a41f8:	4681      	mov	r9, r0
		if (result != STATUS_OK) {
 80a41fa:	d123      	bne.n	80a4244 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x280>
		if ((buffer[2] != responseBuffer[1]) || (buffer[3] != responseBuffer[2])) {
 80a41fc:	f89d 201e 	ldrb.w	r2, [sp, #30]
 80a4200:	f89b 3001 	ldrb.w	r3, [fp, #1]
 80a4204:	429a      	cmp	r2, r3
 80a4206:	d127      	bne.n	80a4258 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x294>
 80a4208:	f89d 201f 	ldrb.w	r2, [sp, #31]
 80a420c:	f89b 3002 	ldrb.w	r3, [fp, #2]
 80a4210:	429a      	cmp	r2, r3
 80a4212:	d121      	bne.n	80a4258 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x294>
		if (responseBuffer[0] & 0x04) { // Cascade bit set - UID not complete yes
 80a4214:	f89b 3000 	ldrb.w	r3, [fp]
 80a4218:	075a      	lsls	r2, r3, #29
 80a421a:	d50e      	bpl.n	80a423a <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x276>
			cascadeLevel++;
 80a421c:	3501      	adds	r5, #1
 80a421e:	b2ed      	uxtb	r5, r5
		switch (cascadeLevel) {
 80a4220:	2d03      	cmp	r5, #3
 80a4222:	d096      	beq.n	80a4152 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x18e>
 80a4224:	2d04      	cmp	r5, #4
 80a4226:	d002      	beq.n	80a422e <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x26a>
 80a4228:	2d02      	cmp	r5, #2
 80a422a:	f43f aee7 	beq.w	80a3ffc <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x38>
 80a422e:	f04f 0906 	mov.w	r9, #6
 80a4232:	e007      	b.n	80a4244 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x280>
		index			= (buffer[2] == PICC_CMD_CT) ? 3 : 2; // source index in buffer[]
 80a4234:	2302      	movs	r3, #2
		bytesToCopy		= (buffer[2] == PICC_CMD_CT) ? 3 : 4;
 80a4236:	2204      	movs	r2, #4
 80a4238:	e7c0      	b.n	80a41bc <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x1f8>
	uid->size = 3 * cascadeLevel + 1;
 80a423a:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 80a423e:	3501      	adds	r5, #1
			uid->sak = responseBuffer[0];
 80a4240:	72fb      	strb	r3, [r7, #11]
	uid->size = 3 * cascadeLevel + 1;
 80a4242:	703d      	strb	r5, [r7, #0]
} // End PICC_Select()
 80a4244:	4648      	mov	r0, r9
 80a4246:	b00b      	add	sp, #44	; 0x2c
 80a4248:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return STATUS_INVALID;
 80a424c:	f04f 0907 	mov.w	r9, #7
 80a4250:	e7f8      	b.n	80a4244 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x280>
			return STATUS_ERROR;
 80a4252:	f04f 0902 	mov.w	r9, #2
 80a4256:	e7f5      	b.n	80a4244 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x280>
			return STATUS_CRC_WRONG;
 80a4258:	f04f 0908 	mov.w	r9, #8
 80a425c:	e7f2      	b.n	80a4244 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh+0x280>

080a425e <_ZN7MFRC52219PICC_ReadCardSerialEv>:
 * Remember to call PICC_IsNewCardPresent(), PICC_RequestA() or PICC_WakeupA() first.
 * The read UID is available in the class variable uid.
 * 
 * @return bool
 */
bool MFRC522::PICC_ReadCardSerial() {
 80a425e:	b508      	push	{r3, lr}
 80a4260:	4601      	mov	r1, r0
	byte result = PICC_Select(&uid);
 80a4262:	2200      	movs	r2, #0
 80a4264:	f7ff feae 	bl	80a3fc4 <_ZN7MFRC52211PICC_SelectEPNS_3UidEh>
	return (result == STATUS_OK);
} // End PICC_ReadCardSerial()
 80a4268:	1e43      	subs	r3, r0, #1
 80a426a:	4258      	negs	r0, r3
 80a426c:	4158      	adcs	r0, r3
 80a426e:	bd08      	pop	{r3, pc}

080a4270 <_ZN7MFRC52210PICC_HaltAEv>:
	buffer[0] = PICC_CMD_HLTA;
 80a4270:	2350      	movs	r3, #80	; 0x50
byte MFRC522::PICC_HaltA() {
 80a4272:	b530      	push	{r4, r5, lr}
 80a4274:	b087      	sub	sp, #28
	buffer[0] = PICC_CMD_HLTA;
 80a4276:	f8ad 3014 	strh.w	r3, [sp, #20]
	result = PCD_CalculateCRC(buffer, 2, &buffer[2]);
 80a427a:	2202      	movs	r2, #2
 80a427c:	f10d 0316 	add.w	r3, sp, #22
 80a4280:	a905      	add	r1, sp, #20
byte MFRC522::PICC_HaltA() {
 80a4282:	4605      	mov	r5, r0
	result = PCD_CalculateCRC(buffer, 2, &buffer[2]);
 80a4284:	f7ff fcb3 	bl	80a3bee <_ZN7MFRC52216PCD_CalculateCRCEPhhS0_>
	if (result != STATUS_OK) {
 80a4288:	2801      	cmp	r0, #1
	result = PCD_CalculateCRC(buffer, 2, &buffer[2]);
 80a428a:	4604      	mov	r4, r0
	if (result != STATUS_OK) {
 80a428c:	d10f      	bne.n	80a42ae <_ZN7MFRC52210PICC_HaltAEv+0x3e>
	result = PCD_TransceiveData(buffer, sizeof(buffer), NULL, 0);
 80a428e:	2300      	movs	r3, #0
 80a4290:	2204      	movs	r2, #4
 80a4292:	4628      	mov	r0, r5
 80a4294:	e9cd 3302 	strd	r3, r3, [sp, #8]
 80a4298:	e9cd 3300 	strd	r3, r3, [sp]
 80a429c:	a905      	add	r1, sp, #20
 80a429e:	f7ff fe36 	bl	80a3f0e <_ZN7MFRC52218PCD_TransceiveDataEPhhS0_S0_S0_hb>
	if (result == STATUS_TIMEOUT) {
 80a42a2:	2804      	cmp	r0, #4
 80a42a4:	d003      	beq.n	80a42ae <_ZN7MFRC52210PICC_HaltAEv+0x3e>
		return STATUS_ERROR;
 80a42a6:	2801      	cmp	r0, #1
 80a42a8:	bf14      	ite	ne
 80a42aa:	4604      	movne	r4, r0
 80a42ac:	2402      	moveq	r4, #2
} // End PICC_HaltA()
 80a42ae:	4620      	mov	r0, r4
 80a42b0:	b007      	add	sp, #28
 80a42b2:	bd30      	pop	{r4, r5, pc}

080a42b4 <_ZN7MFRC52212setSPIConfigEv>:
void MFRC522::setSPIConfig() {
 80a42b4:	b508      	push	{r3, lr}
        instance().begin();
 80a42b6:	f7fd fe61 	bl	80a1f7c <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8instanceEv>
 80a42ba:	f001 fcbb 	bl	80a5c34 <_ZN8SPIClass5beginEv>
        instance().setClockDivider(divider);
 80a42be:	f7fd fe5d 	bl	80a1f7c <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8instanceEv>
 80a42c2:	2110      	movs	r1, #16
 80a42c4:	f001 fda0 	bl	80a5e08 <_ZN8SPIClass15setClockDividerEh>
        instance().setBitOrder(order);
 80a42c8:	f7fd fe58 	bl	80a1f7c <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8instanceEv>
 80a42cc:	2101      	movs	r1, #1
 80a42ce:	f001 fccd 	bl	80a5c6c <_ZN8SPIClass11setBitOrderEh>
        instance().setDataMode(mode);
 80a42d2:	f7fd fe53 	bl	80a1f7c <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8instanceEv>
} // End setSPIConfig()
 80a42d6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 80a42da:	2100      	movs	r1, #0
 80a42dc:	f001 bcd4 	b.w	80a5c88 <_ZN8SPIClass11setDataModeEh>

080a42e0 <_ZN8particle11SPISettingsD1Ev>:
  SPISettings()
  {
  }

  virtual ~SPISettings() {
  }
 80a42e0:	4770      	bx	lr

080a42e2 <_ZN16Adafruit_ILI934110fillScreenEt>:
  digitalWrite(_cs, HIGH);
#endif
  if (hwSPI) spi_end();
}

void Adafruit_ILI9341::fillScreen(uint16_t color) {
 80a42e2:	b513      	push	{r0, r1, r4, lr}
  fillRect(0, 0,  _width, _height, color);
 80a42e4:	9101      	str	r1, [sp, #4]
 80a42e6:	f9b0 100e 	ldrsh.w	r1, [r0, #14]
 80a42ea:	6802      	ldr	r2, [r0, #0]
 80a42ec:	9100      	str	r1, [sp, #0]
 80a42ee:	6a54      	ldr	r4, [r2, #36]	; 0x24
 80a42f0:	2200      	movs	r2, #0
 80a42f2:	f9b0 300c 	ldrsh.w	r3, [r0, #12]
 80a42f6:	4611      	mov	r1, r2
 80a42f8:	47a0      	blx	r4
}
 80a42fa:	b002      	add	sp, #8
 80a42fc:	bd10      	pop	{r4, pc}

080a42fe <_ZN16Adafruit_ILI9341D1Ev>:
#define ILI9341_WHITE       0xFFFF      /* 255, 255, 255 */
#define ILI9341_ORANGE      0xFD20      /* 255, 165,   0 */
#define ILI9341_GREENYELLOW 0xAFE5      /* 173, 255,  47 */
#define ILI9341_PINK        0xF81F

class Adafruit_ILI9341 : public Adafruit_GFX {
 80a42fe:	4770      	bx	lr

080a4300 <_ZN8particle11SPISettingsD0Ev>:
  virtual ~SPISettings() {
 80a4300:	b510      	push	{r4, lr}
 80a4302:	4604      	mov	r4, r0
  }
 80a4304:	2110      	movs	r1, #16
 80a4306:	f003 f984 	bl	80a7612 <_ZdlPvj>
 80a430a:	4620      	mov	r0, r4
 80a430c:	bd10      	pop	{r4, pc}

080a430e <_ZN16Adafruit_ILI9341D0Ev>:
 80a430e:	b510      	push	{r4, lr}
 80a4310:	4604      	mov	r4, r0
 80a4312:	2134      	movs	r1, #52	; 0x34
 80a4314:	f003 f97d 	bl	80a7612 <_ZdlPvj>
 80a4318:	4620      	mov	r0, r4
 80a431a:	bd10      	pop	{r4, pc}

080a431c <_ZN5Print6printfEPKcz>:
    size_t printf(const char* format, ...) __attribute__ ((format(printf, 2, 3)))
 80a431c:	b40e      	push	{r1, r2, r3}
 80a431e:	b503      	push	{r0, r1, lr}
 80a4320:	ab03      	add	r3, sp, #12
 80a4322:	f853 2b04 	ldr.w	r2, [r3], #4
        auto r = this->vprintf(false, format, args);
 80a4326:	2100      	movs	r1, #0
        va_start(args, format);
 80a4328:	9301      	str	r3, [sp, #4]
        auto r = this->vprintf(false, format, args);
 80a432a:	f002 ff71 	bl	80a7210 <_ZN5Print7vprintfEbPKcSt9__va_list>
    }
 80a432e:	b002      	add	sp, #8
 80a4330:	f85d eb04 	ldr.w	lr, [sp], #4
 80a4334:	b003      	add	sp, #12
 80a4336:	4770      	bx	lr

080a4338 <_ZNK8particle11SPISettings7printToER5Print>:
  bool operator!=(const SPISettings& other) const
  {
    return !(other == *this);
  }

  virtual size_t printTo(Print& p) const
 80a4338:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80a433a:	4604      	mov	r4, r0
  {
    if (default_ && clock_ == 0)
 80a433c:	7922      	ldrb	r2, [r4, #4]
  virtual size_t printTo(Print& p) const
 80a433e:	4608      	mov	r0, r1
 80a4340:	68a3      	ldr	r3, [r4, #8]
    if (default_ && clock_ == 0)
 80a4342:	b132      	cbz	r2, 80a4352 <_ZNK8particle11SPISettings7printToER5Print+0x1a>
 80a4344:	b9a3      	cbnz	r3, 80a4370 <_ZNK8particle11SPISettings7printToER5Print+0x38>
      return p.print("<SPISettings default>");
 80a4346:	490b      	ldr	r1, [pc, #44]	; (80a4374 <_ZNK8particle11SPISettings7printToER5Print+0x3c>)
    else
      return p.printf("<SPISettings %s%u %s MODE%u>", default_ ? "default " : "", (unsigned int)clock_,
          bitOrder_ == MSBFIRST ? "MSB" : "LSB", (unsigned int)dataMode_);
  }
 80a4348:	b002      	add	sp, #8
 80a434a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      return p.print("<SPISettings default>");
 80a434e:	f002 bf2f 	b.w	80a71b0 <_ZN5Print5printEPKc>
      return p.printf("<SPISettings %s%u %s MODE%u>", default_ ? "default " : "", (unsigned int)clock_,
 80a4352:	4a09      	ldr	r2, [pc, #36]	; (80a4378 <_ZNK8particle11SPISettings7printToER5Print+0x40>)
 80a4354:	7b26      	ldrb	r6, [r4, #12]
 80a4356:	4d09      	ldr	r5, [pc, #36]	; (80a437c <_ZNK8particle11SPISettings7printToER5Print+0x44>)
 80a4358:	4909      	ldr	r1, [pc, #36]	; (80a4380 <_ZNK8particle11SPISettings7printToER5Print+0x48>)
 80a435a:	7b64      	ldrb	r4, [r4, #13]
 80a435c:	2e01      	cmp	r6, #1
 80a435e:	bf18      	it	ne
 80a4360:	4629      	movne	r1, r5
 80a4362:	e9cd 1400 	strd	r1, r4, [sp]
 80a4366:	4907      	ldr	r1, [pc, #28]	; (80a4384 <_ZNK8particle11SPISettings7printToER5Print+0x4c>)
 80a4368:	f7ff ffd8 	bl	80a431c <_ZN5Print6printfEPKcz>
  }
 80a436c:	b002      	add	sp, #8
 80a436e:	bd70      	pop	{r4, r5, r6, pc}
      return p.printf("<SPISettings %s%u %s MODE%u>", default_ ? "default " : "", (unsigned int)clock_,
 80a4370:	4a05      	ldr	r2, [pc, #20]	; (80a4388 <_ZNK8particle11SPISettings7printToER5Print+0x50>)
 80a4372:	e7ef      	b.n	80a4354 <_ZNK8particle11SPISettings7printToER5Print+0x1c>
 80a4374:	080aa429 	.word	0x080aa429
 80a4378:	080aa420 	.word	0x080aa420
 80a437c:	080aa425 	.word	0x080aa425
 80a4380:	080aa421 	.word	0x080aa421
 80a4384:	080aa43f 	.word	0x080aa43f
 80a4388:	080aa418 	.word	0x080aa418

080a438c <_ZN16Adafruit_ILI9341C1Eaaaaaa>:
Adafruit_ILI9341::Adafruit_ILI9341(int8_t cs, int8_t dc, int8_t mosi,
 80a438c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a438e:	4604      	mov	r4, r0
 80a4390:	460f      	mov	r7, r1
 80a4392:	4616      	mov	r6, r2
				   int8_t sclk, int8_t rst, int8_t miso) : Adafruit_GFX(ILI9341_TFTWIDTH, ILI9341_TFTHEIGHT) {
 80a4394:	21f0      	movs	r1, #240	; 0xf0
 80a4396:	f44f 72a0 	mov.w	r2, #320	; 0x140
Adafruit_ILI9341::Adafruit_ILI9341(int8_t cs, int8_t dc, int8_t mosi,
 80a439a:	461d      	mov	r5, r3
				   int8_t sclk, int8_t rst, int8_t miso) : Adafruit_GFX(ILI9341_TFTWIDTH, ILI9341_TFTHEIGHT) {
 80a439c:	f7fe f974 	bl	80a2688 <_ZN12Adafruit_GFXC1Ess>
 80a43a0:	4b0c      	ldr	r3, [pc, #48]	; (80a43d4 <_ZN16Adafruit_ILI9341C1Eaaaaaa+0x48>)
}
 80a43a2:	4620      	mov	r0, r4
				   int8_t sclk, int8_t rst, int8_t miso) : Adafruit_GFX(ILI9341_TFTWIDTH, ILI9341_TFTHEIGHT) {
 80a43a4:	6023      	str	r3, [r4, #0]
  _miso = miso;
 80a43a6:	f99d 3020 	ldrsb.w	r3, [sp, #32]
  _cs   = cs;
 80a43aa:	f884 702b 	strb.w	r7, [r4, #43]	; 0x2b
  _miso = miso;
 80a43ae:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
  _sclk = sclk;
 80a43b2:	f99d 3018 	ldrsb.w	r3, [sp, #24]
  _dc   = dc;
 80a43b6:	f884 602c 	strb.w	r6, [r4, #44]	; 0x2c
  _sclk = sclk;
 80a43ba:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
  _rst  = rst;
 80a43be:	f99d 301c 	ldrsb.w	r3, [sp, #28]
  _mosi  = mosi;
 80a43c2:	f884 502e 	strb.w	r5, [r4, #46]	; 0x2e
  _rst  = rst;
 80a43c6:	f884 302d 	strb.w	r3, [r4, #45]	; 0x2d
  hwSPI = false;
 80a43ca:	2300      	movs	r3, #0
 80a43cc:	f884 302a 	strb.w	r3, [r4, #42]	; 0x2a
}
 80a43d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a43d2:	bf00      	nop
 80a43d4:	080aa478 	.word	0x080aa478

080a43d8 <_ZN16Adafruit_ILI93418spiwriteEh>:
void Adafruit_ILI9341::spiwrite(uint8_t c) {
 80a43d8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if (hwSPI) {
 80a43dc:	f890 302a 	ldrb.w	r3, [r0, #42]	; 0x2a
void Adafruit_ILI9341::spiwrite(uint8_t c) {
 80a43e0:	4607      	mov	r7, r0
 80a43e2:	4688      	mov	r8, r1
  if (hwSPI) {
 80a43e4:	b13b      	cbz	r3, 80a43f6 <_ZN16Adafruit_ILI93418spiwriteEh+0x1e>
        return instance().transfer(data);
 80a43e6:	f7fd fdc9 	bl	80a1f7c <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8instanceEv>
 80a43ea:	4641      	mov	r1, r8
}
 80a43ec:	b003      	add	sp, #12
 80a43ee:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a43f2:	f001 bd2d 	b.w	80a5e50 <_ZN8SPIClass8transferEh>
 80a43f6:	f04f 0a08 	mov.w	sl, #8
    for(uint8_t bit = 0x80; bit; bit >>= 1) {
 80a43fa:	f04f 0b80 	mov.w	fp, #128	; 0x80
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRL = fastPinGetPinmap()[_pin].gpio_pin;
}

inline void pinResetFast(pin_t _pin)
{
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRH = fastPinGetPinmap()[_pin].gpio_pin;
 80a43fe:	f04f 091c 	mov.w	r9, #28
 80a4402:	4c5b      	ldr	r4, [pc, #364]	; (80a4570 <_ZN16Adafruit_ILI93418spiwriteEh+0x198>)
 80a4404:	4d5b      	ldr	r5, [pc, #364]	; (80a4574 <_ZN16Adafruit_ILI93418spiwriteEh+0x19c>)
      if(c & bit) {
 80a4406:	f997 602e 	ldrsb.w	r6, [r7, #46]	; 0x2e
 80a440a:	ea18 0f0b 	tst.w	r8, fp
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a440e:	7823      	ldrb	r3, [r4, #0]
 80a4410:	b2b6      	uxth	r6, r6
 80a4412:	f3bf 8f5b 	dmb	ish
 80a4416:	f000 8084 	beq.w	80a4522 <_ZN16Adafruit_ILI93418spiwriteEh+0x14a>
 80a441a:	07d8      	lsls	r0, r3, #31
 80a441c:	d409      	bmi.n	80a4432 <_ZN16Adafruit_ILI93418spiwriteEh+0x5a>
 80a441e:	4620      	mov	r0, r4
 80a4420:	f7fb fe4a 	bl	80a00b8 <__cxa_guard_acquire>
 80a4424:	b128      	cbz	r0, 80a4432 <_ZN16Adafruit_ILI93418spiwriteEh+0x5a>
 80a4426:	f001 f9f3 	bl	80a5810 <HAL_Pin_Map>
 80a442a:	6028      	str	r0, [r5, #0]
 80a442c:	4620      	mov	r0, r4
 80a442e:	f7fb fe48 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRL = fastPinGetPinmap()[_pin].gpio_pin;
 80a4432:	fb09 f606 	mul.w	r6, r9, r6
 80a4436:	682b      	ldr	r3, [r5, #0]
 80a4438:	4433      	add	r3, r6
 80a443a:	9301      	str	r3, [sp, #4]
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a443c:	7823      	ldrb	r3, [r4, #0]
 80a443e:	f3bf 8f5b 	dmb	ish
 80a4442:	07d9      	lsls	r1, r3, #31
 80a4444:	d409      	bmi.n	80a445a <_ZN16Adafruit_ILI93418spiwriteEh+0x82>
 80a4446:	4620      	mov	r0, r4
 80a4448:	f7fb fe36 	bl	80a00b8 <__cxa_guard_acquire>
 80a444c:	b128      	cbz	r0, 80a445a <_ZN16Adafruit_ILI93418spiwriteEh+0x82>
 80a444e:	f001 f9df 	bl	80a5810 <HAL_Pin_Map>
 80a4452:	6028      	str	r0, [r5, #0]
 80a4454:	4620      	mov	r0, r4
 80a4456:	f7fb fe34 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRL = fastPinGetPinmap()[_pin].gpio_pin;
 80a445a:	682b      	ldr	r3, [r5, #0]
 80a445c:	9a01      	ldr	r2, [sp, #4]
 80a445e:	599b      	ldr	r3, [r3, r6]
 80a4460:	8892      	ldrh	r2, [r2, #4]
 80a4462:	831a      	strh	r2, [r3, #24]
      pinSetFast(_sclk);
 80a4464:	f997 6030 	ldrsb.w	r6, [r7, #48]	; 0x30
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a4468:	7823      	ldrb	r3, [r4, #0]
 80a446a:	b2b6      	uxth	r6, r6
 80a446c:	07d8      	lsls	r0, r3, #31
 80a446e:	f3bf 8f5b 	dmb	ish
 80a4472:	d409      	bmi.n	80a4488 <_ZN16Adafruit_ILI93418spiwriteEh+0xb0>
 80a4474:	4620      	mov	r0, r4
 80a4476:	f7fb fe1f 	bl	80a00b8 <__cxa_guard_acquire>
 80a447a:	b128      	cbz	r0, 80a4488 <_ZN16Adafruit_ILI93418spiwriteEh+0xb0>
 80a447c:	f001 f9c8 	bl	80a5810 <HAL_Pin_Map>
 80a4480:	6028      	str	r0, [r5, #0]
 80a4482:	4620      	mov	r0, r4
 80a4484:	f7fb fe1d 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRL = fastPinGetPinmap()[_pin].gpio_pin;
 80a4488:	fb09 f606 	mul.w	r6, r9, r6
 80a448c:	682b      	ldr	r3, [r5, #0]
 80a448e:	4433      	add	r3, r6
 80a4490:	9301      	str	r3, [sp, #4]
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a4492:	7823      	ldrb	r3, [r4, #0]
 80a4494:	f3bf 8f5b 	dmb	ish
 80a4498:	07d9      	lsls	r1, r3, #31
 80a449a:	d409      	bmi.n	80a44b0 <_ZN16Adafruit_ILI93418spiwriteEh+0xd8>
 80a449c:	4620      	mov	r0, r4
 80a449e:	f7fb fe0b 	bl	80a00b8 <__cxa_guard_acquire>
 80a44a2:	b128      	cbz	r0, 80a44b0 <_ZN16Adafruit_ILI93418spiwriteEh+0xd8>
 80a44a4:	f001 f9b4 	bl	80a5810 <HAL_Pin_Map>
 80a44a8:	6028      	str	r0, [r5, #0]
 80a44aa:	4620      	mov	r0, r4
 80a44ac:	f7fb fe09 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRL = fastPinGetPinmap()[_pin].gpio_pin;
 80a44b0:	682b      	ldr	r3, [r5, #0]
 80a44b2:	9a01      	ldr	r2, [sp, #4]
 80a44b4:	599b      	ldr	r3, [r3, r6]
 80a44b6:	8892      	ldrh	r2, [r2, #4]
 80a44b8:	831a      	strh	r2, [r3, #24]
      pinResetFast(_sclk);
 80a44ba:	f997 6030 	ldrsb.w	r6, [r7, #48]	; 0x30
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a44be:	7823      	ldrb	r3, [r4, #0]
 80a44c0:	b2b6      	uxth	r6, r6
 80a44c2:	07da      	lsls	r2, r3, #31
 80a44c4:	f3bf 8f5b 	dmb	ish
 80a44c8:	d409      	bmi.n	80a44de <_ZN16Adafruit_ILI93418spiwriteEh+0x106>
 80a44ca:	4620      	mov	r0, r4
 80a44cc:	f7fb fdf4 	bl	80a00b8 <__cxa_guard_acquire>
 80a44d0:	b128      	cbz	r0, 80a44de <_ZN16Adafruit_ILI93418spiwriteEh+0x106>
 80a44d2:	f001 f99d 	bl	80a5810 <HAL_Pin_Map>
 80a44d6:	6028      	str	r0, [r5, #0]
 80a44d8:	4620      	mov	r0, r4
 80a44da:	f7fb fdf2 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRH = fastPinGetPinmap()[_pin].gpio_pin;
 80a44de:	fb09 f606 	mul.w	r6, r9, r6
 80a44e2:	682b      	ldr	r3, [r5, #0]
 80a44e4:	4433      	add	r3, r6
 80a44e6:	9301      	str	r3, [sp, #4]
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a44e8:	7823      	ldrb	r3, [r4, #0]
 80a44ea:	f3bf 8f5b 	dmb	ish
 80a44ee:	07db      	lsls	r3, r3, #31
 80a44f0:	d409      	bmi.n	80a4506 <_ZN16Adafruit_ILI93418spiwriteEh+0x12e>
 80a44f2:	4620      	mov	r0, r4
 80a44f4:	f7fb fde0 	bl	80a00b8 <__cxa_guard_acquire>
 80a44f8:	b128      	cbz	r0, 80a4506 <_ZN16Adafruit_ILI93418spiwriteEh+0x12e>
 80a44fa:	f001 f989 	bl	80a5810 <HAL_Pin_Map>
 80a44fe:	6028      	str	r0, [r5, #0]
 80a4500:	4620      	mov	r0, r4
 80a4502:	f7fb fdde 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRH = fastPinGetPinmap()[_pin].gpio_pin;
 80a4506:	682b      	ldr	r3, [r5, #0]
 80a4508:	9a01      	ldr	r2, [sp, #4]
 80a450a:	599b      	ldr	r3, [r3, r6]
 80a450c:	8892      	ldrh	r2, [r2, #4]
    for(uint8_t bit = 0x80; bit; bit >>= 1) {
 80a450e:	f1ba 0a01 	subs.w	sl, sl, #1
 80a4512:	835a      	strh	r2, [r3, #26]
 80a4514:	ea4f 0b5b 	mov.w	fp, fp, lsr #1
 80a4518:	f47f af75 	bne.w	80a4406 <_ZN16Adafruit_ILI93418spiwriteEh+0x2e>
}
 80a451c:	b003      	add	sp, #12
 80a451e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a4522:	07da      	lsls	r2, r3, #31
 80a4524:	d409      	bmi.n	80a453a <_ZN16Adafruit_ILI93418spiwriteEh+0x162>
 80a4526:	4620      	mov	r0, r4
 80a4528:	f7fb fdc6 	bl	80a00b8 <__cxa_guard_acquire>
 80a452c:	b128      	cbz	r0, 80a453a <_ZN16Adafruit_ILI93418spiwriteEh+0x162>
 80a452e:	f001 f96f 	bl	80a5810 <HAL_Pin_Map>
 80a4532:	6028      	str	r0, [r5, #0]
 80a4534:	4620      	mov	r0, r4
 80a4536:	f7fb fdc4 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRH = fastPinGetPinmap()[_pin].gpio_pin;
 80a453a:	fb09 f606 	mul.w	r6, r9, r6
 80a453e:	682b      	ldr	r3, [r5, #0]
 80a4540:	4433      	add	r3, r6
 80a4542:	9301      	str	r3, [sp, #4]
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a4544:	7823      	ldrb	r3, [r4, #0]
 80a4546:	f3bf 8f5b 	dmb	ish
 80a454a:	07db      	lsls	r3, r3, #31
 80a454c:	d409      	bmi.n	80a4562 <_ZN16Adafruit_ILI93418spiwriteEh+0x18a>
 80a454e:	4620      	mov	r0, r4
 80a4550:	f7fb fdb2 	bl	80a00b8 <__cxa_guard_acquire>
 80a4554:	b128      	cbz	r0, 80a4562 <_ZN16Adafruit_ILI93418spiwriteEh+0x18a>
 80a4556:	f001 f95b 	bl	80a5810 <HAL_Pin_Map>
 80a455a:	6028      	str	r0, [r5, #0]
 80a455c:	4620      	mov	r0, r4
 80a455e:	f7fb fdb0 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRH = fastPinGetPinmap()[_pin].gpio_pin;
 80a4562:	682b      	ldr	r3, [r5, #0]
 80a4564:	9a01      	ldr	r2, [sp, #4]
 80a4566:	599b      	ldr	r3, [r3, r6]
 80a4568:	8892      	ldrh	r2, [r2, #4]
 80a456a:	835a      	strh	r2, [r3, #26]
}
 80a456c:	e77a      	b.n	80a4464 <_ZN16Adafruit_ILI93418spiwriteEh+0x8c>
 80a456e:	bf00      	nop
 80a4570:	20000d94 	.word	0x20000d94
 80a4574:	20000d98 	.word	0x20000d98

080a4578 <_ZN16Adafruit_ILI934112writecommandEh>:
void Adafruit_ILI9341::writecommand(uint8_t c) {
 80a4578:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a457c:	4d5a      	ldr	r5, [pc, #360]	; (80a46e8 <_ZN16Adafruit_ILI934112writecommandEh+0x170>)
  pinResetFast(_dc);
 80a457e:	f990 702c 	ldrsb.w	r7, [r0, #44]	; 0x2c
 80a4582:	782b      	ldrb	r3, [r5, #0]
void Adafruit_ILI9341::writecommand(uint8_t c) {
 80a4584:	4606      	mov	r6, r0
 80a4586:	f013 0f01 	tst.w	r3, #1
 80a458a:	4688      	mov	r8, r1
 80a458c:	f3bf 8f5b 	dmb	ish
 80a4590:	4c56      	ldr	r4, [pc, #344]	; (80a46ec <_ZN16Adafruit_ILI934112writecommandEh+0x174>)
  pinResetFast(_dc);
 80a4592:	b2bf      	uxth	r7, r7
 80a4594:	d109      	bne.n	80a45aa <_ZN16Adafruit_ILI934112writecommandEh+0x32>
 80a4596:	4628      	mov	r0, r5
 80a4598:	f7fb fd8e 	bl	80a00b8 <__cxa_guard_acquire>
 80a459c:	b128      	cbz	r0, 80a45aa <_ZN16Adafruit_ILI934112writecommandEh+0x32>
 80a459e:	f001 f937 	bl	80a5810 <HAL_Pin_Map>
 80a45a2:	6020      	str	r0, [r4, #0]
 80a45a4:	4628      	mov	r0, r5
 80a45a6:	f7fb fd8c 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRH = fastPinGetPinmap()[_pin].gpio_pin;
 80a45aa:	231c      	movs	r3, #28
 80a45ac:	435f      	muls	r7, r3
 80a45ae:	6823      	ldr	r3, [r4, #0]
 80a45b0:	eb03 0907 	add.w	r9, r3, r7
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a45b4:	782b      	ldrb	r3, [r5, #0]
 80a45b6:	f3bf 8f5b 	dmb	ish
 80a45ba:	07d9      	lsls	r1, r3, #31
 80a45bc:	d409      	bmi.n	80a45d2 <_ZN16Adafruit_ILI934112writecommandEh+0x5a>
 80a45be:	484a      	ldr	r0, [pc, #296]	; (80a46e8 <_ZN16Adafruit_ILI934112writecommandEh+0x170>)
 80a45c0:	f7fb fd7a 	bl	80a00b8 <__cxa_guard_acquire>
 80a45c4:	b128      	cbz	r0, 80a45d2 <_ZN16Adafruit_ILI934112writecommandEh+0x5a>
 80a45c6:	f001 f923 	bl	80a5810 <HAL_Pin_Map>
 80a45ca:	6020      	str	r0, [r4, #0]
 80a45cc:	4846      	ldr	r0, [pc, #280]	; (80a46e8 <_ZN16Adafruit_ILI934112writecommandEh+0x170>)
 80a45ce:	f7fb fd78 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRH = fastPinGetPinmap()[_pin].gpio_pin;
 80a45d2:	6823      	ldr	r3, [r4, #0]
 80a45d4:	f8b9 2004 	ldrh.w	r2, [r9, #4]
 80a45d8:	59db      	ldr	r3, [r3, r7]
 80a45da:	835a      	strh	r2, [r3, #26]
  pinResetFast(_sclk);
 80a45dc:	f996 7030 	ldrsb.w	r7, [r6, #48]	; 0x30
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a45e0:	782b      	ldrb	r3, [r5, #0]
 80a45e2:	b2bf      	uxth	r7, r7
 80a45e4:	07da      	lsls	r2, r3, #31
 80a45e6:	f3bf 8f5b 	dmb	ish
 80a45ea:	d409      	bmi.n	80a4600 <_ZN16Adafruit_ILI934112writecommandEh+0x88>
 80a45ec:	483e      	ldr	r0, [pc, #248]	; (80a46e8 <_ZN16Adafruit_ILI934112writecommandEh+0x170>)
 80a45ee:	f7fb fd63 	bl	80a00b8 <__cxa_guard_acquire>
 80a45f2:	b128      	cbz	r0, 80a4600 <_ZN16Adafruit_ILI934112writecommandEh+0x88>
 80a45f4:	f001 f90c 	bl	80a5810 <HAL_Pin_Map>
 80a45f8:	6020      	str	r0, [r4, #0]
 80a45fa:	483b      	ldr	r0, [pc, #236]	; (80a46e8 <_ZN16Adafruit_ILI934112writecommandEh+0x170>)
 80a45fc:	f7fb fd61 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRH = fastPinGetPinmap()[_pin].gpio_pin;
 80a4600:	231c      	movs	r3, #28
 80a4602:	435f      	muls	r7, r3
 80a4604:	6823      	ldr	r3, [r4, #0]
 80a4606:	eb03 0907 	add.w	r9, r3, r7
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a460a:	782b      	ldrb	r3, [r5, #0]
 80a460c:	f3bf 8f5b 	dmb	ish
 80a4610:	07db      	lsls	r3, r3, #31
 80a4612:	d409      	bmi.n	80a4628 <_ZN16Adafruit_ILI934112writecommandEh+0xb0>
 80a4614:	4834      	ldr	r0, [pc, #208]	; (80a46e8 <_ZN16Adafruit_ILI934112writecommandEh+0x170>)
 80a4616:	f7fb fd4f 	bl	80a00b8 <__cxa_guard_acquire>
 80a461a:	b128      	cbz	r0, 80a4628 <_ZN16Adafruit_ILI934112writecommandEh+0xb0>
 80a461c:	f001 f8f8 	bl	80a5810 <HAL_Pin_Map>
 80a4620:	6020      	str	r0, [r4, #0]
 80a4622:	4831      	ldr	r0, [pc, #196]	; (80a46e8 <_ZN16Adafruit_ILI934112writecommandEh+0x170>)
 80a4624:	f7fb fd4d 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRH = fastPinGetPinmap()[_pin].gpio_pin;
 80a4628:	6823      	ldr	r3, [r4, #0]
 80a462a:	f8b9 2004 	ldrh.w	r2, [r9, #4]
 80a462e:	59db      	ldr	r3, [r3, r7]
 80a4630:	835a      	strh	r2, [r3, #26]
  pinResetFast(_cs);
 80a4632:	f996 702b 	ldrsb.w	r7, [r6, #43]	; 0x2b
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a4636:	782b      	ldrb	r3, [r5, #0]
 80a4638:	b2bf      	uxth	r7, r7
 80a463a:	07d8      	lsls	r0, r3, #31
 80a463c:	f3bf 8f5b 	dmb	ish
 80a4640:	d409      	bmi.n	80a4656 <_ZN16Adafruit_ILI934112writecommandEh+0xde>
 80a4642:	4829      	ldr	r0, [pc, #164]	; (80a46e8 <_ZN16Adafruit_ILI934112writecommandEh+0x170>)
 80a4644:	f7fb fd38 	bl	80a00b8 <__cxa_guard_acquire>
 80a4648:	b128      	cbz	r0, 80a4656 <_ZN16Adafruit_ILI934112writecommandEh+0xde>
 80a464a:	f001 f8e1 	bl	80a5810 <HAL_Pin_Map>
 80a464e:	6020      	str	r0, [r4, #0]
 80a4650:	4825      	ldr	r0, [pc, #148]	; (80a46e8 <_ZN16Adafruit_ILI934112writecommandEh+0x170>)
 80a4652:	f7fb fd36 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRH = fastPinGetPinmap()[_pin].gpio_pin;
 80a4656:	231c      	movs	r3, #28
 80a4658:	435f      	muls	r7, r3
 80a465a:	6823      	ldr	r3, [r4, #0]
 80a465c:	eb03 0907 	add.w	r9, r3, r7
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a4660:	782b      	ldrb	r3, [r5, #0]
 80a4662:	f3bf 8f5b 	dmb	ish
 80a4666:	07d9      	lsls	r1, r3, #31
 80a4668:	d409      	bmi.n	80a467e <_ZN16Adafruit_ILI934112writecommandEh+0x106>
 80a466a:	481f      	ldr	r0, [pc, #124]	; (80a46e8 <_ZN16Adafruit_ILI934112writecommandEh+0x170>)
 80a466c:	f7fb fd24 	bl	80a00b8 <__cxa_guard_acquire>
 80a4670:	b128      	cbz	r0, 80a467e <_ZN16Adafruit_ILI934112writecommandEh+0x106>
 80a4672:	f001 f8cd 	bl	80a5810 <HAL_Pin_Map>
 80a4676:	6020      	str	r0, [r4, #0]
 80a4678:	481b      	ldr	r0, [pc, #108]	; (80a46e8 <_ZN16Adafruit_ILI934112writecommandEh+0x170>)
 80a467a:	f7fb fd22 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRH = fastPinGetPinmap()[_pin].gpio_pin;
 80a467e:	6823      	ldr	r3, [r4, #0]
 80a4680:	f8b9 2004 	ldrh.w	r2, [r9, #4]
 80a4684:	59db      	ldr	r3, [r3, r7]
  spiwrite(c);
 80a4686:	4630      	mov	r0, r6
 80a4688:	835a      	strh	r2, [r3, #26]
 80a468a:	4641      	mov	r1, r8
 80a468c:	f7ff fea4 	bl	80a43d8 <_ZN16Adafruit_ILI93418spiwriteEh>
  pinSetFast(_cs);
 80a4690:	f996 602b 	ldrsb.w	r6, [r6, #43]	; 0x2b
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a4694:	782b      	ldrb	r3, [r5, #0]
 80a4696:	b2b6      	uxth	r6, r6
 80a4698:	07da      	lsls	r2, r3, #31
 80a469a:	f3bf 8f5b 	dmb	ish
 80a469e:	d409      	bmi.n	80a46b4 <_ZN16Adafruit_ILI934112writecommandEh+0x13c>
 80a46a0:	4811      	ldr	r0, [pc, #68]	; (80a46e8 <_ZN16Adafruit_ILI934112writecommandEh+0x170>)
 80a46a2:	f7fb fd09 	bl	80a00b8 <__cxa_guard_acquire>
 80a46a6:	b128      	cbz	r0, 80a46b4 <_ZN16Adafruit_ILI934112writecommandEh+0x13c>
 80a46a8:	f001 f8b2 	bl	80a5810 <HAL_Pin_Map>
 80a46ac:	6020      	str	r0, [r4, #0]
 80a46ae:	480e      	ldr	r0, [pc, #56]	; (80a46e8 <_ZN16Adafruit_ILI934112writecommandEh+0x170>)
 80a46b0:	f7fb fd07 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRL = fastPinGetPinmap()[_pin].gpio_pin;
 80a46b4:	231c      	movs	r3, #28
 80a46b6:	435e      	muls	r6, r3
 80a46b8:	6827      	ldr	r7, [r4, #0]
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a46ba:	782b      	ldrb	r3, [r5, #0]
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRL = fastPinGetPinmap()[_pin].gpio_pin;
 80a46bc:	4437      	add	r7, r6
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a46be:	07db      	lsls	r3, r3, #31
 80a46c0:	f3bf 8f5b 	dmb	ish
 80a46c4:	d409      	bmi.n	80a46da <_ZN16Adafruit_ILI934112writecommandEh+0x162>
 80a46c6:	4808      	ldr	r0, [pc, #32]	; (80a46e8 <_ZN16Adafruit_ILI934112writecommandEh+0x170>)
 80a46c8:	f7fb fcf6 	bl	80a00b8 <__cxa_guard_acquire>
 80a46cc:	b128      	cbz	r0, 80a46da <_ZN16Adafruit_ILI934112writecommandEh+0x162>
 80a46ce:	f001 f89f 	bl	80a5810 <HAL_Pin_Map>
 80a46d2:	6020      	str	r0, [r4, #0]
 80a46d4:	4804      	ldr	r0, [pc, #16]	; (80a46e8 <_ZN16Adafruit_ILI934112writecommandEh+0x170>)
 80a46d6:	f7fb fcf4 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRL = fastPinGetPinmap()[_pin].gpio_pin;
 80a46da:	6823      	ldr	r3, [r4, #0]
 80a46dc:	88ba      	ldrh	r2, [r7, #4]
 80a46de:	599b      	ldr	r3, [r3, r6]
 80a46e0:	831a      	strh	r2, [r3, #24]
}
 80a46e2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80a46e6:	bf00      	nop
 80a46e8:	20000d94 	.word	0x20000d94
 80a46ec:	20000d98 	.word	0x20000d98

080a46f0 <_ZN16Adafruit_ILI93419writedataEh>:
void Adafruit_ILI9341::writedata(uint8_t c) {
 80a46f0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a46f4:	4d44      	ldr	r5, [pc, #272]	; (80a4808 <_ZN16Adafruit_ILI93419writedataEh+0x118>)
  pinSetFast(_dc);
 80a46f6:	f990 702c 	ldrsb.w	r7, [r0, #44]	; 0x2c
 80a46fa:	782b      	ldrb	r3, [r5, #0]
void Adafruit_ILI9341::writedata(uint8_t c) {
 80a46fc:	4606      	mov	r6, r0
 80a46fe:	f013 0f01 	tst.w	r3, #1
 80a4702:	4688      	mov	r8, r1
 80a4704:	f3bf 8f5b 	dmb	ish
 80a4708:	4c40      	ldr	r4, [pc, #256]	; (80a480c <_ZN16Adafruit_ILI93419writedataEh+0x11c>)
  pinSetFast(_dc);
 80a470a:	b2bf      	uxth	r7, r7
 80a470c:	d109      	bne.n	80a4722 <_ZN16Adafruit_ILI93419writedataEh+0x32>
 80a470e:	4628      	mov	r0, r5
 80a4710:	f7fb fcd2 	bl	80a00b8 <__cxa_guard_acquire>
 80a4714:	b128      	cbz	r0, 80a4722 <_ZN16Adafruit_ILI93419writedataEh+0x32>
 80a4716:	f001 f87b 	bl	80a5810 <HAL_Pin_Map>
 80a471a:	6020      	str	r0, [r4, #0]
 80a471c:	4628      	mov	r0, r5
 80a471e:	f7fb fcd0 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRL = fastPinGetPinmap()[_pin].gpio_pin;
 80a4722:	231c      	movs	r3, #28
 80a4724:	435f      	muls	r7, r3
 80a4726:	6823      	ldr	r3, [r4, #0]
 80a4728:	eb03 0907 	add.w	r9, r3, r7
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a472c:	782b      	ldrb	r3, [r5, #0]
 80a472e:	f3bf 8f5b 	dmb	ish
 80a4732:	07db      	lsls	r3, r3, #31
 80a4734:	d409      	bmi.n	80a474a <_ZN16Adafruit_ILI93419writedataEh+0x5a>
 80a4736:	4834      	ldr	r0, [pc, #208]	; (80a4808 <_ZN16Adafruit_ILI93419writedataEh+0x118>)
 80a4738:	f7fb fcbe 	bl	80a00b8 <__cxa_guard_acquire>
 80a473c:	b128      	cbz	r0, 80a474a <_ZN16Adafruit_ILI93419writedataEh+0x5a>
 80a473e:	f001 f867 	bl	80a5810 <HAL_Pin_Map>
 80a4742:	6020      	str	r0, [r4, #0]
 80a4744:	4830      	ldr	r0, [pc, #192]	; (80a4808 <_ZN16Adafruit_ILI93419writedataEh+0x118>)
 80a4746:	f7fb fcbc 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRL = fastPinGetPinmap()[_pin].gpio_pin;
 80a474a:	6823      	ldr	r3, [r4, #0]
 80a474c:	f8b9 2004 	ldrh.w	r2, [r9, #4]
 80a4750:	59db      	ldr	r3, [r3, r7]
 80a4752:	831a      	strh	r2, [r3, #24]
  pinResetFast(_cs);
 80a4754:	f996 702b 	ldrsb.w	r7, [r6, #43]	; 0x2b
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a4758:	782b      	ldrb	r3, [r5, #0]
 80a475a:	b2bf      	uxth	r7, r7
 80a475c:	07d8      	lsls	r0, r3, #31
 80a475e:	f3bf 8f5b 	dmb	ish
 80a4762:	d409      	bmi.n	80a4778 <_ZN16Adafruit_ILI93419writedataEh+0x88>
 80a4764:	4828      	ldr	r0, [pc, #160]	; (80a4808 <_ZN16Adafruit_ILI93419writedataEh+0x118>)
 80a4766:	f7fb fca7 	bl	80a00b8 <__cxa_guard_acquire>
 80a476a:	b128      	cbz	r0, 80a4778 <_ZN16Adafruit_ILI93419writedataEh+0x88>
 80a476c:	f001 f850 	bl	80a5810 <HAL_Pin_Map>
 80a4770:	6020      	str	r0, [r4, #0]
 80a4772:	4825      	ldr	r0, [pc, #148]	; (80a4808 <_ZN16Adafruit_ILI93419writedataEh+0x118>)
 80a4774:	f7fb fca5 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRH = fastPinGetPinmap()[_pin].gpio_pin;
 80a4778:	231c      	movs	r3, #28
 80a477a:	435f      	muls	r7, r3
 80a477c:	6823      	ldr	r3, [r4, #0]
 80a477e:	eb03 0907 	add.w	r9, r3, r7
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a4782:	782b      	ldrb	r3, [r5, #0]
 80a4784:	f3bf 8f5b 	dmb	ish
 80a4788:	07d9      	lsls	r1, r3, #31
 80a478a:	d409      	bmi.n	80a47a0 <_ZN16Adafruit_ILI93419writedataEh+0xb0>
 80a478c:	481e      	ldr	r0, [pc, #120]	; (80a4808 <_ZN16Adafruit_ILI93419writedataEh+0x118>)
 80a478e:	f7fb fc93 	bl	80a00b8 <__cxa_guard_acquire>
 80a4792:	b128      	cbz	r0, 80a47a0 <_ZN16Adafruit_ILI93419writedataEh+0xb0>
 80a4794:	f001 f83c 	bl	80a5810 <HAL_Pin_Map>
 80a4798:	6020      	str	r0, [r4, #0]
 80a479a:	481b      	ldr	r0, [pc, #108]	; (80a4808 <_ZN16Adafruit_ILI93419writedataEh+0x118>)
 80a479c:	f7fb fc91 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRH = fastPinGetPinmap()[_pin].gpio_pin;
 80a47a0:	6823      	ldr	r3, [r4, #0]
 80a47a2:	f8b9 2004 	ldrh.w	r2, [r9, #4]
 80a47a6:	59db      	ldr	r3, [r3, r7]
  spiwrite(c);
 80a47a8:	4630      	mov	r0, r6
 80a47aa:	835a      	strh	r2, [r3, #26]
 80a47ac:	4641      	mov	r1, r8
 80a47ae:	f7ff fe13 	bl	80a43d8 <_ZN16Adafruit_ILI93418spiwriteEh>
  pinSetFast(_cs);
 80a47b2:	f996 602b 	ldrsb.w	r6, [r6, #43]	; 0x2b
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a47b6:	782b      	ldrb	r3, [r5, #0]
 80a47b8:	b2b6      	uxth	r6, r6
 80a47ba:	07da      	lsls	r2, r3, #31
 80a47bc:	f3bf 8f5b 	dmb	ish
 80a47c0:	d409      	bmi.n	80a47d6 <_ZN16Adafruit_ILI93419writedataEh+0xe6>
 80a47c2:	4811      	ldr	r0, [pc, #68]	; (80a4808 <_ZN16Adafruit_ILI93419writedataEh+0x118>)
 80a47c4:	f7fb fc78 	bl	80a00b8 <__cxa_guard_acquire>
 80a47c8:	b128      	cbz	r0, 80a47d6 <_ZN16Adafruit_ILI93419writedataEh+0xe6>
 80a47ca:	f001 f821 	bl	80a5810 <HAL_Pin_Map>
 80a47ce:	6020      	str	r0, [r4, #0]
 80a47d0:	480d      	ldr	r0, [pc, #52]	; (80a4808 <_ZN16Adafruit_ILI93419writedataEh+0x118>)
 80a47d2:	f7fb fc76 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRL = fastPinGetPinmap()[_pin].gpio_pin;
 80a47d6:	231c      	movs	r3, #28
 80a47d8:	435e      	muls	r6, r3
 80a47da:	6827      	ldr	r7, [r4, #0]
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a47dc:	782b      	ldrb	r3, [r5, #0]
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRL = fastPinGetPinmap()[_pin].gpio_pin;
 80a47de:	4437      	add	r7, r6
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a47e0:	07db      	lsls	r3, r3, #31
 80a47e2:	f3bf 8f5b 	dmb	ish
 80a47e6:	d409      	bmi.n	80a47fc <_ZN16Adafruit_ILI93419writedataEh+0x10c>
 80a47e8:	4807      	ldr	r0, [pc, #28]	; (80a4808 <_ZN16Adafruit_ILI93419writedataEh+0x118>)
 80a47ea:	f7fb fc65 	bl	80a00b8 <__cxa_guard_acquire>
 80a47ee:	b128      	cbz	r0, 80a47fc <_ZN16Adafruit_ILI93419writedataEh+0x10c>
 80a47f0:	f001 f80e 	bl	80a5810 <HAL_Pin_Map>
 80a47f4:	6020      	str	r0, [r4, #0]
 80a47f6:	4804      	ldr	r0, [pc, #16]	; (80a4808 <_ZN16Adafruit_ILI93419writedataEh+0x118>)
 80a47f8:	f7fb fc63 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRL = fastPinGetPinmap()[_pin].gpio_pin;
 80a47fc:	6823      	ldr	r3, [r4, #0]
 80a47fe:	88ba      	ldrh	r2, [r7, #4]
 80a4800:	599b      	ldr	r3, [r3, r6]
 80a4802:	831a      	strh	r2, [r3, #24]
} 
 80a4804:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80a4808:	20000d94 	.word	0x20000d94
 80a480c:	20000d98 	.word	0x20000d98

080a4810 <_ZN16Adafruit_ILI934113setAddrWindowEtttt>:
 uint16_t y1) {
 80a4810:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a4814:	4604      	mov	r4, r0
 80a4816:	460f      	mov	r7, r1
 80a4818:	461e      	mov	r6, r3
 80a481a:	4615      	mov	r5, r2
  writecommand(ILI9341_CASET); // Column addr set
 80a481c:	212a      	movs	r1, #42	; 0x2a
 uint16_t y1) {
 80a481e:	f8bd 8018 	ldrh.w	r8, [sp, #24]
  writecommand(ILI9341_CASET); // Column addr set
 80a4822:	f7ff fea9 	bl	80a4578 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(x0 >> 8);
 80a4826:	4620      	mov	r0, r4
 80a4828:	0a39      	lsrs	r1, r7, #8
 80a482a:	f7ff ff61 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(x0 & 0xFF);     // XSTART 
 80a482e:	4620      	mov	r0, r4
 80a4830:	b2f9      	uxtb	r1, r7
 80a4832:	f7ff ff5d 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(x1 >> 8);
 80a4836:	4620      	mov	r0, r4
 80a4838:	0a31      	lsrs	r1, r6, #8
 80a483a:	f7ff ff59 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(x1 & 0xFF);     // XEND
 80a483e:	4620      	mov	r0, r4
 80a4840:	b2f1      	uxtb	r1, r6
 80a4842:	f7ff ff55 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writecommand(ILI9341_PASET); // Row addr set
 80a4846:	4620      	mov	r0, r4
 80a4848:	212b      	movs	r1, #43	; 0x2b
 80a484a:	f7ff fe95 	bl	80a4578 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(y0>>8);
 80a484e:	4620      	mov	r0, r4
 80a4850:	0a29      	lsrs	r1, r5, #8
 80a4852:	f7ff ff4d 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(y0);     // YSTART
 80a4856:	4620      	mov	r0, r4
 80a4858:	b2e9      	uxtb	r1, r5
 80a485a:	f7ff ff49 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(y1>>8);
 80a485e:	4620      	mov	r0, r4
 80a4860:	ea4f 2118 	mov.w	r1, r8, lsr #8
 80a4864:	f7ff ff44 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(y1);     // YEND
 80a4868:	4620      	mov	r0, r4
 80a486a:	fa5f f188 	uxtb.w	r1, r8
 80a486e:	f7ff ff3f 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writecommand(ILI9341_RAMWR); // write to RAM
 80a4872:	4620      	mov	r0, r4
}
 80a4874:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  writecommand(ILI9341_RAMWR); // write to RAM
 80a4878:	212c      	movs	r1, #44	; 0x2c
 80a487a:	f7ff be7d 	b.w	80a4578 <_ZN16Adafruit_ILI934112writecommandEh>

080a487e <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE14endTransactionEv.isra.0>:
    void endTransaction() {
 80a487e:	b508      	push	{r3, lr}
        instance().endTransaction();
 80a4880:	f7fd fb7c 	bl	80a1f7c <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8instanceEv>
    }
 80a4884:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        instance().endTransaction();
 80a4888:	f001 ba0c 	b.w	80a5ca4 <_ZN8SPIClass14endTransactionEv>

080a488c <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE16beginTransactionERKNS_11SPISettingsE.isra.0.constprop.0>:
    int32_t beginTransaction(const particle::SPISettings& settings) {
 80a488c:	b510      	push	{r4, lr}
 80a488e:	4604      	mov	r4, r0
        return instance().beginTransaction(settings);
 80a4890:	f7fd fb74 	bl	80a1f7c <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8instanceEv>
 80a4894:	4621      	mov	r1, r4
    }
 80a4896:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        return instance().beginTransaction(settings);
 80a489a:	f001 ba1d 	b.w	80a5cd8 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE>
	...

080a48a0 <_ZN16Adafruit_ILI934113invertDisplayEb>:
  }
  if (hwSPI) spi_end();
}


void Adafruit_ILI9341::invertDisplay(boolean i) {
 80a48a0:	b530      	push	{r4, r5, lr}
  if (hwSPI) spi_begin();
 80a48a2:	f890 302a 	ldrb.w	r3, [r0, #42]	; 0x2a
void Adafruit_ILI9341::invertDisplay(boolean i) {
 80a48a6:	4604      	mov	r4, r0
 80a48a8:	460d      	mov	r5, r1
 80a48aa:	b085      	sub	sp, #20
  if (hwSPI) spi_begin();
 80a48ac:	b163      	cbz	r3, 80a48c8 <_ZN16Adafruit_ILI934113invertDisplayEb+0x28>
      dataMode_{dataMode}
 80a48ae:	4b0d      	ldr	r3, [pc, #52]	; (80a48e4 <_ZN16Adafruit_ILI934113invertDisplayEb+0x44>)
  SPI.beginTransaction(SPISettings(30000000, MSBFIRST, SPI_MODE0));
 80a48b0:	4668      	mov	r0, sp
 80a48b2:	9300      	str	r3, [sp, #0]
 80a48b4:	2300      	movs	r3, #0
 80a48b6:	f88d 3004 	strb.w	r3, [sp, #4]
 80a48ba:	4b0b      	ldr	r3, [pc, #44]	; (80a48e8 <_ZN16Adafruit_ILI934113invertDisplayEb+0x48>)
 80a48bc:	9302      	str	r3, [sp, #8]
 80a48be:	2301      	movs	r3, #1
 80a48c0:	f8ad 300c 	strh.w	r3, [sp, #12]
 80a48c4:	f7ff ffe2 	bl	80a488c <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE16beginTransactionERKNS_11SPISettingsE.isra.0.constprop.0>
  writecommand(i ? ILI9341_INVON : ILI9341_INVOFF);
 80a48c8:	2d00      	cmp	r5, #0
 80a48ca:	bf14      	ite	ne
 80a48cc:	2121      	movne	r1, #33	; 0x21
 80a48ce:	2120      	moveq	r1, #32
 80a48d0:	4620      	mov	r0, r4
 80a48d2:	f7ff fe51 	bl	80a4578 <_ZN16Adafruit_ILI934112writecommandEh>
  if (hwSPI) spi_end();
 80a48d6:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
 80a48da:	b10b      	cbz	r3, 80a48e0 <_ZN16Adafruit_ILI934113invertDisplayEb+0x40>
  SPI.endTransaction();
 80a48dc:	f7ff ffcf 	bl	80a487e <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE14endTransactionEv.isra.0>
}
 80a48e0:	b005      	add	sp, #20
 80a48e2:	bd30      	pop	{r4, r5, pc}
 80a48e4:	080aa464 	.word	0x080aa464
 80a48e8:	01c9c380 	.word	0x01c9c380

080a48ec <_ZN16Adafruit_ILI934111setRotationEh>:
void Adafruit_ILI9341::setRotation(uint8_t m) {
 80a48ec:	b530      	push	{r4, r5, lr}
  if (hwSPI) spi_begin();
 80a48ee:	f890 302a 	ldrb.w	r3, [r0, #42]	; 0x2a
void Adafruit_ILI9341::setRotation(uint8_t m) {
 80a48f2:	4604      	mov	r4, r0
 80a48f4:	460d      	mov	r5, r1
 80a48f6:	b085      	sub	sp, #20
  if (hwSPI) spi_begin();
 80a48f8:	b163      	cbz	r3, 80a4914 <_ZN16Adafruit_ILI934111setRotationEh+0x28>
 80a48fa:	4b18      	ldr	r3, [pc, #96]	; (80a495c <_ZN16Adafruit_ILI934111setRotationEh+0x70>)
  SPI.beginTransaction(SPISettings(30000000, MSBFIRST, SPI_MODE0));
 80a48fc:	4668      	mov	r0, sp
 80a48fe:	9300      	str	r3, [sp, #0]
 80a4900:	2300      	movs	r3, #0
 80a4902:	f88d 3004 	strb.w	r3, [sp, #4]
 80a4906:	4b16      	ldr	r3, [pc, #88]	; (80a4960 <_ZN16Adafruit_ILI934111setRotationEh+0x74>)
 80a4908:	9302      	str	r3, [sp, #8]
 80a490a:	2301      	movs	r3, #1
 80a490c:	f8ad 300c 	strh.w	r3, [sp, #12]
 80a4910:	f7ff ffbc 	bl	80a488c <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE16beginTransactionERKNS_11SPISettingsE.isra.0.constprop.0>
  writecommand(ILI9341_MADCTL);
 80a4914:	2136      	movs	r1, #54	; 0x36
 80a4916:	4620      	mov	r0, r4
 80a4918:	f7ff fe2e 	bl	80a4578 <_ZN16Adafruit_ILI934112writecommandEh>
  rotation = m % 4; // can't be higher than 3
 80a491c:	f005 0103 	and.w	r1, r5, #3
  switch (rotation) {
 80a4920:	2902      	cmp	r1, #2
  rotation = m % 4; // can't be higher than 3
 80a4922:	7661      	strb	r1, [r4, #25]
  switch (rotation) {
 80a4924:	d016      	beq.n	80a4954 <_ZN16Adafruit_ILI934111setRotationEh+0x68>
 80a4926:	2903      	cmp	r1, #3
 80a4928:	d016      	beq.n	80a4958 <_ZN16Adafruit_ILI934111setRotationEh+0x6c>
 80a492a:	2901      	cmp	r1, #1
 80a492c:	d00c      	beq.n	80a4948 <_ZN16Adafruit_ILI934111setRotationEh+0x5c>
     writedata(MADCTL_MX | MADCTL_BGR);
 80a492e:	2148      	movs	r1, #72	; 0x48
    writedata(MADCTL_MY | MADCTL_BGR);
 80a4930:	4620      	mov	r0, r4
 80a4932:	f7ff fedd 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
     _width  = ILI9341_TFTWIDTH;
 80a4936:	4b0b      	ldr	r3, [pc, #44]	; (80a4964 <_ZN16Adafruit_ILI934111setRotationEh+0x78>)
     _width  = ILI9341_TFTHEIGHT;
 80a4938:	60e3      	str	r3, [r4, #12]
  if (hwSPI) spi_end();
 80a493a:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
 80a493e:	b10b      	cbz	r3, 80a4944 <_ZN16Adafruit_ILI934111setRotationEh+0x58>
  SPI.endTransaction();
 80a4940:	f7ff ff9d 	bl	80a487e <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE14endTransactionEv.isra.0>
}
 80a4944:	b005      	add	sp, #20
 80a4946:	bd30      	pop	{r4, r5, pc}
     writedata(MADCTL_MV | MADCTL_BGR);
 80a4948:	2128      	movs	r1, #40	; 0x28
     writedata(MADCTL_MX | MADCTL_MY | MADCTL_MV | MADCTL_BGR);
 80a494a:	4620      	mov	r0, r4
 80a494c:	f7ff fed0 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
     _width  = ILI9341_TFTHEIGHT;
 80a4950:	4b05      	ldr	r3, [pc, #20]	; (80a4968 <_ZN16Adafruit_ILI934111setRotationEh+0x7c>)
 80a4952:	e7f1      	b.n	80a4938 <_ZN16Adafruit_ILI934111setRotationEh+0x4c>
    writedata(MADCTL_MY | MADCTL_BGR);
 80a4954:	2188      	movs	r1, #136	; 0x88
 80a4956:	e7eb      	b.n	80a4930 <_ZN16Adafruit_ILI934111setRotationEh+0x44>
     writedata(MADCTL_MX | MADCTL_MY | MADCTL_MV | MADCTL_BGR);
 80a4958:	21e8      	movs	r1, #232	; 0xe8
 80a495a:	e7f6      	b.n	80a494a <_ZN16Adafruit_ILI934111setRotationEh+0x5e>
 80a495c:	080aa464 	.word	0x080aa464
 80a4960:	01c9c380 	.word	0x01c9c380
 80a4964:	014000f0 	.word	0x014000f0
 80a4968:	00f00140 	.word	0x00f00140

080a496c <_ZN16Adafruit_ILI93419drawPixelEsst>:
void Adafruit_ILI9341::drawPixel(int16_t x, int16_t y, uint16_t color) {
 80a496c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  if((x < 0) ||(x >= _width) || (y < 0) || (y >= _height)) return;
 80a4970:	1e0d      	subs	r5, r1, #0
void Adafruit_ILI9341::drawPixel(int16_t x, int16_t y, uint16_t color) {
 80a4972:	4604      	mov	r4, r0
 80a4974:	4616      	mov	r6, r2
 80a4976:	461f      	mov	r7, r3
 80a4978:	b087      	sub	sp, #28
  if((x < 0) ||(x >= _width) || (y < 0) || (y >= _height)) return;
 80a497a:	f2c0 80be 	blt.w	80a4afa <_ZN16Adafruit_ILI93419drawPixelEsst+0x18e>
 80a497e:	f9b0 300c 	ldrsh.w	r3, [r0, #12]
 80a4982:	42ab      	cmp	r3, r5
 80a4984:	f340 80b9 	ble.w	80a4afa <_ZN16Adafruit_ILI93419drawPixelEsst+0x18e>
 80a4988:	2a00      	cmp	r2, #0
 80a498a:	f2c0 80b6 	blt.w	80a4afa <_ZN16Adafruit_ILI93419drawPixelEsst+0x18e>
 80a498e:	f9b0 300e 	ldrsh.w	r3, [r0, #14]
 80a4992:	4293      	cmp	r3, r2
 80a4994:	f340 80b1 	ble.w	80a4afa <_ZN16Adafruit_ILI93419drawPixelEsst+0x18e>
  if (hwSPI) spi_begin();
 80a4998:	f890 302a 	ldrb.w	r3, [r0, #42]	; 0x2a
 80a499c:	b163      	cbz	r3, 80a49b8 <_ZN16Adafruit_ILI93419drawPixelEsst+0x4c>
 80a499e:	4b58      	ldr	r3, [pc, #352]	; (80a4b00 <_ZN16Adafruit_ILI93419drawPixelEsst+0x194>)
  SPI.beginTransaction(SPISettings(30000000, MSBFIRST, SPI_MODE0));
 80a49a0:	a802      	add	r0, sp, #8
 80a49a2:	9302      	str	r3, [sp, #8]
 80a49a4:	2300      	movs	r3, #0
 80a49a6:	f88d 300c 	strb.w	r3, [sp, #12]
 80a49aa:	4b56      	ldr	r3, [pc, #344]	; (80a4b04 <_ZN16Adafruit_ILI93419drawPixelEsst+0x198>)
 80a49ac:	9304      	str	r3, [sp, #16]
 80a49ae:	2301      	movs	r3, #1
 80a49b0:	f8ad 3014 	strh.w	r3, [sp, #20]
 80a49b4:	f7ff ff6a 	bl	80a488c <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE16beginTransactionERKNS_11SPISettingsE.isra.0.constprop.0>
  setAddrWindow(x,y,x+1,y+1);
 80a49b8:	b2b2      	uxth	r2, r6
 80a49ba:	b2a9      	uxth	r1, r5
 80a49bc:	1c50      	adds	r0, r2, #1
 80a49be:	1c4b      	adds	r3, r1, #1
 80a49c0:	b280      	uxth	r0, r0
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a49c2:	4e51      	ldr	r6, [pc, #324]	; (80a4b08 <_ZN16Adafruit_ILI93419drawPixelEsst+0x19c>)
 80a49c4:	9000      	str	r0, [sp, #0]
 80a49c6:	b29b      	uxth	r3, r3
 80a49c8:	4620      	mov	r0, r4
 80a49ca:	f7ff ff21 	bl	80a4810 <_ZN16Adafruit_ILI934113setAddrWindowEtttt>
  pinSetFast(_dc);
 80a49ce:	f994 802c 	ldrsb.w	r8, [r4, #44]	; 0x2c
 80a49d2:	7833      	ldrb	r3, [r6, #0]
 80a49d4:	4d4d      	ldr	r5, [pc, #308]	; (80a4b0c <_ZN16Adafruit_ILI93419drawPixelEsst+0x1a0>)
 80a49d6:	f013 0f01 	tst.w	r3, #1
 80a49da:	f3bf 8f5b 	dmb	ish
 80a49de:	fa1f f888 	uxth.w	r8, r8
 80a49e2:	d109      	bne.n	80a49f8 <_ZN16Adafruit_ILI93419drawPixelEsst+0x8c>
 80a49e4:	4630      	mov	r0, r6
 80a49e6:	f7fb fb67 	bl	80a00b8 <__cxa_guard_acquire>
 80a49ea:	b128      	cbz	r0, 80a49f8 <_ZN16Adafruit_ILI93419drawPixelEsst+0x8c>
 80a49ec:	f000 ff10 	bl	80a5810 <HAL_Pin_Map>
 80a49f0:	6028      	str	r0, [r5, #0]
 80a49f2:	4630      	mov	r0, r6
 80a49f4:	f7fb fb65 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRL = fastPinGetPinmap()[_pin].gpio_pin;
 80a49f8:	231c      	movs	r3, #28
 80a49fa:	fb03 f808 	mul.w	r8, r3, r8
 80a49fe:	682b      	ldr	r3, [r5, #0]
 80a4a00:	eb03 0908 	add.w	r9, r3, r8
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a4a04:	7833      	ldrb	r3, [r6, #0]
 80a4a06:	f3bf 8f5b 	dmb	ish
 80a4a0a:	07db      	lsls	r3, r3, #31
 80a4a0c:	d409      	bmi.n	80a4a22 <_ZN16Adafruit_ILI93419drawPixelEsst+0xb6>
 80a4a0e:	483e      	ldr	r0, [pc, #248]	; (80a4b08 <_ZN16Adafruit_ILI93419drawPixelEsst+0x19c>)
 80a4a10:	f7fb fb52 	bl	80a00b8 <__cxa_guard_acquire>
 80a4a14:	b128      	cbz	r0, 80a4a22 <_ZN16Adafruit_ILI93419drawPixelEsst+0xb6>
 80a4a16:	f000 fefb 	bl	80a5810 <HAL_Pin_Map>
 80a4a1a:	6028      	str	r0, [r5, #0]
 80a4a1c:	483a      	ldr	r0, [pc, #232]	; (80a4b08 <_ZN16Adafruit_ILI93419drawPixelEsst+0x19c>)
 80a4a1e:	f7fb fb50 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRL = fastPinGetPinmap()[_pin].gpio_pin;
 80a4a22:	682b      	ldr	r3, [r5, #0]
 80a4a24:	f8b9 2004 	ldrh.w	r2, [r9, #4]
 80a4a28:	f853 3008 	ldr.w	r3, [r3, r8]
 80a4a2c:	831a      	strh	r2, [r3, #24]
  pinResetFast(_cs);
 80a4a2e:	f994 802b 	ldrsb.w	r8, [r4, #43]	; 0x2b
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a4a32:	7833      	ldrb	r3, [r6, #0]
 80a4a34:	fa1f f888 	uxth.w	r8, r8
 80a4a38:	07d8      	lsls	r0, r3, #31
 80a4a3a:	f3bf 8f5b 	dmb	ish
 80a4a3e:	d409      	bmi.n	80a4a54 <_ZN16Adafruit_ILI93419drawPixelEsst+0xe8>
 80a4a40:	4831      	ldr	r0, [pc, #196]	; (80a4b08 <_ZN16Adafruit_ILI93419drawPixelEsst+0x19c>)
 80a4a42:	f7fb fb39 	bl	80a00b8 <__cxa_guard_acquire>
 80a4a46:	b128      	cbz	r0, 80a4a54 <_ZN16Adafruit_ILI93419drawPixelEsst+0xe8>
 80a4a48:	f000 fee2 	bl	80a5810 <HAL_Pin_Map>
 80a4a4c:	6028      	str	r0, [r5, #0]
 80a4a4e:	482e      	ldr	r0, [pc, #184]	; (80a4b08 <_ZN16Adafruit_ILI93419drawPixelEsst+0x19c>)
 80a4a50:	f7fb fb37 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRH = fastPinGetPinmap()[_pin].gpio_pin;
 80a4a54:	231c      	movs	r3, #28
 80a4a56:	fb03 f808 	mul.w	r8, r3, r8
 80a4a5a:	682b      	ldr	r3, [r5, #0]
 80a4a5c:	eb03 0908 	add.w	r9, r3, r8
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a4a60:	7833      	ldrb	r3, [r6, #0]
 80a4a62:	f3bf 8f5b 	dmb	ish
 80a4a66:	07d9      	lsls	r1, r3, #31
 80a4a68:	d409      	bmi.n	80a4a7e <_ZN16Adafruit_ILI93419drawPixelEsst+0x112>
 80a4a6a:	4827      	ldr	r0, [pc, #156]	; (80a4b08 <_ZN16Adafruit_ILI93419drawPixelEsst+0x19c>)
 80a4a6c:	f7fb fb24 	bl	80a00b8 <__cxa_guard_acquire>
 80a4a70:	b128      	cbz	r0, 80a4a7e <_ZN16Adafruit_ILI93419drawPixelEsst+0x112>
 80a4a72:	f000 fecd 	bl	80a5810 <HAL_Pin_Map>
 80a4a76:	6028      	str	r0, [r5, #0]
 80a4a78:	4823      	ldr	r0, [pc, #140]	; (80a4b08 <_ZN16Adafruit_ILI93419drawPixelEsst+0x19c>)
 80a4a7a:	f7fb fb22 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRH = fastPinGetPinmap()[_pin].gpio_pin;
 80a4a7e:	682b      	ldr	r3, [r5, #0]
 80a4a80:	f8b9 2004 	ldrh.w	r2, [r9, #4]
 80a4a84:	f853 3008 	ldr.w	r3, [r3, r8]
  spiwrite(color >> 8);
 80a4a88:	0a39      	lsrs	r1, r7, #8
 80a4a8a:	835a      	strh	r2, [r3, #26]
 80a4a8c:	4620      	mov	r0, r4
 80a4a8e:	f7ff fca3 	bl	80a43d8 <_ZN16Adafruit_ILI93418spiwriteEh>
  spiwrite(color);
 80a4a92:	b2f9      	uxtb	r1, r7
 80a4a94:	4620      	mov	r0, r4
 80a4a96:	f7ff fc9f 	bl	80a43d8 <_ZN16Adafruit_ILI93418spiwriteEh>
  pinSetFast(_cs);
 80a4a9a:	f994 702b 	ldrsb.w	r7, [r4, #43]	; 0x2b
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a4a9e:	7833      	ldrb	r3, [r6, #0]
 80a4aa0:	b2bf      	uxth	r7, r7
 80a4aa2:	07da      	lsls	r2, r3, #31
 80a4aa4:	f3bf 8f5b 	dmb	ish
 80a4aa8:	d409      	bmi.n	80a4abe <_ZN16Adafruit_ILI93419drawPixelEsst+0x152>
 80a4aaa:	4817      	ldr	r0, [pc, #92]	; (80a4b08 <_ZN16Adafruit_ILI93419drawPixelEsst+0x19c>)
 80a4aac:	f7fb fb04 	bl	80a00b8 <__cxa_guard_acquire>
 80a4ab0:	b128      	cbz	r0, 80a4abe <_ZN16Adafruit_ILI93419drawPixelEsst+0x152>
 80a4ab2:	f000 fead 	bl	80a5810 <HAL_Pin_Map>
 80a4ab6:	6028      	str	r0, [r5, #0]
 80a4ab8:	4813      	ldr	r0, [pc, #76]	; (80a4b08 <_ZN16Adafruit_ILI93419drawPixelEsst+0x19c>)
 80a4aba:	f7fb fb02 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRL = fastPinGetPinmap()[_pin].gpio_pin;
 80a4abe:	231c      	movs	r3, #28
 80a4ac0:	435f      	muls	r7, r3
 80a4ac2:	682b      	ldr	r3, [r5, #0]
 80a4ac4:	eb03 0807 	add.w	r8, r3, r7
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a4ac8:	7833      	ldrb	r3, [r6, #0]
 80a4aca:	f3bf 8f5b 	dmb	ish
 80a4ace:	07db      	lsls	r3, r3, #31
 80a4ad0:	d409      	bmi.n	80a4ae6 <_ZN16Adafruit_ILI93419drawPixelEsst+0x17a>
 80a4ad2:	480d      	ldr	r0, [pc, #52]	; (80a4b08 <_ZN16Adafruit_ILI93419drawPixelEsst+0x19c>)
 80a4ad4:	f7fb faf0 	bl	80a00b8 <__cxa_guard_acquire>
 80a4ad8:	b128      	cbz	r0, 80a4ae6 <_ZN16Adafruit_ILI93419drawPixelEsst+0x17a>
 80a4ada:	f000 fe99 	bl	80a5810 <HAL_Pin_Map>
 80a4ade:	6028      	str	r0, [r5, #0]
 80a4ae0:	4809      	ldr	r0, [pc, #36]	; (80a4b08 <_ZN16Adafruit_ILI93419drawPixelEsst+0x19c>)
 80a4ae2:	f7fb faee 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRL = fastPinGetPinmap()[_pin].gpio_pin;
 80a4ae6:	682b      	ldr	r3, [r5, #0]
 80a4ae8:	f8b8 2004 	ldrh.w	r2, [r8, #4]
 80a4aec:	59db      	ldr	r3, [r3, r7]
 80a4aee:	831a      	strh	r2, [r3, #24]
  if (hwSPI) spi_end();
 80a4af0:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
 80a4af4:	b10b      	cbz	r3, 80a4afa <_ZN16Adafruit_ILI93419drawPixelEsst+0x18e>
  SPI.endTransaction();
 80a4af6:	f7ff fec2 	bl	80a487e <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE14endTransactionEv.isra.0>
}
 80a4afa:	b007      	add	sp, #28
 80a4afc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80a4b00:	080aa464 	.word	0x080aa464
 80a4b04:	01c9c380 	.word	0x01c9c380
 80a4b08:	20000d94 	.word	0x20000d94
 80a4b0c:	20000d98 	.word	0x20000d98

080a4b10 <_ZN16Adafruit_ILI934113drawFastVLineEssst>:
 uint16_t color) {
 80a4b10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a4b14:	4604      	mov	r4, r0
 80a4b16:	461f      	mov	r7, r3
  if((x >= _width) || (y >= _height)) return;
 80a4b18:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 uint16_t color) {
 80a4b1c:	b087      	sub	sp, #28
  if((x >= _width) || (y >= _height)) return;
 80a4b1e:	428b      	cmp	r3, r1
 uint16_t color) {
 80a4b20:	460d      	mov	r5, r1
 80a4b22:	4610      	mov	r0, r2
 80a4b24:	f8bd a040 	ldrh.w	sl, [sp, #64]	; 0x40
  if((x >= _width) || (y >= _height)) return;
 80a4b28:	f340 80c8 	ble.w	80a4cbc <_ZN16Adafruit_ILI934113drawFastVLineEssst+0x1ac>
 80a4b2c:	f9b4 300e 	ldrsh.w	r3, [r4, #14]
 80a4b30:	4293      	cmp	r3, r2
 80a4b32:	f340 80c3 	ble.w	80a4cbc <_ZN16Adafruit_ILI934113drawFastVLineEssst+0x1ac>
  if((y+h-1) >= _height) 
 80a4b36:	4438      	add	r0, r7
 80a4b38:	4298      	cmp	r0, r3
    h = _height-y;
 80a4b3a:	fa1f f882 	uxth.w	r8, r2
 80a4b3e:	bfc4      	itt	gt
 80a4b40:	eba3 0308 	subgt.w	r3, r3, r8
 80a4b44:	b21f      	sxthgt	r7, r3
  if (hwSPI) spi_begin();
 80a4b46:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
 80a4b4a:	b163      	cbz	r3, 80a4b66 <_ZN16Adafruit_ILI934113drawFastVLineEssst+0x56>
 80a4b4c:	4b5d      	ldr	r3, [pc, #372]	; (80a4cc4 <_ZN16Adafruit_ILI934113drawFastVLineEssst+0x1b4>)
  SPI.beginTransaction(SPISettings(30000000, MSBFIRST, SPI_MODE0));
 80a4b4e:	a802      	add	r0, sp, #8
 80a4b50:	9302      	str	r3, [sp, #8]
 80a4b52:	2300      	movs	r3, #0
 80a4b54:	f88d 300c 	strb.w	r3, [sp, #12]
 80a4b58:	4b5b      	ldr	r3, [pc, #364]	; (80a4cc8 <_ZN16Adafruit_ILI934113drawFastVLineEssst+0x1b8>)
 80a4b5a:	9304      	str	r3, [sp, #16]
 80a4b5c:	2301      	movs	r3, #1
 80a4b5e:	f8ad 3014 	strh.w	r3, [sp, #20]
 80a4b62:	f7ff fe93 	bl	80a488c <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE16beginTransactionERKNS_11SPISettingsE.isra.0.constprop.0>
  setAddrWindow(x, y, x, y+h-1);
 80a4b66:	f108 30ff 	add.w	r0, r8, #4294967295	; 0xffffffff
 80a4b6a:	4438      	add	r0, r7
 80a4b6c:	b2ab      	uxth	r3, r5
 80a4b6e:	b280      	uxth	r0, r0
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a4b70:	4e56      	ldr	r6, [pc, #344]	; (80a4ccc <_ZN16Adafruit_ILI934113drawFastVLineEssst+0x1bc>)
 80a4b72:	4642      	mov	r2, r8
 80a4b74:	4619      	mov	r1, r3
 80a4b76:	9000      	str	r0, [sp, #0]
 80a4b78:	4620      	mov	r0, r4
 80a4b7a:	f7ff fe49 	bl	80a4810 <_ZN16Adafruit_ILI934113setAddrWindowEtttt>
  pinSetFast(_dc);
 80a4b7e:	f994 802c 	ldrsb.w	r8, [r4, #44]	; 0x2c
 80a4b82:	7833      	ldrb	r3, [r6, #0]
  uint8_t hi = color >> 8, lo = color;
 80a4b84:	ea4f 291a 	mov.w	r9, sl, lsr #8
 80a4b88:	f013 0f01 	tst.w	r3, #1
 80a4b8c:	f3bf 8f5b 	dmb	ish
 80a4b90:	4d4f      	ldr	r5, [pc, #316]	; (80a4cd0 <_ZN16Adafruit_ILI934113drawFastVLineEssst+0x1c0>)
 80a4b92:	fa5f fa8a 	uxtb.w	sl, sl
  pinSetFast(_dc);
 80a4b96:	fa1f f888 	uxth.w	r8, r8
 80a4b9a:	d109      	bne.n	80a4bb0 <_ZN16Adafruit_ILI934113drawFastVLineEssst+0xa0>
 80a4b9c:	4630      	mov	r0, r6
 80a4b9e:	f7fb fa8b 	bl	80a00b8 <__cxa_guard_acquire>
 80a4ba2:	b128      	cbz	r0, 80a4bb0 <_ZN16Adafruit_ILI934113drawFastVLineEssst+0xa0>
 80a4ba4:	f000 fe34 	bl	80a5810 <HAL_Pin_Map>
 80a4ba8:	6028      	str	r0, [r5, #0]
 80a4baa:	4630      	mov	r0, r6
 80a4bac:	f7fb fa89 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRL = fastPinGetPinmap()[_pin].gpio_pin;
 80a4bb0:	231c      	movs	r3, #28
 80a4bb2:	fb03 f808 	mul.w	r8, r3, r8
 80a4bb6:	682b      	ldr	r3, [r5, #0]
 80a4bb8:	eb03 0b08 	add.w	fp, r3, r8
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a4bbc:	7833      	ldrb	r3, [r6, #0]
 80a4bbe:	f3bf 8f5b 	dmb	ish
 80a4bc2:	07da      	lsls	r2, r3, #31
 80a4bc4:	d409      	bmi.n	80a4bda <_ZN16Adafruit_ILI934113drawFastVLineEssst+0xca>
 80a4bc6:	4841      	ldr	r0, [pc, #260]	; (80a4ccc <_ZN16Adafruit_ILI934113drawFastVLineEssst+0x1bc>)
 80a4bc8:	f7fb fa76 	bl	80a00b8 <__cxa_guard_acquire>
 80a4bcc:	b128      	cbz	r0, 80a4bda <_ZN16Adafruit_ILI934113drawFastVLineEssst+0xca>
 80a4bce:	f000 fe1f 	bl	80a5810 <HAL_Pin_Map>
 80a4bd2:	6028      	str	r0, [r5, #0]
 80a4bd4:	483d      	ldr	r0, [pc, #244]	; (80a4ccc <_ZN16Adafruit_ILI934113drawFastVLineEssst+0x1bc>)
 80a4bd6:	f7fb fa74 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRL = fastPinGetPinmap()[_pin].gpio_pin;
 80a4bda:	682b      	ldr	r3, [r5, #0]
 80a4bdc:	f8bb 2004 	ldrh.w	r2, [fp, #4]
 80a4be0:	f853 3008 	ldr.w	r3, [r3, r8]
 80a4be4:	831a      	strh	r2, [r3, #24]
  pinResetFast(_cs);
 80a4be6:	f994 802b 	ldrsb.w	r8, [r4, #43]	; 0x2b
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a4bea:	7833      	ldrb	r3, [r6, #0]
 80a4bec:	fa1f f888 	uxth.w	r8, r8
 80a4bf0:	07db      	lsls	r3, r3, #31
 80a4bf2:	f3bf 8f5b 	dmb	ish
 80a4bf6:	d409      	bmi.n	80a4c0c <_ZN16Adafruit_ILI934113drawFastVLineEssst+0xfc>
 80a4bf8:	4834      	ldr	r0, [pc, #208]	; (80a4ccc <_ZN16Adafruit_ILI934113drawFastVLineEssst+0x1bc>)
 80a4bfa:	f7fb fa5d 	bl	80a00b8 <__cxa_guard_acquire>
 80a4bfe:	b128      	cbz	r0, 80a4c0c <_ZN16Adafruit_ILI934113drawFastVLineEssst+0xfc>
 80a4c00:	f000 fe06 	bl	80a5810 <HAL_Pin_Map>
 80a4c04:	6028      	str	r0, [r5, #0]
 80a4c06:	4831      	ldr	r0, [pc, #196]	; (80a4ccc <_ZN16Adafruit_ILI934113drawFastVLineEssst+0x1bc>)
 80a4c08:	f7fb fa5b 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRH = fastPinGetPinmap()[_pin].gpio_pin;
 80a4c0c:	231c      	movs	r3, #28
 80a4c0e:	fb03 f808 	mul.w	r8, r3, r8
 80a4c12:	682b      	ldr	r3, [r5, #0]
 80a4c14:	eb03 0b08 	add.w	fp, r3, r8
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a4c18:	7833      	ldrb	r3, [r6, #0]
 80a4c1a:	f3bf 8f5b 	dmb	ish
 80a4c1e:	07d8      	lsls	r0, r3, #31
 80a4c20:	d409      	bmi.n	80a4c36 <_ZN16Adafruit_ILI934113drawFastVLineEssst+0x126>
 80a4c22:	482a      	ldr	r0, [pc, #168]	; (80a4ccc <_ZN16Adafruit_ILI934113drawFastVLineEssst+0x1bc>)
 80a4c24:	f7fb fa48 	bl	80a00b8 <__cxa_guard_acquire>
 80a4c28:	b128      	cbz	r0, 80a4c36 <_ZN16Adafruit_ILI934113drawFastVLineEssst+0x126>
 80a4c2a:	f000 fdf1 	bl	80a5810 <HAL_Pin_Map>
 80a4c2e:	6028      	str	r0, [r5, #0]
 80a4c30:	4826      	ldr	r0, [pc, #152]	; (80a4ccc <_ZN16Adafruit_ILI934113drawFastVLineEssst+0x1bc>)
 80a4c32:	f7fb fa46 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRH = fastPinGetPinmap()[_pin].gpio_pin;
 80a4c36:	682b      	ldr	r3, [r5, #0]
 80a4c38:	f8bb 2004 	ldrh.w	r2, [fp, #4]
 80a4c3c:	f853 3008 	ldr.w	r3, [r3, r8]
 80a4c40:	835a      	strh	r2, [r3, #26]
  while (h--) {
 80a4c42:	3f01      	subs	r7, #1
 80a4c44:	b23f      	sxth	r7, r7
 80a4c46:	1c79      	adds	r1, r7, #1
 80a4c48:	d008      	beq.n	80a4c5c <_ZN16Adafruit_ILI934113drawFastVLineEssst+0x14c>
    spiwrite(hi);
 80a4c4a:	4649      	mov	r1, r9
 80a4c4c:	4620      	mov	r0, r4
 80a4c4e:	f7ff fbc3 	bl	80a43d8 <_ZN16Adafruit_ILI93418spiwriteEh>
    spiwrite(lo);
 80a4c52:	4651      	mov	r1, sl
 80a4c54:	4620      	mov	r0, r4
 80a4c56:	f7ff fbbf 	bl	80a43d8 <_ZN16Adafruit_ILI93418spiwriteEh>
  while (h--) {
 80a4c5a:	e7f2      	b.n	80a4c42 <_ZN16Adafruit_ILI934113drawFastVLineEssst+0x132>
  pinSetFast(_cs);
 80a4c5c:	f994 702b 	ldrsb.w	r7, [r4, #43]	; 0x2b
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a4c60:	7833      	ldrb	r3, [r6, #0]
 80a4c62:	b2bf      	uxth	r7, r7
 80a4c64:	07da      	lsls	r2, r3, #31
 80a4c66:	f3bf 8f5b 	dmb	ish
 80a4c6a:	d409      	bmi.n	80a4c80 <_ZN16Adafruit_ILI934113drawFastVLineEssst+0x170>
 80a4c6c:	4817      	ldr	r0, [pc, #92]	; (80a4ccc <_ZN16Adafruit_ILI934113drawFastVLineEssst+0x1bc>)
 80a4c6e:	f7fb fa23 	bl	80a00b8 <__cxa_guard_acquire>
 80a4c72:	b128      	cbz	r0, 80a4c80 <_ZN16Adafruit_ILI934113drawFastVLineEssst+0x170>
 80a4c74:	f000 fdcc 	bl	80a5810 <HAL_Pin_Map>
 80a4c78:	6028      	str	r0, [r5, #0]
 80a4c7a:	4814      	ldr	r0, [pc, #80]	; (80a4ccc <_ZN16Adafruit_ILI934113drawFastVLineEssst+0x1bc>)
 80a4c7c:	f7fb fa21 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRL = fastPinGetPinmap()[_pin].gpio_pin;
 80a4c80:	231c      	movs	r3, #28
 80a4c82:	435f      	muls	r7, r3
 80a4c84:	682b      	ldr	r3, [r5, #0]
 80a4c86:	eb03 0807 	add.w	r8, r3, r7
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a4c8a:	7833      	ldrb	r3, [r6, #0]
 80a4c8c:	f3bf 8f5b 	dmb	ish
 80a4c90:	07db      	lsls	r3, r3, #31
 80a4c92:	d409      	bmi.n	80a4ca8 <_ZN16Adafruit_ILI934113drawFastVLineEssst+0x198>
 80a4c94:	480d      	ldr	r0, [pc, #52]	; (80a4ccc <_ZN16Adafruit_ILI934113drawFastVLineEssst+0x1bc>)
 80a4c96:	f7fb fa0f 	bl	80a00b8 <__cxa_guard_acquire>
 80a4c9a:	b128      	cbz	r0, 80a4ca8 <_ZN16Adafruit_ILI934113drawFastVLineEssst+0x198>
 80a4c9c:	f000 fdb8 	bl	80a5810 <HAL_Pin_Map>
 80a4ca0:	6028      	str	r0, [r5, #0]
 80a4ca2:	480a      	ldr	r0, [pc, #40]	; (80a4ccc <_ZN16Adafruit_ILI934113drawFastVLineEssst+0x1bc>)
 80a4ca4:	f7fb fa0d 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRL = fastPinGetPinmap()[_pin].gpio_pin;
 80a4ca8:	682b      	ldr	r3, [r5, #0]
 80a4caa:	f8b8 2004 	ldrh.w	r2, [r8, #4]
 80a4cae:	59db      	ldr	r3, [r3, r7]
 80a4cb0:	831a      	strh	r2, [r3, #24]
  if (hwSPI) spi_end();
 80a4cb2:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
 80a4cb6:	b10b      	cbz	r3, 80a4cbc <_ZN16Adafruit_ILI934113drawFastVLineEssst+0x1ac>
  SPI.endTransaction();
 80a4cb8:	f7ff fde1 	bl	80a487e <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE14endTransactionEv.isra.0>
}
 80a4cbc:	b007      	add	sp, #28
 80a4cbe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a4cc2:	bf00      	nop
 80a4cc4:	080aa464 	.word	0x080aa464
 80a4cc8:	01c9c380 	.word	0x01c9c380
 80a4ccc:	20000d94 	.word	0x20000d94
 80a4cd0:	20000d98 	.word	0x20000d98

080a4cd4 <_ZN16Adafruit_ILI934113drawFastHLineEssst>:
  uint16_t color) {
 80a4cd4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a4cd8:	4604      	mov	r4, r0
 80a4cda:	461f      	mov	r7, r3
  if((x >= _width) || (y >= _height)) return;
 80a4cdc:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  uint16_t color) {
 80a4ce0:	b087      	sub	sp, #28
  if((x >= _width) || (y >= _height)) return;
 80a4ce2:	428b      	cmp	r3, r1
  uint16_t color) {
 80a4ce4:	4608      	mov	r0, r1
 80a4ce6:	4615      	mov	r5, r2
 80a4ce8:	f8bd a040 	ldrh.w	sl, [sp, #64]	; 0x40
  if((x >= _width) || (y >= _height)) return;
 80a4cec:	f340 80c7 	ble.w	80a4e7e <_ZN16Adafruit_ILI934113drawFastHLineEssst+0x1aa>
 80a4cf0:	f9b4 200e 	ldrsh.w	r2, [r4, #14]
 80a4cf4:	42aa      	cmp	r2, r5
 80a4cf6:	f340 80c2 	ble.w	80a4e7e <_ZN16Adafruit_ILI934113drawFastHLineEssst+0x1aa>
  if((x+w-1) >= _width)  w = _width-x;
 80a4cfa:	4438      	add	r0, r7
 80a4cfc:	4298      	cmp	r0, r3
 80a4cfe:	fa1f f881 	uxth.w	r8, r1
 80a4d02:	bfc4      	itt	gt
 80a4d04:	eba3 0308 	subgt.w	r3, r3, r8
 80a4d08:	b21f      	sxthgt	r7, r3
  if (hwSPI) spi_begin();
 80a4d0a:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
 80a4d0e:	b163      	cbz	r3, 80a4d2a <_ZN16Adafruit_ILI934113drawFastHLineEssst+0x56>
 80a4d10:	4b5c      	ldr	r3, [pc, #368]	; (80a4e84 <_ZN16Adafruit_ILI934113drawFastHLineEssst+0x1b0>)
  SPI.beginTransaction(SPISettings(30000000, MSBFIRST, SPI_MODE0));
 80a4d12:	a802      	add	r0, sp, #8
 80a4d14:	9302      	str	r3, [sp, #8]
 80a4d16:	2300      	movs	r3, #0
 80a4d18:	f88d 300c 	strb.w	r3, [sp, #12]
 80a4d1c:	4b5a      	ldr	r3, [pc, #360]	; (80a4e88 <_ZN16Adafruit_ILI934113drawFastHLineEssst+0x1b4>)
 80a4d1e:	9304      	str	r3, [sp, #16]
 80a4d20:	2301      	movs	r3, #1
 80a4d22:	f8ad 3014 	strh.w	r3, [sp, #20]
 80a4d26:	f7ff fdb1 	bl	80a488c <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE16beginTransactionERKNS_11SPISettingsE.isra.0.constprop.0>
  setAddrWindow(x, y, x+w-1, y);
 80a4d2a:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
 80a4d2e:	b2aa      	uxth	r2, r5
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a4d30:	4e56      	ldr	r6, [pc, #344]	; (80a4e8c <_ZN16Adafruit_ILI934113drawFastHLineEssst+0x1b8>)
 80a4d32:	443b      	add	r3, r7
 80a4d34:	4641      	mov	r1, r8
 80a4d36:	b29b      	uxth	r3, r3
 80a4d38:	4620      	mov	r0, r4
 80a4d3a:	9200      	str	r2, [sp, #0]
 80a4d3c:	f7ff fd68 	bl	80a4810 <_ZN16Adafruit_ILI934113setAddrWindowEtttt>
  pinSetFast(_dc);
 80a4d40:	f994 802c 	ldrsb.w	r8, [r4, #44]	; 0x2c
 80a4d44:	7833      	ldrb	r3, [r6, #0]
  uint8_t hi = color >> 8, lo = color;
 80a4d46:	ea4f 291a 	mov.w	r9, sl, lsr #8
 80a4d4a:	f013 0f01 	tst.w	r3, #1
 80a4d4e:	f3bf 8f5b 	dmb	ish
 80a4d52:	4d4f      	ldr	r5, [pc, #316]	; (80a4e90 <_ZN16Adafruit_ILI934113drawFastHLineEssst+0x1bc>)
 80a4d54:	fa5f fa8a 	uxtb.w	sl, sl
  pinSetFast(_dc);
 80a4d58:	fa1f f888 	uxth.w	r8, r8
 80a4d5c:	d109      	bne.n	80a4d72 <_ZN16Adafruit_ILI934113drawFastHLineEssst+0x9e>
 80a4d5e:	4630      	mov	r0, r6
 80a4d60:	f7fb f9aa 	bl	80a00b8 <__cxa_guard_acquire>
 80a4d64:	b128      	cbz	r0, 80a4d72 <_ZN16Adafruit_ILI934113drawFastHLineEssst+0x9e>
 80a4d66:	f000 fd53 	bl	80a5810 <HAL_Pin_Map>
 80a4d6a:	6028      	str	r0, [r5, #0]
 80a4d6c:	4630      	mov	r0, r6
 80a4d6e:	f7fb f9a8 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRL = fastPinGetPinmap()[_pin].gpio_pin;
 80a4d72:	231c      	movs	r3, #28
 80a4d74:	fb03 f808 	mul.w	r8, r3, r8
 80a4d78:	682b      	ldr	r3, [r5, #0]
 80a4d7a:	eb03 0b08 	add.w	fp, r3, r8
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a4d7e:	7833      	ldrb	r3, [r6, #0]
 80a4d80:	f3bf 8f5b 	dmb	ish
 80a4d84:	07da      	lsls	r2, r3, #31
 80a4d86:	d409      	bmi.n	80a4d9c <_ZN16Adafruit_ILI934113drawFastHLineEssst+0xc8>
 80a4d88:	4840      	ldr	r0, [pc, #256]	; (80a4e8c <_ZN16Adafruit_ILI934113drawFastHLineEssst+0x1b8>)
 80a4d8a:	f7fb f995 	bl	80a00b8 <__cxa_guard_acquire>
 80a4d8e:	b128      	cbz	r0, 80a4d9c <_ZN16Adafruit_ILI934113drawFastHLineEssst+0xc8>
 80a4d90:	f000 fd3e 	bl	80a5810 <HAL_Pin_Map>
 80a4d94:	6028      	str	r0, [r5, #0]
 80a4d96:	483d      	ldr	r0, [pc, #244]	; (80a4e8c <_ZN16Adafruit_ILI934113drawFastHLineEssst+0x1b8>)
 80a4d98:	f7fb f993 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRL = fastPinGetPinmap()[_pin].gpio_pin;
 80a4d9c:	682b      	ldr	r3, [r5, #0]
 80a4d9e:	f8bb 2004 	ldrh.w	r2, [fp, #4]
 80a4da2:	f853 3008 	ldr.w	r3, [r3, r8]
 80a4da6:	831a      	strh	r2, [r3, #24]
  pinResetFast(_cs);
 80a4da8:	f994 802b 	ldrsb.w	r8, [r4, #43]	; 0x2b
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a4dac:	7833      	ldrb	r3, [r6, #0]
 80a4dae:	fa1f f888 	uxth.w	r8, r8
 80a4db2:	07db      	lsls	r3, r3, #31
 80a4db4:	f3bf 8f5b 	dmb	ish
 80a4db8:	d409      	bmi.n	80a4dce <_ZN16Adafruit_ILI934113drawFastHLineEssst+0xfa>
 80a4dba:	4834      	ldr	r0, [pc, #208]	; (80a4e8c <_ZN16Adafruit_ILI934113drawFastHLineEssst+0x1b8>)
 80a4dbc:	f7fb f97c 	bl	80a00b8 <__cxa_guard_acquire>
 80a4dc0:	b128      	cbz	r0, 80a4dce <_ZN16Adafruit_ILI934113drawFastHLineEssst+0xfa>
 80a4dc2:	f000 fd25 	bl	80a5810 <HAL_Pin_Map>
 80a4dc6:	6028      	str	r0, [r5, #0]
 80a4dc8:	4830      	ldr	r0, [pc, #192]	; (80a4e8c <_ZN16Adafruit_ILI934113drawFastHLineEssst+0x1b8>)
 80a4dca:	f7fb f97a 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRH = fastPinGetPinmap()[_pin].gpio_pin;
 80a4dce:	231c      	movs	r3, #28
 80a4dd0:	fb03 f808 	mul.w	r8, r3, r8
 80a4dd4:	682b      	ldr	r3, [r5, #0]
 80a4dd6:	eb03 0b08 	add.w	fp, r3, r8
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a4dda:	7833      	ldrb	r3, [r6, #0]
 80a4ddc:	f3bf 8f5b 	dmb	ish
 80a4de0:	07d8      	lsls	r0, r3, #31
 80a4de2:	d409      	bmi.n	80a4df8 <_ZN16Adafruit_ILI934113drawFastHLineEssst+0x124>
 80a4de4:	4829      	ldr	r0, [pc, #164]	; (80a4e8c <_ZN16Adafruit_ILI934113drawFastHLineEssst+0x1b8>)
 80a4de6:	f7fb f967 	bl	80a00b8 <__cxa_guard_acquire>
 80a4dea:	b128      	cbz	r0, 80a4df8 <_ZN16Adafruit_ILI934113drawFastHLineEssst+0x124>
 80a4dec:	f000 fd10 	bl	80a5810 <HAL_Pin_Map>
 80a4df0:	6028      	str	r0, [r5, #0]
 80a4df2:	4826      	ldr	r0, [pc, #152]	; (80a4e8c <_ZN16Adafruit_ILI934113drawFastHLineEssst+0x1b8>)
 80a4df4:	f7fb f965 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRH = fastPinGetPinmap()[_pin].gpio_pin;
 80a4df8:	682b      	ldr	r3, [r5, #0]
 80a4dfa:	f8bb 2004 	ldrh.w	r2, [fp, #4]
 80a4dfe:	f853 3008 	ldr.w	r3, [r3, r8]
 80a4e02:	835a      	strh	r2, [r3, #26]
  while (w--) {
 80a4e04:	3f01      	subs	r7, #1
 80a4e06:	b23f      	sxth	r7, r7
 80a4e08:	1c79      	adds	r1, r7, #1
 80a4e0a:	d008      	beq.n	80a4e1e <_ZN16Adafruit_ILI934113drawFastHLineEssst+0x14a>
    spiwrite(hi);
 80a4e0c:	4649      	mov	r1, r9
 80a4e0e:	4620      	mov	r0, r4
 80a4e10:	f7ff fae2 	bl	80a43d8 <_ZN16Adafruit_ILI93418spiwriteEh>
    spiwrite(lo);
 80a4e14:	4651      	mov	r1, sl
 80a4e16:	4620      	mov	r0, r4
 80a4e18:	f7ff fade 	bl	80a43d8 <_ZN16Adafruit_ILI93418spiwriteEh>
  while (w--) {
 80a4e1c:	e7f2      	b.n	80a4e04 <_ZN16Adafruit_ILI934113drawFastHLineEssst+0x130>
  pinSetFast(_cs);
 80a4e1e:	f994 702b 	ldrsb.w	r7, [r4, #43]	; 0x2b
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a4e22:	7833      	ldrb	r3, [r6, #0]
 80a4e24:	b2bf      	uxth	r7, r7
 80a4e26:	07da      	lsls	r2, r3, #31
 80a4e28:	f3bf 8f5b 	dmb	ish
 80a4e2c:	d409      	bmi.n	80a4e42 <_ZN16Adafruit_ILI934113drawFastHLineEssst+0x16e>
 80a4e2e:	4817      	ldr	r0, [pc, #92]	; (80a4e8c <_ZN16Adafruit_ILI934113drawFastHLineEssst+0x1b8>)
 80a4e30:	f7fb f942 	bl	80a00b8 <__cxa_guard_acquire>
 80a4e34:	b128      	cbz	r0, 80a4e42 <_ZN16Adafruit_ILI934113drawFastHLineEssst+0x16e>
 80a4e36:	f000 fceb 	bl	80a5810 <HAL_Pin_Map>
 80a4e3a:	6028      	str	r0, [r5, #0]
 80a4e3c:	4813      	ldr	r0, [pc, #76]	; (80a4e8c <_ZN16Adafruit_ILI934113drawFastHLineEssst+0x1b8>)
 80a4e3e:	f7fb f940 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRL = fastPinGetPinmap()[_pin].gpio_pin;
 80a4e42:	231c      	movs	r3, #28
 80a4e44:	435f      	muls	r7, r3
 80a4e46:	682b      	ldr	r3, [r5, #0]
 80a4e48:	eb03 0807 	add.w	r8, r3, r7
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a4e4c:	7833      	ldrb	r3, [r6, #0]
 80a4e4e:	f3bf 8f5b 	dmb	ish
 80a4e52:	07db      	lsls	r3, r3, #31
 80a4e54:	d409      	bmi.n	80a4e6a <_ZN16Adafruit_ILI934113drawFastHLineEssst+0x196>
 80a4e56:	480d      	ldr	r0, [pc, #52]	; (80a4e8c <_ZN16Adafruit_ILI934113drawFastHLineEssst+0x1b8>)
 80a4e58:	f7fb f92e 	bl	80a00b8 <__cxa_guard_acquire>
 80a4e5c:	b128      	cbz	r0, 80a4e6a <_ZN16Adafruit_ILI934113drawFastHLineEssst+0x196>
 80a4e5e:	f000 fcd7 	bl	80a5810 <HAL_Pin_Map>
 80a4e62:	6028      	str	r0, [r5, #0]
 80a4e64:	4809      	ldr	r0, [pc, #36]	; (80a4e8c <_ZN16Adafruit_ILI934113drawFastHLineEssst+0x1b8>)
 80a4e66:	f7fb f92c 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRL = fastPinGetPinmap()[_pin].gpio_pin;
 80a4e6a:	682b      	ldr	r3, [r5, #0]
 80a4e6c:	f8b8 2004 	ldrh.w	r2, [r8, #4]
 80a4e70:	59db      	ldr	r3, [r3, r7]
 80a4e72:	831a      	strh	r2, [r3, #24]
  if (hwSPI) spi_end();
 80a4e74:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
 80a4e78:	b10b      	cbz	r3, 80a4e7e <_ZN16Adafruit_ILI934113drawFastHLineEssst+0x1aa>
  SPI.endTransaction();
 80a4e7a:	f7ff fd00 	bl	80a487e <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE14endTransactionEv.isra.0>
}
 80a4e7e:	b007      	add	sp, #28
 80a4e80:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a4e84:	080aa464 	.word	0x080aa464
 80a4e88:	01c9c380 	.word	0x01c9c380
 80a4e8c:	20000d94 	.word	0x20000d94
 80a4e90:	20000d98 	.word	0x20000d98

080a4e94 <_ZN16Adafruit_ILI93418fillRectEsssst>:
  uint16_t color) {
 80a4e94:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a4e98:	4604      	mov	r4, r0
 80a4e9a:	4698      	mov	r8, r3
  if((x >= _width) || (y >= _height)) return;
 80a4e9c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
  uint16_t color) {
 80a4ea0:	b089      	sub	sp, #36	; 0x24
  if((x >= _width) || (y >= _height)) return;
 80a4ea2:	428b      	cmp	r3, r1
  uint16_t color) {
 80a4ea4:	460d      	mov	r5, r1
 80a4ea6:	4610      	mov	r0, r2
 80a4ea8:	f9bd 7048 	ldrsh.w	r7, [sp, #72]	; 0x48
 80a4eac:	f8bd 904c 	ldrh.w	r9, [sp, #76]	; 0x4c
  if((x >= _width) || (y >= _height)) return;
 80a4eb0:	f340 80d8 	ble.w	80a5064 <_ZN16Adafruit_ILI93418fillRectEsssst+0x1d0>
 80a4eb4:	f9b4 200e 	ldrsh.w	r2, [r4, #14]
 80a4eb8:	4282      	cmp	r2, r0
 80a4eba:	f340 80d3 	ble.w	80a5064 <_ZN16Adafruit_ILI93418fillRectEsssst+0x1d0>
  if((x + w - 1) >= _width)  w = _width  - x;
 80a4ebe:	4445      	add	r5, r8
 80a4ec0:	429d      	cmp	r5, r3
 80a4ec2:	b28e      	uxth	r6, r1
 80a4ec4:	bfc8      	it	gt
 80a4ec6:	1b9b      	subgt	r3, r3, r6
 80a4ec8:	b285      	uxth	r5, r0
  if((y + h - 1) >= _height) h = _height - y;
 80a4eca:	4438      	add	r0, r7
  if((x + w - 1) >= _width)  w = _width  - x;
 80a4ecc:	bfc8      	it	gt
 80a4ece:	fa0f f883 	sxthgt.w	r8, r3
  if((y + h - 1) >= _height) h = _height - y;
 80a4ed2:	4290      	cmp	r0, r2
  if (hwSPI) spi_begin();
 80a4ed4:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
  if((y + h - 1) >= _height) h = _height - y;
 80a4ed8:	bfc4      	itt	gt
 80a4eda:	1b57      	subgt	r7, r2, r5
 80a4edc:	b23f      	sxthgt	r7, r7
  if (hwSPI) spi_begin();
 80a4ede:	b163      	cbz	r3, 80a4efa <_ZN16Adafruit_ILI93418fillRectEsssst+0x66>
 80a4ee0:	4b62      	ldr	r3, [pc, #392]	; (80a506c <_ZN16Adafruit_ILI93418fillRectEsssst+0x1d8>)
  SPI.beginTransaction(SPISettings(30000000, MSBFIRST, SPI_MODE0));
 80a4ee2:	a804      	add	r0, sp, #16
 80a4ee4:	9304      	str	r3, [sp, #16]
 80a4ee6:	2300      	movs	r3, #0
 80a4ee8:	f88d 3014 	strb.w	r3, [sp, #20]
 80a4eec:	4b60      	ldr	r3, [pc, #384]	; (80a5070 <_ZN16Adafruit_ILI93418fillRectEsssst+0x1dc>)
 80a4eee:	9306      	str	r3, [sp, #24]
 80a4ef0:	2301      	movs	r3, #1
 80a4ef2:	f8ad 301c 	strh.w	r3, [sp, #28]
 80a4ef6:	f7ff fcc9 	bl	80a488c <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE16beginTransactionERKNS_11SPISettingsE.isra.0.constprop.0>
  setAddrWindow(x, y, x+w-1, y+h-1);
 80a4efa:	1e69      	subs	r1, r5, #1
 80a4efc:	4439      	add	r1, r7
 80a4efe:	1e73      	subs	r3, r6, #1
 80a4f00:	b289      	uxth	r1, r1
 80a4f02:	9100      	str	r1, [sp, #0]
 80a4f04:	4443      	add	r3, r8
 80a4f06:	4631      	mov	r1, r6
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a4f08:	4e5a      	ldr	r6, [pc, #360]	; (80a5074 <_ZN16Adafruit_ILI93418fillRectEsssst+0x1e0>)
 80a4f0a:	462a      	mov	r2, r5
 80a4f0c:	b29b      	uxth	r3, r3
 80a4f0e:	4620      	mov	r0, r4
 80a4f10:	f7ff fc7e 	bl	80a4810 <_ZN16Adafruit_ILI934113setAddrWindowEtttt>
  pinSetFast(_dc);
 80a4f14:	f994 a02c 	ldrsb.w	sl, [r4, #44]	; 0x2c
 80a4f18:	7833      	ldrb	r3, [r6, #0]
  uint8_t hi = color >> 8, lo = color;
 80a4f1a:	ea4f 2b19 	mov.w	fp, r9, lsr #8
 80a4f1e:	f013 0f01 	tst.w	r3, #1
 80a4f22:	f3bf 8f5b 	dmb	ish
 80a4f26:	4d54      	ldr	r5, [pc, #336]	; (80a5078 <_ZN16Adafruit_ILI93418fillRectEsssst+0x1e4>)
 80a4f28:	fa5f f989 	uxtb.w	r9, r9
  pinSetFast(_dc);
 80a4f2c:	fa1f fa8a 	uxth.w	sl, sl
 80a4f30:	d109      	bne.n	80a4f46 <_ZN16Adafruit_ILI93418fillRectEsssst+0xb2>
 80a4f32:	4630      	mov	r0, r6
 80a4f34:	f7fb f8c0 	bl	80a00b8 <__cxa_guard_acquire>
 80a4f38:	b128      	cbz	r0, 80a4f46 <_ZN16Adafruit_ILI93418fillRectEsssst+0xb2>
 80a4f3a:	f000 fc69 	bl	80a5810 <HAL_Pin_Map>
 80a4f3e:	6028      	str	r0, [r5, #0]
 80a4f40:	4630      	mov	r0, r6
 80a4f42:	f7fb f8be 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRL = fastPinGetPinmap()[_pin].gpio_pin;
 80a4f46:	231c      	movs	r3, #28
 80a4f48:	fb03 fa0a 	mul.w	sl, r3, sl
 80a4f4c:	682b      	ldr	r3, [r5, #0]
 80a4f4e:	4453      	add	r3, sl
 80a4f50:	9303      	str	r3, [sp, #12]
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a4f52:	7833      	ldrb	r3, [r6, #0]
 80a4f54:	f3bf 8f5b 	dmb	ish
 80a4f58:	07db      	lsls	r3, r3, #31
 80a4f5a:	d409      	bmi.n	80a4f70 <_ZN16Adafruit_ILI93418fillRectEsssst+0xdc>
 80a4f5c:	4845      	ldr	r0, [pc, #276]	; (80a5074 <_ZN16Adafruit_ILI93418fillRectEsssst+0x1e0>)
 80a4f5e:	f7fb f8ab 	bl	80a00b8 <__cxa_guard_acquire>
 80a4f62:	b128      	cbz	r0, 80a4f70 <_ZN16Adafruit_ILI93418fillRectEsssst+0xdc>
 80a4f64:	f000 fc54 	bl	80a5810 <HAL_Pin_Map>
 80a4f68:	6028      	str	r0, [r5, #0]
 80a4f6a:	4842      	ldr	r0, [pc, #264]	; (80a5074 <_ZN16Adafruit_ILI93418fillRectEsssst+0x1e0>)
 80a4f6c:	f7fb f8a9 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRL = fastPinGetPinmap()[_pin].gpio_pin;
 80a4f70:	682b      	ldr	r3, [r5, #0]
 80a4f72:	9a03      	ldr	r2, [sp, #12]
 80a4f74:	f853 300a 	ldr.w	r3, [r3, sl]
 80a4f78:	8892      	ldrh	r2, [r2, #4]
 80a4f7a:	831a      	strh	r2, [r3, #24]
  pinResetFast(_cs);
 80a4f7c:	f994 a02b 	ldrsb.w	sl, [r4, #43]	; 0x2b
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a4f80:	7833      	ldrb	r3, [r6, #0]
 80a4f82:	fa1f fa8a 	uxth.w	sl, sl
 80a4f86:	07d8      	lsls	r0, r3, #31
 80a4f88:	f3bf 8f5b 	dmb	ish
 80a4f8c:	d409      	bmi.n	80a4fa2 <_ZN16Adafruit_ILI93418fillRectEsssst+0x10e>
 80a4f8e:	4839      	ldr	r0, [pc, #228]	; (80a5074 <_ZN16Adafruit_ILI93418fillRectEsssst+0x1e0>)
 80a4f90:	f7fb f892 	bl	80a00b8 <__cxa_guard_acquire>
 80a4f94:	b128      	cbz	r0, 80a4fa2 <_ZN16Adafruit_ILI93418fillRectEsssst+0x10e>
 80a4f96:	f000 fc3b 	bl	80a5810 <HAL_Pin_Map>
 80a4f9a:	6028      	str	r0, [r5, #0]
 80a4f9c:	4835      	ldr	r0, [pc, #212]	; (80a5074 <_ZN16Adafruit_ILI93418fillRectEsssst+0x1e0>)
 80a4f9e:	f7fb f890 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRH = fastPinGetPinmap()[_pin].gpio_pin;
 80a4fa2:	231c      	movs	r3, #28
 80a4fa4:	fb03 fa0a 	mul.w	sl, r3, sl
 80a4fa8:	682b      	ldr	r3, [r5, #0]
 80a4faa:	4453      	add	r3, sl
 80a4fac:	9303      	str	r3, [sp, #12]
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a4fae:	7833      	ldrb	r3, [r6, #0]
 80a4fb0:	f3bf 8f5b 	dmb	ish
 80a4fb4:	07d9      	lsls	r1, r3, #31
 80a4fb6:	d409      	bmi.n	80a4fcc <_ZN16Adafruit_ILI93418fillRectEsssst+0x138>
 80a4fb8:	482e      	ldr	r0, [pc, #184]	; (80a5074 <_ZN16Adafruit_ILI93418fillRectEsssst+0x1e0>)
 80a4fba:	f7fb f87d 	bl	80a00b8 <__cxa_guard_acquire>
 80a4fbe:	b128      	cbz	r0, 80a4fcc <_ZN16Adafruit_ILI93418fillRectEsssst+0x138>
 80a4fc0:	f000 fc26 	bl	80a5810 <HAL_Pin_Map>
 80a4fc4:	6028      	str	r0, [r5, #0]
 80a4fc6:	482b      	ldr	r0, [pc, #172]	; (80a5074 <_ZN16Adafruit_ILI93418fillRectEsssst+0x1e0>)
 80a4fc8:	f7fb f87b 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRH = fastPinGetPinmap()[_pin].gpio_pin;
 80a4fcc:	682b      	ldr	r3, [r5, #0]
 80a4fce:	9a03      	ldr	r2, [sp, #12]
 80a4fd0:	f853 300a 	ldr.w	r3, [r3, sl]
 80a4fd4:	8892      	ldrh	r2, [r2, #4]
 80a4fd6:	835a      	strh	r2, [r3, #26]
  for(y=h; y>0; y--) {
 80a4fd8:	2f00      	cmp	r7, #0
 80a4fda:	dd13      	ble.n	80a5004 <_ZN16Adafruit_ILI93418fillRectEsssst+0x170>
    for(x=w; x>0; x--) {
 80a4fdc:	46c2      	mov	sl, r8
 80a4fde:	f1ba 0f00 	cmp.w	sl, #0
 80a4fe2:	dd0c      	ble.n	80a4ffe <_ZN16Adafruit_ILI93418fillRectEsssst+0x16a>
      spiwrite(hi);
 80a4fe4:	4659      	mov	r1, fp
 80a4fe6:	4620      	mov	r0, r4
 80a4fe8:	f7ff f9f6 	bl	80a43d8 <_ZN16Adafruit_ILI93418spiwriteEh>
      spiwrite(lo);
 80a4fec:	f10a 3aff 	add.w	sl, sl, #4294967295	; 0xffffffff
 80a4ff0:	4649      	mov	r1, r9
 80a4ff2:	4620      	mov	r0, r4
 80a4ff4:	f7ff f9f0 	bl	80a43d8 <_ZN16Adafruit_ILI93418spiwriteEh>
    for(x=w; x>0; x--) {
 80a4ff8:	fa0f fa8a 	sxth.w	sl, sl
 80a4ffc:	e7ef      	b.n	80a4fde <_ZN16Adafruit_ILI93418fillRectEsssst+0x14a>
  for(y=h; y>0; y--) {
 80a4ffe:	3f01      	subs	r7, #1
 80a5000:	b23f      	sxth	r7, r7
 80a5002:	e7e9      	b.n	80a4fd8 <_ZN16Adafruit_ILI93418fillRectEsssst+0x144>
  pinSetFast(_cs);
 80a5004:	f994 702b 	ldrsb.w	r7, [r4, #43]	; 0x2b
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a5008:	7833      	ldrb	r3, [r6, #0]
 80a500a:	b2bf      	uxth	r7, r7
 80a500c:	07da      	lsls	r2, r3, #31
 80a500e:	f3bf 8f5b 	dmb	ish
 80a5012:	d409      	bmi.n	80a5028 <_ZN16Adafruit_ILI93418fillRectEsssst+0x194>
 80a5014:	4817      	ldr	r0, [pc, #92]	; (80a5074 <_ZN16Adafruit_ILI93418fillRectEsssst+0x1e0>)
 80a5016:	f7fb f84f 	bl	80a00b8 <__cxa_guard_acquire>
 80a501a:	b128      	cbz	r0, 80a5028 <_ZN16Adafruit_ILI93418fillRectEsssst+0x194>
 80a501c:	f000 fbf8 	bl	80a5810 <HAL_Pin_Map>
 80a5020:	6028      	str	r0, [r5, #0]
 80a5022:	4814      	ldr	r0, [pc, #80]	; (80a5074 <_ZN16Adafruit_ILI93418fillRectEsssst+0x1e0>)
 80a5024:	f7fb f84d 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRL = fastPinGetPinmap()[_pin].gpio_pin;
 80a5028:	231c      	movs	r3, #28
 80a502a:	435f      	muls	r7, r3
 80a502c:	682b      	ldr	r3, [r5, #0]
 80a502e:	eb03 0807 	add.w	r8, r3, r7
    static const Hal_Pin_Info* pinMap = HAL_Pin_Map();
 80a5032:	7833      	ldrb	r3, [r6, #0]
 80a5034:	f3bf 8f5b 	dmb	ish
 80a5038:	07db      	lsls	r3, r3, #31
 80a503a:	d409      	bmi.n	80a5050 <_ZN16Adafruit_ILI93418fillRectEsssst+0x1bc>
 80a503c:	480d      	ldr	r0, [pc, #52]	; (80a5074 <_ZN16Adafruit_ILI93418fillRectEsssst+0x1e0>)
 80a503e:	f7fb f83b 	bl	80a00b8 <__cxa_guard_acquire>
 80a5042:	b128      	cbz	r0, 80a5050 <_ZN16Adafruit_ILI93418fillRectEsssst+0x1bc>
 80a5044:	f000 fbe4 	bl	80a5810 <HAL_Pin_Map>
 80a5048:	6028      	str	r0, [r5, #0]
 80a504a:	480a      	ldr	r0, [pc, #40]	; (80a5074 <_ZN16Adafruit_ILI93418fillRectEsssst+0x1e0>)
 80a504c:	f7fb f839 	bl	80a00c2 <__cxa_guard_release>
    fastPinGetPinmap()[_pin].gpio_peripheral->BSRRL = fastPinGetPinmap()[_pin].gpio_pin;
 80a5050:	682b      	ldr	r3, [r5, #0]
 80a5052:	f8b8 2004 	ldrh.w	r2, [r8, #4]
 80a5056:	59db      	ldr	r3, [r3, r7]
 80a5058:	831a      	strh	r2, [r3, #24]
  if (hwSPI) spi_end();
 80a505a:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
 80a505e:	b10b      	cbz	r3, 80a5064 <_ZN16Adafruit_ILI93418fillRectEsssst+0x1d0>
  SPI.endTransaction();
 80a5060:	f7ff fc0d 	bl	80a487e <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE14endTransactionEv.isra.0>
}
 80a5064:	b009      	add	sp, #36	; 0x24
 80a5066:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a506a:	bf00      	nop
 80a506c:	080aa464 	.word	0x080aa464
 80a5070:	01c9c380 	.word	0x01c9c380
 80a5074:	20000d94 	.word	0x20000d94
 80a5078:	20000d98 	.word	0x20000d98

080a507c <_ZN16Adafruit_ILI93415beginEv>:
void Adafruit_ILI9341::begin(void) {
 80a507c:	b530      	push	{r4, r5, lr}
 80a507e:	4604      	mov	r4, r0
  if (_rst > 0) {
 80a5080:	f990 002d 	ldrsb.w	r0, [r0, #45]	; 0x2d
void Adafruit_ILI9341::begin(void) {
 80a5084:	b085      	sub	sp, #20
  if (_rst > 0) {
 80a5086:	2800      	cmp	r0, #0
 80a5088:	dd09      	ble.n	80a509e <_ZN16Adafruit_ILI93415beginEv+0x22>
    pinMode(_rst, OUTPUT);
 80a508a:	2101      	movs	r1, #1
 80a508c:	b280      	uxth	r0, r0
 80a508e:	f002 fa83 	bl	80a7598 <pinMode>
    digitalWrite(_rst, LOW);
 80a5092:	f994 002d 	ldrsb.w	r0, [r4, #45]	; 0x2d
 80a5096:	2100      	movs	r1, #0
 80a5098:	b280      	uxth	r0, r0
 80a509a:	f002 fa8e 	bl	80a75ba <digitalWrite>
  pinMode(_dc, OUTPUT);
 80a509e:	f994 002c 	ldrsb.w	r0, [r4, #44]	; 0x2c
 80a50a2:	2101      	movs	r1, #1
 80a50a4:	b280      	uxth	r0, r0
 80a50a6:	f002 fa77 	bl	80a7598 <pinMode>
  pinMode(_cs, OUTPUT);
 80a50aa:	f994 002b 	ldrsb.w	r0, [r4, #43]	; 0x2b
 80a50ae:	2101      	movs	r1, #1
 80a50b0:	b280      	uxth	r0, r0
 80a50b2:	f002 fa71 	bl	80a7598 <pinMode>
  if(hwSPI) { // Using hardware SPI
 80a50b6:	f894 502a 	ldrb.w	r5, [r4, #42]	; 0x2a
 80a50ba:	2d00      	cmp	r5, #0
 80a50bc:	f000 81ac 	beq.w	80a5418 <_ZN16Adafruit_ILI93415beginEv+0x39c>
    SPI.begin(_cs);
 80a50c0:	f994 502b 	ldrsb.w	r5, [r4, #43]	; 0x2b
        instance().begin(ss_pin);
 80a50c4:	f7fc ff5a 	bl	80a1f7c <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE8instanceEv>
 80a50c8:	b2ad      	uxth	r5, r5
 80a50ca:	4629      	mov	r1, r5
 80a50cc:	f000 fdc0 	bl	80a5c50 <_ZN8SPIClass5beginEt>
  if (_rst > 0) {
 80a50d0:	f994 002d 	ldrsb.w	r0, [r4, #45]	; 0x2d
 80a50d4:	2800      	cmp	r0, #0
 80a50d6:	dd18      	ble.n	80a510a <_ZN16Adafruit_ILI93415beginEv+0x8e>
    digitalWrite(_rst, HIGH);
 80a50d8:	2101      	movs	r1, #1
 80a50da:	b280      	uxth	r0, r0
 80a50dc:	f002 fa6d 	bl	80a75ba <digitalWrite>
    delay(5);
 80a50e0:	2005      	movs	r0, #5
 80a50e2:	f001 fc13 	bl	80a690c <delay>
    digitalWrite(_rst, LOW);
 80a50e6:	f994 002d 	ldrsb.w	r0, [r4, #45]	; 0x2d
 80a50ea:	2100      	movs	r1, #0
 80a50ec:	b280      	uxth	r0, r0
 80a50ee:	f002 fa64 	bl	80a75ba <digitalWrite>
    delay(20);
 80a50f2:	2014      	movs	r0, #20
 80a50f4:	f001 fc0a 	bl	80a690c <delay>
    digitalWrite(_rst, HIGH);
 80a50f8:	f994 002d 	ldrsb.w	r0, [r4, #45]	; 0x2d
 80a50fc:	2101      	movs	r1, #1
 80a50fe:	b280      	uxth	r0, r0
 80a5100:	f002 fa5b 	bl	80a75ba <digitalWrite>
    delay(150);
 80a5104:	2096      	movs	r0, #150	; 0x96
 80a5106:	f001 fc01 	bl	80a690c <delay>
  if (hwSPI) spi_begin();
 80a510a:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
 80a510e:	b163      	cbz	r3, 80a512a <_ZN16Adafruit_ILI93415beginEv+0xae>
 80a5110:	4bcb      	ldr	r3, [pc, #812]	; (80a5440 <_ZN16Adafruit_ILI93415beginEv+0x3c4>)
  SPI.beginTransaction(SPISettings(30000000, MSBFIRST, SPI_MODE0));
 80a5112:	4668      	mov	r0, sp
 80a5114:	9300      	str	r3, [sp, #0]
 80a5116:	2300      	movs	r3, #0
 80a5118:	f88d 3004 	strb.w	r3, [sp, #4]
 80a511c:	4bc9      	ldr	r3, [pc, #804]	; (80a5444 <_ZN16Adafruit_ILI93415beginEv+0x3c8>)
 80a511e:	9302      	str	r3, [sp, #8]
 80a5120:	2301      	movs	r3, #1
 80a5122:	f8ad 300c 	strh.w	r3, [sp, #12]
 80a5126:	f7ff fbb1 	bl	80a488c <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE16beginTransactionERKNS_11SPISettingsE.isra.0.constprop.0>
  writecommand(0xEF);
 80a512a:	21ef      	movs	r1, #239	; 0xef
 80a512c:	4620      	mov	r0, r4
 80a512e:	f7ff fa23 	bl	80a4578 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x03);
 80a5132:	2103      	movs	r1, #3
 80a5134:	4620      	mov	r0, r4
 80a5136:	f7ff fadb 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x80);
 80a513a:	2180      	movs	r1, #128	; 0x80
 80a513c:	4620      	mov	r0, r4
 80a513e:	f7ff fad7 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x02);
 80a5142:	2102      	movs	r1, #2
 80a5144:	4620      	mov	r0, r4
 80a5146:	f7ff fad3 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writecommand(0xCF);  
 80a514a:	21cf      	movs	r1, #207	; 0xcf
 80a514c:	4620      	mov	r0, r4
 80a514e:	f7ff fa13 	bl	80a4578 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x00); 
 80a5152:	2100      	movs	r1, #0
 80a5154:	4620      	mov	r0, r4
 80a5156:	f7ff facb 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0XC1); 
 80a515a:	21c1      	movs	r1, #193	; 0xc1
 80a515c:	4620      	mov	r0, r4
 80a515e:	f7ff fac7 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0X30); 
 80a5162:	2130      	movs	r1, #48	; 0x30
 80a5164:	4620      	mov	r0, r4
 80a5166:	f7ff fac3 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writecommand(0xED);  
 80a516a:	21ed      	movs	r1, #237	; 0xed
 80a516c:	4620      	mov	r0, r4
 80a516e:	f7ff fa03 	bl	80a4578 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x64); 
 80a5172:	2164      	movs	r1, #100	; 0x64
 80a5174:	4620      	mov	r0, r4
 80a5176:	f7ff fabb 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x03); 
 80a517a:	2103      	movs	r1, #3
 80a517c:	4620      	mov	r0, r4
 80a517e:	f7ff fab7 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0X12); 
 80a5182:	2112      	movs	r1, #18
 80a5184:	4620      	mov	r0, r4
 80a5186:	f7ff fab3 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0X81); 
 80a518a:	2181      	movs	r1, #129	; 0x81
 80a518c:	4620      	mov	r0, r4
 80a518e:	f7ff faaf 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writecommand(0xE8);  
 80a5192:	21e8      	movs	r1, #232	; 0xe8
 80a5194:	4620      	mov	r0, r4
 80a5196:	f7ff f9ef 	bl	80a4578 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x85); 
 80a519a:	2185      	movs	r1, #133	; 0x85
 80a519c:	4620      	mov	r0, r4
 80a519e:	f7ff faa7 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x00); 
 80a51a2:	2100      	movs	r1, #0
 80a51a4:	4620      	mov	r0, r4
 80a51a6:	f7ff faa3 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x78); 
 80a51aa:	2178      	movs	r1, #120	; 0x78
 80a51ac:	4620      	mov	r0, r4
 80a51ae:	f7ff fa9f 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writecommand(0xCB);  
 80a51b2:	21cb      	movs	r1, #203	; 0xcb
 80a51b4:	4620      	mov	r0, r4
 80a51b6:	f7ff f9df 	bl	80a4578 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x39); 
 80a51ba:	2139      	movs	r1, #57	; 0x39
 80a51bc:	4620      	mov	r0, r4
 80a51be:	f7ff fa97 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x2C); 
 80a51c2:	212c      	movs	r1, #44	; 0x2c
 80a51c4:	4620      	mov	r0, r4
 80a51c6:	f7ff fa93 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x00); 
 80a51ca:	2100      	movs	r1, #0
 80a51cc:	4620      	mov	r0, r4
 80a51ce:	f7ff fa8f 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x34); 
 80a51d2:	2134      	movs	r1, #52	; 0x34
 80a51d4:	4620      	mov	r0, r4
 80a51d6:	f7ff fa8b 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x02); 
 80a51da:	2102      	movs	r1, #2
 80a51dc:	4620      	mov	r0, r4
 80a51de:	f7ff fa87 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writecommand(0xF7);  
 80a51e2:	21f7      	movs	r1, #247	; 0xf7
 80a51e4:	4620      	mov	r0, r4
 80a51e6:	f7ff f9c7 	bl	80a4578 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x20); 
 80a51ea:	2120      	movs	r1, #32
 80a51ec:	4620      	mov	r0, r4
 80a51ee:	f7ff fa7f 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writecommand(0xEA);  
 80a51f2:	21ea      	movs	r1, #234	; 0xea
 80a51f4:	4620      	mov	r0, r4
 80a51f6:	f7ff f9bf 	bl	80a4578 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x00); 
 80a51fa:	2100      	movs	r1, #0
 80a51fc:	4620      	mov	r0, r4
 80a51fe:	f7ff fa77 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x00); 
 80a5202:	2100      	movs	r1, #0
 80a5204:	4620      	mov	r0, r4
 80a5206:	f7ff fa73 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writecommand(ILI9341_PWCTR1);    //Power control 
 80a520a:	21c0      	movs	r1, #192	; 0xc0
 80a520c:	4620      	mov	r0, r4
 80a520e:	f7ff f9b3 	bl	80a4578 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x23);   //VRH[5:0] 
 80a5212:	2123      	movs	r1, #35	; 0x23
 80a5214:	4620      	mov	r0, r4
 80a5216:	f7ff fa6b 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writecommand(ILI9341_PWCTR2);    //Power control 
 80a521a:	21c1      	movs	r1, #193	; 0xc1
 80a521c:	4620      	mov	r0, r4
 80a521e:	f7ff f9ab 	bl	80a4578 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x10);   //SAP[2:0];BT[3:0] 
 80a5222:	2110      	movs	r1, #16
 80a5224:	4620      	mov	r0, r4
 80a5226:	f7ff fa63 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writecommand(ILI9341_VMCTR1);    //VCM control 
 80a522a:	21c5      	movs	r1, #197	; 0xc5
 80a522c:	4620      	mov	r0, r4
 80a522e:	f7ff f9a3 	bl	80a4578 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x3e); //
 80a5232:	213e      	movs	r1, #62	; 0x3e
 80a5234:	4620      	mov	r0, r4
 80a5236:	f7ff fa5b 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x28); 
 80a523a:	2128      	movs	r1, #40	; 0x28
 80a523c:	4620      	mov	r0, r4
 80a523e:	f7ff fa57 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writecommand(ILI9341_VMCTR2);    //VCM control2 
 80a5242:	21c7      	movs	r1, #199	; 0xc7
 80a5244:	4620      	mov	r0, r4
 80a5246:	f7ff f997 	bl	80a4578 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x86);  //--
 80a524a:	2186      	movs	r1, #134	; 0x86
 80a524c:	4620      	mov	r0, r4
 80a524e:	f7ff fa4f 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writecommand(ILI9341_MADCTL);    // Memory Access Control 
 80a5252:	2136      	movs	r1, #54	; 0x36
 80a5254:	4620      	mov	r0, r4
 80a5256:	f7ff f98f 	bl	80a4578 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x48);
 80a525a:	2148      	movs	r1, #72	; 0x48
 80a525c:	4620      	mov	r0, r4
 80a525e:	f7ff fa47 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writecommand(ILI9341_PIXFMT);    
 80a5262:	213a      	movs	r1, #58	; 0x3a
 80a5264:	4620      	mov	r0, r4
 80a5266:	f7ff f987 	bl	80a4578 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x55); 
 80a526a:	2155      	movs	r1, #85	; 0x55
 80a526c:	4620      	mov	r0, r4
 80a526e:	f7ff fa3f 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writecommand(ILI9341_FRMCTR1);    
 80a5272:	21b1      	movs	r1, #177	; 0xb1
 80a5274:	4620      	mov	r0, r4
 80a5276:	f7ff f97f 	bl	80a4578 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x00);  
 80a527a:	2100      	movs	r1, #0
 80a527c:	4620      	mov	r0, r4
 80a527e:	f7ff fa37 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x18); 
 80a5282:	2118      	movs	r1, #24
 80a5284:	4620      	mov	r0, r4
 80a5286:	f7ff fa33 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writecommand(ILI9341_DFUNCTR);    // Display Function Control 
 80a528a:	21b6      	movs	r1, #182	; 0xb6
 80a528c:	4620      	mov	r0, r4
 80a528e:	f7ff f973 	bl	80a4578 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x08); 
 80a5292:	2108      	movs	r1, #8
 80a5294:	4620      	mov	r0, r4
 80a5296:	f7ff fa2b 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x82);
 80a529a:	2182      	movs	r1, #130	; 0x82
 80a529c:	4620      	mov	r0, r4
 80a529e:	f7ff fa27 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x27);  
 80a52a2:	2127      	movs	r1, #39	; 0x27
 80a52a4:	4620      	mov	r0, r4
 80a52a6:	f7ff fa23 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writecommand(0xF2);    // 3Gamma Function Disable 
 80a52aa:	21f2      	movs	r1, #242	; 0xf2
 80a52ac:	4620      	mov	r0, r4
 80a52ae:	f7ff f963 	bl	80a4578 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x00); 
 80a52b2:	2100      	movs	r1, #0
 80a52b4:	4620      	mov	r0, r4
 80a52b6:	f7ff fa1b 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writecommand(ILI9341_GAMMASET);    //Gamma curve selected 
 80a52ba:	2126      	movs	r1, #38	; 0x26
 80a52bc:	4620      	mov	r0, r4
 80a52be:	f7ff f95b 	bl	80a4578 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x01); 
 80a52c2:	2101      	movs	r1, #1
 80a52c4:	4620      	mov	r0, r4
 80a52c6:	f7ff fa13 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writecommand(ILI9341_GMCTRP1);    //Set Gamma 
 80a52ca:	21e0      	movs	r1, #224	; 0xe0
 80a52cc:	4620      	mov	r0, r4
 80a52ce:	f7ff f953 	bl	80a4578 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x0F); 
 80a52d2:	210f      	movs	r1, #15
 80a52d4:	4620      	mov	r0, r4
 80a52d6:	f7ff fa0b 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x31); 
 80a52da:	2131      	movs	r1, #49	; 0x31
 80a52dc:	4620      	mov	r0, r4
 80a52de:	f7ff fa07 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x2B); 
 80a52e2:	212b      	movs	r1, #43	; 0x2b
 80a52e4:	4620      	mov	r0, r4
 80a52e6:	f7ff fa03 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x0C); 
 80a52ea:	210c      	movs	r1, #12
 80a52ec:	4620      	mov	r0, r4
 80a52ee:	f7ff f9ff 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x0E); 
 80a52f2:	210e      	movs	r1, #14
 80a52f4:	4620      	mov	r0, r4
 80a52f6:	f7ff f9fb 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x08); 
 80a52fa:	2108      	movs	r1, #8
 80a52fc:	4620      	mov	r0, r4
 80a52fe:	f7ff f9f7 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x4E); 
 80a5302:	214e      	movs	r1, #78	; 0x4e
 80a5304:	4620      	mov	r0, r4
 80a5306:	f7ff f9f3 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0xF1); 
 80a530a:	21f1      	movs	r1, #241	; 0xf1
 80a530c:	4620      	mov	r0, r4
 80a530e:	f7ff f9ef 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x37); 
 80a5312:	2137      	movs	r1, #55	; 0x37
 80a5314:	4620      	mov	r0, r4
 80a5316:	f7ff f9eb 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x07); 
 80a531a:	2107      	movs	r1, #7
 80a531c:	4620      	mov	r0, r4
 80a531e:	f7ff f9e7 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x10); 
 80a5322:	2110      	movs	r1, #16
 80a5324:	4620      	mov	r0, r4
 80a5326:	f7ff f9e3 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x03); 
 80a532a:	2103      	movs	r1, #3
 80a532c:	4620      	mov	r0, r4
 80a532e:	f7ff f9df 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x0E); 
 80a5332:	210e      	movs	r1, #14
 80a5334:	4620      	mov	r0, r4
 80a5336:	f7ff f9db 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x09); 
 80a533a:	2109      	movs	r1, #9
 80a533c:	4620      	mov	r0, r4
 80a533e:	f7ff f9d7 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x00); 
 80a5342:	2100      	movs	r1, #0
 80a5344:	4620      	mov	r0, r4
 80a5346:	f7ff f9d3 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writecommand(ILI9341_GMCTRN1);    //Set Gamma 
 80a534a:	21e1      	movs	r1, #225	; 0xe1
 80a534c:	4620      	mov	r0, r4
 80a534e:	f7ff f913 	bl	80a4578 <_ZN16Adafruit_ILI934112writecommandEh>
  writedata(0x00); 
 80a5352:	2100      	movs	r1, #0
 80a5354:	4620      	mov	r0, r4
 80a5356:	f7ff f9cb 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x0E); 
 80a535a:	210e      	movs	r1, #14
 80a535c:	4620      	mov	r0, r4
 80a535e:	f7ff f9c7 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x14); 
 80a5362:	2114      	movs	r1, #20
 80a5364:	4620      	mov	r0, r4
 80a5366:	f7ff f9c3 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x03); 
 80a536a:	2103      	movs	r1, #3
 80a536c:	4620      	mov	r0, r4
 80a536e:	f7ff f9bf 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x11); 
 80a5372:	2111      	movs	r1, #17
 80a5374:	4620      	mov	r0, r4
 80a5376:	f7ff f9bb 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x07); 
 80a537a:	2107      	movs	r1, #7
 80a537c:	4620      	mov	r0, r4
 80a537e:	f7ff f9b7 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x31); 
 80a5382:	2131      	movs	r1, #49	; 0x31
 80a5384:	4620      	mov	r0, r4
 80a5386:	f7ff f9b3 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0xC1); 
 80a538a:	21c1      	movs	r1, #193	; 0xc1
 80a538c:	4620      	mov	r0, r4
 80a538e:	f7ff f9af 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x48); 
 80a5392:	2148      	movs	r1, #72	; 0x48
 80a5394:	4620      	mov	r0, r4
 80a5396:	f7ff f9ab 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x08); 
 80a539a:	2108      	movs	r1, #8
 80a539c:	4620      	mov	r0, r4
 80a539e:	f7ff f9a7 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x0F); 
 80a53a2:	210f      	movs	r1, #15
 80a53a4:	4620      	mov	r0, r4
 80a53a6:	f7ff f9a3 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x0C); 
 80a53aa:	210c      	movs	r1, #12
 80a53ac:	4620      	mov	r0, r4
 80a53ae:	f7ff f99f 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x31); 
 80a53b2:	2131      	movs	r1, #49	; 0x31
 80a53b4:	4620      	mov	r0, r4
 80a53b6:	f7ff f99b 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x36); 
 80a53ba:	2136      	movs	r1, #54	; 0x36
 80a53bc:	4620      	mov	r0, r4
 80a53be:	f7ff f997 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writedata(0x0F); 
 80a53c2:	210f      	movs	r1, #15
 80a53c4:	4620      	mov	r0, r4
 80a53c6:	f7ff f993 	bl	80a46f0 <_ZN16Adafruit_ILI93419writedataEh>
  writecommand(ILI9341_SLPOUT);    //Exit Sleep 
 80a53ca:	2111      	movs	r1, #17
 80a53cc:	4620      	mov	r0, r4
 80a53ce:	f7ff f8d3 	bl	80a4578 <_ZN16Adafruit_ILI934112writecommandEh>
  if (hwSPI) spi_end();
 80a53d2:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
 80a53d6:	b10b      	cbz	r3, 80a53dc <_ZN16Adafruit_ILI93415beginEv+0x360>
  SPI.endTransaction();
 80a53d8:	f7ff fa51 	bl	80a487e <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE14endTransactionEv.isra.0>
  delay(120); 		
 80a53dc:	2078      	movs	r0, #120	; 0x78
 80a53de:	f001 fa95 	bl	80a690c <delay>
  if (hwSPI) spi_begin();
 80a53e2:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
 80a53e6:	b163      	cbz	r3, 80a5402 <_ZN16Adafruit_ILI93415beginEv+0x386>
 80a53e8:	4b15      	ldr	r3, [pc, #84]	; (80a5440 <_ZN16Adafruit_ILI93415beginEv+0x3c4>)
  SPI.beginTransaction(SPISettings(30000000, MSBFIRST, SPI_MODE0));
 80a53ea:	4668      	mov	r0, sp
 80a53ec:	9300      	str	r3, [sp, #0]
 80a53ee:	2300      	movs	r3, #0
 80a53f0:	f88d 3004 	strb.w	r3, [sp, #4]
 80a53f4:	4b13      	ldr	r3, [pc, #76]	; (80a5444 <_ZN16Adafruit_ILI93415beginEv+0x3c8>)
 80a53f6:	9302      	str	r3, [sp, #8]
 80a53f8:	2301      	movs	r3, #1
 80a53fa:	f8ad 300c 	strh.w	r3, [sp, #12]
 80a53fe:	f7ff fa45 	bl	80a488c <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE16beginTransactionERKNS_11SPISettingsE.isra.0.constprop.0>
  writecommand(ILI9341_DISPON);    //Display on 
 80a5402:	2129      	movs	r1, #41	; 0x29
 80a5404:	4620      	mov	r0, r4
 80a5406:	f7ff f8b7 	bl	80a4578 <_ZN16Adafruit_ILI934112writecommandEh>
  if (hwSPI) spi_end();
 80a540a:	f894 302a 	ldrb.w	r3, [r4, #42]	; 0x2a
 80a540e:	b10b      	cbz	r3, 80a5414 <_ZN16Adafruit_ILI93415beginEv+0x398>
  SPI.endTransaction();
 80a5410:	f7ff fa35 	bl	80a487e <_ZN8particle8SpiProxyIL19hal_spi_interface_t0EE14endTransactionEv.isra.0>
}
 80a5414:	b005      	add	sp, #20
 80a5416:	bd30      	pop	{r4, r5, pc}
    pinMode(_sclk, OUTPUT);
 80a5418:	f994 0030 	ldrsb.w	r0, [r4, #48]	; 0x30
 80a541c:	2101      	movs	r1, #1
 80a541e:	b280      	uxth	r0, r0
 80a5420:	f002 f8ba 	bl	80a7598 <pinMode>
    pinMode(_mosi, OUTPUT);
 80a5424:	f994 002e 	ldrsb.w	r0, [r4, #46]	; 0x2e
 80a5428:	2101      	movs	r1, #1
 80a542a:	b280      	uxth	r0, r0
 80a542c:	f002 f8b4 	bl	80a7598 <pinMode>
    pinMode(_miso, INPUT);
 80a5430:	f994 002f 	ldrsb.w	r0, [r4, #47]	; 0x2f
 80a5434:	4629      	mov	r1, r5
 80a5436:	b280      	uxth	r0, r0
 80a5438:	f002 f8ae 	bl	80a7598 <pinMode>
 80a543c:	e648      	b.n	80a50d0 <_ZN16Adafruit_ILI93415beginEv+0x54>
 80a543e:	bf00      	nop
 80a5440:	080aa464 	.word	0x080aa464
 80a5444:	01c9c380 	.word	0x01c9c380

080a5448 <inet_gethostbyname>:
DYNALIB_FN(14, hal_wlan, wlan_set_error_count, void(uint32_t))
DYNALIB_FN(15, hal_wlan, wlan_fetch_ipconfig, int(WLanConfig*))
DYNALIB_FN(16, hal_wlan, wlan_setup, void(void))

DYNALIB_FN(17, hal_wlan, HAL_NET_SetNetWatchDog, uint32_t(uint32_t))
DYNALIB_FN(18, hal_wlan, inet_gethostbyname, int(const char*, uint16_t, HAL_IPAddress*, network_interface_t, void*))
 80a5448:	b508      	push	{r3, lr}
 80a544a:	4b02      	ldr	r3, [pc, #8]	; (80a5454 <inet_gethostbyname+0xc>)
 80a544c:	681b      	ldr	r3, [r3, #0]
 80a544e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80a5450:	9301      	str	r3, [sp, #4]
 80a5452:	bd08      	pop	{r3, pc}
 80a5454:	080601c0 	.word	0x080601c0

080a5458 <HAL_USB_USART_Init>:
#endif

DYNALIB_BEGIN(hal_usb)

#ifdef USB_CDC_ENABLE
DYNALIB_FN(0, hal_usb, HAL_USB_USART_Init, void(HAL_USB_USART_Serial, const HAL_USB_USART_Config*))
 80a5458:	b508      	push	{r3, lr}
 80a545a:	4b02      	ldr	r3, [pc, #8]	; (80a5464 <HAL_USB_USART_Init+0xc>)
 80a545c:	681b      	ldr	r3, [r3, #0]
 80a545e:	681b      	ldr	r3, [r3, #0]
 80a5460:	9301      	str	r3, [sp, #4]
 80a5462:	bd08      	pop	{r3, pc}
 80a5464:	080601d8 	.word	0x080601d8

080a5468 <HAL_USB_USART_Available_Data>:
DYNALIB_FN(1, hal_usb, HAL_USB_USART_Begin, void(HAL_USB_USART_Serial, uint32_t, void *))
DYNALIB_FN(2, hal_usb, HAL_USB_USART_End, void(HAL_USB_USART_Serial))
DYNALIB_FN(3, hal_usb, HAL_USB_USART_Baud_Rate, unsigned int(HAL_USB_USART_Serial))
DYNALIB_FN(4, hal_usb, HAL_USB_USART_Available_Data, int32_t(HAL_USB_USART_Serial))
 80a5468:	b508      	push	{r3, lr}
 80a546a:	4b02      	ldr	r3, [pc, #8]	; (80a5474 <HAL_USB_USART_Available_Data+0xc>)
 80a546c:	681b      	ldr	r3, [r3, #0]
 80a546e:	691b      	ldr	r3, [r3, #16]
 80a5470:	9301      	str	r3, [sp, #4]
 80a5472:	bd08      	pop	{r3, pc}
 80a5474:	080601d8 	.word	0x080601d8

080a5478 <HAL_USB_USART_Available_Data_For_Write>:
DYNALIB_FN(5, hal_usb, HAL_USB_USART_Available_Data_For_Write, int32_t(HAL_USB_USART_Serial))
 80a5478:	b508      	push	{r3, lr}
 80a547a:	4b02      	ldr	r3, [pc, #8]	; (80a5484 <HAL_USB_USART_Available_Data_For_Write+0xc>)
 80a547c:	681b      	ldr	r3, [r3, #0]
 80a547e:	695b      	ldr	r3, [r3, #20]
 80a5480:	9301      	str	r3, [sp, #4]
 80a5482:	bd08      	pop	{r3, pc}
 80a5484:	080601d8 	.word	0x080601d8

080a5488 <HAL_USB_USART_Receive_Data>:
DYNALIB_FN(6, hal_usb, HAL_USB_USART_Receive_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
 80a5488:	b508      	push	{r3, lr}
 80a548a:	4b02      	ldr	r3, [pc, #8]	; (80a5494 <HAL_USB_USART_Receive_Data+0xc>)
 80a548c:	681b      	ldr	r3, [r3, #0]
 80a548e:	699b      	ldr	r3, [r3, #24]
 80a5490:	9301      	str	r3, [sp, #4]
 80a5492:	bd08      	pop	{r3, pc}
 80a5494:	080601d8 	.word	0x080601d8

080a5498 <HAL_USB_USART_Send_Data>:
DYNALIB_FN(7, hal_usb, HAL_USB_USART_Send_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
 80a5498:	b508      	push	{r3, lr}
 80a549a:	4b02      	ldr	r3, [pc, #8]	; (80a54a4 <HAL_USB_USART_Send_Data+0xc>)
 80a549c:	681b      	ldr	r3, [r3, #0]
 80a549e:	69db      	ldr	r3, [r3, #28]
 80a54a0:	9301      	str	r3, [sp, #4]
 80a54a2:	bd08      	pop	{r3, pc}
 80a54a4:	080601d8 	.word	0x080601d8

080a54a8 <HAL_USB_USART_Flush_Data>:
DYNALIB_FN(8, hal_usb, HAL_USB_USART_Flush_Data, void(HAL_USB_USART_Serial))
 80a54a8:	b508      	push	{r3, lr}
 80a54aa:	4b02      	ldr	r3, [pc, #8]	; (80a54b4 <HAL_USB_USART_Flush_Data+0xc>)
 80a54ac:	681b      	ldr	r3, [r3, #0]
 80a54ae:	6a1b      	ldr	r3, [r3, #32]
 80a54b0:	9301      	str	r3, [sp, #4]
 80a54b2:	bd08      	pop	{r3, pc}
 80a54b4:	080601d8 	.word	0x080601d8

080a54b8 <hal_spi_begin>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_spi)

DYNALIB_FN(0, hal_spi, hal_spi_begin, void(hal_spi_interface_t, uint16_t))
 80a54b8:	b508      	push	{r3, lr}
 80a54ba:	4b02      	ldr	r3, [pc, #8]	; (80a54c4 <hal_spi_begin+0xc>)
 80a54bc:	681b      	ldr	r3, [r3, #0]
 80a54be:	681b      	ldr	r3, [r3, #0]
 80a54c0:	9301      	str	r3, [sp, #4]
 80a54c2:	bd08      	pop	{r3, pc}
 80a54c4:	080601b4 	.word	0x080601b4

080a54c8 <hal_spi_set_bit_order>:
DYNALIB_FN(1, hal_spi, hal_spi_end, void(hal_spi_interface_t))
DYNALIB_FN(2, hal_spi, hal_spi_set_bit_order, void(hal_spi_interface_t, uint8_t))
 80a54c8:	b508      	push	{r3, lr}
 80a54ca:	4b02      	ldr	r3, [pc, #8]	; (80a54d4 <hal_spi_set_bit_order+0xc>)
 80a54cc:	681b      	ldr	r3, [r3, #0]
 80a54ce:	689b      	ldr	r3, [r3, #8]
 80a54d0:	9301      	str	r3, [sp, #4]
 80a54d2:	bd08      	pop	{r3, pc}
 80a54d4:	080601b4 	.word	0x080601b4

080a54d8 <hal_spi_set_data_mode>:
DYNALIB_FN(3, hal_spi, hal_spi_set_data_mode, void(hal_spi_interface_t, uint8_t))
 80a54d8:	b508      	push	{r3, lr}
 80a54da:	4b02      	ldr	r3, [pc, #8]	; (80a54e4 <hal_spi_set_data_mode+0xc>)
 80a54dc:	681b      	ldr	r3, [r3, #0]
 80a54de:	68db      	ldr	r3, [r3, #12]
 80a54e0:	9301      	str	r3, [sp, #4]
 80a54e2:	bd08      	pop	{r3, pc}
 80a54e4:	080601b4 	.word	0x080601b4

080a54e8 <hal_spi_set_clock_divider>:
DYNALIB_FN(4, hal_spi, hal_spi_set_clock_divider, void(hal_spi_interface_t, uint8_t))
 80a54e8:	b508      	push	{r3, lr}
 80a54ea:	4b02      	ldr	r3, [pc, #8]	; (80a54f4 <hal_spi_set_clock_divider+0xc>)
 80a54ec:	681b      	ldr	r3, [r3, #0]
 80a54ee:	691b      	ldr	r3, [r3, #16]
 80a54f0:	9301      	str	r3, [sp, #4]
 80a54f2:	bd08      	pop	{r3, pc}
 80a54f4:	080601b4 	.word	0x080601b4

080a54f8 <hal_spi_transfer>:
DYNALIB_FN(5, hal_spi, hal_spi_transfer, uint16_t(hal_spi_interface_t, uint16_t))
 80a54f8:	b508      	push	{r3, lr}
 80a54fa:	4b02      	ldr	r3, [pc, #8]	; (80a5504 <hal_spi_transfer+0xc>)
 80a54fc:	681b      	ldr	r3, [r3, #0]
 80a54fe:	695b      	ldr	r3, [r3, #20]
 80a5500:	9301      	str	r3, [sp, #4]
 80a5502:	bd08      	pop	{r3, pc}
 80a5504:	080601b4 	.word	0x080601b4

080a5508 <hal_spi_init>:
DYNALIB_FN(6, hal_spi, hal_spi_is_enabled_deprecated, bool(void))
DYNALIB_FN(7, hal_spi, hal_spi_init, void(hal_spi_interface_t))
 80a5508:	b508      	push	{r3, lr}
 80a550a:	4b02      	ldr	r3, [pc, #8]	; (80a5514 <hal_spi_init+0xc>)
 80a550c:	681b      	ldr	r3, [r3, #0]
 80a550e:	69db      	ldr	r3, [r3, #28]
 80a5510:	9301      	str	r3, [sp, #4]
 80a5512:	bd08      	pop	{r3, pc}
 80a5514:	080601b4 	.word	0x080601b4

080a5518 <hal_spi_is_enabled>:
DYNALIB_FN(8, hal_spi, hal_spi_is_enabled, bool(hal_spi_interface_t))
 80a5518:	b508      	push	{r3, lr}
 80a551a:	4b02      	ldr	r3, [pc, #8]	; (80a5524 <hal_spi_is_enabled+0xc>)
 80a551c:	681b      	ldr	r3, [r3, #0]
 80a551e:	6a1b      	ldr	r3, [r3, #32]
 80a5520:	9301      	str	r3, [sp, #4]
 80a5522:	bd08      	pop	{r3, pc}
 80a5524:	080601b4 	.word	0x080601b4

080a5528 <hal_spi_info>:
DYNALIB_FN(9, hal_spi, hal_spi_info, void(hal_spi_interface_t, hal_spi_info_t*, void*))
 80a5528:	b508      	push	{r3, lr}
 80a552a:	4b02      	ldr	r3, [pc, #8]	; (80a5534 <hal_spi_info+0xc>)
 80a552c:	681b      	ldr	r3, [r3, #0]
 80a552e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a5530:	9301      	str	r3, [sp, #4]
 80a5532:	bd08      	pop	{r3, pc}
 80a5534:	080601b4 	.word	0x080601b4

080a5538 <hal_spi_set_settings>:
DYNALIB_FN(10, hal_spi, hal_spi_transfer_dma, void(hal_spi_interface_t, void*, void*, uint32_t, hal_spi_dma_user_callback))
DYNALIB_FN(11, hal_spi, hal_spi_begin_ext, void(hal_spi_interface_t, hal_spi_mode_t, uint16_t, void*))
DYNALIB_FN(12, hal_spi, hal_spi_set_callback_on_selected, void(hal_spi_interface_t, hal_spi_select_user_callback, void*))
DYNALIB_FN(13, hal_spi, hal_spi_transfer_dma_cancel, void(hal_spi_interface_t))
DYNALIB_FN(14, hal_spi, hal_spi_transfer_dma_status, int32_t(hal_spi_interface_t, hal_spi_transfer_status_t*))
DYNALIB_FN(15, hal_spi, hal_spi_set_settings, int32_t(hal_spi_interface_t, uint8_t, uint8_t, uint8_t, uint8_t, void*))
 80a5538:	b508      	push	{r3, lr}
 80a553a:	4b02      	ldr	r3, [pc, #8]	; (80a5544 <hal_spi_set_settings+0xc>)
 80a553c:	681b      	ldr	r3, [r3, #0]
 80a553e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80a5540:	9301      	str	r3, [sp, #4]
 80a5542:	bd08      	pop	{r3, pc}
 80a5544:	080601b4 	.word	0x080601b4

080a5548 <socket_handle_valid>:
// GNINRAW

DYNALIB_BEGIN(hal_socket)

DYNALIB_FN(0, hal_socket, socket_active_status, uint8_t(sock_handle_t))
DYNALIB_FN(1, hal_socket, socket_handle_valid, uint8_t(sock_handle_t))
 80a5548:	b508      	push	{r3, lr}
 80a554a:	4b02      	ldr	r3, [pc, #8]	; (80a5554 <socket_handle_valid+0xc>)
 80a554c:	681b      	ldr	r3, [r3, #0]
 80a554e:	685b      	ldr	r3, [r3, #4]
 80a5550:	9301      	str	r3, [sp, #4]
 80a5552:	bd08      	pop	{r3, pc}
 80a5554:	080601bc 	.word	0x080601bc

080a5558 <socket_create>:
DYNALIB_FN(2, hal_socket, socket_create, sock_handle_t(uint8_t, uint8_t, uint8_t, uint16_t, network_interface_t))
 80a5558:	b508      	push	{r3, lr}
 80a555a:	4b02      	ldr	r3, [pc, #8]	; (80a5564 <socket_create+0xc>)
 80a555c:	681b      	ldr	r3, [r3, #0]
 80a555e:	689b      	ldr	r3, [r3, #8]
 80a5560:	9301      	str	r3, [sp, #4]
 80a5562:	bd08      	pop	{r3, pc}
 80a5564:	080601bc 	.word	0x080601bc

080a5568 <socket_sendto>:
DYNALIB_FN(3, hal_socket, socket_connect, int32_t(sock_handle_t, const sockaddr_t*, long))
DYNALIB_FN(4, hal_socket, socket_receive, sock_result_t(sock_handle_t, void*, socklen_t, system_tick_t))
DYNALIB_FN(5, hal_socket, socket_receivefrom, sock_result_t(sock_handle_t, void*, socklen_t, uint32_t, sockaddr_t*, socklen_t*))
DYNALIB_FN(6, hal_socket, socket_send, sock_result_t(sock_handle_t, const void*, socklen_t))
DYNALIB_FN(7, hal_socket, socket_sendto, sock_result_t(sock_handle_t, const void*, socklen_t, uint32_t, sockaddr_t*, socklen_t))
 80a5568:	b508      	push	{r3, lr}
 80a556a:	4b02      	ldr	r3, [pc, #8]	; (80a5574 <socket_sendto+0xc>)
 80a556c:	681b      	ldr	r3, [r3, #0]
 80a556e:	69db      	ldr	r3, [r3, #28]
 80a5570:	9301      	str	r3, [sp, #4]
 80a5572:	bd08      	pop	{r3, pc}
 80a5574:	080601bc 	.word	0x080601bc

080a5578 <socket_close>:
DYNALIB_FN(8, hal_socket, socket_close, sock_result_t(sock_handle_t))
 80a5578:	b508      	push	{r3, lr}
 80a557a:	4b02      	ldr	r3, [pc, #8]	; (80a5584 <socket_close+0xc>)
 80a557c:	681b      	ldr	r3, [r3, #0]
 80a557e:	6a1b      	ldr	r3, [r3, #32]
 80a5580:	9301      	str	r3, [sp, #4]
 80a5582:	bd08      	pop	{r3, pc}
 80a5584:	080601bc 	.word	0x080601bc

080a5588 <socket_handle_invalid>:
DYNALIB_FN(9, hal_socket, socket_reset_blocking_call, sock_result_t(void))
DYNALIB_FN(10, hal_socket, socket_create_tcp_server, sock_result_t(uint16_t, network_interface_t))
DYNALIB_FN(11, hal_socket, socket_accept, sock_result_t(sock_handle_t))
DYNALIB_FN(12, hal_socket, socket_handle_invalid, sock_handle_t(void))
 80a5588:	b508      	push	{r3, lr}
 80a558a:	4b02      	ldr	r3, [pc, #8]	; (80a5594 <socket_handle_invalid+0xc>)
 80a558c:	681b      	ldr	r3, [r3, #0]
 80a558e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a5590:	9301      	str	r3, [sp, #4]
 80a5592:	bd08      	pop	{r3, pc}
 80a5594:	080601bc 	.word	0x080601bc

080a5598 <socket_receivefrom_ex>:
DYNALIB_FN(13, hal_socket, socket_join_multicast, sock_result_t(const HAL_IPAddress*, network_interface_t, socket_multicast_info_t*))
DYNALIB_FN(14, hal_socket, socket_leave_multicast, sock_result_t(const HAL_IPAddress*, network_interface_t, socket_multicast_info_t*))
DYNALIB_FN(15, hal_socket, socket_peer, sock_result_t(sock_handle_t, sock_peer_t*, void*))
DYNALIB_FN(16, hal_socket, socket_shutdown, sock_result_t(sock_handle_t, int))
DYNALIB_FN(17, hal_socket, socket_send_ex, sock_result_t(sock_handle_t, const void*, socklen_t, uint32_t, system_tick_t, void*))
DYNALIB_FN(18, hal_socket, socket_receivefrom_ex, sock_result_t(sock_handle_t, void*, socklen_t, uint32_t, sockaddr_t*, socklen_t*, system_tick_t, void*))
 80a5598:	b508      	push	{r3, lr}
 80a559a:	4b02      	ldr	r3, [pc, #8]	; (80a55a4 <socket_receivefrom_ex+0xc>)
 80a559c:	681b      	ldr	r3, [r3, #0]
 80a559e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80a55a0:	9301      	str	r3, [sp, #4]
 80a55a2:	bd08      	pop	{r3, pc}
 80a55a4:	080601bc 	.word	0x080601bc

080a55a8 <hal_i2c_begin>:
#endif

DYNALIB_FN(BASE_IDX + 0, hal_i2c, hal_i2c_set_speed, void(hal_i2c_interface_t, uint32_t, void*))
DYNALIB_FN(BASE_IDX + 1, hal_i2c, hal_i2c_enable_dma_mode, void(hal_i2c_interface_t, bool, void*))
DYNALIB_FN(BASE_IDX + 2, hal_i2c, hal_i2c_stretch_clock, void(hal_i2c_interface_t, bool, void*))
DYNALIB_FN(BASE_IDX + 3, hal_i2c, hal_i2c_begin, void(hal_i2c_interface_t, hal_i2c_mode_t, uint8_t, void*))
 80a55a8:	b508      	push	{r3, lr}
 80a55aa:	4b02      	ldr	r3, [pc, #8]	; (80a55b4 <hal_i2c_begin+0xc>)
 80a55ac:	681b      	ldr	r3, [r3, #0]
 80a55ae:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80a55b0:	9301      	str	r3, [sp, #4]
 80a55b2:	bd08      	pop	{r3, pc}
 80a55b4:	080601ac 	.word	0x080601ac

080a55b8 <hal_i2c_begin_transmission>:
DYNALIB_FN(BASE_IDX + 4, hal_i2c, hal_i2c_end, void(hal_i2c_interface_t, void*))
DYNALIB_FN(BASE_IDX + 5, hal_i2c, hal_i2c_request, uint32_t(hal_i2c_interface_t, uint8_t, uint8_t, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 6, hal_i2c, hal_i2c_begin_transmission, void(hal_i2c_interface_t, uint8_t, const hal_i2c_transmission_config_t*))
 80a55b8:	b508      	push	{r3, lr}
 80a55ba:	4b02      	ldr	r3, [pc, #8]	; (80a55c4 <hal_i2c_begin_transmission+0xc>)
 80a55bc:	681b      	ldr	r3, [r3, #0]
 80a55be:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80a55c0:	9301      	str	r3, [sp, #4]
 80a55c2:	bd08      	pop	{r3, pc}
 80a55c4:	080601ac 	.word	0x080601ac

080a55c8 <hal_i2c_end_transmission>:
DYNALIB_FN(BASE_IDX + 7, hal_i2c, hal_i2c_end_transmission, uint8_t(hal_i2c_interface_t, uint8_t, void*))
 80a55c8:	b508      	push	{r3, lr}
 80a55ca:	4b02      	ldr	r3, [pc, #8]	; (80a55d4 <hal_i2c_end_transmission+0xc>)
 80a55cc:	681b      	ldr	r3, [r3, #0]
 80a55ce:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80a55d0:	9301      	str	r3, [sp, #4]
 80a55d2:	bd08      	pop	{r3, pc}
 80a55d4:	080601ac 	.word	0x080601ac

080a55d8 <hal_i2c_write>:
DYNALIB_FN(BASE_IDX + 8, hal_i2c, hal_i2c_write, uint32_t(hal_i2c_interface_t, uint8_t, void*))
 80a55d8:	b508      	push	{r3, lr}
 80a55da:	4b02      	ldr	r3, [pc, #8]	; (80a55e4 <hal_i2c_write+0xc>)
 80a55dc:	681b      	ldr	r3, [r3, #0]
 80a55de:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80a55e0:	9301      	str	r3, [sp, #4]
 80a55e2:	bd08      	pop	{r3, pc}
 80a55e4:	080601ac 	.word	0x080601ac

080a55e8 <hal_i2c_available>:
DYNALIB_FN(BASE_IDX + 9, hal_i2c, hal_i2c_available, int32_t(hal_i2c_interface_t, void*))
 80a55e8:	b508      	push	{r3, lr}
 80a55ea:	4b02      	ldr	r3, [pc, #8]	; (80a55f4 <hal_i2c_available+0xc>)
 80a55ec:	681b      	ldr	r3, [r3, #0]
 80a55ee:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80a55f0:	9301      	str	r3, [sp, #4]
 80a55f2:	bd08      	pop	{r3, pc}
 80a55f4:	080601ac 	.word	0x080601ac

080a55f8 <hal_i2c_read>:
DYNALIB_FN(BASE_IDX + 10, hal_i2c, hal_i2c_read, int32_t(hal_i2c_interface_t, void*))
 80a55f8:	b508      	push	{r3, lr}
 80a55fa:	4b02      	ldr	r3, [pc, #8]	; (80a5604 <hal_i2c_read+0xc>)
 80a55fc:	681b      	ldr	r3, [r3, #0]
 80a55fe:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80a5600:	9301      	str	r3, [sp, #4]
 80a5602:	bd08      	pop	{r3, pc}
 80a5604:	080601ac 	.word	0x080601ac

080a5608 <hal_i2c_peek>:
DYNALIB_FN(BASE_IDX + 11, hal_i2c, hal_i2c_peek, int32_t(hal_i2c_interface_t, void*))
 80a5608:	b508      	push	{r3, lr}
 80a560a:	4b02      	ldr	r3, [pc, #8]	; (80a5614 <hal_i2c_peek+0xc>)
 80a560c:	681b      	ldr	r3, [r3, #0]
 80a560e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80a5610:	9301      	str	r3, [sp, #4]
 80a5612:	bd08      	pop	{r3, pc}
 80a5614:	080601ac 	.word	0x080601ac

080a5618 <hal_i2c_flush>:
DYNALIB_FN(BASE_IDX + 12, hal_i2c, hal_i2c_flush, void(hal_i2c_interface_t, void*))
 80a5618:	b508      	push	{r3, lr}
 80a561a:	4b02      	ldr	r3, [pc, #8]	; (80a5624 <hal_i2c_flush+0xc>)
 80a561c:	681b      	ldr	r3, [r3, #0]
 80a561e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80a5620:	9301      	str	r3, [sp, #4]
 80a5622:	bd08      	pop	{r3, pc}
 80a5624:	080601ac 	.word	0x080601ac

080a5628 <hal_i2c_is_enabled>:
DYNALIB_FN(BASE_IDX + 13, hal_i2c, hal_i2c_is_enabled, bool(hal_i2c_interface_t, void*))
 80a5628:	b508      	push	{r3, lr}
 80a562a:	4b02      	ldr	r3, [pc, #8]	; (80a5634 <hal_i2c_is_enabled+0xc>)
 80a562c:	681b      	ldr	r3, [r3, #0]
 80a562e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80a5630:	9301      	str	r3, [sp, #4]
 80a5632:	bd08      	pop	{r3, pc}
 80a5634:	080601ac 	.word	0x080601ac

080a5638 <hal_i2c_init>:
DYNALIB_FN(BASE_IDX + 14, hal_i2c, hal_i2c_set_callback_on_received, void(hal_i2c_interface_t, void(*)(int), void*))
DYNALIB_FN(BASE_IDX + 15, hal_i2c, hal_i2c_set_callback_on_requested, void(hal_i2c_interface_t, void(*)(void), void*))
DYNALIB_FN(BASE_IDX + 16, hal_i2c, hal_i2c_init, int(hal_i2c_interface_t, const hal_i2c_config_t*))
 80a5638:	b508      	push	{r3, lr}
 80a563a:	4b03      	ldr	r3, [pc, #12]	; (80a5648 <hal_i2c_init+0x10>)
 80a563c:	681b      	ldr	r3, [r3, #0]
 80a563e:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80a5642:	9301      	str	r3, [sp, #4]
 80a5644:	bd08      	pop	{r3, pc}
 80a5646:	0000      	.short	0x0000
 80a5648:	080601ac 	.word	0x080601ac

080a564c <hal_i2c_request_ex>:
DYNALIB_FN(BASE_IDX + 17, hal_i2c, hal_i2c_reset, uint8_t(hal_i2c_interface_t, uint32_t, void*))
DYNALIB_FN(BASE_IDX + 18, hal_i2c, hal_i2c_lock, int32_t(hal_i2c_interface_t, void*))
DYNALIB_FN(BASE_IDX + 19, hal_i2c, hal_i2c_unlock, int32_t(hal_i2c_interface_t, void*))
DYNALIB_FN(BASE_IDX + 20, hal_i2c, hal_i2c_request_ex, int32_t(hal_i2c_interface_t, const hal_i2c_transmission_config_t*, void*))
 80a564c:	b508      	push	{r3, lr}
 80a564e:	4b03      	ldr	r3, [pc, #12]	; (80a565c <hal_i2c_request_ex+0x10>)
 80a5650:	681b      	ldr	r3, [r3, #0]
 80a5652:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80a5656:	9301      	str	r3, [sp, #4]
 80a5658:	bd08      	pop	{r3, pc}
 80a565a:	0000      	.short	0x0000
 80a565c:	080601ac 	.word	0x080601ac

080a5660 <hal_usart_init>:
#define BASE_IDX 6 // Base index for all subsequent functions
#else
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal_usart, hal_usart_init, void(hal_usart_interface_t, hal_usart_ring_buffer_t*, hal_usart_ring_buffer_t*))
 80a5660:	b508      	push	{r3, lr}
 80a5662:	4b02      	ldr	r3, [pc, #8]	; (80a566c <hal_usart_init+0xc>)
 80a5664:	681b      	ldr	r3, [r3, #0]
 80a5666:	699b      	ldr	r3, [r3, #24]
 80a5668:	9301      	str	r3, [sp, #4]
 80a566a:	bd08      	pop	{r3, pc}
 80a566c:	080601c4 	.word	0x080601c4

080a5670 <hal_usart_end>:
DYNALIB_FN(BASE_IDX + 1, hal_usart, hal_usart_begin, void(hal_usart_interface_t, uint32_t))
DYNALIB_FN(BASE_IDX + 2, hal_usart, hal_usart_end, void(hal_usart_interface_t))
 80a5670:	b508      	push	{r3, lr}
 80a5672:	4b02      	ldr	r3, [pc, #8]	; (80a567c <hal_usart_end+0xc>)
 80a5674:	681b      	ldr	r3, [r3, #0]
 80a5676:	6a1b      	ldr	r3, [r3, #32]
 80a5678:	9301      	str	r3, [sp, #4]
 80a567a:	bd08      	pop	{r3, pc}
 80a567c:	080601c4 	.word	0x080601c4

080a5680 <hal_usart_write>:
DYNALIB_FN(BASE_IDX + 3, hal_usart, hal_usart_write, uint32_t(hal_usart_interface_t, uint8_t))
 80a5680:	b508      	push	{r3, lr}
 80a5682:	4b02      	ldr	r3, [pc, #8]	; (80a568c <hal_usart_write+0xc>)
 80a5684:	681b      	ldr	r3, [r3, #0]
 80a5686:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a5688:	9301      	str	r3, [sp, #4]
 80a568a:	bd08      	pop	{r3, pc}
 80a568c:	080601c4 	.word	0x080601c4

080a5690 <hal_usart_available>:
DYNALIB_FN(BASE_IDX + 4, hal_usart, hal_usart_available, int32_t(hal_usart_interface_t))
 80a5690:	b508      	push	{r3, lr}
 80a5692:	4b02      	ldr	r3, [pc, #8]	; (80a569c <hal_usart_available+0xc>)
 80a5694:	681b      	ldr	r3, [r3, #0]
 80a5696:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a5698:	9301      	str	r3, [sp, #4]
 80a569a:	bd08      	pop	{r3, pc}
 80a569c:	080601c4 	.word	0x080601c4

080a56a0 <hal_usart_read>:
DYNALIB_FN(BASE_IDX + 5, hal_usart, hal_usart_read, int32_t(hal_usart_interface_t))
 80a56a0:	b508      	push	{r3, lr}
 80a56a2:	4b02      	ldr	r3, [pc, #8]	; (80a56ac <hal_usart_read+0xc>)
 80a56a4:	681b      	ldr	r3, [r3, #0]
 80a56a6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a56a8:	9301      	str	r3, [sp, #4]
 80a56aa:	bd08      	pop	{r3, pc}
 80a56ac:	080601c4 	.word	0x080601c4

080a56b0 <hal_usart_peek>:
DYNALIB_FN(BASE_IDX + 6, hal_usart, hal_usart_peek, int32_t(hal_usart_interface_t))
 80a56b0:	b508      	push	{r3, lr}
 80a56b2:	4b02      	ldr	r3, [pc, #8]	; (80a56bc <hal_usart_peek+0xc>)
 80a56b4:	681b      	ldr	r3, [r3, #0]
 80a56b6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a56b8:	9301      	str	r3, [sp, #4]
 80a56ba:	bd08      	pop	{r3, pc}
 80a56bc:	080601c4 	.word	0x080601c4

080a56c0 <hal_usart_flush>:
DYNALIB_FN(BASE_IDX + 7, hal_usart, hal_usart_flush, void(hal_usart_interface_t))
 80a56c0:	b508      	push	{r3, lr}
 80a56c2:	4b02      	ldr	r3, [pc, #8]	; (80a56cc <hal_usart_flush+0xc>)
 80a56c4:	681b      	ldr	r3, [r3, #0]
 80a56c6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a56c8:	9301      	str	r3, [sp, #4]
 80a56ca:	bd08      	pop	{r3, pc}
 80a56cc:	080601c4 	.word	0x080601c4

080a56d0 <hal_usart_is_enabled>:
DYNALIB_FN(BASE_IDX + 8, hal_usart, hal_usart_is_enabled, bool(hal_usart_interface_t))
 80a56d0:	b508      	push	{r3, lr}
 80a56d2:	4b02      	ldr	r3, [pc, #8]	; (80a56dc <hal_usart_is_enabled+0xc>)
 80a56d4:	681b      	ldr	r3, [r3, #0]
 80a56d6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80a56d8:	9301      	str	r3, [sp, #4]
 80a56da:	bd08      	pop	{r3, pc}
 80a56dc:	080601c4 	.word	0x080601c4

080a56e0 <hal_usart_available_data_for_write>:
DYNALIB_FN(BASE_IDX + 9, hal_usart, hal_usart_half_duplex, void(hal_usart_interface_t, bool))
DYNALIB_FN(BASE_IDX + 10, hal_usart, hal_usart_available_data_for_write, int32_t(hal_usart_interface_t))
 80a56e0:	b508      	push	{r3, lr}
 80a56e2:	4b02      	ldr	r3, [pc, #8]	; (80a56ec <hal_usart_available_data_for_write+0xc>)
 80a56e4:	681b      	ldr	r3, [r3, #0]
 80a56e6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80a56e8:	9301      	str	r3, [sp, #4]
 80a56ea:	bd08      	pop	{r3, pc}
 80a56ec:	080601c4 	.word	0x080601c4

080a56f0 <hal_usart_begin_config>:
#define BASE_IDX2 (BASE_IDX+13)
#else
#define BASE_IDX2 (BASE_IDX+11)
#endif

DYNALIB_FN(BASE_IDX2 + 0, hal_usart, hal_usart_begin_config, void(hal_usart_interface_t serial, uint32_t baud, uint32_t config, void *ptr))
 80a56f0:	b508      	push	{r3, lr}
 80a56f2:	4b02      	ldr	r3, [pc, #8]	; (80a56fc <hal_usart_begin_config+0xc>)
 80a56f4:	681b      	ldr	r3, [r3, #0]
 80a56f6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80a56f8:	9301      	str	r3, [sp, #4]
 80a56fa:	bd08      	pop	{r3, pc}
 80a56fc:	080601c4 	.word	0x080601c4

080a5700 <os_thread_yield>:

#if PLATFORM_THREADING
DYNALIB_FN(0, hal_concurrent, __gthread_equal, bool(__gthread_t, __gthread_t))
DYNALIB_FN(1, hal_concurrent, os_thread_create, os_result_t(os_thread_t*, const char*, os_thread_prio_t, os_thread_fn_t, void*, size_t))
DYNALIB_FN(2, hal_concurrent, os_thread_is_current, bool(os_thread_t))
DYNALIB_FN(3, hal_concurrent, os_thread_yield, os_result_t(void))
 80a5700:	b508      	push	{r3, lr}
 80a5702:	4b02      	ldr	r3, [pc, #8]	; (80a570c <os_thread_yield+0xc>)
 80a5704:	681b      	ldr	r3, [r3, #0]
 80a5706:	68db      	ldr	r3, [r3, #12]
 80a5708:	9301      	str	r3, [sp, #4]
 80a570a:	bd08      	pop	{r3, pc}
 80a570c:	080601d0 	.word	0x080601d0

080a5710 <os_thread_scheduling>:
DYNALIB_FN(4, hal_concurrent, os_thread_join, os_result_t(os_thread_t))
DYNALIB_FN(5, hal_concurrent, os_thread_cleanup, os_result_t(os_thread_t))
DYNALIB_FN(6, hal_concurrent, os_thread_delay_until, os_result_t(system_tick_t*, system_tick_t))
DYNALIB_FN(7, hal_concurrent, os_thread_scheduling, void(bool, void*))
 80a5710:	b508      	push	{r3, lr}
 80a5712:	4b02      	ldr	r3, [pc, #8]	; (80a571c <os_thread_scheduling+0xc>)
 80a5714:	681b      	ldr	r3, [r3, #0]
 80a5716:	69db      	ldr	r3, [r3, #28]
 80a5718:	9301      	str	r3, [sp, #4]
 80a571a:	bd08      	pop	{r3, pc}
 80a571c:	080601d0 	.word	0x080601d0

080a5720 <os_timer_create>:

DYNALIB_FN(8, hal_concurrent, os_timer_create, int(os_timer_t*, unsigned, void(*)(os_timer_t), void*, bool, void*))
 80a5720:	b508      	push	{r3, lr}
 80a5722:	4b02      	ldr	r3, [pc, #8]	; (80a572c <os_timer_create+0xc>)
 80a5724:	681b      	ldr	r3, [r3, #0]
 80a5726:	6a1b      	ldr	r3, [r3, #32]
 80a5728:	9301      	str	r3, [sp, #4]
 80a572a:	bd08      	pop	{r3, pc}
 80a572c:	080601d0 	.word	0x080601d0

080a5730 <os_timer_destroy>:
DYNALIB_FN(9, hal_concurrent, os_timer_destroy, int(os_timer_t, void*))
 80a5730:	b508      	push	{r3, lr}
 80a5732:	4b02      	ldr	r3, [pc, #8]	; (80a573c <os_timer_destroy+0xc>)
 80a5734:	681b      	ldr	r3, [r3, #0]
 80a5736:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a5738:	9301      	str	r3, [sp, #4]
 80a573a:	bd08      	pop	{r3, pc}
 80a573c:	080601d0 	.word	0x080601d0

080a5740 <os_timer_get_id>:
DYNALIB_FN(10, hal_concurrent, os_timer_get_id, int(os_timer_t, void**))
 80a5740:	b508      	push	{r3, lr}
 80a5742:	4b02      	ldr	r3, [pc, #8]	; (80a574c <os_timer_get_id+0xc>)
 80a5744:	681b      	ldr	r3, [r3, #0]
 80a5746:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a5748:	9301      	str	r3, [sp, #4]
 80a574a:	bd08      	pop	{r3, pc}
 80a574c:	080601d0 	.word	0x080601d0

080a5750 <os_timer_change>:
DYNALIB_FN(11, hal_concurrent, os_timer_change, int(os_timer_t, os_timer_change_t, bool, unsigned, unsigned, void*))
 80a5750:	b508      	push	{r3, lr}
 80a5752:	4b02      	ldr	r3, [pc, #8]	; (80a575c <os_timer_change+0xc>)
 80a5754:	681b      	ldr	r3, [r3, #0]
 80a5756:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a5758:	9301      	str	r3, [sp, #4]
 80a575a:	bd08      	pop	{r3, pc}
 80a575c:	080601d0 	.word	0x080601d0

080a5760 <os_mutex_recursive_create>:
DYNALIB_FN(13, hal_concurrent, os_mutex_destroy, int(os_mutex_t))
DYNALIB_FN(14, hal_concurrent, os_mutex_lock, int(os_mutex_t))
DYNALIB_FN(15, hal_concurrent, os_mutex_trylock, int(os_mutex_t))
DYNALIB_FN(16, hal_concurrent, os_mutex_unlock, int(os_mutex_t))

DYNALIB_FN(17, hal_concurrent, os_mutex_recursive_create, int(os_mutex_recursive_t*))
 80a5760:	b508      	push	{r3, lr}
 80a5762:	4b02      	ldr	r3, [pc, #8]	; (80a576c <os_mutex_recursive_create+0xc>)
 80a5764:	681b      	ldr	r3, [r3, #0]
 80a5766:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80a5768:	9301      	str	r3, [sp, #4]
 80a576a:	bd08      	pop	{r3, pc}
 80a576c:	080601d0 	.word	0x080601d0

080a5770 <os_mutex_recursive_destroy>:
DYNALIB_FN(18, hal_concurrent, os_mutex_recursive_destroy, int(os_mutex_recursive_t))
 80a5770:	b508      	push	{r3, lr}
 80a5772:	4b02      	ldr	r3, [pc, #8]	; (80a577c <os_mutex_recursive_destroy+0xc>)
 80a5774:	681b      	ldr	r3, [r3, #0]
 80a5776:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80a5778:	9301      	str	r3, [sp, #4]
 80a577a:	bd08      	pop	{r3, pc}
 80a577c:	080601d0 	.word	0x080601d0

080a5780 <os_mutex_recursive_lock>:
DYNALIB_FN(19, hal_concurrent, os_mutex_recursive_lock, int(os_mutex_recursive_t))
 80a5780:	b508      	push	{r3, lr}
 80a5782:	4b02      	ldr	r3, [pc, #8]	; (80a578c <os_mutex_recursive_lock+0xc>)
 80a5784:	681b      	ldr	r3, [r3, #0]
 80a5786:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80a5788:	9301      	str	r3, [sp, #4]
 80a578a:	bd08      	pop	{r3, pc}
 80a578c:	080601d0 	.word	0x080601d0

080a5790 <os_mutex_recursive_unlock>:
DYNALIB_FN(20, hal_concurrent, os_mutex_recursive_trylock, int(os_mutex_recursive_t))
DYNALIB_FN(21, hal_concurrent, os_mutex_recursive_unlock, int(os_mutex_recursive_t))
 80a5790:	b508      	push	{r3, lr}
 80a5792:	4b02      	ldr	r3, [pc, #8]	; (80a579c <os_mutex_recursive_unlock+0xc>)
 80a5794:	681b      	ldr	r3, [r3, #0]
 80a5796:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80a5798:	9301      	str	r3, [sp, #4]
 80a579a:	bd08      	pop	{r3, pc}
 80a579c:	080601d0 	.word	0x080601d0

080a57a0 <os_timer_set_id>:
DYNALIB_FN(24, hal_concurrent, os_queue_destroy, int(os_queue_t, void*))
DYNALIB_FN(25, hal_concurrent, os_queue_put, int(os_queue_t, const void* item, system_tick_t, void*))
DYNALIB_FN(26, hal_concurrent, os_queue_take, int(os_queue_t, void* item, system_tick_t, void*))
DYNALIB_FN(27, hal_concurrent, os_thread_exit, os_result_t(os_thread_t))

DYNALIB_FN(28, hal_concurrent, os_timer_set_id, int(os_timer_t, void*))
 80a57a0:	b508      	push	{r3, lr}
 80a57a2:	4b02      	ldr	r3, [pc, #8]	; (80a57ac <os_timer_set_id+0xc>)
 80a57a4:	681b      	ldr	r3, [r3, #0]
 80a57a6:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80a57a8:	9301      	str	r3, [sp, #4]
 80a57aa:	bd08      	pop	{r3, pc}
 80a57ac:	080601d0 	.word	0x080601d0

080a57b0 <HAL_RNG_GetRandomNumber>:

DYNALIB_BEGIN(hal)

#if PLATFORM_ID > 3
DYNALIB_FN(0, hal, HAL_RNG_Configuration, void(void))
DYNALIB_FN(1, hal, HAL_RNG_GetRandomNumber, uint32_t(void))
 80a57b0:	b508      	push	{r3, lr}
 80a57b2:	4b02      	ldr	r3, [pc, #8]	; (80a57bc <HAL_RNG_GetRandomNumber+0xc>)
 80a57b4:	681b      	ldr	r3, [r3, #0]
 80a57b6:	685b      	ldr	r3, [r3, #4]
 80a57b8:	9301      	str	r3, [sp, #4]
 80a57ba:	bd08      	pop	{r3, pc}
 80a57bc:	0806019c 	.word	0x0806019c

080a57c0 <HAL_Delay_Microseconds>:
#else
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal, HAL_Delay_Milliseconds, void(uint32_t))
DYNALIB_FN(BASE_IDX + 1, hal, HAL_Delay_Microseconds, void(uint32_t))
 80a57c0:	b508      	push	{r3, lr}
 80a57c2:	4b02      	ldr	r3, [pc, #8]	; (80a57cc <HAL_Delay_Microseconds+0xc>)
 80a57c4:	681b      	ldr	r3, [r3, #0]
 80a57c6:	68db      	ldr	r3, [r3, #12]
 80a57c8:	9301      	str	r3, [sp, #4]
 80a57ca:	bd08      	pop	{r3, pc}
 80a57cc:	0806019c 	.word	0x0806019c

080a57d0 <HAL_Timer_Get_Micro_Seconds>:
DYNALIB_FN(BASE_IDX + 2, hal, HAL_Timer_Get_Micro_Seconds, system_tick_t(void))
 80a57d0:	b508      	push	{r3, lr}
 80a57d2:	4b02      	ldr	r3, [pc, #8]	; (80a57dc <HAL_Timer_Get_Micro_Seconds+0xc>)
 80a57d4:	681b      	ldr	r3, [r3, #0]
 80a57d6:	691b      	ldr	r3, [r3, #16]
 80a57d8:	9301      	str	r3, [sp, #4]
 80a57da:	bd08      	pop	{r3, pc}
 80a57dc:	0806019c 	.word	0x0806019c

080a57e0 <HAL_Timer_Get_Milli_Seconds>:
DYNALIB_FN(BASE_IDX + 3, hal, HAL_Timer_Get_Milli_Seconds, system_tick_t(void))
 80a57e0:	b508      	push	{r3, lr}
 80a57e2:	4b02      	ldr	r3, [pc, #8]	; (80a57ec <HAL_Timer_Get_Milli_Seconds+0xc>)
 80a57e4:	681b      	ldr	r3, [r3, #0]
 80a57e6:	695b      	ldr	r3, [r3, #20]
 80a57e8:	9301      	str	r3, [sp, #4]
 80a57ea:	bd08      	pop	{r3, pc}
 80a57ec:	0806019c 	.word	0x0806019c

080a57f0 <hal_rtc_time_is_valid>:
DYNALIB_FN(BASE_IDX + 15, hal, HAL_EEPROM_Get, void(uint32_t, void *, size_t))
DYNALIB_FN(BASE_IDX + 16, hal, HAL_EEPROM_Put, void(uint32_t, const void *, size_t))
DYNALIB_FN(BASE_IDX + 17, hal, HAL_EEPROM_Clear, void(void))
DYNALIB_FN(BASE_IDX + 18, hal, HAL_EEPROM_Has_Pending_Erase, bool(void))
DYNALIB_FN(BASE_IDX + 19, hal, HAL_EEPROM_Perform_Pending_Erase, void(void))
DYNALIB_FN(BASE_IDX + 20, hal, hal_rtc_time_is_valid, bool(void*))
 80a57f0:	b508      	push	{r3, lr}
 80a57f2:	4b02      	ldr	r3, [pc, #8]	; (80a57fc <hal_rtc_time_is_valid+0xc>)
 80a57f4:	681b      	ldr	r3, [r3, #0]
 80a57f6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80a57f8:	9301      	str	r3, [sp, #4]
 80a57fa:	bd08      	pop	{r3, pc}
 80a57fc:	0806019c 	.word	0x0806019c

080a5800 <hal_rtc_get_time>:

DYNALIB_FN(BASE_IDX + 21, hal, hal_timer_millis, uint64_t(void*))
DYNALIB_FN(BASE_IDX + 22, hal, hal_timer_micros, uint64_t(void*))

DYNALIB_FN(BASE_IDX + 23, hal, hal_rtc_get_time, int(struct timeval*, void*))
 80a5800:	b508      	push	{r3, lr}
 80a5802:	4b02      	ldr	r3, [pc, #8]	; (80a580c <hal_rtc_get_time+0xc>)
 80a5804:	681b      	ldr	r3, [r3, #0]
 80a5806:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80a5808:	9301      	str	r3, [sp, #4]
 80a580a:	bd08      	pop	{r3, pc}
 80a580c:	0806019c 	.word	0x0806019c

080a5810 <HAL_Pin_Map>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_gpio)

DYNALIB_FN(0, hal_gpio, HAL_Pin_Map, Hal_Pin_Info*(void))
 80a5810:	b508      	push	{r3, lr}
 80a5812:	4b02      	ldr	r3, [pc, #8]	; (80a581c <HAL_Pin_Map+0xc>)
 80a5814:	681b      	ldr	r3, [r3, #0]
 80a5816:	681b      	ldr	r3, [r3, #0]
 80a5818:	9301      	str	r3, [sp, #4]
 80a581a:	bd08      	pop	{r3, pc}
 80a581c:	080601b0 	.word	0x080601b0

080a5820 <HAL_Pin_Mode>:
DYNALIB_FN(1, hal_gpio, HAL_Validate_Pin_Function, PinFunction(pin_t, PinFunction))
DYNALIB_FN(2, hal_gpio, HAL_Pin_Mode, void(pin_t, PinMode))
 80a5820:	b508      	push	{r3, lr}
 80a5822:	4b02      	ldr	r3, [pc, #8]	; (80a582c <HAL_Pin_Mode+0xc>)
 80a5824:	681b      	ldr	r3, [r3, #0]
 80a5826:	689b      	ldr	r3, [r3, #8]
 80a5828:	9301      	str	r3, [sp, #4]
 80a582a:	bd08      	pop	{r3, pc}
 80a582c:	080601b0 	.word	0x080601b0

080a5830 <HAL_Get_Pin_Mode>:
DYNALIB_FN(3, hal_gpio, HAL_Get_Pin_Mode, PinMode(pin_t))
 80a5830:	b508      	push	{r3, lr}
 80a5832:	4b02      	ldr	r3, [pc, #8]	; (80a583c <HAL_Get_Pin_Mode+0xc>)
 80a5834:	681b      	ldr	r3, [r3, #0]
 80a5836:	68db      	ldr	r3, [r3, #12]
 80a5838:	9301      	str	r3, [sp, #4]
 80a583a:	bd08      	pop	{r3, pc}
 80a583c:	080601b0 	.word	0x080601b0

080a5840 <HAL_GPIO_Write>:
DYNALIB_FN(4, hal_gpio, HAL_GPIO_Write, void(pin_t, uint8_t))
 80a5840:	b508      	push	{r3, lr}
 80a5842:	4b02      	ldr	r3, [pc, #8]	; (80a584c <HAL_GPIO_Write+0xc>)
 80a5844:	681b      	ldr	r3, [r3, #0]
 80a5846:	691b      	ldr	r3, [r3, #16]
 80a5848:	9301      	str	r3, [sp, #4]
 80a584a:	bd08      	pop	{r3, pc}
 80a584c:	080601b0 	.word	0x080601b0

080a5850 <HAL_GPIO_Read>:
DYNALIB_FN(5, hal_gpio, HAL_GPIO_Read, int32_t(pin_t))
 80a5850:	b508      	push	{r3, lr}
 80a5852:	4b02      	ldr	r3, [pc, #8]	; (80a585c <HAL_GPIO_Read+0xc>)
 80a5854:	681b      	ldr	r3, [r3, #0]
 80a5856:	695b      	ldr	r3, [r3, #20]
 80a5858:	9301      	str	r3, [sp, #4]
 80a585a:	bd08      	pop	{r3, pc}
 80a585c:	080601b0 	.word	0x080601b0

080a5860 <LED_SetSignalingColor>:
#endif // defined(DYNALIB_EXPORT)

DYNALIB_BEGIN(services)

DYNALIB_FN(0, services, LED_SetRGBColor, void(uint32_t))
DYNALIB_FN(1, services, LED_SetSignalingColor, void(uint32_t))
 80a5860:	b508      	push	{r3, lr}
 80a5862:	4b02      	ldr	r3, [pc, #8]	; (80a586c <LED_SetSignalingColor+0xc>)
 80a5864:	681b      	ldr	r3, [r3, #0]
 80a5866:	685b      	ldr	r3, [r3, #4]
 80a5868:	9301      	str	r3, [sp, #4]
 80a586a:	bd08      	pop	{r3, pc}
 80a586c:	080201a8 	.word	0x080201a8

080a5870 <LED_Signaling_Start>:
DYNALIB_FN(2, services, LED_Signaling_Start, void(void))
 80a5870:	b508      	push	{r3, lr}
 80a5872:	4b02      	ldr	r3, [pc, #8]	; (80a587c <LED_Signaling_Start+0xc>)
 80a5874:	681b      	ldr	r3, [r3, #0]
 80a5876:	689b      	ldr	r3, [r3, #8]
 80a5878:	9301      	str	r3, [sp, #4]
 80a587a:	bd08      	pop	{r3, pc}
 80a587c:	080201a8 	.word	0x080201a8

080a5880 <LED_Signaling_Stop>:
DYNALIB_FN(3, services, LED_Signaling_Stop, void(void))
 80a5880:	b508      	push	{r3, lr}
 80a5882:	4b02      	ldr	r3, [pc, #8]	; (80a588c <LED_Signaling_Stop+0xc>)
 80a5884:	681b      	ldr	r3, [r3, #0]
 80a5886:	68db      	ldr	r3, [r3, #12]
 80a5888:	9301      	str	r3, [sp, #4]
 80a588a:	bd08      	pop	{r3, pc}
 80a588c:	080201a8 	.word	0x080201a8

080a5890 <LED_SetBrightness>:
DYNALIB_FN(4, services, LED_SetBrightness, void(uint8_t))
 80a5890:	b508      	push	{r3, lr}
 80a5892:	4b02      	ldr	r3, [pc, #8]	; (80a589c <LED_SetBrightness+0xc>)
 80a5894:	681b      	ldr	r3, [r3, #0]
 80a5896:	691b      	ldr	r3, [r3, #16]
 80a5898:	9301      	str	r3, [sp, #4]
 80a589a:	bd08      	pop	{r3, pc}
 80a589c:	080201a8 	.word	0x080201a8

080a58a0 <LED_RGB_IsOverRidden>:
DYNALIB_FN(5, services, LED_RGB_Get, void(uint8_t*))
DYNALIB_FN(6, services, LED_RGB_IsOverRidden, bool(void))
 80a58a0:	b508      	push	{r3, lr}
 80a58a2:	4b02      	ldr	r3, [pc, #8]	; (80a58ac <LED_RGB_IsOverRidden+0xc>)
 80a58a4:	681b      	ldr	r3, [r3, #0]
 80a58a6:	699b      	ldr	r3, [r3, #24]
 80a58a8:	9301      	str	r3, [sp, #4]
 80a58aa:	bd08      	pop	{r3, pc}
 80a58ac:	080201a8 	.word	0x080201a8

080a58b0 <LED_On>:
DYNALIB_FN(7, services, LED_On, void(Led_TypeDef))
 80a58b0:	b508      	push	{r3, lr}
 80a58b2:	4b02      	ldr	r3, [pc, #8]	; (80a58bc <LED_On+0xc>)
 80a58b4:	681b      	ldr	r3, [r3, #0]
 80a58b6:	69db      	ldr	r3, [r3, #28]
 80a58b8:	9301      	str	r3, [sp, #4]
 80a58ba:	bd08      	pop	{r3, pc}
 80a58bc:	080201a8 	.word	0x080201a8

080a58c0 <panic_>:
DYNALIB_FN(9, services, LED_Toggle, void(Led_TypeDef))
DYNALIB_FN(10, services, LED_Fade, void(Led_TypeDef))
DYNALIB_FN(11, services, Get_LED_Brightness, uint8_t(void))

DYNALIB_FN(12, services, set_logger_output, void(debug_output_fn, LoggerOutputLevel)) // Deprecated
DYNALIB_FN(13, services, panic_, void(ePanicCode, void*, void(*)(uint32_t)))
 80a58c0:	b508      	push	{r3, lr}
 80a58c2:	4b02      	ldr	r3, [pc, #8]	; (80a58cc <panic_+0xc>)
 80a58c4:	681b      	ldr	r3, [r3, #0]
 80a58c6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a58c8:	9301      	str	r3, [sp, #4]
 80a58ca:	bd08      	pop	{r3, pc}
 80a58cc:	080201a8 	.word	0x080201a8

080a58d0 <spark_process>:

DYNALIB_BEGIN(system_cloud)

DYNALIB_FN(0, system_cloud, spark_variable, bool(const char*, const void*, Spark_Data_TypeDef, spark_variable_t*))
DYNALIB_FN(1, system_cloud, spark_function, bool(const char*, p_user_function_int_str_t, void*))
DYNALIB_FN(2, system_cloud, spark_process, void(void))
 80a58d0:	b508      	push	{r3, lr}
 80a58d2:	4b02      	ldr	r3, [pc, #8]	; (80a58dc <spark_process+0xc>)
 80a58d4:	681b      	ldr	r3, [r3, #0]
 80a58d6:	689b      	ldr	r3, [r3, #8]
 80a58d8:	9301      	str	r3, [sp, #4]
 80a58da:	bd08      	pop	{r3, pc}
 80a58dc:	080601cc 	.word	0x080601cc

080a58e0 <spark_cloud_flag_connect>:
DYNALIB_FN(3, system_cloud, spark_cloud_flag_connect, void(void))
 80a58e0:	b508      	push	{r3, lr}
 80a58e2:	4b02      	ldr	r3, [pc, #8]	; (80a58ec <spark_cloud_flag_connect+0xc>)
 80a58e4:	681b      	ldr	r3, [r3, #0]
 80a58e6:	68db      	ldr	r3, [r3, #12]
 80a58e8:	9301      	str	r3, [sp, #4]
 80a58ea:	bd08      	pop	{r3, pc}
 80a58ec:	080601cc 	.word	0x080601cc

080a58f0 <spark_cloud_flag_connected>:
DYNALIB_FN(4, system_cloud, spark_cloud_flag_disconnect, void(void))
DYNALIB_FN(5, system_cloud, spark_cloud_flag_connected, bool(void))
 80a58f0:	b508      	push	{r3, lr}
 80a58f2:	4b02      	ldr	r3, [pc, #8]	; (80a58fc <spark_cloud_flag_connected+0xc>)
 80a58f4:	681b      	ldr	r3, [r3, #0]
 80a58f6:	695b      	ldr	r3, [r3, #20]
 80a58f8:	9301      	str	r3, [sp, #4]
 80a58fa:	bd08      	pop	{r3, pc}
 80a58fc:	080601cc 	.word	0x080601cc

080a5900 <spark_send_event>:
DYNALIB_FN(6, system_cloud, system_cloud_protocol_instance, ProtocolFacade*(void))
DYNALIB_FN(7, system_cloud, spark_deviceID, String(void))
DYNALIB_FN(8, system_cloud, spark_send_event, bool(const char*, const char*, int, uint32_t, void*))
 80a5900:	b508      	push	{r3, lr}
 80a5902:	4b02      	ldr	r3, [pc, #8]	; (80a590c <spark_send_event+0xc>)
 80a5904:	681b      	ldr	r3, [r3, #0]
 80a5906:	6a1b      	ldr	r3, [r3, #32]
 80a5908:	9301      	str	r3, [sp, #4]
 80a590a:	bd08      	pop	{r3, pc}
 80a590c:	080601cc 	.word	0x080601cc

080a5910 <spark_subscribe>:
DYNALIB_FN(9, system_cloud, spark_subscribe, bool(const char*, EventHandler, void*, Spark_Subscription_Scope_TypeDef, const char*, void*))
 80a5910:	b508      	push	{r3, lr}
 80a5912:	4b02      	ldr	r3, [pc, #8]	; (80a591c <spark_subscribe+0xc>)
 80a5914:	681b      	ldr	r3, [r3, #0]
 80a5916:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a5918:	9301      	str	r3, [sp, #4]
 80a591a:	bd08      	pop	{r3, pc}
 80a591c:	080601cc 	.word	0x080601cc

080a5920 <spark_sync_time_pending>:
DYNALIB_FN(10, system_cloud, spark_unsubscribe, void(void*))
DYNALIB_FN(11, system_cloud, spark_sync_time, bool(void*))
DYNALIB_FN(12, system_cloud, spark_sync_time_pending, bool(void*))
 80a5920:	b508      	push	{r3, lr}
 80a5922:	4b02      	ldr	r3, [pc, #8]	; (80a592c <spark_sync_time_pending+0xc>)
 80a5924:	681b      	ldr	r3, [r3, #0]
 80a5926:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a5928:	9301      	str	r3, [sp, #4]
 80a592a:	bd08      	pop	{r3, pc}
 80a592c:	080601cc 	.word	0x080601cc

080a5930 <spark_set_random_seed_from_cloud_handler>:
DYNALIB_FN(13, system_cloud, spark_sync_time_last, system_tick_t(time32_t*, time_t*))
DYNALIB_FN(14, system_cloud, spark_set_connection_property, int(unsigned, unsigned, const void*, void*))
DYNALIB_FN(15, system_cloud, spark_set_random_seed_from_cloud_handler, int(void (*handler)(unsigned int), void*))
 80a5930:	b508      	push	{r3, lr}
 80a5932:	4b02      	ldr	r3, [pc, #8]	; (80a593c <spark_set_random_seed_from_cloud_handler+0xc>)
 80a5934:	681b      	ldr	r3, [r3, #0]
 80a5936:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80a5938:	9301      	str	r3, [sp, #4]
 80a593a:	bd08      	pop	{r3, pc}
 80a593c:	080601cc 	.word	0x080601cc

080a5940 <network_connect>:
#endif

DYNALIB_BEGIN(system_net)

DYNALIB_FN(0, system_net, network_config, const void*(network_handle_t, uint32_t, void*))
DYNALIB_FN(1, system_net, network_connect, void(network_handle_t, uint32_t, uint32_t, void*))
 80a5940:	b508      	push	{r3, lr}
 80a5942:	4b02      	ldr	r3, [pc, #8]	; (80a594c <network_connect+0xc>)
 80a5944:	681b      	ldr	r3, [r3, #0]
 80a5946:	685b      	ldr	r3, [r3, #4]
 80a5948:	9301      	str	r3, [sp, #4]
 80a594a:	bd08      	pop	{r3, pc}
 80a594c:	080601c8 	.word	0x080601c8

080a5950 <network_connecting>:
DYNALIB_FN(2, system_net, network_connecting, bool(network_handle_t, uint32_t, void*))
 80a5950:	b508      	push	{r3, lr}
 80a5952:	4b02      	ldr	r3, [pc, #8]	; (80a595c <network_connecting+0xc>)
 80a5954:	681b      	ldr	r3, [r3, #0]
 80a5956:	689b      	ldr	r3, [r3, #8]
 80a5958:	9301      	str	r3, [sp, #4]
 80a595a:	bd08      	pop	{r3, pc}
 80a595c:	080601c8 	.word	0x080601c8

080a5960 <network_disconnect>:
DYNALIB_FN(3, system_net, network_disconnect, void(network_handle_t, uint32_t, void*))
 80a5960:	b508      	push	{r3, lr}
 80a5962:	4b02      	ldr	r3, [pc, #8]	; (80a596c <network_disconnect+0xc>)
 80a5964:	681b      	ldr	r3, [r3, #0]
 80a5966:	68db      	ldr	r3, [r3, #12]
 80a5968:	9301      	str	r3, [sp, #4]
 80a596a:	bd08      	pop	{r3, pc}
 80a596c:	080601c8 	.word	0x080601c8

080a5970 <network_ready>:
DYNALIB_FN(4, system_net, network_ready, bool(network_handle_t, uint32_t, void*))
 80a5970:	b508      	push	{r3, lr}
 80a5972:	4b02      	ldr	r3, [pc, #8]	; (80a597c <network_ready+0xc>)
 80a5974:	681b      	ldr	r3, [r3, #0]
 80a5976:	691b      	ldr	r3, [r3, #16]
 80a5978:	9301      	str	r3, [sp, #4]
 80a597a:	bd08      	pop	{r3, pc}
 80a597c:	080601c8 	.word	0x080601c8

080a5980 <network_on>:
DYNALIB_FN(5, system_net, network_on, void(network_handle_t, uint32_t, uint32_t, void*))
 80a5980:	b508      	push	{r3, lr}
 80a5982:	4b02      	ldr	r3, [pc, #8]	; (80a598c <network_on+0xc>)
 80a5984:	681b      	ldr	r3, [r3, #0]
 80a5986:	695b      	ldr	r3, [r3, #20]
 80a5988:	9301      	str	r3, [sp, #4]
 80a598a:	bd08      	pop	{r3, pc}
 80a598c:	080601c8 	.word	0x080601c8

080a5990 <network_off>:
DYNALIB_FN(6, system_net, network_off, void(network_handle_t, uint32_t, uint32_t, void*))
 80a5990:	b508      	push	{r3, lr}
 80a5992:	4b02      	ldr	r3, [pc, #8]	; (80a599c <network_off+0xc>)
 80a5994:	681b      	ldr	r3, [r3, #0]
 80a5996:	699b      	ldr	r3, [r3, #24]
 80a5998:	9301      	str	r3, [sp, #4]
 80a599a:	bd08      	pop	{r3, pc}
 80a599c:	080601c8 	.word	0x080601c8

080a59a0 <network_listen>:
DYNALIB_FN(7, system_net, network_listen, void(network_handle_t, uint32_t, void*))
 80a59a0:	b508      	push	{r3, lr}
 80a59a2:	4b02      	ldr	r3, [pc, #8]	; (80a59ac <network_listen+0xc>)
 80a59a4:	681b      	ldr	r3, [r3, #0]
 80a59a6:	69db      	ldr	r3, [r3, #28]
 80a59a8:	9301      	str	r3, [sp, #4]
 80a59aa:	bd08      	pop	{r3, pc}
 80a59ac:	080601c8 	.word	0x080601c8

080a59b0 <network_listening>:
DYNALIB_FN(8, system_net, network_listening, bool(network_handle_t, uint32_t, void*))
 80a59b0:	b508      	push	{r3, lr}
 80a59b2:	4b02      	ldr	r3, [pc, #8]	; (80a59bc <network_listening+0xc>)
 80a59b4:	681b      	ldr	r3, [r3, #0]
 80a59b6:	6a1b      	ldr	r3, [r3, #32]
 80a59b8:	9301      	str	r3, [sp, #4]
 80a59ba:	bd08      	pop	{r3, pc}
 80a59bc:	080601c8 	.word	0x080601c8

080a59c0 <network_set_listen_timeout>:
DYNALIB_FN(9, system_net, network_has_credentials, bool(network_handle_t, uint32_t, void*))
DYNALIB_FN(10, system_net, network_set_credentials, int(network_handle_t, uint32_t, NetworkCredentials*, void*))
DYNALIB_FN(11, system_net, network_clear_credentials, bool(network_handle_t, uint32_t, NetworkCredentials*, void*))
DYNALIB_FN(12, system_net, network_set_listen_timeout, void(network_handle_t, uint16_t, void*))
 80a59c0:	b508      	push	{r3, lr}
 80a59c2:	4b02      	ldr	r3, [pc, #8]	; (80a59cc <network_set_listen_timeout+0xc>)
 80a59c4:	681b      	ldr	r3, [r3, #0]
 80a59c6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a59c8:	9301      	str	r3, [sp, #4]
 80a59ca:	bd08      	pop	{r3, pc}
 80a59cc:	080601c8 	.word	0x080601c8

080a59d0 <network_get_listen_timeout>:
DYNALIB_FN(13, system_net, network_get_listen_timeout, uint16_t(network_handle_t, uint32_t, void*))
 80a59d0:	b508      	push	{r3, lr}
 80a59d2:	4b02      	ldr	r3, [pc, #8]	; (80a59dc <network_get_listen_timeout+0xc>)
 80a59d4:	681b      	ldr	r3, [r3, #0]
 80a59d6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a59d8:	9301      	str	r3, [sp, #4]
 80a59da:	bd08      	pop	{r3, pc}
 80a59dc:	080601c8 	.word	0x080601c8

080a59e0 <network_is_on>:
DYNALIB_FN(14, system_net, network_set_hostname, int(network_handle_t, uint32_t, const char*, void*))
DYNALIB_FN(15, system_net, network_get_hostname, int(network_handle_t, uint32_t, char*, size_t, void*))
DYNALIB_FN(16, system_net, network_is_on, bool(network_handle_t, void*))
 80a59e0:	b508      	push	{r3, lr}
 80a59e2:	4b02      	ldr	r3, [pc, #8]	; (80a59ec <network_is_on+0xc>)
 80a59e4:	681b      	ldr	r3, [r3, #0]
 80a59e6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80a59e8:	9301      	str	r3, [sp, #4]
 80a59ea:	bd08      	pop	{r3, pc}
 80a59ec:	080601c8 	.word	0x080601c8

080a59f0 <network_is_off>:
DYNALIB_FN(17, system_net, network_is_off, bool(network_handle_t, void*))
 80a59f0:	b508      	push	{r3, lr}
 80a59f2:	4b02      	ldr	r3, [pc, #8]	; (80a59fc <network_is_off+0xc>)
 80a59f4:	681b      	ldr	r3, [r3, #0]
 80a59f6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80a59f8:	9301      	str	r3, [sp, #4]
 80a59fa:	bd08      	pop	{r3, pc}
 80a59fc:	080601c8 	.word	0x080601c8

080a5a00 <system_mode>:
#include "system_power.h"
#endif

DYNALIB_BEGIN(system)

DYNALIB_FN(0, system, system_mode, System_Mode_TypeDef(void))
 80a5a00:	b508      	push	{r3, lr}
 80a5a02:	4b02      	ldr	r3, [pc, #8]	; (80a5a0c <system_mode+0xc>)
 80a5a04:	681b      	ldr	r3, [r3, #0]
 80a5a06:	681b      	ldr	r3, [r3, #0]
 80a5a08:	9301      	str	r3, [sp, #4]
 80a5a0a:	bd08      	pop	{r3, pc}
 80a5a0c:	080601a4 	.word	0x080601a4

080a5a10 <set_system_mode>:
DYNALIB_FN(1, system, set_system_mode, void(System_Mode_TypeDef))
 80a5a10:	b508      	push	{r3, lr}
 80a5a12:	4b02      	ldr	r3, [pc, #8]	; (80a5a1c <set_system_mode+0xc>)
 80a5a14:	681b      	ldr	r3, [r3, #0]
 80a5a16:	685b      	ldr	r3, [r3, #4]
 80a5a18:	9301      	str	r3, [sp, #4]
 80a5a1a:	bd08      	pop	{r3, pc}
 80a5a1c:	080601a4 	.word	0x080601a4

080a5a20 <system_delay_ms>:

DYNALIB_FN(2, system, set_ymodem_serial_flash_update_handler, void(ymodem_serial_flash_update_handler))
DYNALIB_FN(3, system, system_firmwareUpdate, bool(Stream*, void*))
DYNALIB_FN(4, system, system_fileTransfer, bool(system_file_transfer_t*, void*))

DYNALIB_FN(5, system, system_delay_ms, void(unsigned long, bool))
 80a5a20:	b508      	push	{r3, lr}
 80a5a22:	4b02      	ldr	r3, [pc, #8]	; (80a5a2c <system_delay_ms+0xc>)
 80a5a24:	681b      	ldr	r3, [r3, #0]
 80a5a26:	695b      	ldr	r3, [r3, #20]
 80a5a28:	9301      	str	r3, [sp, #4]
 80a5a2a:	bd08      	pop	{r3, pc}
 80a5a2c:	080601a4 	.word	0x080601a4

080a5a30 <application_thread_current>:
DYNALIB_FN(15, system, system_get_flag, int(system_flag_t, uint8_t*, void*))
DYNALIB_FN(16, system, Spark_Prepare_For_Firmware_Update, int(FileTransfer::Descriptor&, uint32_t, void*))
DYNALIB_FN(17, system, Spark_Save_Firmware_Chunk, int(FileTransfer::Descriptor&, const uint8_t*, void*))
DYNALIB_FN(18, system, Spark_Finish_Firmware_Update, int(FileTransfer::Descriptor&, uint32_t, void*))

DYNALIB_FN(19, system, application_thread_current, uint8_t(void*))
 80a5a30:	b508      	push	{r3, lr}
 80a5a32:	4b02      	ldr	r3, [pc, #8]	; (80a5a3c <application_thread_current+0xc>)
 80a5a34:	681b      	ldr	r3, [r3, #0]
 80a5a36:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80a5a38:	9301      	str	r3, [sp, #4]
 80a5a3a:	bd08      	pop	{r3, pc}
 80a5a3c:	080601a4 	.word	0x080601a4

080a5a40 <application_thread_invoke>:
DYNALIB_FN(20, system, system_thread_current, uint8_t(void*))
DYNALIB_FN(21, system, application_thread_invoke, uint8_t(void(*)(void*), void*, void*))
 80a5a40:	b508      	push	{r3, lr}
 80a5a42:	4b02      	ldr	r3, [pc, #8]	; (80a5a4c <application_thread_invoke+0xc>)
 80a5a44:	681b      	ldr	r3, [r3, #0]
 80a5a46:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80a5a48:	9301      	str	r3, [sp, #4]
 80a5a4a:	bd08      	pop	{r3, pc}
 80a5a4c:	080601a4 	.word	0x080601a4

080a5a50 <system_thread_get_state>:
DYNALIB_FN(22, system, system_thread_get_state, spark::feature::State(void*))
 80a5a50:	b508      	push	{r3, lr}
 80a5a52:	4b02      	ldr	r3, [pc, #8]	; (80a5a5c <system_thread_get_state+0xc>)
 80a5a54:	681b      	ldr	r3, [r3, #0]
 80a5a56:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80a5a58:	9301      	str	r3, [sp, #4]
 80a5a5a:	bd08      	pop	{r3, pc}
 80a5a5c:	080601a4 	.word	0x080601a4

080a5a60 <system_ctrl_set_app_request_handler>:
DYNALIB_FN(BASE_IDX + 6, system, led_pattern_period, uint16_t(int, int, void*))
DYNALIB_FN(BASE_IDX + 7, system, system_set_tester_handlers, int(system_tester_handlers_t*, void*))
DYNALIB_FN(BASE_IDX + 8, system, system_format_diag_data, int(const uint16_t*, size_t, unsigned, appender_fn, void*, void*))

// Control requests
DYNALIB_FN(BASE_IDX + 9, system, system_ctrl_set_app_request_handler, int(ctrl_request_handler_fn, void*))
 80a5a60:	b508      	push	{r3, lr}
 80a5a62:	4b03      	ldr	r3, [pc, #12]	; (80a5a70 <system_ctrl_set_app_request_handler+0x10>)
 80a5a64:	681b      	ldr	r3, [r3, #0]
 80a5a66:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80a5a6a:	9301      	str	r3, [sp, #4]
 80a5a6c:	bd08      	pop	{r3, pc}
 80a5a6e:	0000      	.short	0x0000
 80a5a70:	080601a4 	.word	0x080601a4

080a5a74 <system_ctrl_set_result>:
DYNALIB_FN(BASE_IDX + 10, system, system_ctrl_alloc_reply_data, int(ctrl_request*, size_t, void*))
DYNALIB_FN(BASE_IDX + 11, system, system_ctrl_free_request_data, void(ctrl_request*, void*))
DYNALIB_FN(BASE_IDX + 12, system, system_ctrl_set_result, void(ctrl_request*, int, ctrl_completion_handler_fn, void*, void*))
 80a5a74:	b508      	push	{r3, lr}
 80a5a76:	4b03      	ldr	r3, [pc, #12]	; (80a5a84 <system_ctrl_set_result+0x10>)
 80a5a78:	681b      	ldr	r3, [r3, #0]
 80a5a7a:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 80a5a7e:	9301      	str	r3, [sp, #4]
 80a5a80:	bd08      	pop	{r3, pc}
 80a5a82:	0000      	.short	0x0000
 80a5a84:	080601a4 	.word	0x080601a4

080a5a88 <system_reset>:
#else
#define BASE_IDX1 (BASE_IDX + 17)
#endif // HAL_PLATFORM_POWER_MANAGEMENT

DYNALIB_FN(BASE_IDX1 + 0, system, system_sleep_ext, int(const hal_sleep_config_t*, hal_wakeup_source_base_t**, void*))
DYNALIB_FN(BASE_IDX1 + 1, system, system_reset, int(unsigned, unsigned, unsigned, unsigned, void*))
 80a5a88:	b508      	push	{r3, lr}
 80a5a8a:	4b03      	ldr	r3, [pc, #12]	; (80a5a98 <system_reset+0x10>)
 80a5a8c:	681b      	ldr	r3, [r3, #0]
 80a5a8e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80a5a92:	9301      	str	r3, [sp, #4]
 80a5a94:	bd08      	pop	{r3, pc}
 80a5a96:	0000      	.short	0x0000
 80a5a98:	080601a4 	.word	0x080601a4

080a5a9c <malloc>:
#include "hal_platform.h"
#endif // defined(DYNALIB_EXPORT) || (defined(DYNALIB_IMPORT) && !defined(RT_DYNALIB_NO_DEPENDENCY_BREAKING_IMPORTS))

DYNALIB_BEGIN(rt)

DYNALIB_FN(0, rt, malloc, void*(size_t))
 80a5a9c:	b508      	push	{r3, lr}
 80a5a9e:	4b02      	ldr	r3, [pc, #8]	; (80a5aa8 <malloc+0xc>)
 80a5aa0:	681b      	ldr	r3, [r3, #0]
 80a5aa2:	681b      	ldr	r3, [r3, #0]
 80a5aa4:	9301      	str	r3, [sp, #4]
 80a5aa6:	bd08      	pop	{r3, pc}
 80a5aa8:	080601a0 	.word	0x080601a0

080a5aac <free>:
DYNALIB_FN(1, rt, free, void(void*))
 80a5aac:	b508      	push	{r3, lr}
 80a5aae:	4b02      	ldr	r3, [pc, #8]	; (80a5ab8 <free+0xc>)
 80a5ab0:	681b      	ldr	r3, [r3, #0]
 80a5ab2:	685b      	ldr	r3, [r3, #4]
 80a5ab4:	9301      	str	r3, [sp, #4]
 80a5ab6:	bd08      	pop	{r3, pc}
 80a5ab8:	080601a0 	.word	0x080601a0

080a5abc <realloc>:
DYNALIB_FN(2, rt, realloc, void*(void*, size_t))
 80a5abc:	b508      	push	{r3, lr}
 80a5abe:	4b02      	ldr	r3, [pc, #8]	; (80a5ac8 <realloc+0xc>)
 80a5ac0:	681b      	ldr	r3, [r3, #0]
 80a5ac2:	689b      	ldr	r3, [r3, #8]
 80a5ac4:	9301      	str	r3, [sp, #4]
 80a5ac6:	bd08      	pop	{r3, pc}
 80a5ac8:	080601a0 	.word	0x080601a0

080a5acc <siscanf>:
DYNALIB_FN(3, rt, sprintf, int(char*, const char*, ...))
DYNALIB_FN(4, rt, siprintf, int(char*, const char*, ...))
DYNALIB_FN(5, rt, sscanf, int(const char*, const char*, ...))
DYNALIB_FN(6, rt, siscanf, int(const char*, const char*, ...))
 80a5acc:	b508      	push	{r3, lr}
 80a5ace:	4b02      	ldr	r3, [pc, #8]	; (80a5ad8 <siscanf+0xc>)
 80a5ad0:	681b      	ldr	r3, [r3, #0]
 80a5ad2:	699b      	ldr	r3, [r3, #24]
 80a5ad4:	9301      	str	r3, [sp, #4]
 80a5ad6:	bd08      	pop	{r3, pc}
 80a5ad8:	080601a0 	.word	0x080601a0

080a5adc <vsnprintf>:
DYNALIB_FN(7, rt, snprintf, int(char*, size_t, const char*, ...))
DYNALIB_FN(8, rt, sniprintf, int(char*, size_t, const char*, ...))
DYNALIB_FN(9, rt, vsnprintf, int(char*, size_t, const char*, va_list))
 80a5adc:	b508      	push	{r3, lr}
 80a5ade:	4b02      	ldr	r3, [pc, #8]	; (80a5ae8 <vsnprintf+0xc>)
 80a5ae0:	681b      	ldr	r3, [r3, #0]
 80a5ae2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a5ae4:	9301      	str	r3, [sp, #4]
 80a5ae6:	bd08      	pop	{r3, pc}
 80a5ae8:	080601a0 	.word	0x080601a0

080a5aec <abort>:
DYNALIB_FN(10, rt, vsniprintf, int(char*, size_t, const char*, va_list))
DYNALIB_FN(11, rt, abort, void(void))
 80a5aec:	b508      	push	{r3, lr}
 80a5aee:	4b02      	ldr	r3, [pc, #8]	; (80a5af8 <abort+0xc>)
 80a5af0:	681b      	ldr	r3, [r3, #0]
 80a5af2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a5af4:	9301      	str	r3, [sp, #4]
 80a5af6:	bd08      	pop	{r3, pc}
 80a5af8:	080601a0 	.word	0x080601a0

080a5afc <_malloc_r>:
DYNALIB_FN(12, rt, _malloc_r, void*(struct _reent*, size_t))
 80a5afc:	b508      	push	{r3, lr}
 80a5afe:	4b02      	ldr	r3, [pc, #8]	; (80a5b08 <_malloc_r+0xc>)
 80a5b00:	681b      	ldr	r3, [r3, #0]
 80a5b02:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a5b04:	9301      	str	r3, [sp, #4]
 80a5b06:	bd08      	pop	{r3, pc}
 80a5b08:	080601a0 	.word	0x080601a0

080a5b0c <newlib_impure_ptr_callback>:
// RT is currently being imported into system-part1 from system-part2,
// which is the reverse direction.

#if defined(DYNALIB_EXPORT) || (defined(DYNALIB_IMPORT) && !defined(RT_DYNALIB_NO_DEPENDENCY_BREAKING_IMPORTS))
DYNALIB_FN(16, rt, __assert_func, void(const char*, int, const char*, const char*))
DYNALIB_FN(17, rt, newlib_impure_ptr_callback, void(void (*)(struct _reent*, size_t, uint32_t, void*), void*))
 80a5b0c:	b508      	push	{r3, lr}
 80a5b0e:	4b02      	ldr	r3, [pc, #8]	; (80a5b18 <newlib_impure_ptr_callback+0xc>)
 80a5b10:	681b      	ldr	r3, [r3, #0]
 80a5b12:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80a5b14:	9301      	str	r3, [sp, #4]
 80a5b16:	bd08      	pop	{r3, pc}
 80a5b18:	080601a0 	.word	0x080601a0

080a5b1c <_ZN5spark12NetworkClass7connectEj>:
        return Network;
    }
}

void NetworkClass::connect(unsigned flags) {
    network_connect(*this, flags, 0, nullptr);
 80a5b1c:	2300      	movs	r3, #0
 80a5b1e:	6840      	ldr	r0, [r0, #4]
 80a5b20:	461a      	mov	r2, r3
 80a5b22:	f7ff bf0d 	b.w	80a5940 <network_connect>

080a5b26 <_ZN5spark12NetworkClass10disconnectEv>:
}

void NetworkClass::disconnect() {
    network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, nullptr);
 80a5b26:	2200      	movs	r2, #0
 80a5b28:	2102      	movs	r1, #2
 80a5b2a:	6840      	ldr	r0, [r0, #4]
 80a5b2c:	f7ff bf18 	b.w	80a5960 <network_disconnect>

080a5b30 <_ZN5spark12NetworkClass10connectingEv>:
}

bool NetworkClass::connecting() {
    return network_connecting(*this, 0, nullptr);
 80a5b30:	2200      	movs	r2, #0
 80a5b32:	6840      	ldr	r0, [r0, #4]
 80a5b34:	4611      	mov	r1, r2
 80a5b36:	f7ff bf0b 	b.w	80a5950 <network_connecting>

080a5b3a <_ZN5spark12NetworkClass5readyEv>:
}

bool NetworkClass::ready() {
    return network_ready(*this, 0, nullptr);
 80a5b3a:	2200      	movs	r2, #0
 80a5b3c:	6840      	ldr	r0, [r0, #4]
 80a5b3e:	4611      	mov	r1, r2
 80a5b40:	f7ff bf16 	b.w	80a5970 <network_ready>

080a5b44 <_ZN5spark12NetworkClass2onEv>:
}

void NetworkClass::on() {
    network_on(*this, 0, 0, nullptr);
 80a5b44:	2300      	movs	r3, #0
 80a5b46:	6840      	ldr	r0, [r0, #4]
 80a5b48:	461a      	mov	r2, r3
 80a5b4a:	4619      	mov	r1, r3
 80a5b4c:	f7ff bf18 	b.w	80a5980 <network_on>

080a5b50 <_ZN5spark12NetworkClass3offEv>:
}

void NetworkClass::off() {
    network_off(*this, 0, 0, nullptr);
 80a5b50:	2300      	movs	r3, #0
 80a5b52:	6840      	ldr	r0, [r0, #4]
 80a5b54:	461a      	mov	r2, r3
 80a5b56:	4619      	mov	r1, r3
 80a5b58:	f7ff bf1a 	b.w	80a5990 <network_off>

080a5b5c <_ZN5spark12NetworkClass4isOnEv>:
}

bool NetworkClass::isOn() {
    return network_is_on(*this, nullptr);
 80a5b5c:	2100      	movs	r1, #0
 80a5b5e:	6840      	ldr	r0, [r0, #4]
 80a5b60:	f7ff bf3e 	b.w	80a59e0 <network_is_on>

080a5b64 <_ZN5spark12NetworkClass5isOffEv>:
}

bool NetworkClass::isOff() {
    return network_is_off(*this, nullptr);
 80a5b64:	2100      	movs	r1, #0
 80a5b66:	6840      	ldr	r0, [r0, #4]
 80a5b68:	f7ff bf42 	b.w	80a59f0 <network_is_off>

080a5b6c <_ZN5spark12NetworkClass6listenEb>:
}

void NetworkClass::listen(bool begin) {
    network_listen(*this, begin ? 0 : 1, nullptr);
 80a5b6c:	2200      	movs	r2, #0
 80a5b6e:	6840      	ldr	r0, [r0, #4]
 80a5b70:	f081 0101 	eor.w	r1, r1, #1
 80a5b74:	f7ff bf14 	b.w	80a59a0 <network_listen>

080a5b78 <_ZN5spark12NetworkClass16setListenTimeoutEt>:
}

void NetworkClass::setListenTimeout(uint16_t timeout) {
    network_set_listen_timeout(*this, timeout, nullptr);
 80a5b78:	2200      	movs	r2, #0
 80a5b7a:	6840      	ldr	r0, [r0, #4]
 80a5b7c:	f7ff bf20 	b.w	80a59c0 <network_set_listen_timeout>

080a5b80 <_ZN5spark12NetworkClass16getListenTimeoutEv>:
}

uint16_t NetworkClass::getListenTimeout() {
    return network_get_listen_timeout(*this, 0, nullptr);
 80a5b80:	2200      	movs	r2, #0
 80a5b82:	6840      	ldr	r0, [r0, #4]
 80a5b84:	4611      	mov	r1, r2
 80a5b86:	f7ff bf23 	b.w	80a59d0 <network_get_listen_timeout>

080a5b8a <_ZN5spark12NetworkClass9listeningEv>:
}

bool NetworkClass::listening() {
    return network_listening(*this, 0, nullptr);
 80a5b8a:	2200      	movs	r2, #0
 80a5b8c:	6840      	ldr	r0, [r0, #4]
 80a5b8e:	4611      	mov	r1, r2
 80a5b90:	f7ff bf0e 	b.w	80a59b0 <network_listening>

080a5b94 <_ZN5spark12NetworkClass7resolveEPKc>:
}

IPAddress NetworkClass::resolve(const char* name) {
 80a5b94:	b570      	push	{r4, r5, r6, lr}
 80a5b96:	4615      	mov	r5, r2
 80a5b98:	b08e      	sub	sp, #56	; 0x38
 80a5b9a:	4604      	mov	r4, r0
    IPAddress addr;
 80a5b9c:	a808      	add	r0, sp, #32
 80a5b9e:	f000 fbb5 	bl	80a630c <_ZN9IPAddressC1Ev>
    }

#if !HAL_USE_INET_HAL_POSIX
    IPAddress resolve(const char* name)
    {
        HAL_IPAddress ip = {};
 80a5ba2:	2211      	movs	r2, #17
 80a5ba4:	2100      	movs	r1, #0
 80a5ba6:	a803      	add	r0, sp, #12
 80a5ba8:	f002 fe9e 	bl	80a88e8 <memset>
        return (inet_gethostbyname(name, strlen(name), &ip, *this, NULL) != 0) ?
 80a5bac:	2600      	movs	r6, #0
 80a5bae:	4628      	mov	r0, r5
 80a5bb0:	f002 ff37 	bl	80a8a22 <strlen>
 80a5bb4:	4b0a      	ldr	r3, [pc, #40]	; (80a5be0 <_ZN5spark12NetworkClass7resolveEPKc+0x4c>)
 80a5bb6:	9600      	str	r6, [sp, #0]
 80a5bb8:	b281      	uxth	r1, r0
 80a5bba:	685b      	ldr	r3, [r3, #4]
 80a5bbc:	4628      	mov	r0, r5
 80a5bbe:	aa03      	add	r2, sp, #12
 80a5bc0:	f7ff fc42 	bl	80a5448 <inet_gethostbyname>
                IPAddress(uint32_t(0)) : IPAddress(ip);
 80a5bc4:	b130      	cbz	r0, 80a5bd4 <_ZN5spark12NetworkClass7resolveEPKc+0x40>
 80a5bc6:	4631      	mov	r1, r6
 80a5bc8:	4620      	mov	r0, r4
 80a5bca:	f000 fbbf 	bl	80a634c <_ZN9IPAddressC1Em>
    return Cellular.resolve(name);
#endif // Wiring_Cellular

#endif // HAL_USE_INET_HAL_POSIX
    return addr;
}
 80a5bce:	4620      	mov	r0, r4
 80a5bd0:	b00e      	add	sp, #56	; 0x38
 80a5bd2:	bd70      	pop	{r4, r5, r6, pc}
 80a5bd4:	4620      	mov	r0, r4
 80a5bd6:	a903      	add	r1, sp, #12
 80a5bd8:	f000 fba6 	bl	80a6328 <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>
    IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet);
    IPAddress(uint32_t address);
    IPAddress(const uint8_t* address);
    IPAddress(const HAL_IPAddress& address);

    virtual ~IPAddress() {}
 80a5bdc:	e7f7      	b.n	80a5bce <_ZN5spark12NetworkClass7resolveEPKc+0x3a>
 80a5bde:	bf00      	nop
 80a5be0:	20000da4 	.word	0x20000da4

080a5be4 <_ZN5spark12NetworkClass4fromEm>:
}
 80a5be4:	4a03      	ldr	r2, [pc, #12]	; (80a5bf4 <_ZN5spark12NetworkClass4fromEm+0x10>)
 80a5be6:	4b04      	ldr	r3, [pc, #16]	; (80a5bf8 <_ZN5spark12NetworkClass4fromEm+0x14>)
 80a5be8:	2804      	cmp	r0, #4
 80a5bea:	bf14      	ite	ne
 80a5bec:	4610      	movne	r0, r2
 80a5bee:	4618      	moveq	r0, r3
 80a5bf0:	4770      	bx	lr
 80a5bf2:	bf00      	nop
 80a5bf4:	20000d9c 	.word	0x20000d9c
 80a5bf8:	20000da4 	.word	0x20000da4

080a5bfc <_GLOBAL__sub_I__ZN5spark7NetworkE>:
    static NetworkClass& from(network_interface_t nif);

    virtual IPAddress resolve(const char* name);

    explicit NetworkClass(network_interface_t iface)
            : iface_(iface) {
 80a5bfc:	4b02      	ldr	r3, [pc, #8]	; (80a5c08 <_GLOBAL__sub_I__ZN5spark7NetworkE+0xc>)
 80a5bfe:	4a03      	ldr	r2, [pc, #12]	; (80a5c0c <_GLOBAL__sub_I__ZN5spark7NetworkE+0x10>)
 80a5c00:	601a      	str	r2, [r3, #0]
 80a5c02:	2200      	movs	r2, #0
 80a5c04:	605a      	str	r2, [r3, #4]

} // spark
 80a5c06:	4770      	bx	lr
 80a5c08:	20000d9c 	.word	0x20000d9c
 80a5c0c:	080aa4b4 	.word	0x080aa4b4

080a5c10 <_ZN8SPIClass6unlockEv>:
    }

    void lock() { os_mutex_recursive_lock(handle_); }
    bool trylock() { return os_mutex_recursive_trylock(handle_)==0; }
    bool try_lock() { return trylock(); }
    void unlock() { os_mutex_recursive_unlock(handle_); }
 80a5c10:	6880      	ldr	r0, [r0, #8]
 80a5c12:	f7ff bdbd 	b.w	80a5790 <os_mutex_recursive_unlock>

080a5c16 <_ZN8SPIClassC1E19hal_spi_interface_t>:
    }
    return particle::SPISettings(info->clock, info->bit_order, info->data_mode);
}
} // namespace

SPIClass::SPIClass(hal_spi_interface_t spi)
 80a5c16:	b570      	push	{r4, r5, r6, lr}
    RecursiveMutex() : handle_(nullptr)
 80a5c18:	2600      	movs	r6, #0
 80a5c1a:	4604      	mov	r4, r0
 80a5c1c:	460d      	mov	r5, r1
 80a5c1e:	f840 6f08 	str.w	r6, [r0, #8]!
        os_mutex_recursive_create(&handle_);
 80a5c22:	f7ff fd9d 	bl	80a5760 <os_mutex_recursive_create>
{
    _spi = spi;
    hal_spi_init(_spi);
 80a5c26:	4628      	mov	r0, r5
    _spi = spi;
 80a5c28:	7025      	strb	r5, [r4, #0]
    hal_spi_init(_spi);
 80a5c2a:	f7ff fc6d 	bl	80a5508 <hal_spi_init>
    _dividerReference = SPI_CLK_SYSTEM; // 0 indicates the system clock
}
 80a5c2e:	4620      	mov	r0, r4
    _dividerReference = SPI_CLK_SYSTEM; // 0 indicates the system clock
 80a5c30:	6066      	str	r6, [r4, #4]
}
 80a5c32:	bd70      	pop	{r4, r5, r6, pc}

080a5c34 <_ZN8SPIClass5beginEv>:

void SPIClass::begin()
{
 80a5c34:	b510      	push	{r4, lr}
 80a5c36:	4604      	mov	r4, r0
    void lock() { os_mutex_recursive_lock(handle_); }
 80a5c38:	6880      	ldr	r0, [r0, #8]
 80a5c3a:	f7ff fda1 	bl	80a5780 <os_mutex_recursive_lock>
    // TODO: Fetch default pin from HAL
    if (!lock())
    {
        hal_spi_begin(_spi, SPI_DEFAULT_SS);
 80a5c3e:	7820      	ldrb	r0, [r4, #0]
 80a5c40:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80a5c44:	f7ff fc38 	bl	80a54b8 <hal_spi_begin>
        unlock();
 80a5c48:	4620      	mov	r0, r4
 80a5c4a:	f7ff ffe1 	bl	80a5c10 <_ZN8SPIClass6unlockEv>
    }
}
 80a5c4e:	bd10      	pop	{r4, pc}

080a5c50 <_ZN8SPIClass5beginEt>:

void SPIClass::begin(uint16_t ss_pin)
{
 80a5c50:	b538      	push	{r3, r4, r5, lr}
 80a5c52:	4604      	mov	r4, r0
 80a5c54:	460d      	mov	r5, r1
 80a5c56:	6880      	ldr	r0, [r0, #8]
 80a5c58:	f7ff fd92 	bl	80a5780 <os_mutex_recursive_lock>
    if (!lock())
    {
        hal_spi_begin(_spi, ss_pin);
 80a5c5c:	7820      	ldrb	r0, [r4, #0]
 80a5c5e:	4629      	mov	r1, r5
 80a5c60:	f7ff fc2a 	bl	80a54b8 <hal_spi_begin>
        unlock();
 80a5c64:	4620      	mov	r0, r4
 80a5c66:	f7ff ffd3 	bl	80a5c10 <_ZN8SPIClass6unlockEv>
    }
}
 80a5c6a:	bd38      	pop	{r3, r4, r5, pc}

080a5c6c <_ZN8SPIClass11setBitOrderEh>:
        unlock();
    }
}

void SPIClass::setBitOrder(uint8_t bitOrder)
{
 80a5c6c:	b538      	push	{r3, r4, r5, lr}
 80a5c6e:	4604      	mov	r4, r0
 80a5c70:	460d      	mov	r5, r1
 80a5c72:	6880      	ldr	r0, [r0, #8]
 80a5c74:	f7ff fd84 	bl	80a5780 <os_mutex_recursive_lock>
    if (!lock())
    {
        hal_spi_set_bit_order(_spi, bitOrder);
 80a5c78:	7820      	ldrb	r0, [r4, #0]
 80a5c7a:	4629      	mov	r1, r5
 80a5c7c:	f7ff fc24 	bl	80a54c8 <hal_spi_set_bit_order>
        unlock();
 80a5c80:	4620      	mov	r0, r4
 80a5c82:	f7ff ffc5 	bl	80a5c10 <_ZN8SPIClass6unlockEv>
    }
}
 80a5c86:	bd38      	pop	{r3, r4, r5, pc}

080a5c88 <_ZN8SPIClass11setDataModeEh>:

void SPIClass::setDataMode(uint8_t mode)
{
 80a5c88:	b538      	push	{r3, r4, r5, lr}
 80a5c8a:	4604      	mov	r4, r0
 80a5c8c:	460d      	mov	r5, r1
 80a5c8e:	6880      	ldr	r0, [r0, #8]
 80a5c90:	f7ff fd76 	bl	80a5780 <os_mutex_recursive_lock>
    if (!lock())
    {
        hal_spi_set_data_mode(_spi, mode);
 80a5c94:	7820      	ldrb	r0, [r4, #0]
 80a5c96:	4629      	mov	r1, r5
 80a5c98:	f7ff fc1e 	bl	80a54d8 <hal_spi_set_data_mode>
        unlock();
 80a5c9c:	4620      	mov	r0, r4
 80a5c9e:	f7ff ffb7 	bl	80a5c10 <_ZN8SPIClass6unlockEv>
    }
}
 80a5ca2:	bd38      	pop	{r3, r4, r5, pc}

080a5ca4 <_ZN8SPIClass14endTransactionEv>:

    return 0;
}

void SPIClass::endTransaction()
{
 80a5ca4:	b508      	push	{r3, lr}
    // Release peripheral
    unlock();
 80a5ca6:	f7ff ffb3 	bl	80a5c10 <_ZN8SPIClass6unlockEv>
}
 80a5caa:	bd08      	pop	{r3, pc}

080a5cac <_ZN8SPIClass19computeClockDividerEjjRhRj>:
    }
}

void SPIClass::computeClockDivider(unsigned reference, unsigned targetSpeed, uint8_t& divider,
                                   unsigned& clock)
{
 80a5cac:	b530      	push	{r4, r5, lr}
    clock = reference;
    uint8_t scale = 0;
    clock >>= 1; // div2 is the first
 80a5cae:	2400      	movs	r4, #0
 80a5cb0:	0840      	lsrs	r0, r0, #1
 80a5cb2:	6018      	str	r0, [r3, #0]
    while (clock > targetSpeed && scale < 7)
 80a5cb4:	6818      	ldr	r0, [r3, #0]
 80a5cb6:	b2e5      	uxtb	r5, r4
 80a5cb8:	4288      	cmp	r0, r1
 80a5cba:	d906      	bls.n	80a5cca <_ZN8SPIClass19computeClockDividerEjjRhRj+0x1e>
 80a5cbc:	3401      	adds	r4, #1
 80a5cbe:	2c08      	cmp	r4, #8
 80a5cc0:	d002      	beq.n	80a5cc8 <_ZN8SPIClass19computeClockDividerEjjRhRj+0x1c>
    {
        clock >>= 1;
 80a5cc2:	0840      	lsrs	r0, r0, #1
 80a5cc4:	6018      	str	r0, [r3, #0]
    while (clock > targetSpeed && scale < 7)
 80a5cc6:	e7f5      	b.n	80a5cb4 <_ZN8SPIClass19computeClockDividerEjjRhRj+0x8>
 80a5cc8:	2507      	movs	r5, #7
        scale++;
    }
    divider = clock_divisors[scale];
 80a5cca:	4b02      	ldr	r3, [pc, #8]	; (80a5cd4 <_ZN8SPIClass19computeClockDividerEjjRhRj+0x28>)
 80a5ccc:	5d5b      	ldrb	r3, [r3, r5]
 80a5cce:	7013      	strb	r3, [r2, #0]
}
 80a5cd0:	bd30      	pop	{r4, r5, pc}
 80a5cd2:	bf00      	nop
 80a5cd4:	080aa4e8 	.word	0x080aa4e8

080a5cd8 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE>:
{
 80a5cd8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a5cdc:	4606      	mov	r6, r0
 80a5cde:	b08f      	sub	sp, #60	; 0x3c
 80a5ce0:	6880      	ldr	r0, [r0, #8]
 80a5ce2:	460c      	mov	r4, r1
 80a5ce4:	f7ff fd4c 	bl	80a5780 <os_mutex_recursive_lock>
    memset(info, 0, sizeof(hal_spi_info_t));
 80a5ce8:	2214      	movs	r2, #20
 80a5cea:	2100      	movs	r1, #0
 80a5cec:	a809      	add	r0, sp, #36	; 0x24
    querySpiInfo(_spi, &spi_info);
 80a5cee:	7835      	ldrb	r5, [r6, #0]
    memset(info, 0, sizeof(hal_spi_info_t));
 80a5cf0:	f002 fdfa 	bl	80a88e8 <memset>
    info->version = HAL_SPI_INFO_VERSION_1;
 80a5cf4:	230b      	movs	r3, #11
    hal_spi_info(spi, info, nullptr);
 80a5cf6:	2200      	movs	r2, #0
 80a5cf8:	4628      	mov	r0, r5
 80a5cfa:	a909      	add	r1, sp, #36	; 0x24
    info->version = HAL_SPI_INFO_VERSION_1;
 80a5cfc:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
    hal_spi_info(spi, info, nullptr);
 80a5d00:	f7ff fc12 	bl	80a5528 <hal_spi_info>
    if (!info || !info->enabled || info->default_settings)
 80a5d04:	f89d 302d 	ldrb.w	r3, [sp, #45]	; 0x2d
 80a5d08:	b113      	cbz	r3, 80a5d10 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x38>
 80a5d0a:	f89d 502c 	ldrb.w	r5, [sp, #44]	; 0x2c
 80a5d0e:	b155      	cbz	r5, 80a5d26 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x4e>
      dataMode_{dataMode}
  {
  }

  SPISettings()
  {
 80a5d10:	2700      	movs	r7, #0
 80a5d12:	2501      	movs	r5, #1
 80a5d14:	46b9      	mov	r9, r7
 80a5d16:	46b8      	mov	r8, r7
  virtual ~SPISettings() {
  }

  bool operator==(const SPISettings& other) const
  {
    if (default_ && other.default_)
 80a5d18:	7923      	ldrb	r3, [r4, #4]
 80a5d1a:	b15d      	cbz	r5, 80a5d34 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x5c>
 80a5d1c:	b1c3      	cbz	r3, 80a5d50 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x78>
}
 80a5d1e:	2000      	movs	r0, #0
 80a5d20:	b00f      	add	sp, #60	; 0x3c
 80a5d22:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    return particle::SPISettings(info->clock, info->bit_order, info->data_mode);
 80a5d26:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
 80a5d2a:	f89d 9034 	ldrb.w	r9, [sp, #52]	; 0x34
 80a5d2e:	f89d 7035 	ldrb.w	r7, [sp, #53]	; 0x35
  }
 80a5d32:	e7f1      	b.n	80a5d18 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x40>
      return true;

    if (default_ == other.default_ &&
 80a5d34:	2b00      	cmp	r3, #0
 80a5d36:	d135      	bne.n	80a5da4 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0xcc>
 80a5d38:	68a3      	ldr	r3, [r4, #8]
 80a5d3a:	4543      	cmp	r3, r8
 80a5d3c:	d108      	bne.n	80a5d50 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x78>
        clock_ == other.clock_ &&
        bitOrder_ == other.bitOrder_ &&
 80a5d3e:	f88d 9020 	strb.w	r9, [sp, #32]
 80a5d42:	f88d 7021 	strb.w	r7, [sp, #33]	; 0x21
 80a5d46:	f8bd 2020 	ldrh.w	r2, [sp, #32]
 80a5d4a:	89a3      	ldrh	r3, [r4, #12]
 80a5d4c:	429a      	cmp	r2, r3
 80a5d4e:	d0e6      	beq.n	80a5d1e <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x46>
            uint8_t divisor = 0;
 80a5d50:	2300      	movs	r3, #0
            computeClockDivider((unsigned int)spi_info.system_clock, settings.clock_, divisor,
 80a5d52:	68a1      	ldr	r1, [r4, #8]
            uint8_t divisor = 0;
 80a5d54:	f88d 300f 	strb.w	r3, [sp, #15]
            computeClockDivider((unsigned int)spi_info.system_clock, settings.clock_, divisor,
 80a5d58:	980a      	ldr	r0, [sp, #40]	; 0x28
 80a5d5a:	ab04      	add	r3, sp, #16
 80a5d5c:	f10d 020f 	add.w	r2, sp, #15
 80a5d60:	f7ff ffa4 	bl	80a5cac <_ZN8SPIClass19computeClockDividerEjjRhRj>
    return false;
  }

  bool operator<=(const SPISettings& other) const
  {
    if (default_ && other.default_)
 80a5d64:	7921      	ldrb	r1, [r4, #4]
 80a5d66:	b985      	cbnz	r5, 80a5d8a <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0xb2>
      return true;

    if (default_ == other.default_ &&
 80a5d68:	b989      	cbnz	r1, 80a5d8e <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0xb6>
 80a5d6a:	68a3      	ldr	r3, [r4, #8]
 80a5d6c:	4543      	cmp	r3, r8
 80a5d6e:	d30e      	bcc.n	80a5d8e <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0xb6>
        clock_ <= other.clock_ &&
        bitOrder_ == other.bitOrder_ &&
 80a5d70:	f88d 9020 	strb.w	r9, [sp, #32]
 80a5d74:	f88d 7021 	strb.w	r7, [sp, #33]	; 0x21
 80a5d78:	f8bd 2020 	ldrh.w	r2, [sp, #32]
 80a5d7c:	89a3      	ldrh	r3, [r4, #12]
 80a5d7e:	429a      	cmp	r2, r3
 80a5d80:	d105      	bne.n	80a5d8e <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0xb6>
            if (!(spi_settings <= settings && clock == spi_settings.clock_))
 80a5d82:	9b04      	ldr	r3, [sp, #16]
 80a5d84:	4543      	cmp	r3, r8
 80a5d86:	d102      	bne.n	80a5d8e <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0xb6>
 80a5d88:	e7c9      	b.n	80a5d1e <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x46>
    if (default_ && other.default_)
 80a5d8a:	2900      	cmp	r1, #0
 80a5d8c:	d1f9      	bne.n	80a5d82 <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0xaa>
                hal_spi_set_settings(_spi, settings.default_, divisor, settings.bitOrder_,
 80a5d8e:	2300      	movs	r3, #0
 80a5d90:	9301      	str	r3, [sp, #4]
 80a5d92:	7b63      	ldrb	r3, [r4, #13]
 80a5d94:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80a5d98:	9300      	str	r3, [sp, #0]
 80a5d9a:	7b23      	ldrb	r3, [r4, #12]
            hal_spi_set_settings(_spi, settings.default_, 0, 0, 0, nullptr);
 80a5d9c:	7830      	ldrb	r0, [r6, #0]
 80a5d9e:	f7ff fbcb 	bl	80a5538 <hal_spi_set_settings>
    return 0;
 80a5da2:	e7bc      	b.n	80a5d1e <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0x46>
            hal_spi_set_settings(_spi, settings.default_, 0, 0, 0, nullptr);
 80a5da4:	462b      	mov	r3, r5
 80a5da6:	462a      	mov	r2, r5
 80a5da8:	2101      	movs	r1, #1
 80a5daa:	e9cd 5500 	strd	r5, r5, [sp]
 80a5dae:	e7f5      	b.n	80a5d9c <_ZN8SPIClass16beginTransactionERKN8particle11SPISettingsE+0xc4>

080a5db0 <_ZN8SPIClass13setClockSpeedEjj>:

unsigned SPIClass::setClockSpeed(unsigned value, unsigned value_scale)
{
 80a5db0:	b5f0      	push	{r4, r5, r6, r7, lr}
    unsigned clock = 0;
 80a5db2:	2500      	movs	r5, #0
{
 80a5db4:	4604      	mov	r4, r0
 80a5db6:	b089      	sub	sp, #36	; 0x24
 80a5db8:	6880      	ldr	r0, [r0, #8]

    // actual speed is the system clock divided by some scalar
    unsigned targetSpeed = value * value_scale;
 80a5dba:	fb02 f601 	mul.w	r6, r2, r1
    unsigned clock = 0;
 80a5dbe:	9502      	str	r5, [sp, #8]
 80a5dc0:	f7ff fcde 	bl	80a5780 <os_mutex_recursive_lock>
    memset(info, 0, sizeof(hal_spi_info_t));
 80a5dc4:	4629      	mov	r1, r5
 80a5dc6:	2214      	movs	r2, #20
 80a5dc8:	a803      	add	r0, sp, #12

    if (!lock())
    {
        // Query SPI info
        hal_spi_info_t info;
        querySpiInfo(_spi, &info);
 80a5dca:	7827      	ldrb	r7, [r4, #0]
    memset(info, 0, sizeof(hal_spi_info_t));
 80a5dcc:	f002 fd8c 	bl	80a88e8 <memset>
    info->version = HAL_SPI_INFO_VERSION_1;
 80a5dd0:	230b      	movs	r3, #11
    hal_spi_info(spi, info, nullptr);
 80a5dd2:	462a      	mov	r2, r5
 80a5dd4:	4638      	mov	r0, r7
 80a5dd6:	a903      	add	r1, sp, #12
    info->version = HAL_SPI_INFO_VERSION_1;
 80a5dd8:	f8ad 300c 	strh.w	r3, [sp, #12]
    hal_spi_info(spi, info, nullptr);
 80a5ddc:	f7ff fba4 	bl	80a5528 <hal_spi_info>

        // Calculate clock divider
        uint8_t divisor = 0;
        computeClockDivider(info.system_clock, targetSpeed, divisor, clock);
 80a5de0:	ab02      	add	r3, sp, #8
 80a5de2:	f10d 0207 	add.w	r2, sp, #7
 80a5de6:	4631      	mov	r1, r6
 80a5de8:	9804      	ldr	r0, [sp, #16]
        uint8_t divisor = 0;
 80a5dea:	f88d 5007 	strb.w	r5, [sp, #7]
        computeClockDivider(info.system_clock, targetSpeed, divisor, clock);
 80a5dee:	f7ff ff5d 	bl	80a5cac <_ZN8SPIClass19computeClockDividerEjjRhRj>

        // Update SPI peripheral
        hal_spi_set_clock_divider(_spi, divisor);
 80a5df2:	f89d 1007 	ldrb.w	r1, [sp, #7]
 80a5df6:	7820      	ldrb	r0, [r4, #0]
 80a5df8:	f7ff fb76 	bl	80a54e8 <hal_spi_set_clock_divider>
        unlock();
 80a5dfc:	4620      	mov	r0, r4
 80a5dfe:	f7ff ff07 	bl	80a5c10 <_ZN8SPIClass6unlockEv>
    }

    return clock;
}
 80a5e02:	9802      	ldr	r0, [sp, #8]
 80a5e04:	b009      	add	sp, #36	; 0x24
 80a5e06:	bdf0      	pop	{r4, r5, r6, r7, pc}

080a5e08 <_ZN8SPIClass15setClockDividerEh>:
{
 80a5e08:	b538      	push	{r3, r4, r5, lr}
 80a5e0a:	4604      	mov	r4, r0
 80a5e0c:	6880      	ldr	r0, [r0, #8]
 80a5e0e:	460d      	mov	r5, r1
 80a5e10:	f7ff fcb6 	bl	80a5780 <os_mutex_recursive_lock>
        if (_dividerReference)
 80a5e14:	6861      	ldr	r1, [r4, #4]
 80a5e16:	b199      	cbz	r1, 80a5e40 <_ZN8SPIClass15setClockDividerEh+0x38>
    unsigned result = 0;
 80a5e18:	2300      	movs	r3, #0
 80a5e1a:	4a0c      	ldr	r2, [pc, #48]	; (80a5e4c <_ZN8SPIClass15setClockDividerEh+0x44>)
        if (clock_divisors[result] == divider)
 80a5e1c:	f812 0b01 	ldrb.w	r0, [r2], #1
 80a5e20:	4285      	cmp	r5, r0
 80a5e22:	d002      	beq.n	80a5e2a <_ZN8SPIClass15setClockDividerEh+0x22>
    for (; result < arraySize(clock_divisors); result++)
 80a5e24:	3301      	adds	r3, #1
 80a5e26:	2b08      	cmp	r3, #8
 80a5e28:	d1f8      	bne.n	80a5e1c <_ZN8SPIClass15setClockDividerEh+0x14>
    return result + 1;
 80a5e2a:	3301      	adds	r3, #1
            unsigned targetSpeed = _dividerReference >> scale;
 80a5e2c:	b2db      	uxtb	r3, r3
            setClockSpeed(targetSpeed);
 80a5e2e:	2201      	movs	r2, #1
 80a5e30:	4620      	mov	r0, r4
 80a5e32:	40d9      	lsrs	r1, r3
 80a5e34:	f7ff ffbc 	bl	80a5db0 <_ZN8SPIClass13setClockSpeedEjj>
        unlock();
 80a5e38:	4620      	mov	r0, r4
 80a5e3a:	f7ff fee9 	bl	80a5c10 <_ZN8SPIClass6unlockEv>
}
 80a5e3e:	bd38      	pop	{r3, r4, r5, pc}
            hal_spi_set_clock_divider(_spi, rate);
 80a5e40:	4629      	mov	r1, r5
 80a5e42:	7820      	ldrb	r0, [r4, #0]
 80a5e44:	f7ff fb50 	bl	80a54e8 <hal_spi_set_clock_divider>
 80a5e48:	e7f6      	b.n	80a5e38 <_ZN8SPIClass15setClockDividerEh+0x30>
 80a5e4a:	bf00      	nop
 80a5e4c:	080aa4e8 	.word	0x080aa4e8

080a5e50 <_ZN8SPIClass8transferEh>:

byte SPIClass::transfer(byte _data)
{
 80a5e50:	b508      	push	{r3, lr}
    return static_cast<byte>(hal_spi_transfer(_spi, _data));
 80a5e52:	7800      	ldrb	r0, [r0, #0]
 80a5e54:	f7ff fb50 	bl	80a54f8 <hal_spi_transfer>
}
 80a5e58:	b2c0      	uxtb	r0, r0
 80a5e5a:	bd08      	pop	{r3, pc}

080a5e5c <_ZN5spark9WiFiClass5readyEv>:
        return network_ready(*this, 0, NULL);
 80a5e5c:	2200      	movs	r2, #0
 80a5e5e:	6840      	ldr	r0, [r0, #4]
 80a5e60:	4611      	mov	r1, r2
 80a5e62:	f7ff bd85 	b.w	80a5970 <network_ready>

080a5e66 <_ZN5spark9WiFiClass7resolveEPKc>:
    IPAddress resolve(const char* name)
 80a5e66:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a5e68:	4615      	mov	r5, r2
 80a5e6a:	b089      	sub	sp, #36	; 0x24
        HAL_IPAddress ip = {};
 80a5e6c:	2211      	movs	r2, #17
    IPAddress resolve(const char* name)
 80a5e6e:	460e      	mov	r6, r1
 80a5e70:	4604      	mov	r4, r0
        HAL_IPAddress ip = {};
 80a5e72:	2100      	movs	r1, #0
 80a5e74:	a803      	add	r0, sp, #12
 80a5e76:	f002 fd37 	bl	80a88e8 <memset>
        return (inet_gethostbyname(name, strlen(name), &ip, *this, NULL) != 0) ?
 80a5e7a:	4628      	mov	r0, r5
 80a5e7c:	f002 fdd1 	bl	80a8a22 <strlen>
 80a5e80:	2700      	movs	r7, #0
 80a5e82:	b281      	uxth	r1, r0
 80a5e84:	6873      	ldr	r3, [r6, #4]
 80a5e86:	4628      	mov	r0, r5
 80a5e88:	9700      	str	r7, [sp, #0]
 80a5e8a:	aa03      	add	r2, sp, #12
 80a5e8c:	f7ff fadc 	bl	80a5448 <inet_gethostbyname>
                IPAddress(uint32_t(0)) : IPAddress(ip);
 80a5e90:	b130      	cbz	r0, 80a5ea0 <_ZN5spark9WiFiClass7resolveEPKc+0x3a>
 80a5e92:	4639      	mov	r1, r7
 80a5e94:	4620      	mov	r0, r4
 80a5e96:	f000 fa59 	bl	80a634c <_ZN9IPAddressC1Em>
    }
 80a5e9a:	4620      	mov	r0, r4
 80a5e9c:	b009      	add	sp, #36	; 0x24
 80a5e9e:	bdf0      	pop	{r4, r5, r6, r7, pc}
                IPAddress(uint32_t(0)) : IPAddress(ip);
 80a5ea0:	4620      	mov	r0, r4
 80a5ea2:	a903      	add	r1, sp, #12
 80a5ea4:	f000 fa40 	bl	80a6328 <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>
 80a5ea8:	e7f7      	b.n	80a5e9a <_ZN5spark9WiFiClass7resolveEPKc+0x34>

080a5eaa <_ZN5spark9WiFiClass9listeningEv>:
        return network_listening(*this, 0, NULL);
 80a5eaa:	2200      	movs	r2, #0
 80a5eac:	6840      	ldr	r0, [r0, #4]
 80a5eae:	4611      	mov	r1, r2
 80a5eb0:	f7ff bd7e 	b.w	80a59b0 <network_listening>

080a5eb4 <_ZN5spark9WiFiClass16getListenTimeoutEv>:
        return network_get_listen_timeout(*this, 0, NULL);
 80a5eb4:	2200      	movs	r2, #0
 80a5eb6:	6840      	ldr	r0, [r0, #4]
 80a5eb8:	4611      	mov	r1, r2
 80a5eba:	f7ff bd89 	b.w	80a59d0 <network_get_listen_timeout>

080a5ebe <_ZN5spark9WiFiClass16setListenTimeoutEt>:
        network_set_listen_timeout(*this, timeout, NULL);
 80a5ebe:	2200      	movs	r2, #0
 80a5ec0:	6840      	ldr	r0, [r0, #4]
 80a5ec2:	f7ff bd7d 	b.w	80a59c0 <network_set_listen_timeout>

080a5ec6 <_ZN5spark9WiFiClass6listenEb>:
        network_listen(*this, begin ? 0 : 1, NULL);
 80a5ec6:	2200      	movs	r2, #0
 80a5ec8:	6840      	ldr	r0, [r0, #4]
 80a5eca:	f081 0101 	eor.w	r1, r1, #1
 80a5ece:	f7ff bd67 	b.w	80a59a0 <network_listen>

080a5ed2 <_ZN5spark9WiFiClass3offEv>:
        network_off(*this, 0, 0, NULL);
 80a5ed2:	2300      	movs	r3, #0
 80a5ed4:	6840      	ldr	r0, [r0, #4]
 80a5ed6:	461a      	mov	r2, r3
 80a5ed8:	4619      	mov	r1, r3
 80a5eda:	f7ff bd59 	b.w	80a5990 <network_off>

080a5ede <_ZN5spark9WiFiClass2onEv>:
        network_on(*this, 0, 0, NULL);
 80a5ede:	2300      	movs	r3, #0
 80a5ee0:	6840      	ldr	r0, [r0, #4]
 80a5ee2:	461a      	mov	r2, r3
 80a5ee4:	4619      	mov	r1, r3
 80a5ee6:	f7ff bd4b 	b.w	80a5980 <network_on>

080a5eea <_ZN5spark9WiFiClass10connectingEv>:
        return network_connecting(*this, 0, NULL);
 80a5eea:	2200      	movs	r2, #0
 80a5eec:	6840      	ldr	r0, [r0, #4]
 80a5eee:	4611      	mov	r1, r2
 80a5ef0:	f7ff bd2e 	b.w	80a5950 <network_connecting>

080a5ef4 <_ZN5spark9WiFiClass10disconnectEv>:
        network_disconnect(*this, NETWORK_DISCONNECT_REASON_USER, NULL);
 80a5ef4:	2200      	movs	r2, #0
 80a5ef6:	2102      	movs	r1, #2
 80a5ef8:	6840      	ldr	r0, [r0, #4]
 80a5efa:	f7ff bd31 	b.w	80a5960 <network_disconnect>

080a5efe <_ZN5spark9WiFiClass7connectEj>:
        network_connect(*this, flags, 0, NULL);
 80a5efe:	2300      	movs	r3, #0
 80a5f00:	6840      	ldr	r0, [r0, #4]
 80a5f02:	461a      	mov	r2, r3
 80a5f04:	f7ff bd1c 	b.w	80a5940 <network_connect>

080a5f08 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t>:
 80a5f08:	2204      	movs	r2, #4
 80a5f0a:	4b02      	ldr	r3, [pc, #8]	; (80a5f14 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0xc>)
 80a5f0c:	605a      	str	r2, [r3, #4]
            NetworkClass(NETWORK_INTERFACE_WIFI_STA) {
 80a5f0e:	4a02      	ldr	r2, [pc, #8]	; (80a5f18 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x10>)
 80a5f10:	601a      	str	r2, [r3, #0]
the same way.
*****************************************************************************/

    WiFiClass WiFi;
    // NetworkClass& Network = WiFi;
}
 80a5f12:	4770      	bx	lr
 80a5f14:	20000da4 	.word	0x20000da4
 80a5f18:	080aa4f8 	.word	0x080aa4f8

080a5f1c <_ZN8particle6detail21futureCallbackWrapperEPv>:
 * License along with this library; if not, see <http://www.gnu.org/licenses/>.
 */

#include "spark_wiring_async.h"

void particle::detail::futureCallbackWrapper(void* data) {
 80a5f1c:	b510      	push	{r4, lr}
      if (_M_empty())
 80a5f1e:	6883      	ldr	r3, [r0, #8]
 80a5f20:	4604      	mov	r4, r0
 80a5f22:	b90b      	cbnz	r3, 80a5f28 <_ZN8particle6detail21futureCallbackWrapperEPv+0xc>
	__throw_bad_function_call();
 80a5f24:	f001 fb79 	bl	80a761a <_ZSt25__throw_bad_function_callv>
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a5f28:	68c3      	ldr	r3, [r0, #12]
 80a5f2a:	4798      	blx	r3
      if (_M_manager)
 80a5f2c:	68a3      	ldr	r3, [r4, #8]
 80a5f2e:	b11b      	cbz	r3, 80a5f38 <_ZN8particle6detail21futureCallbackWrapperEPv+0x1c>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
 80a5f30:	2203      	movs	r2, #3
 80a5f32:	4621      	mov	r1, r4
 80a5f34:	4620      	mov	r0, r4
 80a5f36:	4798      	blx	r3
    auto callbackPtr = static_cast<const std::function<void()>*>(data);
    (*callbackPtr)();
    delete callbackPtr;
 80a5f38:	4620      	mov	r0, r4
}
 80a5f3a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    delete callbackPtr;
 80a5f3e:	2110      	movs	r1, #16
 80a5f40:	f001 bb67 	b.w	80a7612 <_ZdlPvj>

080a5f44 <_ZN11USARTSerialD1Ev>:
private:
  hal_usart_interface_t _serial;
  bool _blocking;
public:
  USARTSerial(hal_usart_interface_t serial, hal_usart_ring_buffer_t *rx_buffer, hal_usart_ring_buffer_t *tx_buffer);
  virtual ~USARTSerial() {};
 80a5f44:	4770      	bx	lr

080a5f46 <_ZN11USARTSerial14blockOnOverrunEb>:
    hal_usart_half_duplex(_serial, Enable);
}

void USARTSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a5f46:	7441      	strb	r1, [r0, #17]
}
 80a5f48:	4770      	bx	lr

080a5f4a <__tcf_0>:
    serial1_rx_buffer = new hal_usart_ring_buffer_t();
  }
  if (!serial1_tx_buffer) {
    serial1_tx_buffer = new hal_usart_ring_buffer_t();
  }
  static USARTSerial serial1(HAL_USART_SERIAL1, serial1_rx_buffer, serial1_tx_buffer);
 80a5f4a:	4770      	bx	lr

080a5f4c <_ZN11USARTSerial17availableForWriteEv>:
{
 80a5f4c:	b508      	push	{r3, lr}
  return std::max(0, (int)hal_usart_available_data_for_write(_serial));
 80a5f4e:	7c00      	ldrb	r0, [r0, #16]
 80a5f50:	f7ff fbc6 	bl	80a56e0 <hal_usart_available_data_for_write>
}
 80a5f54:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80a5f58:	bd08      	pop	{r3, pc}

080a5f5a <_ZN11USARTSerial9availableEv>:
{
 80a5f5a:	b508      	push	{r3, lr}
  return std::max(0, (int)hal_usart_available(_serial));
 80a5f5c:	7c00      	ldrb	r0, [r0, #16]
 80a5f5e:	f7ff fb97 	bl	80a5690 <hal_usart_available>
}
 80a5f62:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80a5f66:	bd08      	pop	{r3, pc}

080a5f68 <_ZN11USARTSerial4peekEv>:
{
 80a5f68:	b508      	push	{r3, lr}
  return std::max(-1, (int)hal_usart_peek(_serial));
 80a5f6a:	7c00      	ldrb	r0, [r0, #16]
 80a5f6c:	f7ff fba0 	bl	80a56b0 <hal_usart_peek>
}
 80a5f70:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
 80a5f74:	bd08      	pop	{r3, pc}

080a5f76 <_ZN11USARTSerial4readEv>:
{
 80a5f76:	b508      	push	{r3, lr}
  return std::max(-1, (int)hal_usart_read(_serial));
 80a5f78:	7c00      	ldrb	r0, [r0, #16]
 80a5f7a:	f7ff fb91 	bl	80a56a0 <hal_usart_read>
}
 80a5f7e:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
 80a5f82:	bd08      	pop	{r3, pc}

080a5f84 <_ZN11USARTSerial5flushEv>:
  hal_usart_flush(_serial);
 80a5f84:	7c00      	ldrb	r0, [r0, #16]
 80a5f86:	f7ff bb9b 	b.w	80a56c0 <hal_usart_flush>

080a5f8a <_ZN11USARTSerial5writeEh>:
{
 80a5f8a:	b570      	push	{r4, r5, r6, lr}
  if (_blocking || hal_usart_available_data_for_write(_serial) > 0) {
 80a5f8c:	7c46      	ldrb	r6, [r0, #17]
{
 80a5f8e:	4604      	mov	r4, r0
 80a5f90:	460d      	mov	r5, r1
  if (_blocking || hal_usart_available_data_for_write(_serial) > 0) {
 80a5f92:	b12e      	cbz	r6, 80a5fa0 <_ZN11USARTSerial5writeEh+0x16>
	  return hal_usart_write(_serial, c);
 80a5f94:	4629      	mov	r1, r5
 80a5f96:	7c20      	ldrb	r0, [r4, #16]
}
 80a5f98:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	  return hal_usart_write(_serial, c);
 80a5f9c:	f7ff bb70 	b.w	80a5680 <hal_usart_write>
  if (_blocking || hal_usart_available_data_for_write(_serial) > 0) {
 80a5fa0:	7c00      	ldrb	r0, [r0, #16]
 80a5fa2:	f7ff fb9d 	bl	80a56e0 <hal_usart_available_data_for_write>
 80a5fa6:	2800      	cmp	r0, #0
 80a5fa8:	dcf4      	bgt.n	80a5f94 <_ZN11USARTSerial5writeEh+0xa>
}
 80a5faa:	4630      	mov	r0, r6
 80a5fac:	bd70      	pop	{r4, r5, r6, pc}

080a5fae <_ZN11USARTSerialD0Ev>:
 80a5fae:	b510      	push	{r4, lr}
 80a5fb0:	4604      	mov	r4, r0
 80a5fb2:	2114      	movs	r1, #20
 80a5fb4:	f001 fb2d 	bl	80a7612 <_ZdlPvj>
 80a5fb8:	4620      	mov	r0, r4
 80a5fba:	bd10      	pop	{r4, pc}

080a5fbc <_ZN11USARTSerialC1E21hal_usart_interface_tP23hal_usart_ring_buffer_tS2_>:
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
 80a5fbc:	f04f 0c00 	mov.w	ip, #0
USARTSerial::USARTSerial(hal_usart_interface_t serial, hal_usart_ring_buffer_t *rx_buffer, hal_usart_ring_buffer_t *tx_buffer)
 80a5fc0:	b510      	push	{r4, lr}
 80a5fc2:	4604      	mov	r4, r0
 80a5fc4:	4608      	mov	r0, r1
 80a5fc6:	4611      	mov	r1, r2
 80a5fc8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80a5fcc:	e9c4 c201 	strd	ip, r2, [r4, #4]
 80a5fd0:	4a04      	ldr	r2, [pc, #16]	; (80a5fe4 <_ZN11USARTSerialC1E21hal_usart_interface_tP23hal_usart_ring_buffer_tS2_+0x28>)
  _serial = serial;
 80a5fd2:	7420      	strb	r0, [r4, #16]
USARTSerial::USARTSerial(hal_usart_interface_t serial, hal_usart_ring_buffer_t *rx_buffer, hal_usart_ring_buffer_t *tx_buffer)
 80a5fd4:	6022      	str	r2, [r4, #0]
  _blocking = true;
 80a5fd6:	2201      	movs	r2, #1
 80a5fd8:	7462      	strb	r2, [r4, #17]
  hal_usart_init(serial, rx_buffer, tx_buffer);
 80a5fda:	461a      	mov	r2, r3
 80a5fdc:	f7ff fb40 	bl	80a5660 <hal_usart_init>
}
 80a5fe0:	4620      	mov	r0, r4
 80a5fe2:	bd10      	pop	{r4, pc}
 80a5fe4:	080aa534 	.word	0x080aa534

080a5fe8 <_ZN11USARTSerial5beginEmm>:
  hal_usart_begin_config(_serial, baud, config, nullptr);
 80a5fe8:	2300      	movs	r3, #0
 80a5fea:	7c00      	ldrb	r0, [r0, #16]
 80a5fec:	f7ff bb80 	b.w	80a56f0 <hal_usart_begin_config>

080a5ff0 <_ZN11USARTSerial5beginEm>:
  begin(baud, SERIAL_8N1);
 80a5ff0:	2200      	movs	r2, #0
 80a5ff2:	f7ff bff9 	b.w	80a5fe8 <_ZN11USARTSerial5beginEmm>

080a5ff6 <_ZN11USARTSerial3endEv>:
  hal_usart_end(_serial);
 80a5ff6:	7c00      	ldrb	r0, [r0, #16]
 80a5ff8:	f7ff bb3a 	b.w	80a5670 <hal_usart_end>

080a5ffc <_Z22__fetch_global_Serial1v>:
{
 80a5ffc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (!serial1_rx_buffer) {
 80a5ffe:	4c19      	ldr	r4, [pc, #100]	; (80a6064 <_Z22__fetch_global_Serial1v+0x68>)
 80a6000:	6826      	ldr	r6, [r4, #0]
 80a6002:	b94e      	cbnz	r6, 80a6018 <_Z22__fetch_global_Serial1v+0x1c>
    serial1_rx_buffer = new hal_usart_ring_buffer_t();
 80a6004:	2084      	movs	r0, #132	; 0x84
 80a6006:	f7fa f846 	bl	80a0096 <_Znwj>
 80a600a:	4605      	mov	r5, r0
 80a600c:	b118      	cbz	r0, 80a6016 <_Z22__fetch_global_Serial1v+0x1a>
 80a600e:	2284      	movs	r2, #132	; 0x84
 80a6010:	4631      	mov	r1, r6
 80a6012:	f002 fc69 	bl	80a88e8 <memset>
 80a6016:	6025      	str	r5, [r4, #0]
  if (!serial1_tx_buffer) {
 80a6018:	4d13      	ldr	r5, [pc, #76]	; (80a6068 <_Z22__fetch_global_Serial1v+0x6c>)
 80a601a:	682f      	ldr	r7, [r5, #0]
 80a601c:	b94f      	cbnz	r7, 80a6032 <_Z22__fetch_global_Serial1v+0x36>
    serial1_tx_buffer = new hal_usart_ring_buffer_t();
 80a601e:	2084      	movs	r0, #132	; 0x84
 80a6020:	f7fa f839 	bl	80a0096 <_Znwj>
 80a6024:	4606      	mov	r6, r0
 80a6026:	b118      	cbz	r0, 80a6030 <_Z22__fetch_global_Serial1v+0x34>
 80a6028:	2284      	movs	r2, #132	; 0x84
 80a602a:	4639      	mov	r1, r7
 80a602c:	f002 fc5c 	bl	80a88e8 <memset>
 80a6030:	602e      	str	r6, [r5, #0]
  static USARTSerial serial1(HAL_USART_SERIAL1, serial1_rx_buffer, serial1_tx_buffer);
 80a6032:	4f0e      	ldr	r7, [pc, #56]	; (80a606c <_Z22__fetch_global_Serial1v+0x70>)
 80a6034:	7839      	ldrb	r1, [r7, #0]
 80a6036:	f3bf 8f5b 	dmb	ish
 80a603a:	f011 0601 	ands.w	r6, r1, #1
 80a603e:	d10f      	bne.n	80a6060 <_Z22__fetch_global_Serial1v+0x64>
 80a6040:	4638      	mov	r0, r7
 80a6042:	f7fa f839 	bl	80a00b8 <__cxa_guard_acquire>
 80a6046:	b158      	cbz	r0, 80a6060 <_Z22__fetch_global_Serial1v+0x64>
 80a6048:	4631      	mov	r1, r6
 80a604a:	682b      	ldr	r3, [r5, #0]
 80a604c:	6822      	ldr	r2, [r4, #0]
 80a604e:	4808      	ldr	r0, [pc, #32]	; (80a6070 <_Z22__fetch_global_Serial1v+0x74>)
 80a6050:	f7ff ffb4 	bl	80a5fbc <_ZN11USARTSerialC1E21hal_usart_interface_tP23hal_usart_ring_buffer_tS2_>
 80a6054:	4638      	mov	r0, r7
 80a6056:	f7fa f834 	bl	80a00c2 <__cxa_guard_release>
 80a605a:	4806      	ldr	r0, [pc, #24]	; (80a6074 <_Z22__fetch_global_Serial1v+0x78>)
 80a605c:	f002 fb3a 	bl	80a86d4 <atexit>
#endif
	return serial1;
}
 80a6060:	4803      	ldr	r0, [pc, #12]	; (80a6070 <_Z22__fetch_global_Serial1v+0x74>)
 80a6062:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a6064:	20000db0 	.word	0x20000db0
 80a6068:	20000db4 	.word	0x20000db4
 80a606c:	20000dac 	.word	0x20000dac
 80a6070:	20000db8 	.word	0x20000db8
 80a6074:	080a5f4b 	.word	0x080a5f4b

080a6078 <_ZN7TwoWireD1Ev>:
private:
  hal_i2c_interface_t _i2c;

public:
  TwoWire(hal_i2c_interface_t i2c, const hal_i2c_config_t& config);
  virtual ~TwoWire() {};
 80a6078:	4770      	bx	lr

080a607a <_ZN7TwoWire5writeEPKhj>:

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
 80a607a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a607c:	4606      	mov	r6, r0
 80a607e:	4615      	mov	r5, r2
 80a6080:	460c      	mov	r4, r1
 80a6082:	188f      	adds	r7, r1, r2
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
 80a6084:	42bc      	cmp	r4, r7
 80a6086:	d006      	beq.n	80a6096 <_ZN7TwoWire5writeEPKhj+0x1c>
  {
    write(data[i]);
 80a6088:	6833      	ldr	r3, [r6, #0]
 80a608a:	4630      	mov	r0, r6
 80a608c:	689b      	ldr	r3, [r3, #8]
 80a608e:	f814 1b01 	ldrb.w	r1, [r4], #1
 80a6092:	4798      	blx	r3
  for(size_t i = 0; i < quantity; ++i)
 80a6094:	e7f6      	b.n	80a6084 <_ZN7TwoWire5writeEPKhj+0xa>
  }

  return quantity;
}
 80a6096:	4628      	mov	r0, r5
 80a6098:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a609a <_ZN7TwoWire5writeEh>:
  return hal_i2c_write(_i2c, data, NULL);
 80a609a:	2200      	movs	r2, #0
 80a609c:	7c00      	ldrb	r0, [r0, #16]
 80a609e:	f7ff ba9b 	b.w	80a55d8 <hal_i2c_write>

080a60a2 <_ZN7TwoWire9availableEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
  return hal_i2c_available(_i2c, NULL);
 80a60a2:	2100      	movs	r1, #0
 80a60a4:	7c00      	ldrb	r0, [r0, #16]
 80a60a6:	f7ff ba9f 	b.w	80a55e8 <hal_i2c_available>

080a60aa <_ZN7TwoWire4readEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void)
{
  return hal_i2c_read(_i2c, NULL);
 80a60aa:	2100      	movs	r1, #0
 80a60ac:	7c00      	ldrb	r0, [r0, #16]
 80a60ae:	f7ff baa3 	b.w	80a55f8 <hal_i2c_read>

080a60b2 <_ZN7TwoWire4peekEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::peek(void)
{
  return hal_i2c_peek(_i2c, NULL);
 80a60b2:	2100      	movs	r1, #0
 80a60b4:	7c00      	ldrb	r0, [r0, #16]
 80a60b6:	f7ff baa7 	b.w	80a5608 <hal_i2c_peek>

080a60ba <_ZN7TwoWire5flushEv>:
}

void TwoWire::flush(void)
{
  hal_i2c_flush(_i2c, NULL);
 80a60ba:	2100      	movs	r1, #0
 80a60bc:	7c00      	ldrb	r0, [r0, #16]
 80a60be:	f7ff baab 	b.w	80a5618 <hal_i2c_flush>

080a60c2 <_ZN7TwoWireD0Ev>:
 80a60c2:	b510      	push	{r4, lr}
 80a60c4:	4604      	mov	r4, r0
 80a60c6:	2114      	movs	r1, #20
 80a60c8:	f001 faa3 	bl	80a7612 <_ZdlPvj>
 80a60cc:	4620      	mov	r0, r4
 80a60ce:	bd10      	pop	{r4, pc}

080a60d0 <_ZN7TwoWireC1E19hal_i2c_interface_tRK16hal_i2c_config_t>:
TwoWire::TwoWire(hal_i2c_interface_t i2c, const hal_i2c_config_t& conf)
 80a60d0:	b510      	push	{r4, lr}
 80a60d2:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a60d6:	4604      	mov	r4, r0
 80a60d8:	4608      	mov	r0, r1
 80a60da:	2100      	movs	r1, #0
 80a60dc:	e9c4 1301 	strd	r1, r3, [r4, #4]
 80a60e0:	4b03      	ldr	r3, [pc, #12]	; (80a60f0 <_ZN7TwoWireC1E19hal_i2c_interface_tRK16hal_i2c_config_t+0x20>)
  hal_i2c_init(_i2c, &conf);
 80a60e2:	4611      	mov	r1, r2
TwoWire::TwoWire(hal_i2c_interface_t i2c, const hal_i2c_config_t& conf)
 80a60e4:	6023      	str	r3, [r4, #0]
  _i2c = i2c;
 80a60e6:	7420      	strb	r0, [r4, #16]
  hal_i2c_init(_i2c, &conf);
 80a60e8:	f7ff faa6 	bl	80a5638 <hal_i2c_init>
}
 80a60ec:	4620      	mov	r0, r4
 80a60ee:	bd10      	pop	{r4, pc}
 80a60f0:	080aa564 	.word	0x080aa564

080a60f4 <_ZN7TwoWire5beginEv>:
	hal_i2c_begin(_i2c, I2C_MODE_MASTER, 0x00, NULL);
 80a60f4:	2300      	movs	r3, #0
 80a60f6:	7c00      	ldrb	r0, [r0, #16]
 80a60f8:	461a      	mov	r2, r3
 80a60fa:	4619      	mov	r1, r3
 80a60fc:	f7ff ba54 	b.w	80a55a8 <hal_i2c_begin>

080a6100 <_ZN7TwoWire11requestFromERK16WireTransmission>:
size_t TwoWire::requestFrom(const WireTransmission& transfer) {
 80a6100:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
    hal_i2c_transmission_config_t conf = {
 80a6102:	2200      	movs	r2, #0
 80a6104:	2314      	movs	r3, #20
 80a6106:	e9cd 2201 	strd	r2, r2, [sp, #4]
 80a610a:	f8ad 3004 	strh.w	r3, [sp, #4]
    };
 80a610e:	780b      	ldrb	r3, [r1, #0]
  return hal_i2c_request_ex(_i2c, &conf, nullptr);
 80a6110:	7c00      	ldrb	r0, [r0, #16]
 80a6112:	f88d 3008 	strb.w	r3, [sp, #8]
 80a6116:	684b      	ldr	r3, [r1, #4]
 80a6118:	9303      	str	r3, [sp, #12]
 80a611a:	68cb      	ldr	r3, [r1, #12]
 80a611c:	9304      	str	r3, [sp, #16]
      .flags = (uint32_t)(stop_ ? HAL_I2C_TRANSMISSION_FLAG_STOP : 0)
 80a611e:	7a0b      	ldrb	r3, [r1, #8]
 80a6120:	a901      	add	r1, sp, #4
 80a6122:	9305      	str	r3, [sp, #20]
 80a6124:	f7ff fa92 	bl	80a564c <hal_i2c_request_ex>
}
 80a6128:	b007      	add	sp, #28
 80a612a:	f85d fb04 	ldr.w	pc, [sp], #4

080a612e <_ZN7TwoWire11requestFromEhjh>:
{
 80a612e:	b51f      	push	{r0, r1, r2, r3, r4, lr}
  return requestFrom(WireTransmission(address).quantity(quantity).stop(sendStop));
 80a6130:	3b00      	subs	r3, #0
        timeout_{HAL_I2C_DEFAULT_TIMEOUT_MS} {
 80a6132:	f88d 1000 	strb.w	r1, [sp]
 80a6136:	f04f 0164 	mov.w	r1, #100	; 0x64
 80a613a:	bf18      	it	ne
 80a613c:	2301      	movne	r3, #1
 80a613e:	9103      	str	r1, [sp, #12]
 80a6140:	4669      	mov	r1, sp
    size_ = size;
 80a6142:	9201      	str	r2, [sp, #4]
 80a6144:	f88d 3008 	strb.w	r3, [sp, #8]
 80a6148:	f7ff ffda 	bl	80a6100 <_ZN7TwoWire11requestFromERK16WireTransmission>
}
 80a614c:	b005      	add	sp, #20
 80a614e:	f85d fb04 	ldr.w	pc, [sp], #4

080a6152 <_ZN7TwoWire11requestFromEhj>:
  return requestFrom(address, quantity, (uint8_t)true);
 80a6152:	2301      	movs	r3, #1
 80a6154:	f7ff bfeb 	b.w	80a612e <_ZN7TwoWire11requestFromEhjh>

080a6158 <_ZN7TwoWire17beginTransmissionEh>:
	hal_i2c_begin_transmission(_i2c, address, NULL);
 80a6158:	2200      	movs	r2, #0
 80a615a:	7c00      	ldrb	r0, [r0, #16]
 80a615c:	f7ff ba2c 	b.w	80a55b8 <hal_i2c_begin_transmission>

080a6160 <_ZN7TwoWire17beginTransmissionEi>:
  beginTransmission((uint8_t)address);
 80a6160:	b2c9      	uxtb	r1, r1
 80a6162:	f7ff bff9 	b.w	80a6158 <_ZN7TwoWire17beginTransmissionEh>

080a6166 <_ZN7TwoWire15endTransmissionEh>:
	return hal_i2c_end_transmission(_i2c, sendStop, NULL);
 80a6166:	2200      	movs	r2, #0
 80a6168:	7c00      	ldrb	r0, [r0, #16]
 80a616a:	f7ff ba2d 	b.w	80a55c8 <hal_i2c_end_transmission>

080a616e <_ZN7TwoWire15endTransmissionEv>:
  return endTransmission(true);
 80a616e:	2101      	movs	r1, #1
 80a6170:	f7ff bff9 	b.w	80a6166 <_ZN7TwoWire15endTransmissionEh>

080a6174 <_ZN9USBSerial14blockOnOverrunEb>:
  HAL_USB_USART_Flush_Data(_serial);
}

void USBSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a6174:	7441      	strb	r1, [r0, #17]
}
 80a6176:	4770      	bx	lr

080a6178 <__tcf_0>:
}

USBSerial& _fetch_usbserial()
{
  HAL_USB_USART_Config conf = acquireSerialBuffer();
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a6178:	4770      	bx	lr

080a617a <_ZN9USBSerialD1Ev>:
#include "usb_hal.h"
#include "system_task.h"
#include "spark_wiring_startup.h"
#include "concurrent_hal.h"

class USBSerial : public Stream
 80a617a:	4770      	bx	lr

080a617c <_ZN9USBSerial4readEv>:
{
 80a617c:	b508      	push	{r3, lr}
	return std::max(-1, (int)HAL_USB_USART_Receive_Data(_serial, false));
 80a617e:	2100      	movs	r1, #0
 80a6180:	7c00      	ldrb	r0, [r0, #16]
 80a6182:	f7ff f981 	bl	80a5488 <HAL_USB_USART_Receive_Data>
}
 80a6186:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
 80a618a:	bd08      	pop	{r3, pc}

080a618c <_ZN9USBSerial4peekEv>:
{
 80a618c:	b508      	push	{r3, lr}
	return std::max(-1, (int)HAL_USB_USART_Receive_Data(_serial, true));
 80a618e:	2101      	movs	r1, #1
 80a6190:	7c00      	ldrb	r0, [r0, #16]
 80a6192:	f7ff f979 	bl	80a5488 <HAL_USB_USART_Receive_Data>
}
 80a6196:	ea40 70e0 	orr.w	r0, r0, r0, asr #31
 80a619a:	bd08      	pop	{r3, pc}

080a619c <_ZN9USBSerial17availableForWriteEv>:
{
 80a619c:	b508      	push	{r3, lr}
  return std::max(0, (int)HAL_USB_USART_Available_Data_For_Write(_serial));
 80a619e:	7c00      	ldrb	r0, [r0, #16]
 80a61a0:	f7ff f96a 	bl	80a5478 <HAL_USB_USART_Available_Data_For_Write>
}
 80a61a4:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80a61a8:	bd08      	pop	{r3, pc}

080a61aa <_ZN9USBSerial9availableEv>:
{
 80a61aa:	b508      	push	{r3, lr}
	return std::max(0, (int)HAL_USB_USART_Available_Data(_serial));
 80a61ac:	7c00      	ldrb	r0, [r0, #16]
 80a61ae:	f7ff f95b 	bl	80a5468 <HAL_USB_USART_Available_Data>
}
 80a61b2:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 80a61b6:	bd08      	pop	{r3, pc}

080a61b8 <_ZN9USBSerial5writeEh>:
{
 80a61b8:	b538      	push	{r3, r4, r5, lr}
 80a61ba:	4604      	mov	r4, r0
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
 80a61bc:	7c00      	ldrb	r0, [r0, #16]
{
 80a61be:	460d      	mov	r5, r1
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
 80a61c0:	f7ff f95a 	bl	80a5478 <HAL_USB_USART_Available_Data_For_Write>
 80a61c4:	2800      	cmp	r0, #0
 80a61c6:	dc01      	bgt.n	80a61cc <_ZN9USBSerial5writeEh+0x14>
 80a61c8:	7c60      	ldrb	r0, [r4, #17]
 80a61ca:	b128      	cbz	r0, 80a61d8 <_ZN9USBSerial5writeEh+0x20>
    return std::max(0, (int)HAL_USB_USART_Send_Data(_serial, byte));
 80a61cc:	4629      	mov	r1, r5
 80a61ce:	7c20      	ldrb	r0, [r4, #16]
 80a61d0:	f7ff f962 	bl	80a5498 <HAL_USB_USART_Send_Data>
 80a61d4:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
}
 80a61d8:	bd38      	pop	{r3, r4, r5, pc}

080a61da <_ZN9USBSerial5flushEv>:
  HAL_USB_USART_Flush_Data(_serial);
 80a61da:	7c00      	ldrb	r0, [r0, #16]
 80a61dc:	f7ff b964 	b.w	80a54a8 <HAL_USB_USART_Flush_Data>

080a61e0 <_ZN9USBSerialD0Ev>:
 80a61e0:	b510      	push	{r4, lr}
 80a61e2:	4604      	mov	r4, r0
 80a61e4:	2114      	movs	r1, #20
 80a61e6:	f001 fa14 	bl	80a7612 <_ZdlPvj>
 80a61ea:	4620      	mov	r0, r4
 80a61ec:	bd10      	pop	{r4, pc}

080a61ee <__tcf_1>:
 80a61ee:	4770      	bx	lr

080a61f0 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>:
USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
 80a61f0:	b510      	push	{r4, lr}
 80a61f2:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a61f6:	4604      	mov	r4, r0
 80a61f8:	4608      	mov	r0, r1
 80a61fa:	2100      	movs	r1, #0
 80a61fc:	e9c4 1301 	strd	r1, r3, [r4, #4]
 80a6200:	4b04      	ldr	r3, [pc, #16]	; (80a6214 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config+0x24>)
  _serial = serial;
 80a6202:	7420      	strb	r0, [r4, #16]
USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
 80a6204:	6023      	str	r3, [r4, #0]
  _blocking = true;
 80a6206:	2301      	movs	r3, #1
  HAL_USB_USART_Init(_serial, &conf);
 80a6208:	4611      	mov	r1, r2
  _blocking = true;
 80a620a:	7463      	strb	r3, [r4, #17]
  HAL_USB_USART_Init(_serial, &conf);
 80a620c:	f7ff f924 	bl	80a5458 <HAL_USB_USART_Init>
}
 80a6210:	4620      	mov	r0, r4
 80a6212:	bd10      	pop	{r4, pc}
 80a6214:	080aa58c 	.word	0x080aa58c

080a6218 <_Z19acquireSerialBufferv>:
{
 80a6218:	b510      	push	{r4, lr}
 80a621a:	4604      	mov	r4, r0
  HAL_USB_USART_Config conf = {0};
 80a621c:	2214      	movs	r2, #20
 80a621e:	2100      	movs	r1, #0
 80a6220:	f002 fb62 	bl	80a88e8 <memset>
}
 80a6224:	4620      	mov	r0, r4
 80a6226:	bd10      	pop	{r4, pc}

080a6228 <_Z16_fetch_usbserialv>:
{
 80a6228:	b530      	push	{r4, r5, lr}
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a622a:	4d0e      	ldr	r5, [pc, #56]	; (80a6264 <_Z16_fetch_usbserialv+0x3c>)
{
 80a622c:	b087      	sub	sp, #28
  HAL_USB_USART_Config conf = acquireSerialBuffer();
 80a622e:	a801      	add	r0, sp, #4
 80a6230:	f7ff fff2 	bl	80a6218 <_Z19acquireSerialBufferv>
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a6234:	7829      	ldrb	r1, [r5, #0]
 80a6236:	f3bf 8f5b 	dmb	ish
 80a623a:	f011 0401 	ands.w	r4, r1, #1
 80a623e:	d10e      	bne.n	80a625e <_Z16_fetch_usbserialv+0x36>
 80a6240:	4628      	mov	r0, r5
 80a6242:	f7f9 ff39 	bl	80a00b8 <__cxa_guard_acquire>
 80a6246:	b150      	cbz	r0, 80a625e <_Z16_fetch_usbserialv+0x36>
 80a6248:	4621      	mov	r1, r4
 80a624a:	aa01      	add	r2, sp, #4
 80a624c:	4806      	ldr	r0, [pc, #24]	; (80a6268 <_Z16_fetch_usbserialv+0x40>)
 80a624e:	f7ff ffcf 	bl	80a61f0 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
 80a6252:	4628      	mov	r0, r5
 80a6254:	f7f9 ff35 	bl	80a00c2 <__cxa_guard_release>
 80a6258:	4804      	ldr	r0, [pc, #16]	; (80a626c <_Z16_fetch_usbserialv+0x44>)
 80a625a:	f002 fa3b 	bl	80a86d4 <atexit>
	return _usbserial;
}
 80a625e:	4802      	ldr	r0, [pc, #8]	; (80a6268 <_Z16_fetch_usbserialv+0x40>)
 80a6260:	b007      	add	sp, #28
 80a6262:	bd30      	pop	{r4, r5, pc}
 80a6264:	20000dcc 	.word	0x20000dcc
 80a6268:	20000dd4 	.word	0x20000dd4
 80a626c:	080a6179 	.word	0x080a6179

080a6270 <_Z23acquireUSBSerial1Bufferv>:
 80a6270:	b510      	push	{r4, lr}
 80a6272:	4604      	mov	r4, r0
 80a6274:	2214      	movs	r2, #20
 80a6276:	2100      	movs	r1, #0
 80a6278:	f002 fb36 	bl	80a88e8 <memset>
 80a627c:	4620      	mov	r0, r4
 80a627e:	bd10      	pop	{r4, pc}

080a6280 <_Z17_fetch_usbserial1v>:

  return conf;
}

USBSerial& _fetch_usbserial1()
{
 80a6280:	b510      	push	{r4, lr}
  HAL_USB_USART_Config conf = acquireUSBSerial1Buffer();
  static USBSerial _usbserial1(HAL_USB_USART_SERIAL1, conf);
 80a6282:	4c0e      	ldr	r4, [pc, #56]	; (80a62bc <_Z17_fetch_usbserial1v+0x3c>)
{
 80a6284:	b086      	sub	sp, #24
  HAL_USB_USART_Config conf = acquireUSBSerial1Buffer();
 80a6286:	a801      	add	r0, sp, #4
 80a6288:	f7ff fff2 	bl	80a6270 <_Z23acquireUSBSerial1Bufferv>
  static USBSerial _usbserial1(HAL_USB_USART_SERIAL1, conf);
 80a628c:	7823      	ldrb	r3, [r4, #0]
 80a628e:	f3bf 8f5b 	dmb	ish
 80a6292:	07db      	lsls	r3, r3, #31
 80a6294:	d40e      	bmi.n	80a62b4 <_Z17_fetch_usbserial1v+0x34>
 80a6296:	4620      	mov	r0, r4
 80a6298:	f7f9 ff0e 	bl	80a00b8 <__cxa_guard_acquire>
 80a629c:	b150      	cbz	r0, 80a62b4 <_Z17_fetch_usbserial1v+0x34>
 80a629e:	2101      	movs	r1, #1
 80a62a0:	aa01      	add	r2, sp, #4
 80a62a2:	4807      	ldr	r0, [pc, #28]	; (80a62c0 <_Z17_fetch_usbserial1v+0x40>)
 80a62a4:	f7ff ffa4 	bl	80a61f0 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
 80a62a8:	4620      	mov	r0, r4
 80a62aa:	f7f9 ff0a 	bl	80a00c2 <__cxa_guard_release>
 80a62ae:	4805      	ldr	r0, [pc, #20]	; (80a62c4 <_Z17_fetch_usbserial1v+0x44>)
 80a62b0:	f002 fa10 	bl	80a86d4 <atexit>
  return _usbserial1;
}
 80a62b4:	4802      	ldr	r0, [pc, #8]	; (80a62c0 <_Z17_fetch_usbserial1v+0x40>)
 80a62b6:	b006      	add	sp, #24
 80a62b8:	bd10      	pop	{r4, pc}
 80a62ba:	bf00      	nop
 80a62bc:	20000dd0 	.word	0x20000dd0
 80a62c0:	20000de8 	.word	0x20000de8
 80a62c4:	080a61ef 	.word	0x080a61ef

080a62c8 <_ZN9IPAddressD1Ev>:
 80a62c8:	4770      	bx	lr

080a62ca <_ZN9IPAddressD0Ev>:
 80a62ca:	b510      	push	{r4, lr}
 80a62cc:	4604      	mov	r4, r0
 80a62ce:	2118      	movs	r1, #24
 80a62d0:	f001 f99f 	bl	80a7612 <_ZdlPvj>
 80a62d4:	4620      	mov	r0, r4
 80a62d6:	bd10      	pop	{r4, pc}

080a62d8 <_ZNK9IPAddress7printToER5Print>:
#endif // Wiring_IPv6
	return address.ipv4==that.address.ipv4;
}

size_t IPAddress::printTo(Print& p) const
{
 80a62d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a62da:	460e      	mov	r6, r1
 80a62dc:	2400      	movs	r4, #0
 80a62de:	f100 0708 	add.w	r7, r0, #8
 80a62e2:	1d05      	adds	r5, r0, #4
            val = n;
        }
#if __GNUC__ >= 9
#pragma GCC diagnostic pop
#endif // __GNUC__ >= 9
        return printNumber(val, base) + t;
 80a62e4:	f817 1d01 	ldrb.w	r1, [r7, #-1]!
 80a62e8:	220a      	movs	r2, #10
 80a62ea:	4630      	mov	r0, r6
 80a62ec:	f000 ff73 	bl	80a71d6 <_ZN5Print11printNumberEmh>
#else
#pragma message "HAL_USE_INET_HAL_POSIX is required for IPv6 support in IPAddress::printTo()"
#endif // HAL_USE_INET_HAL_POSIX
#endif // Wiring_IPv6
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a62f0:	42af      	cmp	r7, r5
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
 80a62f2:	4404      	add	r4, r0
    for (int i = 0; i < 4; i++)
 80a62f4:	d101      	bne.n	80a62fa <_ZNK9IPAddress7printToER5Print+0x22>
    }
    return n;
}
 80a62f6:	4620      	mov	r0, r4
 80a62f8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        if (n)
 80a62fa:	2c00      	cmp	r4, #0
 80a62fc:	d0f2      	beq.n	80a62e4 <_ZNK9IPAddress7printToER5Print+0xc>
            n += p.print('.');
 80a62fe:	212e      	movs	r1, #46	; 0x2e
 80a6300:	4630      	mov	r0, r6
 80a6302:	f000 ff59 	bl	80a71b8 <_ZN5Print5printEc>
 80a6306:	4404      	add	r4, r0
 80a6308:	e7ec      	b.n	80a62e4 <_ZNK9IPAddress7printToER5Print+0xc>
	...

080a630c <_ZN9IPAddressC1Ev>:
IPAddress::IPAddress()
 80a630c:	b510      	push	{r4, lr}
 80a630e:	4604      	mov	r4, r0
 80a6310:	4b04      	ldr	r3, [pc, #16]	; (80a6324 <_ZN9IPAddressC1Ev+0x18>)
        return address;
    }

    virtual size_t printTo(Print& p) const;

    void clear() { memset(&address, 0, sizeof (address)); }
 80a6312:	2211      	movs	r2, #17
 80a6314:	2100      	movs	r1, #0
 80a6316:	f840 3b04 	str.w	r3, [r0], #4
 80a631a:	f002 fae5 	bl	80a88e8 <memset>
}
 80a631e:	4620      	mov	r0, r4
 80a6320:	bd10      	pop	{r4, pc}
 80a6322:	bf00      	nop
 80a6324:	080aa5bc 	.word	0x080aa5bc

080a6328 <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>:
IPAddress::IPAddress(const HAL_IPAddress& address)
 80a6328:	4603      	mov	r3, r0
 80a632a:	4a07      	ldr	r2, [pc, #28]	; (80a6348 <_ZN9IPAddressC1ERK16_HAL_IPAddress_t+0x20>)
 80a632c:	b510      	push	{r4, lr}
 80a632e:	f843 2b04 	str.w	r2, [r3], #4
    memcpy(&this->address, &address, sizeof(address));
 80a6332:	f101 0210 	add.w	r2, r1, #16
 80a6336:	f851 4b04 	ldr.w	r4, [r1], #4
 80a633a:	4291      	cmp	r1, r2
 80a633c:	f843 4b04 	str.w	r4, [r3], #4
 80a6340:	d1f9      	bne.n	80a6336 <_ZN9IPAddressC1ERK16_HAL_IPAddress_t+0xe>
 80a6342:	780a      	ldrb	r2, [r1, #0]
 80a6344:	701a      	strb	r2, [r3, #0]
}
 80a6346:	bd10      	pop	{r4, pc}
 80a6348:	080aa5bc 	.word	0x080aa5bc

080a634c <_ZN9IPAddressC1Em>:
IPAddress::IPAddress(uint32_t address)
 80a634c:	4a02      	ldr	r2, [pc, #8]	; (80a6358 <_ZN9IPAddressC1Em+0xc>)
    address.ipv4 = ipv4;
 80a634e:	e9c0 2100 	strd	r2, r1, [r0]
        address.v = version;
 80a6352:	2204      	movs	r2, #4
 80a6354:	7502      	strb	r2, [r0, #20]
}
 80a6356:	4770      	bx	lr
 80a6358:	080aa5bc 	.word	0x080aa5bc

080a635c <_ZN9IPAddress8set_ipv4Ehhhh>:
{
 80a635c:	b510      	push	{r4, lr}
    address.ipv4 = b0<<24 | b1 << 16 | b2 << 8 | b3;
 80a635e:	f89d 4008 	ldrb.w	r4, [sp, #8]
 80a6362:	ea44 2403 	orr.w	r4, r4, r3, lsl #8
 80a6366:	2304      	movs	r3, #4
 80a6368:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 80a636c:	ea44 6401 	orr.w	r4, r4, r1, lsl #24
 80a6370:	6044      	str	r4, [r0, #4]
 80a6372:	7503      	strb	r3, [r0, #20]
}
 80a6374:	bd10      	pop	{r4, pc}
	...

080a6378 <_ZN9IPAddressC1Ehhhh>:
IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
 80a6378:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a637a:	4d04      	ldr	r5, [pc, #16]	; (80a638c <_ZN9IPAddressC1Ehhhh+0x14>)
 80a637c:	6005      	str	r5, [r0, #0]
    set_ipv4(first_octet, second_octet, third_octet, fourth_octet);
 80a637e:	f89d 5018 	ldrb.w	r5, [sp, #24]
 80a6382:	9500      	str	r5, [sp, #0]
 80a6384:	f7ff ffea 	bl	80a635c <_ZN9IPAddress8set_ipv4Ehhhh>
}
 80a6388:	b003      	add	sp, #12
 80a638a:	bd30      	pop	{r4, r5, pc}
 80a638c:	080aa5bc 	.word	0x080aa5bc

080a6390 <_ZN9IPAddressaSEPKh>:
{
 80a6390:	b513      	push	{r0, r1, r4, lr}
    set_ipv4(address[0], address[1], address[2], address[3]);
 80a6392:	78cb      	ldrb	r3, [r1, #3]
 80a6394:	9300      	str	r3, [sp, #0]
 80a6396:	788b      	ldrb	r3, [r1, #2]
 80a6398:	784a      	ldrb	r2, [r1, #1]
 80a639a:	7809      	ldrb	r1, [r1, #0]
 80a639c:	f7ff ffde 	bl	80a635c <_ZN9IPAddress8set_ipv4Ehhhh>
}
 80a63a0:	b002      	add	sp, #8
 80a63a2:	bd10      	pop	{r4, pc}

080a63a4 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EED1Ev>:
    class _Sp_counted_ptr final : public _Sp_counted_base<_Lp>
 80a63a4:	4770      	bx	lr

080a63a6 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE14_M_get_deleterERKSt9type_info>:
      { return nullptr; }
 80a63a6:	2000      	movs	r0, #0
 80a63a8:	4770      	bx	lr

080a63aa <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EED0Ev>:
    class _Sp_counted_ptr final : public _Sp_counted_base<_Lp>
 80a63aa:	b510      	push	{r4, lr}
 80a63ac:	4604      	mov	r4, r0
 80a63ae:	2110      	movs	r1, #16
 80a63b0:	f001 f92f 	bl	80a7612 <_ZdlPvj>
 80a63b4:	4620      	mov	r0, r4
 80a63b6:	bd10      	pop	{r4, pc}

080a63b8 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_destroyEv>:
      _M_destroy() noexcept
 80a63b8:	b508      	push	{r3, lr}
      { delete this; }
 80a63ba:	f7ff fff6 	bl	80a63aa <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EED0Ev>
 80a63be:	bd08      	pop	{r3, pc}

080a63c0 <_ZN8particle5ErrorC1EOS0_>:

} // namespace particle

inline particle::Error::Error(Type type) :
        msg_(nullptr),
        type_(type) {
 80a63c0:	2200      	movs	r2, #0

inline particle::Error::Error(const Error& error) :
        Error(error.type_, error.msg_) {
}

inline particle::Error::Error(Error&& error) :
 80a63c2:	b530      	push	{r4, r5, lr}
        type_(type) {
 80a63c4:	f64f 749c 	movw	r4, #65436	; 0xff9c
 80a63c8:	6002      	str	r2, [r0, #0]
 80a63ca:	8084      	strh	r4, [r0, #4]
      __a = _GLIBCXX_MOVE(__b);
 80a63cc:	888d      	ldrh	r5, [r1, #4]
      __b = _GLIBCXX_MOVE(__tmp);
 80a63ce:	808c      	strh	r4, [r1, #4]
      __a = _GLIBCXX_MOVE(__b);
 80a63d0:	680c      	ldr	r4, [r1, #0]
 80a63d2:	8085      	strh	r5, [r0, #4]
 80a63d4:	6004      	str	r4, [r0, #0]
      __b = _GLIBCXX_MOVE(__tmp);
 80a63d6:	600a      	str	r2, [r1, #0]
        Error() {
    swap(*this, error);
}
 80a63d8:	bd30      	pop	{r4, r5, pc}

080a63da <_ZN8particle5ErrorD1Ev>:

inline particle::Error::~Error() {
 80a63da:	b510      	push	{r4, lr}
 80a63dc:	4604      	mov	r4, r0
    free((void*)msg_);
 80a63de:	6800      	ldr	r0, [r0, #0]
 80a63e0:	f7ff fb64 	bl	80a5aac <free>
}
 80a63e4:	4620      	mov	r0, r4
 80a63e6:	bd10      	pop	{r4, pc}

080a63e8 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv>:
      _M_dispose() noexcept
 80a63e8:	b538      	push	{r3, r4, r5, lr}
      { delete _M_ptr; }
 80a63ea:	68c4      	ldr	r4, [r0, #12]
 80a63ec:	b1f4      	cbz	r4, 80a642c <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x44>
      _Tp
      load(memory_order __m = memory_order_seq_cst) const noexcept
      {
	alignas(_Tp) unsigned char __buf[sizeof(_Tp)];
	_Tp* __ptr = reinterpret_cast<_Tp*>(__buf);
	__atomic_load(std::__addressof(_M_i), __ptr, int(__m));
 80a63ee:	7823      	ldrb	r3, [r4, #0]
    ~FutureImpl() {
        // Call destructor of the appropriate unnamed enum's field
        const State s = this->state();
        if (s == State::SUCCEEDED) {
            result_.~ResultT();
        } else if (s == State::FAILED) {
 80a63f0:	2b02      	cmp	r3, #2
 80a63f2:	d103      	bne.n	80a63fc <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x14>
            error_.~Error();
 80a63f4:	f104 000c 	add.w	r0, r4, #12
 80a63f8:	f7ff ffef 	bl	80a63da <_ZN8particle5ErrorD1Ev>
      {
	memory_order __b = __m & __memory_order_mask;
	__glibcxx_assert(__b != memory_order_release);
	__glibcxx_assert(__b != memory_order_acq_rel);

	return __atomic_load_n(&_M_p, int(__m));
 80a63fc:	6865      	ldr	r5, [r4, #4]
        delete onSuccess_.load(std::memory_order_relaxed);
 80a63fe:	b135      	cbz	r5, 80a640e <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x26>
    class function<_Res(_ArgTypes...)>
 80a6400:	4628      	mov	r0, r5
 80a6402:	f7fa f9e8 	bl	80a07d6 <_ZNSt14_Function_baseD1Ev>
 80a6406:	2110      	movs	r1, #16
 80a6408:	4628      	mov	r0, r5
 80a640a:	f001 f902 	bl	80a7612 <_ZdlPvj>
 80a640e:	68a5      	ldr	r5, [r4, #8]
        delete onError_.load(std::memory_order_relaxed);
 80a6410:	b135      	cbz	r5, 80a6420 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x38>
 80a6412:	4628      	mov	r0, r5
 80a6414:	f7fa f9df 	bl	80a07d6 <_ZNSt14_Function_baseD1Ev>
 80a6418:	2110      	movs	r1, #16
 80a641a:	4628      	mov	r0, r5
 80a641c:	f001 f8f9 	bl	80a7612 <_ZdlPvj>
 80a6420:	4620      	mov	r0, r4
 80a6422:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80a6426:	2114      	movs	r1, #20
 80a6428:	f001 b8f3 	b.w	80a7612 <_ZdlPvj>
 80a642c:	bd38      	pop	{r3, r4, r5, pc}

080a642e <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>:
      : _M_pi(__r._M_pi)
 80a642e:	680b      	ldr	r3, [r1, #0]
 80a6430:	6003      	str	r3, [r0, #0]
	if (_M_pi != 0)
 80a6432:	b113      	cbz	r3, 80a643a <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_+0xc>
    { ++_M_use_count; }
 80a6434:	685a      	ldr	r2, [r3, #4]
 80a6436:	3201      	adds	r2, #1
 80a6438:	605a      	str	r2, [r3, #4]
      }
 80a643a:	4770      	bx	lr

080a643c <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE11fromDataPtrEPv>:
        // TODO: Use custom reference counting object to avoid unnecessary memory allocation
        return new detail::FutureImplPtr<ResultT, ContextT>(p_);
    }

    // Unwraps promise from an object pointer created via dataPtr() method
    static Promise<ResultT, ContextT> fromDataPtr(void* data) {
 80a643c:	b573      	push	{r0, r1, r4, r5, r6, lr}
      __shared_ptr(const __shared_ptr&) noexcept = default;
 80a643e:	460e      	mov	r6, r1
 80a6440:	4604      	mov	r4, r0
 80a6442:	f856 3b04 	ldr.w	r3, [r6], #4
 80a6446:	460d      	mov	r5, r1
 80a6448:	a801      	add	r0, sp, #4
 80a644a:	4631      	mov	r1, r6
 80a644c:	9300      	str	r3, [sp, #0]
 80a644e:	f7ff ffee 	bl	80a642e <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
	__shared_ptr(const __shared_ptr<_Yp, _Lp>& __r) noexcept
	: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
	{ }

      __shared_ptr(__shared_ptr&& __r) noexcept
      : _M_ptr(__r._M_ptr), _M_refcount()
 80a6452:	9b00      	ldr	r3, [sp, #0]
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 80a6454:	9a01      	ldr	r2, [sp, #4]
      : _M_ptr(__r._M_ptr), _M_refcount()
 80a6456:	6023      	str	r3, [r4, #0]
	__r._M_pi = _M_pi;
 80a6458:	2300      	movs	r3, #0
	_M_pi = __tmp;
 80a645a:	6062      	str	r2, [r4, #4]
      ~__shared_ptr() = default;
 80a645c:	a801      	add	r0, sp, #4
	__r._M_pi = _M_pi;
 80a645e:	9301      	str	r3, [sp, #4]
      {
	_M_refcount._M_swap(__r._M_refcount);
	__r._M_ptr = 0;
 80a6460:	9300      	str	r3, [sp, #0]
      ~__shared_ptr() = default;
 80a6462:	f7fb f808 	bl	80a1476 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
 80a6466:	4630      	mov	r0, r6
 80a6468:	f7fb f805 	bl	80a1476 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
        auto d = static_cast<detail::FutureImplPtr<ResultT, ContextT>*>(data);
        const Promise<ResultT, ContextT> p(*d);
        delete d;
 80a646c:	4628      	mov	r0, r5
 80a646e:	2108      	movs	r1, #8
 80a6470:	f001 f8cf 	bl	80a7612 <_ZdlPvj>
        return p;
    }
 80a6474:	4620      	mov	r0, r4
 80a6476:	b002      	add	sp, #8
 80a6478:	bd70      	pop	{r4, r5, r6, pc}

080a647a <_ZSt4swapISt9_Any_dataENSt9enable_ifIXsrSt6__and_IJSt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS5_ESt18is_move_assignableIS5_EEE5valueEvE4typeERS5_SF_>:
    swap(_Tp& __a, _Tp& __b)
 80a647a:	b513      	push	{r0, r1, r4, lr}
      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a647c:	466c      	mov	r4, sp
    swap(_Tp& __a, _Tp& __b)
 80a647e:	460b      	mov	r3, r1
 80a6480:	4602      	mov	r2, r0
      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a6482:	c803      	ldmia	r0, {r0, r1}
 80a6484:	e884 0003 	stmia.w	r4, {r0, r1}
      __a = _GLIBCXX_MOVE(__b);
 80a6488:	e893 0003 	ldmia.w	r3, {r0, r1}
 80a648c:	e882 0003 	stmia.w	r2, {r0, r1}
      __b = _GLIBCXX_MOVE(__tmp);
 80a6490:	e894 0003 	ldmia.w	r4, {r0, r1}
 80a6494:	e883 0003 	stmia.w	r3, {r0, r1}
    }
 80a6498:	b002      	add	sp, #8
 80a649a:	bd10      	pop	{r4, pc}

080a649c <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_>:
      if (_M_empty())
 80a649c:	6882      	ldr	r2, [r0, #8]
    function<_Res(_ArgTypes...)>::
 80a649e:	b510      	push	{r4, lr}
      if (_M_empty())
 80a64a0:	b90a      	cbnz	r2, 80a64a6 <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_+0xa>
	__throw_bad_function_call();
 80a64a2:	f001 f8ba 	bl	80a761a <_ZSt25__throw_bad_function_callv>
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a64a6:	68c3      	ldr	r3, [r0, #12]
    }
 80a64a8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a64ac:	4718      	bx	r3

080a64ae <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE9_M_invokeERKSt9_Any_data>:
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
 80a64ae:	b508      	push	{r3, lr}
	    return __source._M_access<_Functor*>();
 80a64b0:	6800      	ldr	r0, [r0, #0]
    { return static_cast<_Up&&>(__t); }

  template<typename _Res, typename _Fn, typename... _Args>
    constexpr _Res
    __invoke_impl(__invoke_other, _Fn&& __f, _Args&&... __args)
    { return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...); }
 80a64b2:	f100 0110 	add.w	r1, r0, #16
 80a64b6:	f7ff fff1 	bl	80a649c <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_>
      }
 80a64ba:	bd08      	pop	{r3, pc}

080a64bc <_ZNKSt8functionIFvRKbEEclES1_>:
      if (_M_empty())
 80a64bc:	6882      	ldr	r2, [r0, #8]
    function<_Res(_ArgTypes...)>::
 80a64be:	b510      	push	{r4, lr}
      if (_M_empty())
 80a64c0:	b90a      	cbnz	r2, 80a64c6 <_ZNKSt8functionIFvRKbEEclES1_+0xa>
	__throw_bad_function_call();
 80a64c2:	f001 f8aa 	bl	80a761a <_ZSt25__throw_bad_function_callv>
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a64c6:	68c3      	ldr	r3, [r0, #12]
    }
 80a64c8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a64cc:	4718      	bx	r3

080a64ce <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKbEEbEEE9_M_invokeERKSt9_Any_data>:
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
 80a64ce:	b508      	push	{r3, lr}
	    return __source._M_access<_Functor*>();
 80a64d0:	6800      	ldr	r0, [r0, #0]
 80a64d2:	f100 0110 	add.w	r1, r0, #16
 80a64d6:	f7ff fff1 	bl	80a64bc <_ZNKSt8functionIFvRKbEEclES1_>
      }
 80a64da:	bd08      	pop	{r3, pc}

080a64dc <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPN8particle6detail10FutureImplIbNS5_13FutureContextEEEEET_>:
	__shared_count(_Ptr __p) : _M_pi(0)
 80a64dc:	b538      	push	{r3, r4, r5, lr}
 80a64de:	2300      	movs	r3, #0
 80a64e0:	4604      	mov	r4, r0
 80a64e2:	6003      	str	r3, [r0, #0]
	      _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
 80a64e4:	2010      	movs	r0, #16
	__shared_count(_Ptr __p) : _M_pi(0)
 80a64e6:	460d      	mov	r5, r1
	      _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
 80a64e8:	f7f9 fdd5 	bl	80a0096 <_Znwj>
 80a64ec:	b128      	cbz	r0, 80a64fa <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPN8particle6detail10FutureImplIbNS5_13FutureContextEEEEET_+0x1e>
      : _M_use_count(1), _M_weak_count(1) { }
 80a64ee:	2301      	movs	r3, #1
 80a64f0:	e9c0 3301 	strd	r3, r3, [r0, #4]
      : _M_ptr(__p) { }
 80a64f4:	4b02      	ldr	r3, [pc, #8]	; (80a6500 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPN8particle6detail10FutureImplIbNS5_13FutureContextEEEEET_+0x24>)
 80a64f6:	60c5      	str	r5, [r0, #12]
 80a64f8:	6003      	str	r3, [r0, #0]
	      _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
 80a64fa:	6020      	str	r0, [r4, #0]
	}
 80a64fc:	4620      	mov	r0, r4
 80a64fe:	bd38      	pop	{r3, r4, r5, pc}
 80a6500:	080aa5d0 	.word	0x080aa5d0

080a6504 <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_>:
    function<_Res(_ArgTypes...)>::
 80a6504:	b538      	push	{r3, r4, r5, lr}
    _Function_base() : _M_manager(nullptr) { }
 80a6506:	2300      	movs	r3, #0
 80a6508:	6083      	str	r3, [r0, #8]
      { return !_M_empty(); }
 80a650a:	688b      	ldr	r3, [r1, #8]
    function<_Res(_ArgTypes...)>::
 80a650c:	4604      	mov	r4, r0
 80a650e:	460d      	mov	r5, r1
      if (static_cast<bool>(__x))
 80a6510:	b12b      	cbz	r3, 80a651e <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_+0x1a>
	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
 80a6512:	2202      	movs	r2, #2
 80a6514:	4798      	blx	r3
	  _M_invoker = __x._M_invoker;
 80a6516:	68eb      	ldr	r3, [r5, #12]
 80a6518:	60e3      	str	r3, [r4, #12]
	  _M_manager = __x._M_manager;
 80a651a:	68ab      	ldr	r3, [r5, #8]
 80a651c:	60a3      	str	r3, [r4, #8]
    }
 80a651e:	4620      	mov	r0, r4
 80a6520:	bd38      	pop	{r3, r4, r5, pc}
	...

080a6524 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE>:
    void setError(Error error) {
 80a6524:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a6526:	b089      	sub	sp, #36	; 0x24
      { return static_cast<const __shared_ptr<_Tp, _Lp>*>(this)->get(); }
 80a6528:	6804      	ldr	r4, [r0, #0]
        p_->setError(std::move(error));
 80a652a:	4668      	mov	r0, sp
 80a652c:	f7ff ff48 	bl	80a63c0 <_ZN8particle5ErrorC1EOS0_>

      bool
      compare_exchange_strong(_Tp& __e, _Tp __i, memory_order __s,
			      memory_order __f) noexcept
      {
	return __atomic_compare_exchange(std::__addressof(_M_i),
 80a6530:	f04f 0302 	mov.w	r3, #2
 80a6534:	e8d4 2f4f 	ldrexb	r2, [r4]
 80a6538:	2a00      	cmp	r2, #0
 80a653a:	d103      	bne.n	80a6544 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x20>
 80a653c:	e8c4 3f41 	strexb	r1, r3, [r4]
 80a6540:	2900      	cmp	r1, #0
 80a6542:	d1f7      	bne.n	80a6534 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x10>
        if (this->changeState(State::FAILED)) {
 80a6544:	d125      	bne.n	80a6592 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x6e>
            new(&error_) Error(std::move(error));
 80a6546:	f104 050c 	add.w	r5, r4, #12
 80a654a:	4669      	mov	r1, sp
 80a654c:	4628      	mov	r0, r5
 80a654e:	f7ff ff37 	bl	80a63c0 <_ZN8particle5ErrorC1EOS0_>
	__atomic_store_n(&_M_i, __i, int(__m));
 80a6552:	2301      	movs	r3, #1
 80a6554:	f3bf 8f5b 	dmb	ish
 80a6558:	7063      	strb	r3, [r4, #1]

      _GLIBCXX_ALWAYS_INLINE __pointer_type
      exchange(__pointer_type __p,
	       memory_order __m = memory_order_seq_cst) noexcept
      {
	return __atomic_exchange_n(&_M_p, __p, int(__m));
 80a655a:	2000      	movs	r0, #0
 80a655c:	f3bf 8f5b 	dmb	ish
 80a6560:	f104 0308 	add.w	r3, r4, #8
 80a6564:	e853 6f00 	ldrex	r6, [r3]
 80a6568:	e843 0200 	strex	r2, r0, [r3]
 80a656c:	2a00      	cmp	r2, #0
 80a656e:	d1f9      	bne.n	80a6564 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x40>
 80a6570:	f3bf 8f5b 	dmb	ish
        if (callbackPtr) {
 80a6574:	b16e      	cbz	r6, 80a6592 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x6e>
        return (application_thread_current(nullptr) != 0);
 80a6576:	f7ff fa5b 	bl	80a5a30 <application_thread_current>
        if (ContextT::isApplicationThreadCurrent()) {
 80a657a:	b178      	cbz	r0, 80a659c <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x78>
            callback(std::forward<ArgsT>(args)...); // Synchronous call
 80a657c:	4629      	mov	r1, r5
 80a657e:	4630      	mov	r0, r6
 80a6580:	f7ff ff8c 	bl	80a649c <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_>
    class function<_Res(_ArgTypes...)>
 80a6584:	4630      	mov	r0, r6
 80a6586:	f7fa f926 	bl	80a07d6 <_ZNSt14_Function_baseD1Ev>
            delete callbackPtr;
 80a658a:	2110      	movs	r1, #16
 80a658c:	4630      	mov	r0, r6
 80a658e:	f001 f840 	bl	80a7612 <_ZdlPvj>
        p_->setError(std::move(error));
 80a6592:	4668      	mov	r0, sp
 80a6594:	f7ff ff21 	bl	80a63da <_ZN8particle5ErrorD1Ev>
    }
 80a6598:	b009      	add	sp, #36	; 0x24
 80a659a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	  typename __cv_quals<_Bound_args>::type...>;

     public:
      template<typename... _Args>
	explicit _Bind(const _Functor& __f, _Args&&... __args)
	: _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 80a659c:	4631      	mov	r1, r6
 80a659e:	a802      	add	r0, sp, #8
 80a65a0:	f7ff ffb0 	bl	80a6504 <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_>
        Error(error.type_, error.msg_) {
 80a65a4:	68e0      	ldr	r0, [r4, #12]
 80a65a6:	f9b4 5010 	ldrsh.w	r5, [r4, #16]
        msg_(msg ? (const char*)strdup(msg) : nullptr),
 80a65aa:	b108      	cbz	r0, 80a65b0 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x8c>
 80a65ac:	f002 fa1e 	bl	80a89ec <strdup>
        type_(type) {
 80a65b0:	9006      	str	r0, [sp, #24]
            auto callbackPtr = new std::function<void()>(std::bind(callback, std::forward<ArgsT>(args)...));
 80a65b2:	2010      	movs	r0, #16
 80a65b4:	f8ad 501c 	strh.w	r5, [sp, #28]
 80a65b8:	f7f9 fd6d 	bl	80a0096 <_Znwj>
 80a65bc:	4605      	mov	r5, r0
 80a65be:	b1e8      	cbz	r0, 80a65fc <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xd8>
    _Function_base() : _M_manager(nullptr) { }
 80a65c0:	2700      	movs	r7, #0
 80a65c2:	6087      	str	r7, [r0, #8]
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
 80a65c4:	2018      	movs	r0, #24
 80a65c6:	f7f9 fd66 	bl	80a0096 <_Znwj>
 80a65ca:	4604      	mov	r4, r0
 80a65cc:	b188      	cbz	r0, 80a65f2 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xce>
	std::swap(_M_functor, __x._M_functor);
 80a65ce:	4601      	mov	r1, r0
    _Function_base() : _M_manager(nullptr) { }
 80a65d0:	6087      	str	r7, [r0, #8]
	std::swap(_M_functor, __x._M_functor);
 80a65d2:	a802      	add	r0, sp, #8
 80a65d4:	f7ff ff51 	bl	80a647a <_ZSt4swapISt9_Any_dataENSt9enable_ifIXsrSt6__and_IJSt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS5_ESt18is_move_assignableIS5_EEE5valueEvE4typeERS5_SF_>
      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a65d8:	9b04      	ldr	r3, [sp, #16]
      __a = _GLIBCXX_MOVE(__b);
 80a65da:	68a2      	ldr	r2, [r4, #8]
      __b = _GLIBCXX_MOVE(__tmp);
 80a65dc:	60a3      	str	r3, [r4, #8]
      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a65de:	9b05      	ldr	r3, [sp, #20]
      __a = _GLIBCXX_MOVE(__b);
 80a65e0:	9204      	str	r2, [sp, #16]
 80a65e2:	68e2      	ldr	r2, [r4, #12]
      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
	: _M_head_impl(std::forward<_UHead>(__h)) { }
 80a65e4:	a906      	add	r1, sp, #24
      __b = _GLIBCXX_MOVE(__tmp);
 80a65e6:	60e3      	str	r3, [r4, #12]
 80a65e8:	f104 0010 	add.w	r0, r4, #16
      __a = _GLIBCXX_MOVE(__b);
 80a65ec:	9205      	str	r2, [sp, #20]
 80a65ee:	f7ff fee7 	bl	80a63c0 <_ZN8particle5ErrorC1EOS0_>
	    _M_invoker = &_My_handler::_M_invoke;
 80a65f2:	4b08      	ldr	r3, [pc, #32]	; (80a6614 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xf0>)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
 80a65f4:	602c      	str	r4, [r5, #0]
	    _M_invoker = &_My_handler::_M_invoke;
 80a65f6:	60eb      	str	r3, [r5, #12]
	    _M_manager = &_My_handler::_M_manager;
 80a65f8:	4b07      	ldr	r3, [pc, #28]	; (80a6618 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xf4>)
 80a65fa:	60ab      	str	r3, [r5, #8]
    struct _Head_base<_Idx, _Head, false>
 80a65fc:	a806      	add	r0, sp, #24
 80a65fe:	f7ff feec 	bl	80a63da <_ZN8particle5ErrorD1Ev>
    class function<_Res(_ArgTypes...)>
 80a6602:	a802      	add	r0, sp, #8
 80a6604:	f7fa f8e7 	bl	80a07d6 <_ZNSt14_Function_baseD1Ev>
        return (application_thread_invoke(callback, data, nullptr) == 0);
 80a6608:	2200      	movs	r2, #0
 80a660a:	4629      	mov	r1, r5
 80a660c:	4803      	ldr	r0, [pc, #12]	; (80a661c <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xf8>)
 80a660e:	f7ff fa17 	bl	80a5a40 <application_thread_invoke>
 80a6612:	e7b7      	b.n	80a6584 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x60>
 80a6614:	080a64af 	.word	0x080a64af
 80a6618:	080a6745 	.word	0x080a6745
 80a661c:	080a5f1d 	.word	0x080a5f1d

080a6620 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE>:
    desc.data = (void*)data;
    desc.funcKey = funcKey;
    return spark_function(NULL, (user_function_int_str_t*)&desc, NULL);
}

Future<bool> CloudClass::publish_event(const char *eventName, const char *eventData, int ttl, PublishFlags flags) {
 80a6620:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80a6624:	b08a      	sub	sp, #40	; 0x28
 80a6626:	4605      	mov	r5, r0
 80a6628:	460c      	mov	r4, r1
 80a662a:	4617      	mov	r7, r2
 80a662c:	4698      	mov	r8, r3
 80a662e:	f89d 9048 	ldrb.w	r9, [sp, #72]	; 0x48
    static void sleep(Spark_Sleep_TypeDef sleepMode, long seconds=0) __attribute__ ((deprecated("Please use System.sleep() instead.")))
    { SystemClass::sleep(sleepMode, seconds); }
    static void sleep(uint16_t wakeUpPin, InterruptMode edgeTriggerMode, long seconds=0) __attribute__ ((deprecated("Please use System.sleep() instead.")))
    { SystemClass::sleep(wakeUpPin, edgeTriggerMode, seconds); }

    static bool connected(void) { return spark_cloud_flag_connected(); }
 80a6632:	f7ff f95d 	bl	80a58f0 <spark_cloud_flag_connected>
 80a6636:	ae07      	add	r6, sp, #28
    if (!connected()) {
 80a6638:	4682      	mov	sl, r0
 80a663a:	bb38      	cbnz	r0, 80a668c <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x6c>
        type_(type) {
 80a663c:	f64f 732e 	movw	r3, #65326	; 0xff2e
 80a6640:	9005      	str	r0, [sp, #20]
    typedef typename detail::FutureImpl<ResultT, ContextT>::OnSuccessCallback OnSuccessCallback;
    typedef typename detail::FutureImpl<ResultT, ContextT>::OnErrorCallback OnErrorCallback;

    // Construct failed future
    explicit FutureBase(Error error) :
            p_(new detail::FutureImpl<ResultT, ContextT>(std::move(error))) {
 80a6642:	a905      	add	r1, sp, #20
 80a6644:	4630      	mov	r0, r6
 80a6646:	f8ad 3018 	strh.w	r3, [sp, #24]
 80a664a:	f7ff feb9 	bl	80a63c0 <_ZN8particle5ErrorC1EOS0_>
 80a664e:	2014      	movs	r0, #20
 80a6650:	f7f9 fd21 	bl	80a0096 <_Znwj>
 80a6654:	4604      	mov	r4, r0
 80a6656:	b148      	cbz	r0, 80a666c <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x4c>
      constexpr atomic(_Tp __i) noexcept : _M_i(__i) { }
 80a6658:	2302      	movs	r3, #2
 80a665a:	7003      	strb	r3, [r0, #0]
      constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }
 80a665c:	2301      	movs	r3, #1
      constexpr __atomic_base(__pointer_type __p) noexcept : _M_p (__p) { }
 80a665e:	e9c0 aa01 	strd	sl, sl, [r0, #4]
      constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }
 80a6662:	7043      	strb	r3, [r0, #1]
            error_(std::move(error)) {
 80a6664:	4631      	mov	r1, r6
 80a6666:	300c      	adds	r0, #12
 80a6668:	f7ff feaa 	bl	80a63c0 <_ZN8particle5ErrorC1EOS0_>
	: _M_ptr(__p), _M_refcount(__p, typename is_array<_Tp>::type())
 80a666c:	4628      	mov	r0, r5
	: __shared_count(__p)
 80a666e:	4621      	mov	r1, r4
	: _M_ptr(__p), _M_refcount(__p, typename is_array<_Tp>::type())
 80a6670:	f840 4b04 	str.w	r4, [r0], #4
	: __shared_count(__p)
 80a6674:	f7ff ff32 	bl	80a64dc <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPN8particle6detail10FutureImplIbNS5_13FutureContextEEEEET_>
            p_(new detail::FutureImpl<ResultT, ContextT>(std::move(error))) {
 80a6678:	4630      	mov	r0, r6
 80a667a:	f7ff feae 	bl	80a63da <_ZN8particle5ErrorD1Ev>
    }

    explicit FutureBase(Error::Type error) :
            FutureBase(Error(error)) {
 80a667e:	a805      	add	r0, sp, #20
 80a6680:	f7ff feab 	bl	80a63da <_ZN8particle5ErrorD1Ev>
        p.setError(Error::UNKNOWN);
        p.fromDataPtr(d.handler_data); // Free wrapper object
    }

    return p.future();
}
 80a6684:	4628      	mov	r0, r5
 80a6686:	b00a      	add	sp, #40	; 0x28
 80a6688:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    spark_send_event_data d = { sizeof(spark_send_event_data) };
 80a668c:	230c      	movs	r3, #12
 80a668e:	f04f 0a00 	mov.w	sl, #0
            p_(new detail::FutureImpl<ResultT, ContextT>(State::RUNNING)) {
 80a6692:	2014      	movs	r0, #20
 80a6694:	e9cd aa08 	strd	sl, sl, [sp, #32]
 80a6698:	9307      	str	r3, [sp, #28]
 80a669a:	f7f9 fcfc 	bl	80a0096 <_Znwj>
 80a669e:	4601      	mov	r1, r0
 80a66a0:	b128      	cbz	r0, 80a66ae <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x8e>
      constexpr __atomic_base(__pointer_type __p) noexcept : _M_p (__p) { }
 80a66a2:	e9c0 aa01 	strd	sl, sl, [r0, #4]
 80a66a6:	f880 a000 	strb.w	sl, [r0]
      constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }
 80a66aa:	f880 a001 	strb.w	sl, [r0, #1]
 80a66ae:	a804      	add	r0, sp, #16
	: _M_ptr(__p), _M_refcount(__p, typename is_array<_Tp>::type())
 80a66b0:	9103      	str	r1, [sp, #12]
	: __shared_count(__p)
 80a66b2:	f7ff ff13 	bl	80a64dc <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1IPN8particle6detail10FutureImplIbNS5_13FutureContextEEEEET_>
    d.handler_callback = publishCompletionCallback;
 80a66b6:	4b22      	ldr	r3, [pc, #136]	; (80a6740 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x120>)
        return new detail::FutureImplPtr<ResultT, ContextT>(p_);
 80a66b8:	2008      	movs	r0, #8
 80a66ba:	9308      	str	r3, [sp, #32]
 80a66bc:	f7f9 fceb 	bl	80a0096 <_Znwj>
 80a66c0:	4682      	mov	sl, r0
 80a66c2:	b128      	cbz	r0, 80a66d0 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0xb0>
      __shared_ptr(const __shared_ptr&) noexcept = default;
 80a66c4:	9b03      	ldr	r3, [sp, #12]
 80a66c6:	a904      	add	r1, sp, #16
 80a66c8:	f840 3b04 	str.w	r3, [r0], #4
 80a66cc:	f7ff feaf 	bl	80a642e <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
    if (!spark_send_event(eventName, eventData, ttl, flags.value(), &d) && !p.isDone()) {
 80a66d0:	4642      	mov	r2, r8
 80a66d2:	4639      	mov	r1, r7
 80a66d4:	4620      	mov	r0, r4
 80a66d6:	9600      	str	r6, [sp, #0]
 80a66d8:	fa5f f389 	uxtb.w	r3, r9
    d.handler_data = p.dataPtr();
 80a66dc:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
    if (!spark_send_event(eventName, eventData, ttl, flags.value(), &d) && !p.isDone()) {
 80a66e0:	f7ff f90e 	bl	80a5900 <spark_send_event>
 80a66e4:	b9b8      	cbnz	r0, 80a6716 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0xf6>
	return __atomic_load_n(&_M_i, int(__m));
 80a66e6:	9b03      	ldr	r3, [sp, #12]
 80a66e8:	785b      	ldrb	r3, [r3, #1]
 80a66ea:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80a66ee:	b993      	cbnz	r3, 80a6716 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0xf6>
 80a66f0:	f64f 739c 	movw	r3, #65436	; 0xff9c
        p.setError(Error::UNKNOWN);
 80a66f4:	a905      	add	r1, sp, #20
 80a66f6:	a803      	add	r0, sp, #12
 80a66f8:	9205      	str	r2, [sp, #20]
 80a66fa:	f8ad 3018 	strh.w	r3, [sp, #24]
 80a66fe:	f7ff ff11 	bl	80a6524 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE>
 80a6702:	a805      	add	r0, sp, #20
 80a6704:	f7ff fe69 	bl	80a63da <_ZN8particle5ErrorD1Ev>
        p.fromDataPtr(d.handler_data); // Free wrapper object
 80a6708:	a805      	add	r0, sp, #20
 80a670a:	9909      	ldr	r1, [sp, #36]	; 0x24
 80a670c:	f7ff fe96 	bl	80a643c <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE11fromDataPtrEPv>
      ~__shared_ptr() = default;
 80a6710:	a806      	add	r0, sp, #24
 80a6712:	f7fa feb0 	bl	80a1476 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
      __shared_ptr(const __shared_ptr&) noexcept = default;
 80a6716:	9b03      	ldr	r3, [sp, #12]
 80a6718:	a904      	add	r1, sp, #16
 80a671a:	a806      	add	r0, sp, #24
 80a671c:	9305      	str	r3, [sp, #20]
 80a671e:	f7ff fe86 	bl	80a642e <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
      : _M_ptr(__r._M_ptr), _M_refcount()
 80a6722:	9b05      	ldr	r3, [sp, #20]
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 80a6724:	9a06      	ldr	r2, [sp, #24]
      : _M_ptr(__r._M_ptr), _M_refcount()
 80a6726:	602b      	str	r3, [r5, #0]
	__r._M_pi = _M_pi;
 80a6728:	2300      	movs	r3, #0
	_M_pi = __tmp;
 80a672a:	606a      	str	r2, [r5, #4]
      ~__shared_ptr() = default;
 80a672c:	a806      	add	r0, sp, #24
	__r._M_pi = _M_pi;
 80a672e:	9306      	str	r3, [sp, #24]
	__r._M_ptr = 0;
 80a6730:	9305      	str	r3, [sp, #20]
      ~__shared_ptr() = default;
 80a6732:	f7fa fea0 	bl	80a1476 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
 80a6736:	a804      	add	r0, sp, #16
 80a6738:	f7fa fe9d 	bl	80a1476 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
class Promise: public PromiseBase<ResultT, ContextT> {
 80a673c:	e7a2      	b.n	80a6684 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x64>
 80a673e:	bf00      	nop
 80a6740:	080a6809 	.word	0x080a6809

080a6744 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation>:
	  switch (__op)
 80a6744:	2a02      	cmp	r2, #2
	_M_manager(_Any_data& __dest, const _Any_data& __source,
 80a6746:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a6748:	4605      	mov	r5, r0
	  switch (__op)
 80a674a:	d007      	beq.n	80a675c <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x18>
 80a674c:	2a03      	cmp	r2, #3
 80a674e:	d018      	beq.n	80a6782 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x3e>
 80a6750:	2a01      	cmp	r2, #1
 80a6752:	d101      	bne.n	80a6758 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x14>
	    return __source._M_access<_Functor*>();
 80a6754:	680b      	ldr	r3, [r1, #0]
	      __dest._M_access<_Functor*>() = _M_get_pointer(__source);
 80a6756:	6003      	str	r3, [r0, #0]
	}
 80a6758:	2000      	movs	r0, #0
 80a675a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	    new _Functor(*__source._M_access<const _Functor*>());
 80a675c:	2018      	movs	r0, #24
	  __dest._M_access<_Functor*>() =
 80a675e:	680e      	ldr	r6, [r1, #0]
	    new _Functor(*__source._M_access<const _Functor*>());
 80a6760:	f7f9 fc99 	bl	80a0096 <_Znwj>
 80a6764:	4604      	mov	r4, r0
 80a6766:	b150      	cbz	r0, 80a677e <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x3a>
      template<typename... _Args>
	explicit _Bind(_Functor&& __f, _Args&&... __args)
	: _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
	{ }

      _Bind(const _Bind&) = default;
 80a6768:	4631      	mov	r1, r6
 80a676a:	f7ff fecb 	bl	80a6504 <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_>
        Error(error.type_, error.msg_) {
 80a676e:	6930      	ldr	r0, [r6, #16]
 80a6770:	f9b6 7014 	ldrsh.w	r7, [r6, #20]
        msg_(msg ? (const char*)strdup(msg) : nullptr),
 80a6774:	b108      	cbz	r0, 80a677a <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x36>
 80a6776:	f002 f939 	bl	80a89ec <strdup>
        type_(type) {
 80a677a:	6120      	str	r0, [r4, #16]
 80a677c:	82a7      	strh	r7, [r4, #20]
	  __dest._M_access<_Functor*>() =
 80a677e:	602c      	str	r4, [r5, #0]
	}
 80a6780:	e7ea      	b.n	80a6758 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x14>
	  delete __victim._M_access<_Functor*>();
 80a6782:	6804      	ldr	r4, [r0, #0]
 80a6784:	2c00      	cmp	r4, #0
 80a6786:	d0e7      	beq.n	80a6758 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x14>
 80a6788:	f104 0010 	add.w	r0, r4, #16
 80a678c:	f7ff fe25 	bl	80a63da <_ZN8particle5ErrorD1Ev>
    class function<_Res(_ArgTypes...)>
 80a6790:	4620      	mov	r0, r4
 80a6792:	f7fa f820 	bl	80a07d6 <_ZNSt14_Function_baseD1Ev>
	  delete __victim._M_access<_Functor*>();
 80a6796:	2118      	movs	r1, #24
 80a6798:	4620      	mov	r0, r4
 80a679a:	f000 ff3a 	bl	80a7612 <_ZdlPvj>
 80a679e:	e7db      	b.n	80a6758 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x14>

080a67a0 <_ZNSt8functionIFvRKbEEC1ERKS3_>:
    function<_Res(_ArgTypes...)>::
 80a67a0:	b538      	push	{r3, r4, r5, lr}
    _Function_base() : _M_manager(nullptr) { }
 80a67a2:	2300      	movs	r3, #0
 80a67a4:	6083      	str	r3, [r0, #8]
      { return !_M_empty(); }
 80a67a6:	688b      	ldr	r3, [r1, #8]
    function<_Res(_ArgTypes...)>::
 80a67a8:	4604      	mov	r4, r0
 80a67aa:	460d      	mov	r5, r1
      if (static_cast<bool>(__x))
 80a67ac:	b12b      	cbz	r3, 80a67ba <_ZNSt8functionIFvRKbEEC1ERKS3_+0x1a>
	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
 80a67ae:	2202      	movs	r2, #2
 80a67b0:	4798      	blx	r3
	  _M_invoker = __x._M_invoker;
 80a67b2:	68eb      	ldr	r3, [r5, #12]
 80a67b4:	60e3      	str	r3, [r4, #12]
	  _M_manager = __x._M_manager;
 80a67b6:	68ab      	ldr	r3, [r5, #8]
 80a67b8:	60a3      	str	r3, [r4, #8]
    }
 80a67ba:	4620      	mov	r0, r4
 80a67bc:	bd38      	pop	{r3, r4, r5, pc}

080a67be <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation>:
	  switch (__op)
 80a67be:	2a02      	cmp	r2, #2
	_M_manager(_Any_data& __dest, const _Any_data& __source,
 80a67c0:	b570      	push	{r4, r5, r6, lr}
 80a67c2:	4604      	mov	r4, r0
	  switch (__op)
 80a67c4:	d007      	beq.n	80a67d6 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x18>
 80a67c6:	2a03      	cmp	r2, #3
 80a67c8:	d012      	beq.n	80a67f0 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x32>
 80a67ca:	2a01      	cmp	r2, #1
 80a67cc:	d101      	bne.n	80a67d2 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x14>
	    return __source._M_access<_Functor*>();
 80a67ce:	680b      	ldr	r3, [r1, #0]
	      __dest._M_access<_Functor*>() = _M_get_pointer(__source);
 80a67d0:	6003      	str	r3, [r0, #0]
	}
 80a67d2:	2000      	movs	r0, #0
 80a67d4:	bd70      	pop	{r4, r5, r6, pc}
	    new _Functor(*__source._M_access<const _Functor*>());
 80a67d6:	2014      	movs	r0, #20
	  __dest._M_access<_Functor*>() =
 80a67d8:	680e      	ldr	r6, [r1, #0]
	    new _Functor(*__source._M_access<const _Functor*>());
 80a67da:	f7f9 fc5c 	bl	80a0096 <_Znwj>
 80a67de:	4605      	mov	r5, r0
 80a67e0:	b120      	cbz	r0, 80a67ec <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x2e>
 80a67e2:	4631      	mov	r1, r6
 80a67e4:	f7ff ffdc 	bl	80a67a0 <_ZNSt8functionIFvRKbEEC1ERKS3_>
 80a67e8:	7c33      	ldrb	r3, [r6, #16]
 80a67ea:	742b      	strb	r3, [r5, #16]
	  __dest._M_access<_Functor*>() =
 80a67ec:	6025      	str	r5, [r4, #0]
	}
 80a67ee:	e7f0      	b.n	80a67d2 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x14>
	  delete __victim._M_access<_Functor*>();
 80a67f0:	6804      	ldr	r4, [r0, #0]
 80a67f2:	2c00      	cmp	r4, #0
 80a67f4:	d0ed      	beq.n	80a67d2 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x14>
    class function<_Res(_ArgTypes...)>
 80a67f6:	4620      	mov	r0, r4
 80a67f8:	f7f9 ffed 	bl	80a07d6 <_ZNSt14_Function_baseD1Ev>
	  delete __victim._M_access<_Functor*>();
 80a67fc:	2114      	movs	r1, #20
 80a67fe:	4620      	mov	r0, r4
 80a6800:	f000 ff07 	bl	80a7612 <_ZdlPvj>
 80a6804:	e7e5      	b.n	80a67d2 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x14>
	...

080a6808 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_>:
void publishCompletionCallback(int error, const void* data, void* callbackData, void* reserved) {
 80a6808:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a680a:	4604      	mov	r4, r0
 80a680c:	b089      	sub	sp, #36	; 0x24
 80a680e:	460d      	mov	r5, r1
    auto p = Promise<bool>::fromDataPtr(callbackData);
 80a6810:	a801      	add	r0, sp, #4
 80a6812:	4611      	mov	r1, r2
 80a6814:	f7ff fe12 	bl	80a643c <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE11fromDataPtrEPv>
    if (error != Error::NONE) {
 80a6818:	b1a4      	cbz	r4, 80a6844 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x3c>
        p.setError(Error((Error::Type)error, (const char*)data));
 80a681a:	b224      	sxth	r4, r4
        msg_(msg ? (const char*)strdup(msg) : nullptr),
 80a681c:	b11d      	cbz	r5, 80a6826 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x1e>
 80a681e:	4628      	mov	r0, r5
 80a6820:	f002 f8e4 	bl	80a89ec <strdup>
 80a6824:	4605      	mov	r5, r0
 80a6826:	a801      	add	r0, sp, #4
 80a6828:	a903      	add	r1, sp, #12
        type_(type) {
 80a682a:	9503      	str	r5, [sp, #12]
 80a682c:	f8ad 4010 	strh.w	r4, [sp, #16]
 80a6830:	f7ff fe78 	bl	80a6524 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE>
 80a6834:	a803      	add	r0, sp, #12
 80a6836:	f7ff fdd0 	bl	80a63da <_ZN8particle5ErrorD1Ev>
 80a683a:	a802      	add	r0, sp, #8
 80a683c:	f7fa fe1b 	bl	80a1476 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
}
 80a6840:	b009      	add	sp, #36	; 0x24
 80a6842:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return __atomic_compare_exchange(std::__addressof(_M_i),
 80a6844:	2301      	movs	r3, #1
      { return static_cast<const __shared_ptr<_Tp, _Lp>*>(this)->get(); }
 80a6846:	9d01      	ldr	r5, [sp, #4]
 80a6848:	e8d5 2f4f 	ldrexb	r2, [r5]
 80a684c:	2a00      	cmp	r2, #0
 80a684e:	d103      	bne.n	80a6858 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x50>
 80a6850:	e8c5 3f41 	strexb	r1, r3, [r5]
 80a6854:	2900      	cmp	r1, #0
 80a6856:	d1f7      	bne.n	80a6848 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x40>
        if (this->changeState(State::SUCCEEDED)) {
 80a6858:	d1ef      	bne.n	80a683a <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x32>
            new(&result_) ResultT(std::move(result));
 80a685a:	732b      	strb	r3, [r5, #12]
	__atomic_store_n(&_M_i, __i, int(__m));
 80a685c:	f3bf 8f5b 	dmb	ish
 80a6860:	706b      	strb	r3, [r5, #1]
	return __atomic_exchange_n(&_M_p, __p, int(__m));
 80a6862:	f3bf 8f5b 	dmb	ish
 80a6866:	1d2b      	adds	r3, r5, #4
 80a6868:	e853 6f00 	ldrex	r6, [r3]
 80a686c:	e843 4200 	strex	r2, r4, [r3]
 80a6870:	2a00      	cmp	r2, #0
 80a6872:	d1f9      	bne.n	80a6868 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x60>
 80a6874:	f3bf 8f5b 	dmb	ish
        if (callbackPtr) {
 80a6878:	2e00      	cmp	r6, #0
 80a687a:	d0de      	beq.n	80a683a <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x32>
        return (application_thread_current(nullptr) != 0);
 80a687c:	4620      	mov	r0, r4
 80a687e:	f7ff f8d7 	bl	80a5a30 <application_thread_current>
        if (ContextT::isApplicationThreadCurrent()) {
 80a6882:	4607      	mov	r7, r0
 80a6884:	b160      	cbz	r0, 80a68a0 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x98>
            callback(std::forward<ArgsT>(args)...); // Synchronous call
 80a6886:	4630      	mov	r0, r6
 80a6888:	f105 010c 	add.w	r1, r5, #12
 80a688c:	f7ff fe16 	bl	80a64bc <_ZNKSt8functionIFvRKbEEclES1_>
    class function<_Res(_ArgTypes...)>
 80a6890:	4630      	mov	r0, r6
 80a6892:	f7f9 ffa0 	bl	80a07d6 <_ZNSt14_Function_baseD1Ev>
            delete callbackPtr;
 80a6896:	2110      	movs	r1, #16
 80a6898:	4630      	mov	r0, r6
 80a689a:	f000 feba 	bl	80a7612 <_ZdlPvj>
 80a689e:	e7cc      	b.n	80a683a <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x32>
	: _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 80a68a0:	4631      	mov	r1, r6
 80a68a2:	a803      	add	r0, sp, #12
 80a68a4:	f7ff ff7c 	bl	80a67a0 <_ZNSt8functionIFvRKbEEC1ERKS3_>
	: _M_head_impl(std::forward<_UHead>(__h)) { }
 80a68a8:	7b2b      	ldrb	r3, [r5, #12]
            auto callbackPtr = new std::function<void()>(std::bind(callback, std::forward<ArgsT>(args)...));
 80a68aa:	2010      	movs	r0, #16
 80a68ac:	f88d 301c 	strb.w	r3, [sp, #28]
 80a68b0:	f7f9 fbf1 	bl	80a0096 <_Znwj>
 80a68b4:	4605      	mov	r5, r0
 80a68b6:	b1d0      	cbz	r0, 80a68ee <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0xe6>
    _Function_base() : _M_manager(nullptr) { }
 80a68b8:	6087      	str	r7, [r0, #8]
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
 80a68ba:	2014      	movs	r0, #20
 80a68bc:	f7f9 fbeb 	bl	80a0096 <_Znwj>
 80a68c0:	4604      	mov	r4, r0
 80a68c2:	b178      	cbz	r0, 80a68e4 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0xdc>
	std::swap(_M_functor, __x._M_functor);
 80a68c4:	4601      	mov	r1, r0
    _Function_base() : _M_manager(nullptr) { }
 80a68c6:	6087      	str	r7, [r0, #8]
	std::swap(_M_functor, __x._M_functor);
 80a68c8:	a803      	add	r0, sp, #12
 80a68ca:	f7ff fdd6 	bl	80a647a <_ZSt4swapISt9_Any_dataENSt9enable_ifIXsrSt6__and_IJSt6__not_ISt15__is_tuple_likeIT_EESt21is_move_constructibleIS5_ESt18is_move_assignableIS5_EEE5valueEvE4typeERS5_SF_>
      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a68ce:	9b05      	ldr	r3, [sp, #20]
      __a = _GLIBCXX_MOVE(__b);
 80a68d0:	68a2      	ldr	r2, [r4, #8]
      __b = _GLIBCXX_MOVE(__tmp);
 80a68d2:	60a3      	str	r3, [r4, #8]
      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a68d4:	9b06      	ldr	r3, [sp, #24]
      __a = _GLIBCXX_MOVE(__b);
 80a68d6:	9205      	str	r2, [sp, #20]
 80a68d8:	68e2      	ldr	r2, [r4, #12]
      __b = _GLIBCXX_MOVE(__tmp);
 80a68da:	60e3      	str	r3, [r4, #12]
 80a68dc:	f89d 301c 	ldrb.w	r3, [sp, #28]
      __a = _GLIBCXX_MOVE(__b);
 80a68e0:	9206      	str	r2, [sp, #24]
 80a68e2:	7423      	strb	r3, [r4, #16]
	    _M_invoker = &_My_handler::_M_invoke;
 80a68e4:	4b06      	ldr	r3, [pc, #24]	; (80a6900 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0xf8>)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
 80a68e6:	602c      	str	r4, [r5, #0]
	    _M_invoker = &_My_handler::_M_invoke;
 80a68e8:	60eb      	str	r3, [r5, #12]
	    _M_manager = &_My_handler::_M_manager;
 80a68ea:	4b06      	ldr	r3, [pc, #24]	; (80a6904 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0xfc>)
 80a68ec:	60ab      	str	r3, [r5, #8]
    class function<_Res(_ArgTypes...)>
 80a68ee:	a803      	add	r0, sp, #12
 80a68f0:	f7f9 ff71 	bl	80a07d6 <_ZNSt14_Function_baseD1Ev>
        return (application_thread_invoke(callback, data, nullptr) == 0);
 80a68f4:	2200      	movs	r2, #0
 80a68f6:	4629      	mov	r1, r5
 80a68f8:	4803      	ldr	r0, [pc, #12]	; (80a6908 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x100>)
 80a68fa:	f7ff f8a1 	bl	80a5a40 <application_thread_invoke>
 80a68fe:	e7c7      	b.n	80a6890 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x88>
 80a6900:	080a64cf 	.word	0x080a64cf
 80a6904:	080a67bf 	.word	0x080a67bf
 80a6908:	080a5f1d 	.word	0x080a5f1d

080a690c <delay>:
    return (value - fromStart) * (toEnd - toStart) / (fromEnd - fromStart) + toStart;
}

void delay(unsigned long ms)
{
    system_delay_ms(ms, false);
 80a690c:	2100      	movs	r1, #0
 80a690e:	f7ff b887 	b.w	80a5a20 <system_delay_ms>
	...

080a6914 <_ZZ21module_user_init_hookENUlP6_reentjmPvE_4_FUNES0_jmS1_>:

void module_user_init_hook()
{
#if HAL_PLATFORM_NEWLIB
    newlib_impure_ptr_callback([](struct _reent* r, size_t size, uint32_t version, void* ctx) -> void {
        _impure_ptr = r;
 80a6914:	4b01      	ldr	r3, [pc, #4]	; (80a691c <_ZZ21module_user_init_hookENUlP6_reentjmPvE_4_FUNES0_jmS1_+0x8>)
 80a6916:	6018      	str	r0, [r3, #0]
    }, nullptr);
 80a6918:	4770      	bx	lr
 80a691a:	bf00      	nop
 80a691c:	20000008 	.word	0x20000008

080a6920 <serialEventRun>:
{
 80a6920:	b508      	push	{r3, lr}
    if (serialEvent && Serial.available()>0)
 80a6922:	4b13      	ldr	r3, [pc, #76]	; (80a6970 <serialEventRun+0x50>)
 80a6924:	b143      	cbz	r3, 80a6938 <serialEventRun+0x18>
 80a6926:	f7ff fc7f 	bl	80a6228 <_Z16_fetch_usbserialv>
 80a692a:	6803      	ldr	r3, [r0, #0]
 80a692c:	691b      	ldr	r3, [r3, #16]
 80a692e:	4798      	blx	r3
 80a6930:	2800      	cmp	r0, #0
 80a6932:	dd01      	ble.n	80a6938 <serialEventRun+0x18>
        serialEvent();
 80a6934:	f3af 8000 	nop.w
    if (serialEvent1 && Serial1.available()>0)
 80a6938:	4b0e      	ldr	r3, [pc, #56]	; (80a6974 <serialEventRun+0x54>)
 80a693a:	b143      	cbz	r3, 80a694e <serialEventRun+0x2e>
 80a693c:	f7ff fb5e 	bl	80a5ffc <_Z22__fetch_global_Serial1v>
 80a6940:	6803      	ldr	r3, [r0, #0]
 80a6942:	691b      	ldr	r3, [r3, #16]
 80a6944:	4798      	blx	r3
 80a6946:	2800      	cmp	r0, #0
 80a6948:	dd01      	ble.n	80a694e <serialEventRun+0x2e>
        serialEvent1();
 80a694a:	f3af 8000 	nop.w
    if (serialEventRun2) serialEventRun2();
 80a694e:	4b0a      	ldr	r3, [pc, #40]	; (80a6978 <serialEventRun+0x58>)
 80a6950:	b10b      	cbz	r3, 80a6956 <serialEventRun+0x36>
 80a6952:	f3af 8000 	nop.w
    if (usbSerialEvent1 && USBSerial1.available()>0)
 80a6956:	4b09      	ldr	r3, [pc, #36]	; (80a697c <serialEventRun+0x5c>)
 80a6958:	b143      	cbz	r3, 80a696c <serialEventRun+0x4c>
 80a695a:	f7ff fc91 	bl	80a6280 <_Z17_fetch_usbserial1v>
 80a695e:	6803      	ldr	r3, [r0, #0]
 80a6960:	691b      	ldr	r3, [r3, #16]
 80a6962:	4798      	blx	r3
 80a6964:	2800      	cmp	r0, #0
 80a6966:	dd01      	ble.n	80a696c <serialEventRun+0x4c>
        usbSerialEvent1();
 80a6968:	f3af 8000 	nop.w
}
 80a696c:	bd08      	pop	{r3, pc}
 80a696e:	bf00      	nop
	...

080a6980 <_post_loop>:
{
 80a6980:	b508      	push	{r3, lr}
	serialEventRun();
 80a6982:	f7ff ffcd 	bl	80a6920 <serialEventRun>
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
 80a6986:	f7fe ff2b 	bl	80a57e0 <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
 80a698a:	4b01      	ldr	r3, [pc, #4]	; (80a6990 <_post_loop+0x10>)
 80a698c:	6018      	str	r0, [r3, #0]
}
 80a698e:	bd08      	pop	{r3, pc}
 80a6990:	20000ea0 	.word	0x20000ea0

080a6994 <_Z33system_initialize_user_backup_ramv>:
    memcpy(&link_global_retained_start, &link_global_retained_initial_values, len);
 80a6994:	4805      	ldr	r0, [pc, #20]	; (80a69ac <_Z33system_initialize_user_backup_ramv+0x18>)
 80a6996:	4a06      	ldr	r2, [pc, #24]	; (80a69b0 <_Z33system_initialize_user_backup_ramv+0x1c>)
{
 80a6998:	b508      	push	{r3, lr}
    memcpy(&link_global_retained_start, &link_global_retained_initial_values, len);
 80a699a:	1a12      	subs	r2, r2, r0
 80a699c:	4905      	ldr	r1, [pc, #20]	; (80a69b4 <_Z33system_initialize_user_backup_ramv+0x20>)
 80a699e:	f001 ff95 	bl	80a88cc <memcpy>
    __backup_sram_signature = signature;
 80a69a2:	4b05      	ldr	r3, [pc, #20]	; (80a69b8 <_Z33system_initialize_user_backup_ramv+0x24>)
 80a69a4:	4a05      	ldr	r2, [pc, #20]	; (80a69bc <_Z33system_initialize_user_backup_ramv+0x28>)
 80a69a6:	601a      	str	r2, [r3, #0]
}
 80a69a8:	bd08      	pop	{r3, pc}
 80a69aa:	bf00      	nop
 80a69ac:	40024000 	.word	0x40024000
 80a69b0:	40024004 	.word	0x40024004
 80a69b4:	080aa848 	.word	0x080aa848
 80a69b8:	40024000 	.word	0x40024000
 80a69bc:	9a271c1e 	.word	0x9a271c1e

080a69c0 <_Z27ctrl_request_custom_handlerP12ctrl_request>:
    system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
 80a69c0:	2300      	movs	r3, #0
void __attribute((weak)) ctrl_request_custom_handler(ctrl_request* req) {
 80a69c2:	b507      	push	{r0, r1, r2, lr}
    system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
 80a69c4:	461a      	mov	r2, r3
 80a69c6:	f06f 0177 	mvn.w	r1, #119	; 0x77
 80a69ca:	9300      	str	r3, [sp, #0]
 80a69cc:	f7ff f852 	bl	80a5a74 <system_ctrl_set_result>
}
 80a69d0:	b003      	add	sp, #12
 80a69d2:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080a69d8 <_ZL20ctrl_request_handlerP12ctrl_request>:
static void ctrl_request_handler(ctrl_request* req) {
 80a69d8:	b507      	push	{r0, r1, r2, lr}
    switch (req->type) {
 80a69da:	8843      	ldrh	r3, [r0, #2]
 80a69dc:	2b0a      	cmp	r3, #10
 80a69de:	d008      	beq.n	80a69f2 <_ZL20ctrl_request_handlerP12ctrl_request+0x1a>
 80a69e0:	2b50      	cmp	r3, #80	; 0x50
 80a69e2:	d10b      	bne.n	80a69fc <_ZL20ctrl_request_handlerP12ctrl_request+0x24>
        if (log_process_ctrl_request_callback) {
 80a69e4:	4b09      	ldr	r3, [pc, #36]	; (80a6a0c <_ZL20ctrl_request_handlerP12ctrl_request+0x34>)
 80a69e6:	681b      	ldr	r3, [r3, #0]
 80a69e8:	b14b      	cbz	r3, 80a69fe <_ZL20ctrl_request_handlerP12ctrl_request+0x26>
}
 80a69ea:	b003      	add	sp, #12
 80a69ec:	f85d eb04 	ldr.w	lr, [sp], #4
            log_process_ctrl_request_callback(req);
 80a69f0:	4718      	bx	r3
        ctrl_request_custom_handler(req);
 80a69f2:	f7ff ffe5 	bl	80a69c0 <_Z27ctrl_request_custom_handlerP12ctrl_request>
}
 80a69f6:	b003      	add	sp, #12
 80a69f8:	f85d fb04 	ldr.w	pc, [sp], #4
        system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
 80a69fc:	2300      	movs	r3, #0
 80a69fe:	461a      	mov	r2, r3
 80a6a00:	f06f 0177 	mvn.w	r1, #119	; 0x77
 80a6a04:	9300      	str	r3, [sp, #0]
 80a6a06:	f7ff f835 	bl	80a5a74 <system_ctrl_set_result>
}
 80a6a0a:	e7f4      	b.n	80a69f6 <_ZL20ctrl_request_handlerP12ctrl_request+0x1e>
 80a6a0c:	20000e00 	.word	0x20000e00

080a6a10 <module_user_init_hook>:
    newlib_impure_ptr_callback([](struct _reent* r, size_t size, uint32_t version, void* ctx) -> void {
 80a6a10:	2100      	movs	r1, #0
{
 80a6a12:	b510      	push	{r4, lr}
    newlib_impure_ptr_callback([](struct _reent* r, size_t size, uint32_t version, void* ctx) -> void {
 80a6a14:	4811      	ldr	r0, [pc, #68]	; (80a6a5c <module_user_init_hook+0x4c>)
 80a6a16:	f7ff f879 	bl	80a5b0c <newlib_impure_ptr_callback>
#endif // HAL_PLATFORM_NEWLIB

#if HAL_PLATFORM_BACKUP_RAM
    backup_ram_was_valid_ = __backup_sram_signature == signature;
 80a6a1a:	4b11      	ldr	r3, [pc, #68]	; (80a6a60 <module_user_init_hook+0x50>)
 80a6a1c:	681a      	ldr	r2, [r3, #0]
 80a6a1e:	4b11      	ldr	r3, [pc, #68]	; (80a6a64 <module_user_init_hook+0x54>)
 80a6a20:	429a      	cmp	r2, r3
 80a6a22:	bf0c      	ite	eq
 80a6a24:	2201      	moveq	r2, #1
 80a6a26:	2200      	movne	r2, #0
 80a6a28:	4b0f      	ldr	r3, [pc, #60]	; (80a6a68 <module_user_init_hook+0x58>)
 80a6a2a:	701a      	strb	r2, [r3, #0]
    if (!backup_ram_was_valid_) {
 80a6a2c:	d001      	beq.n	80a6a32 <module_user_init_hook+0x22>
        system_initialize_user_backup_ram();
 80a6a2e:	f7ff ffb1 	bl	80a6994 <_Z33system_initialize_user_backup_ramv>
    }
#endif

#if HAL_PLATFORM_RNG
    // Initialize the default stdlib PRNG using hardware RNG as a seed
    const uint32_t seed = HAL_RNG_GetRandomNumber();
 80a6a32:	f7fe febd 	bl	80a57b0 <HAL_RNG_GetRandomNumber>
 80a6a36:	4604      	mov	r4, r0
    srand(seed);
 80a6a38:	f001 ff5e 	bl	80a88f8 <srand>

    // If the user defines random_seed_from_cloud, call it with a seed value
    // generated by a hardware RNG as well.
    if (random_seed_from_cloud) {
 80a6a3c:	4b0b      	ldr	r3, [pc, #44]	; (80a6a6c <module_user_init_hook+0x5c>)
 80a6a3e:	b113      	cbz	r3, 80a6a46 <module_user_init_hook+0x36>
        random_seed_from_cloud(seed);
 80a6a40:	4620      	mov	r0, r4
 80a6a42:	f3af 8000 	nop.w
    }
#endif
    // Register the random_seed_from_cloud handler
    spark_set_random_seed_from_cloud_handler(&random_seed_from_cloud, nullptr);
 80a6a46:	2100      	movs	r1, #0
 80a6a48:	4808      	ldr	r0, [pc, #32]	; (80a6a6c <module_user_init_hook+0x5c>)
 80a6a4a:	f7fe ff71 	bl	80a5930 <spark_set_random_seed_from_cloud_handler>

    // Register application handler for the control requests
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
}
 80a6a4e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
 80a6a52:	2100      	movs	r1, #0
 80a6a54:	4806      	ldr	r0, [pc, #24]	; (80a6a70 <module_user_init_hook+0x60>)
 80a6a56:	f7ff b803 	b.w	80a5a60 <system_ctrl_set_app_request_handler>
 80a6a5a:	bf00      	nop
 80a6a5c:	080a6915 	.word	0x080a6915
 80a6a60:	40024000 	.word	0x40024000
 80a6a64:	9a271c1e 	.word	0x9a271c1e
 80a6a68:	20000dfc 	.word	0x20000dfc
 80a6a6c:	00000000 	.word	0x00000000
 80a6a70:	080a69d9 	.word	0x080a69d9

080a6a74 <_ZN8RGBClass7controlEb>:
{
    return LED_RGB_IsOverRidden();
}

void RGBClass::control(bool override)
{
 80a6a74:	b510      	push	{r4, lr}
 80a6a76:	4604      	mov	r4, r0
    return LED_RGB_IsOverRidden();
 80a6a78:	f7fe ff12 	bl	80a58a0 <LED_RGB_IsOverRidden>
    if (override == controlled()) {
 80a6a7c:	4284      	cmp	r4, r0
 80a6a7e:	d008      	beq.n	80a6a92 <_ZN8RGBClass7controlEb+0x1e>
        return;
    } else if (override) {
 80a6a80:	b11c      	cbz	r4, 80a6a8a <_ZN8RGBClass7controlEb+0x16>
        LED_Signaling_Start();
    } else {
        LED_Signaling_Stop();
    }
}
 80a6a82:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        LED_Signaling_Start();
 80a6a86:	f7fe bef3 	b.w	80a5870 <LED_Signaling_Start>
}
 80a6a8a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        LED_Signaling_Stop();
 80a6a8e:	f7fe bef7 	b.w	80a5880 <LED_Signaling_Stop>
}
 80a6a92:	bd10      	pop	{r4, pc}

080a6a94 <_ZN8RGBClass5colorEiii>:
void RGBClass::color(uint32_t rgb) {
    color((rgb>>16)&0xFF, (rgb>>8)&0xFF, (rgb)&0xFF);
}

void RGBClass::color(int red, int green, int blue)
{
 80a6a94:	b570      	push	{r4, r5, r6, lr}
 80a6a96:	4605      	mov	r5, r0
 80a6a98:	460e      	mov	r6, r1
 80a6a9a:	4614      	mov	r4, r2
    return LED_RGB_IsOverRidden();
 80a6a9c:	f7fe ff00 	bl	80a58a0 <LED_RGB_IsOverRidden>
    if (!controlled()) {
 80a6aa0:	b150      	cbz	r0, 80a6ab8 <_ZN8RGBClass5colorEiii+0x24>
        return;
    }
    LED_SetSignalingColor(red << 16 | green << 8 | blue);
 80a6aa2:	ea44 2406 	orr.w	r4, r4, r6, lsl #8
 80a6aa6:	ea44 4005 	orr.w	r0, r4, r5, lsl #16
 80a6aaa:	f7fe fed9 	bl	80a5860 <LED_SetSignalingColor>
    LED_On(LED_RGB);
}
 80a6aae:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    LED_On(LED_RGB);
 80a6ab2:	20e7      	movs	r0, #231	; 0xe7
 80a6ab4:	f7fe befc 	b.w	80a58b0 <LED_On>
}
 80a6ab8:	bd70      	pop	{r4, r5, r6, pc}

080a6aba <_ZN8RGBClass10brightnessEhb>:

void RGBClass::brightness(uint8_t brightness, bool update)
{
 80a6aba:	b510      	push	{r4, lr}
 80a6abc:	460c      	mov	r4, r1
    LED_SetBrightness(brightness);
 80a6abe:	f7fe fee7 	bl	80a5890 <LED_SetBrightness>
    return LED_RGB_IsOverRidden();
 80a6ac2:	f7fe feed 	bl	80a58a0 <LED_RGB_IsOverRidden>
    if (controlled() && update) {
 80a6ac6:	b128      	cbz	r0, 80a6ad4 <_ZN8RGBClass10brightnessEhb+0x1a>
 80a6ac8:	b124      	cbz	r4, 80a6ad4 <_ZN8RGBClass10brightnessEhb+0x1a>
        LED_On(LED_RGB);
    }
}
 80a6aca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        LED_On(LED_RGB);
 80a6ace:	20e7      	movs	r0, #231	; 0xe7
 80a6ad0:	f7fe beee 	b.w	80a58b0 <LED_On>
}
 80a6ad4:	bd10      	pop	{r4, pc}
	...

080a6ad8 <_GLOBAL__sub_I_RGB>:
    _Function_base() : _M_manager(nullptr) { }
 80a6ad8:	2200      	movs	r2, #0
 80a6ada:	4b01      	ldr	r3, [pc, #4]	; (80a6ae0 <_GLOBAL__sub_I_RGB+0x8>)
 80a6adc:	609a      	str	r2, [r3, #8]
{
    RGBClass* const d = static_cast<RGBClass*>(data);
    if (d->changeHandler_) {
        d->changeHandler_(r, g, b);
    }
}
 80a6ade:	4770      	bx	lr
 80a6ae0:	20000e04 	.word	0x20000e04

080a6ae4 <_ZN3UDP13receivePacketEPcjm>:
     * @param buffer        The buffer to read data to
     * @param buf_size      The buffer size
     * @return The number of bytes written to the buffer, or a negative value on error.
     */
    virtual int receivePacket(uint8_t* buffer, size_t buf_size, system_tick_t timeout = 0);
    virtual int receivePacket(char* buffer, size_t buf_size, system_tick_t timeout = 0) {
 80a6ae4:	b410      	push	{r4}
        return receivePacket((uint8_t*)buffer, buf_size, timeout);
 80a6ae6:	6804      	ldr	r4, [r0, #0]
 80a6ae8:	6b24      	ldr	r4, [r4, #48]	; 0x30
 80a6aea:	46a4      	mov	ip, r4
    }
 80a6aec:	bc10      	pop	{r4}
        return receivePacket((uint8_t*)buffer, buf_size, timeout);
 80a6aee:	4760      	bx	ip

080a6af0 <_ZN3UDP4readEPcj>:
     * @return
     */
    virtual int read();
    virtual int read(unsigned char* buffer, size_t len);

    virtual int read(char* buffer, size_t len) { return read((unsigned char*)buffer, len); };
 80a6af0:	6803      	ldr	r3, [r0, #0]
 80a6af2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80a6af4:	4718      	bx	r3

080a6af6 <_ZN3UDP10remotePortEv>:
    void flush_buffer();

    const uint8_t* buffer() const { return _buffer; }

    virtual IPAddress remoteIP() { return _remoteIP; };
    virtual uint16_t remotePort() { return _remotePort; };
 80a6af6:	8e80      	ldrh	r0, [r0, #52]	; 0x34
 80a6af8:	4770      	bx	lr

080a6afa <_ZN3UDP9availableEv>:
    return bound;
}

int UDP::available()
{
    return _total - _offset;
 80a6afa:	8f02      	ldrh	r2, [r0, #56]	; 0x38
 80a6afc:	8ec0      	ldrh	r0, [r0, #54]	; 0x36
}
 80a6afe:	1a10      	subs	r0, r2, r0
 80a6b00:	4770      	bx	lr

080a6b02 <_ZN3UDP5writeEh>:
    DEBUG("sendto(buffer=%lx, size=%d)=%d",buffer, buffer_size , rv);
    return rv;
}

size_t UDP::write(uint8_t byte)
{
 80a6b02:	b507      	push	{r0, r1, r2, lr}
    return write(&byte, 1);
 80a6b04:	6803      	ldr	r3, [r0, #0]
{
 80a6b06:	f88d 1007 	strb.w	r1, [sp, #7]
    return write(&byte, 1);
 80a6b0a:	2201      	movs	r2, #1
 80a6b0c:	68db      	ldr	r3, [r3, #12]
 80a6b0e:	f10d 0107 	add.w	r1, sp, #7
 80a6b12:	4798      	blx	r3
}
 80a6b14:	b003      	add	sp, #12
 80a6b16:	f85d fb04 	ldr.w	pc, [sp], #4

080a6b1a <_ZN3UDP4readEv>:
    }
    return ret;
}

int UDP::read()
{
 80a6b1a:	b510      	push	{r4, lr}
  return available() ? _buffer[_offset++] : -1;
 80a6b1c:	6803      	ldr	r3, [r0, #0]
{
 80a6b1e:	4604      	mov	r4, r0
  return available() ? _buffer[_offset++] : -1;
 80a6b20:	691b      	ldr	r3, [r3, #16]
 80a6b22:	4798      	blx	r3
 80a6b24:	b128      	cbz	r0, 80a6b32 <_ZN3UDP4readEv+0x18>
 80a6b26:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 80a6b28:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 80a6b2a:	1c59      	adds	r1, r3, #1
 80a6b2c:	86e1      	strh	r1, [r4, #54]	; 0x36
 80a6b2e:	5cd0      	ldrb	r0, [r2, r3]
}
 80a6b30:	bd10      	pop	{r4, pc}
  return available() ? _buffer[_offset++] : -1;
 80a6b32:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80a6b36:	e7fb      	b.n	80a6b30 <_ZN3UDP4readEv+0x16>

080a6b38 <_ZN3UDP4peekEv>:
    }
    return read;
}

int UDP::peek()
{
 80a6b38:	b510      	push	{r4, lr}
    return available() ? _buffer[_offset] : -1;
 80a6b3a:	6803      	ldr	r3, [r0, #0]
{
 80a6b3c:	4604      	mov	r4, r0
    return available() ? _buffer[_offset] : -1;
 80a6b3e:	691b      	ldr	r3, [r3, #16]
 80a6b40:	4798      	blx	r3
 80a6b42:	b118      	cbz	r0, 80a6b4c <_ZN3UDP4peekEv+0x14>
 80a6b44:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 80a6b46:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 80a6b48:	5cd0      	ldrb	r0, [r2, r3]
}
 80a6b4a:	bd10      	pop	{r4, pc}
    return available() ? _buffer[_offset] : -1;
 80a6b4c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80a6b50:	e7fb      	b.n	80a6b4a <_ZN3UDP4peekEv+0x12>

080a6b52 <_ZN3UDP5flushEv>:

void UDP::flush()
{
}
 80a6b52:	4770      	bx	lr

080a6b54 <_ZNK3UDP7printToER5Print>:
  _offset = 0;
  _total = 0;
}

size_t UDP::printTo(Print& p) const
{
 80a6b54:	4603      	mov	r3, r0
 80a6b56:	4608      	mov	r0, r1
 80a6b58:	b410      	push	{r4}
    // can't use available() since this is a `const` method, and available is part of the Stream interface, and is non-const.
    int size = _total - _offset;
 80a6b5a:	8ed9      	ldrh	r1, [r3, #54]	; 0x36
    return p.write(_buffer+_offset, size);
 80a6b5c:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
    int size = _total - _offset;
 80a6b5e:	8f1a      	ldrh	r2, [r3, #56]	; 0x38
    return p.write(_buffer+_offset, size);
 80a6b60:	6803      	ldr	r3, [r0, #0]
 80a6b62:	1a52      	subs	r2, r2, r1
 80a6b64:	68db      	ldr	r3, [r3, #12]
 80a6b66:	4421      	add	r1, r4
}
 80a6b68:	bc10      	pop	{r4}
    return p.write(_buffer+_offset, size);
 80a6b6a:	4718      	bx	r3

080a6b6c <_ZThn16_NK3UDP7printToER5Print>:
    /**
     * Prints the current read parsed packet to the given output.
     * @param p
     * @return
     */
    virtual size_t printTo(Print& p) const;
 80a6b6c:	f1a0 0010 	sub.w	r0, r0, #16
 80a6b70:	f7ff bff0 	b.w	80a6b54 <_ZNK3UDP7printToER5Print>

080a6b74 <_ZN3UDP5beginEtm>:
{
 80a6b74:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 80a6b78:	4616      	mov	r6, r2
    stop();
 80a6b7a:	6803      	ldr	r3, [r0, #0]
{
 80a6b7c:	4688      	mov	r8, r1
    stop();
 80a6b7e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
{
 80a6b80:	4604      	mov	r4, r0
    stop();
 80a6b82:	4798      	blx	r3
    if(Network.from(nif).ready())
 80a6b84:	4630      	mov	r0, r6
 80a6b86:	f7ff f82d 	bl	80a5be4 <_ZN5spark12NetworkClass4fromEm>
 80a6b8a:	6803      	ldr	r3, [r0, #0]
 80a6b8c:	68db      	ldr	r3, [r3, #12]
 80a6b8e:	4798      	blx	r3
 80a6b90:	4605      	mov	r5, r0
 80a6b92:	b188      	cbz	r0, 80a6bb8 <_ZN3UDP5beginEtm+0x44>
       _sock = socket_create(AF_INET, SOCK_DGRAM, IPPROTO_UDP, port, nif);
 80a6b94:	2102      	movs	r1, #2
 80a6b96:	4643      	mov	r3, r8
 80a6b98:	2211      	movs	r2, #17
 80a6b9a:	4608      	mov	r0, r1
 80a6b9c:	9600      	str	r6, [sp, #0]
 80a6b9e:	f7fe fcdb 	bl	80a5558 <socket_create>
 80a6ba2:	6160      	str	r0, [r4, #20]
        if (socket_handle_valid(_sock))
 80a6ba4:	f7fe fcd0 	bl	80a5548 <socket_handle_valid>
 80a6ba8:	4607      	mov	r7, r0
 80a6baa:	b148      	cbz	r0, 80a6bc0 <_ZN3UDP5beginEtm+0x4c>
  _offset = 0;
 80a6bac:	2300      	movs	r3, #0
            _port = port;
 80a6bae:	f8a4 8018 	strh.w	r8, [r4, #24]
  _offset = 0;
 80a6bb2:	86e3      	strh	r3, [r4, #54]	; 0x36
  _total = 0;
 80a6bb4:	8723      	strh	r3, [r4, #56]	; 0x38
            _nif = nif;
 80a6bb6:	6466      	str	r6, [r4, #68]	; 0x44
}
 80a6bb8:	4628      	mov	r0, r5
 80a6bba:	b002      	add	sp, #8
 80a6bbc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
            stop();
 80a6bc0:	6823      	ldr	r3, [r4, #0]
 80a6bc2:	4620      	mov	r0, r4
 80a6bc4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a6bc6:	4798      	blx	r3
            bound = false;
 80a6bc8:	463d      	mov	r5, r7
 80a6bca:	e7f5      	b.n	80a6bb8 <_ZN3UDP5beginEtm+0x44>

080a6bcc <_ZN3UDP4stopEv>:
{
 80a6bcc:	b538      	push	{r3, r4, r5, lr}
 80a6bce:	4604      	mov	r4, r0
    if (isOpen(_sock))
 80a6bd0:	6945      	ldr	r5, [r0, #20]
   return sd != socket_handle_invalid();
 80a6bd2:	f7fe fcd9 	bl	80a5588 <socket_handle_invalid>
    if (isOpen(_sock))
 80a6bd6:	4285      	cmp	r5, r0
 80a6bd8:	d002      	beq.n	80a6be0 <_ZN3UDP4stopEv+0x14>
        socket_close(_sock);
 80a6bda:	6960      	ldr	r0, [r4, #20]
 80a6bdc:	f7fe fccc 	bl	80a5578 <socket_close>
    _sock = socket_handle_invalid();
 80a6be0:	f7fe fcd2 	bl	80a5588 <socket_handle_invalid>
  _offset = 0;
 80a6be4:	2300      	movs	r3, #0
    _sock = socket_handle_invalid();
 80a6be6:	6160      	str	r0, [r4, #20]
  _offset = 0;
 80a6be8:	86e3      	strh	r3, [r4, #54]	; 0x36
  _total = 0;
 80a6bea:	8723      	strh	r3, [r4, #56]	; 0x38
}
 80a6bec:	bd38      	pop	{r3, r4, r5, pc}

080a6bee <_ZN3UDP10sendPacketEPKhj9IPAddresst>:
{
 80a6bee:	b510      	push	{r4, lr}
    remoteSockAddr.sa_family = AF_INET;
 80a6bf0:	2402      	movs	r4, #2
{
 80a6bf2:	b086      	sub	sp, #24
    remoteSockAddr.sa_family = AF_INET;
 80a6bf4:	f8ad 4008 	strh.w	r4, [sp, #8]
    remoteSockAddr.sa_data[0] = (port & 0xFF00) >> 8;
 80a6bf8:	f8bd 4020 	ldrh.w	r4, [sp, #32]
 80a6bfc:	ba64      	rev16	r4, r4
 80a6bfe:	f8ad 400a 	strh.w	r4, [sp, #10]
    remoteSockAddr.sa_data[2] = remoteIP[0];
 80a6c02:	79dc      	ldrb	r4, [r3, #7]
 80a6c04:	f88d 400c 	strb.w	r4, [sp, #12]
    remoteSockAddr.sa_data[3] = remoteIP[1];
 80a6c08:	799c      	ldrb	r4, [r3, #6]
 80a6c0a:	f88d 400d 	strb.w	r4, [sp, #13]
    remoteSockAddr.sa_data[4] = remoteIP[2];
 80a6c0e:	795c      	ldrb	r4, [r3, #5]
    remoteSockAddr.sa_data[5] = remoteIP[3];
 80a6c10:	791b      	ldrb	r3, [r3, #4]
    remoteSockAddr.sa_data[4] = remoteIP[2];
 80a6c12:	f88d 400e 	strb.w	r4, [sp, #14]
    remoteSockAddr.sa_data[5] = remoteIP[3];
 80a6c16:	f88d 300f 	strb.w	r3, [sp, #15]
    int rv = socket_sendto(_sock, buffer, buffer_size, 0, &remoteSockAddr, sizeof(remoteSockAddr));
 80a6c1a:	2310      	movs	r3, #16
 80a6c1c:	9301      	str	r3, [sp, #4]
 80a6c1e:	ab02      	add	r3, sp, #8
 80a6c20:	9300      	str	r3, [sp, #0]
 80a6c22:	6940      	ldr	r0, [r0, #20]
 80a6c24:	2300      	movs	r3, #0
 80a6c26:	f7fe fc9f 	bl	80a5568 <socket_sendto>
}
 80a6c2a:	b006      	add	sp, #24
 80a6c2c:	bd10      	pop	{r4, pc}

080a6c2e <_ZN3UDP5writeEPKhj>:
{
 80a6c2e:	b570      	push	{r4, r5, r6, lr}
 80a6c30:	4605      	mov	r5, r0
    size_t available = _buffer ? _buffer_size - _offset : 0;
 80a6c32:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
 80a6c34:	8eee      	ldrh	r6, [r5, #54]	; 0x36
 80a6c36:	b168      	cbz	r0, 80a6c54 <_ZN3UDP5writeEPKhj+0x26>
 80a6c38:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 80a6c3a:	1b9c      	subs	r4, r3, r6
    if (size>available)
 80a6c3c:	4294      	cmp	r4, r2
 80a6c3e:	bf28      	it	cs
 80a6c40:	4614      	movcs	r4, r2
    memcpy(_buffer+_offset, buffer, size);
 80a6c42:	4430      	add	r0, r6
 80a6c44:	4622      	mov	r2, r4
 80a6c46:	f001 fe41 	bl	80a88cc <memcpy>
    _offset += size;
 80a6c4a:	8eeb      	ldrh	r3, [r5, #54]	; 0x36
}
 80a6c4c:	4620      	mov	r0, r4
    _offset += size;
 80a6c4e:	4423      	add	r3, r4
 80a6c50:	86eb      	strh	r3, [r5, #54]	; 0x36
}
 80a6c52:	bd70      	pop	{r4, r5, r6, pc}
    size_t available = _buffer ? _buffer_size - _offset : 0;
 80a6c54:	4604      	mov	r4, r0
 80a6c56:	e7f1      	b.n	80a6c3c <_ZN3UDP5writeEPKhj+0xe>

080a6c58 <_ZN3UDP4readEPhj>:
{
 80a6c58:	b570      	push	{r4, r5, r6, lr}
    if (available())
 80a6c5a:	6803      	ldr	r3, [r0, #0]
{
 80a6c5c:	4604      	mov	r4, r0
    if (available())
 80a6c5e:	691b      	ldr	r3, [r3, #16]
{
 80a6c60:	460e      	mov	r6, r1
 80a6c62:	4615      	mov	r5, r2
    if (available())
 80a6c64:	4798      	blx	r3
 80a6c66:	b190      	cbz	r0, 80a6c8e <_ZN3UDP4readEPhj+0x36>
    read = min(int(len), available());
 80a6c68:	6823      	ldr	r3, [r4, #0]
 80a6c6a:	4620      	mov	r0, r4
 80a6c6c:	691b      	ldr	r3, [r3, #16]
 80a6c6e:	4798      	blx	r3
 80a6c70:	4285      	cmp	r5, r0
 80a6c72:	bfa8      	it	ge
 80a6c74:	4605      	movge	r5, r0
      memcpy(buffer, &_buffer[_offset], read);
 80a6c76:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 80a6c78:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 80a6c7a:	462a      	mov	r2, r5
 80a6c7c:	4419      	add	r1, r3
 80a6c7e:	4630      	mov	r0, r6
 80a6c80:	f001 fe24 	bl	80a88cc <memcpy>
      _offset += read;
 80a6c84:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 80a6c86:	442b      	add	r3, r5
 80a6c88:	86e3      	strh	r3, [r4, #54]	; 0x36
}
 80a6c8a:	4628      	mov	r0, r5
 80a6c8c:	bd70      	pop	{r4, r5, r6, pc}
    int read = -1;
 80a6c8e:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    return read;
 80a6c92:	e7fa      	b.n	80a6c8a <_ZN3UDP4readEPhj+0x32>

080a6c94 <_ZN3UDP13receivePacketEPhjm>:
{
 80a6c94:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a6c98:	4604      	mov	r4, r0
 80a6c9a:	b08a      	sub	sp, #40	; 0x28
    if(Network.from(_nif).ready() && isOpen(_sock) && buffer)
 80a6c9c:	6c40      	ldr	r0, [r0, #68]	; 0x44
{
 80a6c9e:	461f      	mov	r7, r3
 80a6ca0:	460d      	mov	r5, r1
 80a6ca2:	4616      	mov	r6, r2
    if(Network.from(_nif).ready() && isOpen(_sock) && buffer)
 80a6ca4:	f7fe ff9e 	bl	80a5be4 <_ZN5spark12NetworkClass4fromEm>
 80a6ca8:	6803      	ldr	r3, [r0, #0]
 80a6caa:	68db      	ldr	r3, [r3, #12]
 80a6cac:	4798      	blx	r3
 80a6cae:	b928      	cbnz	r0, 80a6cbc <_ZN3UDP13receivePacketEPhjm+0x28>
    int ret = -1;
 80a6cb0:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
}
 80a6cb4:	4628      	mov	r0, r5
 80a6cb6:	b00a      	add	sp, #40	; 0x28
 80a6cb8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if(Network.from(_nif).ready() && isOpen(_sock) && buffer)
 80a6cbc:	f8d4 8014 	ldr.w	r8, [r4, #20]
   return sd != socket_handle_invalid();
 80a6cc0:	f7fe fc62 	bl	80a5588 <socket_handle_invalid>
    if(Network.from(_nif).ready() && isOpen(_sock) && buffer)
 80a6cc4:	4580      	cmp	r8, r0
 80a6cc6:	d0f3      	beq.n	80a6cb0 <_ZN3UDP13receivePacketEPhjm+0x1c>
 80a6cc8:	2d00      	cmp	r5, #0
 80a6cca:	d0f1      	beq.n	80a6cb0 <_ZN3UDP13receivePacketEPhjm+0x1c>
        socklen_t remoteSockAddrLen = sizeof(remoteSockAddr);
 80a6ccc:	2310      	movs	r3, #16
 80a6cce:	9305      	str	r3, [sp, #20]
        ret = socket_receivefrom_ex(_sock, buffer, size, 0, &remoteSockAddr, &remoteSockAddrLen, timeout, nullptr);
 80a6cd0:	2300      	movs	r3, #0
 80a6cd2:	aa05      	add	r2, sp, #20
 80a6cd4:	9201      	str	r2, [sp, #4]
 80a6cd6:	aa06      	add	r2, sp, #24
 80a6cd8:	4629      	mov	r1, r5
 80a6cda:	9200      	str	r2, [sp, #0]
 80a6cdc:	e9cd 7302 	strd	r7, r3, [sp, #8]
 80a6ce0:	4632      	mov	r2, r6
 80a6ce2:	6960      	ldr	r0, [r4, #20]
 80a6ce4:	f7fe fc58 	bl	80a5598 <socket_receivefrom_ex>
        if (ret >= 0)
 80a6ce8:	1e05      	subs	r5, r0, #0
 80a6cea:	dbe3      	blt.n	80a6cb4 <_ZN3UDP13receivePacketEPhjm+0x20>
            _remotePort = remoteSockAddr.sa_data[0] << 8 | remoteSockAddr.sa_data[1];
 80a6cec:	f89d 201a 	ldrb.w	r2, [sp, #26]
 80a6cf0:	f89d 301b 	ldrb.w	r3, [sp, #27]
            _remoteIP = &remoteSockAddr.sa_data[2];
 80a6cf4:	a907      	add	r1, sp, #28
            _remotePort = remoteSockAddr.sa_data[0] << 8 | remoteSockAddr.sa_data[1];
 80a6cf6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80a6cfa:	86a3      	strh	r3, [r4, #52]	; 0x34
            _remoteIP = &remoteSockAddr.sa_data[2];
 80a6cfc:	f104 001c 	add.w	r0, r4, #28
 80a6d00:	f7ff fb46 	bl	80a6390 <_ZN9IPAddressaSEPKh>
    return ret;
 80a6d04:	e7d6      	b.n	80a6cb4 <_ZN3UDP13receivePacketEPhjm+0x20>
	...

080a6d08 <_ZN3UDP11beginPacketEPKct>:
{
 80a6d08:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a6d0c:	4606      	mov	r6, r0
 80a6d0e:	b094      	sub	sp, #80	; 0x50
    if(Network.from(_nif).ready())
 80a6d10:	6c40      	ldr	r0, [r0, #68]	; 0x44
{
 80a6d12:	460d      	mov	r5, r1
 80a6d14:	4617      	mov	r7, r2
    if(Network.from(_nif).ready())
 80a6d16:	f7fe ff65 	bl	80a5be4 <_ZN5spark12NetworkClass4fromEm>
 80a6d1a:	6803      	ldr	r3, [r0, #0]
 80a6d1c:	68db      	ldr	r3, [r3, #12]
 80a6d1e:	4798      	blx	r3
 80a6d20:	b1f0      	cbz	r0, 80a6d60 <_ZN3UDP11beginPacketEPKct+0x58>
        if(inet_gethostbyname((char*)host, strlen(host), &ip_addr, _nif, NULL) == 0)
 80a6d22:	4628      	mov	r0, r5
 80a6d24:	f001 fe7d 	bl	80a8a22 <strlen>
 80a6d28:	2400      	movs	r4, #0
 80a6d2a:	b281      	uxth	r1, r0
 80a6d2c:	6c73      	ldr	r3, [r6, #68]	; 0x44
 80a6d2e:	4628      	mov	r0, r5
 80a6d30:	9400      	str	r4, [sp, #0]
 80a6d32:	aa03      	add	r2, sp, #12
 80a6d34:	f7fe fb88 	bl	80a5448 <inet_gethostbyname>
 80a6d38:	b9a8      	cbnz	r0, 80a6d66 <_ZN3UDP11beginPacketEPKct+0x5e>
            IPAddress remote_addr(ip_addr);
 80a6d3a:	a903      	add	r1, sp, #12
 80a6d3c:	a808      	add	r0, sp, #32
 80a6d3e:	f7ff faf3 	bl	80a6328 <_ZN9IPAddressC1ERK16_HAL_IPAddress_t>
            return beginPacket(remote_addr, port);
 80a6d42:	6833      	ldr	r3, [r6, #0]
class IPAddress : public Printable {
 80a6d44:	ac0f      	add	r4, sp, #60	; 0x3c
 80a6d46:	f8d3 8038 	ldr.w	r8, [r3, #56]	; 0x38
 80a6d4a:	4b08      	ldr	r3, [pc, #32]	; (80a6d6c <_ZN3UDP11beginPacketEPKct+0x64>)
 80a6d4c:	ad09      	add	r5, sp, #36	; 0x24
 80a6d4e:	930e      	str	r3, [sp, #56]	; 0x38
 80a6d50:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80a6d52:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80a6d54:	682b      	ldr	r3, [r5, #0]
 80a6d56:	463a      	mov	r2, r7
 80a6d58:	4630      	mov	r0, r6
 80a6d5a:	7023      	strb	r3, [r4, #0]
 80a6d5c:	a90e      	add	r1, sp, #56	; 0x38
 80a6d5e:	47c0      	blx	r8
}
 80a6d60:	b014      	add	sp, #80	; 0x50
 80a6d62:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return 0;
 80a6d66:	4620      	mov	r0, r4
 80a6d68:	e7fa      	b.n	80a6d60 <_ZN3UDP11beginPacketEPKct+0x58>
 80a6d6a:	bf00      	nop
 80a6d6c:	080aa5bc 	.word	0x080aa5bc

080a6d70 <_ZN3UDP8remoteIPEv>:
    virtual IPAddress remoteIP() { return _remoteIP; };
 80a6d70:	b570      	push	{r4, r5, r6, lr}
 80a6d72:	4604      	mov	r4, r0
 80a6d74:	4606      	mov	r6, r0
 80a6d76:	4b05      	ldr	r3, [pc, #20]	; (80a6d8c <_ZN3UDP8remoteIPEv+0x1c>)
 80a6d78:	f101 0520 	add.w	r5, r1, #32
 80a6d7c:	f844 3b04 	str.w	r3, [r4], #4
 80a6d80:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80a6d82:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80a6d84:	682b      	ldr	r3, [r5, #0]
 80a6d86:	4630      	mov	r0, r6
 80a6d88:	7023      	strb	r3, [r4, #0]
 80a6d8a:	bd70      	pop	{r4, r5, r6, pc}
 80a6d8c:	080aa5bc 	.word	0x080aa5bc

080a6d90 <_ZN3UDP10sendPacketEPKcj9IPAddresst>:
    virtual int sendPacket(const char* buffer, size_t buffer_size, IPAddress destination, uint16_t port) {
 80a6d90:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a6d92:	468c      	mov	ip, r1
 80a6d94:	4696      	mov	lr, r2
 80a6d96:	4606      	mov	r6, r0
        return sendPacket((uint8_t*)buffer, buffer_size, destination, port);
 80a6d98:	6802      	ldr	r2, [r0, #0]
    virtual int sendPacket(const char* buffer, size_t buffer_size, IPAddress destination, uint16_t port) {
 80a6d9a:	b089      	sub	sp, #36	; 0x24
        return sendPacket((uint8_t*)buffer, buffer_size, destination, port);
 80a6d9c:	6a97      	ldr	r7, [r2, #40]	; 0x28
 80a6d9e:	4a09      	ldr	r2, [pc, #36]	; (80a6dc4 <_ZN3UDP10sendPacketEPKcj9IPAddresst+0x34>)
 80a6da0:	ad03      	add	r5, sp, #12
 80a6da2:	1d1c      	adds	r4, r3, #4
 80a6da4:	9202      	str	r2, [sp, #8]
 80a6da6:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80a6da8:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80a6daa:	6823      	ldr	r3, [r4, #0]
 80a6dac:	4672      	mov	r2, lr
 80a6dae:	702b      	strb	r3, [r5, #0]
 80a6db0:	f8bd 3038 	ldrh.w	r3, [sp, #56]	; 0x38
 80a6db4:	4661      	mov	r1, ip
 80a6db6:	9300      	str	r3, [sp, #0]
 80a6db8:	4630      	mov	r0, r6
 80a6dba:	ab02      	add	r3, sp, #8
 80a6dbc:	47b8      	blx	r7
    }
 80a6dbe:	b009      	add	sp, #36	; 0x24
 80a6dc0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a6dc2:	bf00      	nop
 80a6dc4:	080aa5bc 	.word	0x080aa5bc

080a6dc8 <_ZN3UDP9endPacketEv>:
{
 80a6dc8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a6dca:	4604      	mov	r4, r0
    int result = sendPacket(_buffer, _offset, _remoteIP, _remotePort);
 80a6dcc:	6803      	ldr	r3, [r0, #0]
{
 80a6dce:	b089      	sub	sp, #36	; 0x24
    int result = sendPacket(_buffer, _offset, _remoteIP, _remotePort);
 80a6dd0:	6a9f      	ldr	r7, [r3, #40]	; 0x28
 80a6dd2:	4b0c      	ldr	r3, [pc, #48]	; (80a6e04 <_ZN3UDP9endPacketEv+0x3c>)
 80a6dd4:	ad03      	add	r5, sp, #12
 80a6dd6:	f100 0620 	add.w	r6, r0, #32
 80a6dda:	9302      	str	r3, [sp, #8]
 80a6ddc:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 80a6dde:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80a6de0:	6833      	ldr	r3, [r6, #0]
 80a6de2:	8ee2      	ldrh	r2, [r4, #54]	; 0x36
 80a6de4:	702b      	strb	r3, [r5, #0]
 80a6de6:	8ea3      	ldrh	r3, [r4, #52]	; 0x34
 80a6de8:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 80a6dea:	9300      	str	r3, [sp, #0]
 80a6dec:	4620      	mov	r0, r4
 80a6dee:	ab02      	add	r3, sp, #8
 80a6df0:	47b8      	blx	r7
 80a6df2:	4605      	mov	r5, r0
    flush(); // wait for send to complete
 80a6df4:	6823      	ldr	r3, [r4, #0]
 80a6df6:	4620      	mov	r0, r4
 80a6df8:	69db      	ldr	r3, [r3, #28]
 80a6dfa:	4798      	blx	r3
}
 80a6dfc:	4628      	mov	r0, r5
 80a6dfe:	b009      	add	sp, #36	; 0x24
 80a6e00:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a6e02:	bf00      	nop
 80a6e04:	080aa5bc 	.word	0x080aa5bc

080a6e08 <_ZN3UDPC1Ev>:
UDP::UDP() :
 80a6e08:	b538      	push	{r3, r4, r5, lr}
 80a6e0a:	2500      	movs	r5, #0
 80a6e0c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a6e10:	e9c0 5301 	strd	r5, r3, [r0, #4]
        _buffer_allocated(false)
 80a6e14:	4b0c      	ldr	r3, [pc, #48]	; (80a6e48 <_ZN3UDPC1Ev+0x40>)
UDP::UDP() :
 80a6e16:	4604      	mov	r4, r0
        _buffer_allocated(false)
 80a6e18:	f103 0208 	add.w	r2, r3, #8
 80a6e1c:	336c      	adds	r3, #108	; 0x6c
 80a6e1e:	6002      	str	r2, [r0, #0]
 80a6e20:	6103      	str	r3, [r0, #16]
        _sock(socket_handle_invalid()),
 80a6e22:	f7fe fbb1 	bl	80a5588 <socket_handle_invalid>
        _buffer_allocated(false)
 80a6e26:	6160      	str	r0, [r4, #20]
 80a6e28:	f104 001c 	add.w	r0, r4, #28
 80a6e2c:	f7ff fa6e 	bl	80a630c <_ZN9IPAddressC1Ev>
 80a6e30:	f44f 7300 	mov.w	r3, #512	; 0x200
}
 80a6e34:	4620      	mov	r0, r4
        _buffer_allocated(false)
 80a6e36:	e9c4 3510 	strd	r3, r5, [r4, #64]	; 0x40
 80a6e3a:	86e5      	strh	r5, [r4, #54]	; 0x36
 80a6e3c:	8725      	strh	r5, [r4, #56]	; 0x38
 80a6e3e:	63e5      	str	r5, [r4, #60]	; 0x3c
 80a6e40:	f884 5048 	strb.w	r5, [r4, #72]	; 0x48
}
 80a6e44:	bd38      	pop	{r3, r4, r5, pc}
 80a6e46:	bf00      	nop
 80a6e48:	080aa5e4 	.word	0x080aa5e4

080a6e4c <_ZN3UDP13releaseBufferEv>:
{
 80a6e4c:	b510      	push	{r4, lr}
    if (_buffer_allocated && _buffer) {
 80a6e4e:	f890 3048 	ldrb.w	r3, [r0, #72]	; 0x48
{
 80a6e52:	4604      	mov	r4, r0
    if (_buffer_allocated && _buffer) {
 80a6e54:	b123      	cbz	r3, 80a6e60 <_ZN3UDP13releaseBufferEv+0x14>
 80a6e56:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
 80a6e58:	b110      	cbz	r0, 80a6e60 <_ZN3UDP13releaseBufferEv+0x14>
        delete _buffer;
 80a6e5a:	2101      	movs	r1, #1
 80a6e5c:	f000 fbd9 	bl	80a7612 <_ZdlPvj>
    _buffer = NULL;
 80a6e60:	2300      	movs	r3, #0
 80a6e62:	63e3      	str	r3, [r4, #60]	; 0x3c
    _buffer_allocated = false;
 80a6e64:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
    _buffer_size = 0;
 80a6e68:	6423      	str	r3, [r4, #64]	; 0x40
  _offset = 0;
 80a6e6a:	86e3      	strh	r3, [r4, #54]	; 0x36
  _total = 0;
 80a6e6c:	8723      	strh	r3, [r4, #56]	; 0x38
}
 80a6e6e:	bd10      	pop	{r4, pc}

080a6e70 <_ZN3UDP9setBufferEjPh>:
{
 80a6e70:	b570      	push	{r4, r5, r6, lr}
 80a6e72:	4604      	mov	r4, r0
 80a6e74:	4616      	mov	r6, r2
 80a6e76:	460d      	mov	r5, r1
    releaseBuffer();
 80a6e78:	f7ff ffe8 	bl	80a6e4c <_ZN3UDP13releaseBufferEv>
    _buffer_size = 0;
 80a6e7c:	2300      	movs	r3, #0
    _buffer = buffer;
 80a6e7e:	63e6      	str	r6, [r4, #60]	; 0x3c
    _buffer_size = 0;
 80a6e80:	6423      	str	r3, [r4, #64]	; 0x40
    if (!_buffer && buf_size) {         // requested allocation
 80a6e82:	b12e      	cbz	r6, 80a6e90 <_ZN3UDP9setBufferEjPh+0x20>
        _buffer_size = buf_size;
 80a6e84:	6425      	str	r5, [r4, #64]	; 0x40
    return _buffer_size;
 80a6e86:	6c20      	ldr	r0, [r4, #64]	; 0x40
}
 80a6e88:	3800      	subs	r0, #0
 80a6e8a:	bf18      	it	ne
 80a6e8c:	2001      	movne	r0, #1
 80a6e8e:	bd70      	pop	{r4, r5, r6, pc}
    if (!_buffer && buf_size) {         // requested allocation
 80a6e90:	2d00      	cmp	r5, #0
 80a6e92:	d0f8      	beq.n	80a6e86 <_ZN3UDP9setBufferEjPh+0x16>
        _buffer = new uint8_t[buf_size];
 80a6e94:	4628      	mov	r0, r5
 80a6e96:	f7f9 f900 	bl	80a009a <_Znaj>
        _buffer_allocated = true;
 80a6e9a:	2301      	movs	r3, #1
        _buffer = new uint8_t[buf_size];
 80a6e9c:	63e0      	str	r0, [r4, #60]	; 0x3c
        _buffer_allocated = true;
 80a6e9e:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
    if (_buffer) {
 80a6ea2:	2800      	cmp	r0, #0
 80a6ea4:	d0ef      	beq.n	80a6e86 <_ZN3UDP9setBufferEjPh+0x16>
 80a6ea6:	e7ed      	b.n	80a6e84 <_ZN3UDP9setBufferEjPh+0x14>

080a6ea8 <_ZN3UDP11beginPacketE9IPAddresst>:
{
 80a6ea8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a6eaa:	4617      	mov	r7, r2
    if (!_buffer && _buffer_size) {
 80a6eac:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
{
 80a6eae:	4605      	mov	r5, r0
 80a6eb0:	460c      	mov	r4, r1
    if (!_buffer && _buffer_size) {
 80a6eb2:	b91a      	cbnz	r2, 80a6ebc <_ZN3UDP11beginPacketE9IPAddresst+0x14>
 80a6eb4:	6c01      	ldr	r1, [r0, #64]	; 0x40
 80a6eb6:	b109      	cbz	r1, 80a6ebc <_ZN3UDP11beginPacketE9IPAddresst+0x14>
        setBuffer(_buffer_size);
 80a6eb8:	f7ff ffda 	bl	80a6e70 <_ZN3UDP9setBufferEjPh>
 80a6ebc:	f105 0620 	add.w	r6, r5, #32
 80a6ec0:	3404      	adds	r4, #4
 80a6ec2:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80a6ec4:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 80a6ec6:	6823      	ldr	r3, [r4, #0]
 80a6ec8:	7033      	strb	r3, [r6, #0]
  _offset = 0;
 80a6eca:	2300      	movs	r3, #0
}
 80a6ecc:	6c28      	ldr	r0, [r5, #64]	; 0x40
    _remotePort = port;
 80a6ece:	86af      	strh	r7, [r5, #52]	; 0x34
  _offset = 0;
 80a6ed0:	86eb      	strh	r3, [r5, #54]	; 0x36
  _total = 0;
 80a6ed2:	872b      	strh	r3, [r5, #56]	; 0x38
}
 80a6ed4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a6ed6 <_ZN3UDP11parsePacketEm>:
{
 80a6ed6:	b570      	push	{r4, r5, r6, lr}
    if (!_buffer && _buffer_size) {
 80a6ed8:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
{
 80a6eda:	4604      	mov	r4, r0
 80a6edc:	460d      	mov	r5, r1
    if (!_buffer && _buffer_size) {
 80a6ede:	b91a      	cbnz	r2, 80a6ee8 <_ZN3UDP11parsePacketEm+0x12>
 80a6ee0:	6c01      	ldr	r1, [r0, #64]	; 0x40
 80a6ee2:	b109      	cbz	r1, 80a6ee8 <_ZN3UDP11parsePacketEm+0x12>
        setBuffer(_buffer_size);
 80a6ee4:	f7ff ffc4 	bl	80a6e70 <_ZN3UDP9setBufferEjPh>
  _offset = 0;
 80a6ee8:	2300      	movs	r3, #0
    if (_buffer && _buffer_size) {
 80a6eea:	6be1      	ldr	r1, [r4, #60]	; 0x3c
  _offset = 0;
 80a6eec:	86e3      	strh	r3, [r4, #54]	; 0x36
  _total = 0;
 80a6eee:	8723      	strh	r3, [r4, #56]	; 0x38
    if (_buffer && _buffer_size) {
 80a6ef0:	b149      	cbz	r1, 80a6f06 <_ZN3UDP11parsePacketEm+0x30>
 80a6ef2:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80a6ef4:	b13a      	cbz	r2, 80a6f06 <_ZN3UDP11parsePacketEm+0x30>
        int result = receivePacket(_buffer, _buffer_size, timeout);
 80a6ef6:	6823      	ldr	r3, [r4, #0]
 80a6ef8:	4620      	mov	r0, r4
 80a6efa:	6b1e      	ldr	r6, [r3, #48]	; 0x30
 80a6efc:	462b      	mov	r3, r5
 80a6efe:	47b0      	blx	r6
        if (result>0) {
 80a6f00:	2800      	cmp	r0, #0
            _total = result;
 80a6f02:	bfc8      	it	gt
 80a6f04:	8720      	strhgt	r0, [r4, #56]	; 0x38
    return available();
 80a6f06:	6823      	ldr	r3, [r4, #0]
 80a6f08:	4620      	mov	r0, r4
}
 80a6f0a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    return available();
 80a6f0e:	691b      	ldr	r3, [r3, #16]
 80a6f10:	4718      	bx	r3
	...

080a6f14 <_ZN3UDPD1Ev>:
    virtual ~UDP() { stop(); releaseBuffer(); }
 80a6f14:	b510      	push	{r4, lr}
 80a6f16:	4604      	mov	r4, r0
 80a6f18:	4b06      	ldr	r3, [pc, #24]	; (80a6f34 <_ZN3UDPD1Ev+0x20>)
 80a6f1a:	f103 0208 	add.w	r2, r3, #8
 80a6f1e:	336c      	adds	r3, #108	; 0x6c
 80a6f20:	6002      	str	r2, [r0, #0]
 80a6f22:	6103      	str	r3, [r0, #16]
 80a6f24:	f7ff fe52 	bl	80a6bcc <_ZN3UDP4stopEv>
 80a6f28:	4620      	mov	r0, r4
 80a6f2a:	f7ff ff8f 	bl	80a6e4c <_ZN3UDP13releaseBufferEv>
 80a6f2e:	4620      	mov	r0, r4
 80a6f30:	bd10      	pop	{r4, pc}
 80a6f32:	bf00      	nop
 80a6f34:	080aa5e4 	.word	0x080aa5e4

080a6f38 <_ZN3UDPD0Ev>:
 80a6f38:	b510      	push	{r4, lr}
 80a6f3a:	4604      	mov	r4, r0
 80a6f3c:	f7ff ffea 	bl	80a6f14 <_ZN3UDPD1Ev>
 80a6f40:	4620      	mov	r0, r4
 80a6f42:	214c      	movs	r1, #76	; 0x4c
 80a6f44:	f000 fb65 	bl	80a7612 <_ZdlPvj>
 80a6f48:	4620      	mov	r0, r4
 80a6f4a:	bd10      	pop	{r4, pc}

080a6f4c <_ZL22Refresh_UnixTime_Cachex>:
	return calendar_time;
}

/* Refresh Unix/RTC time cache */
static void Refresh_UnixTime_Cache(time_t unix_time)
{
 80a6f4c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    unix_time += time_zone_cache;
 80a6f50:	4a15      	ldr	r2, [pc, #84]	; (80a6fa8 <_ZL22Refresh_UnixTime_Cachex+0x5c>)
    unix_time += dst_current_cache;
    if(unix_time != unix_time_cache)
 80a6f52:	f8df 8060 	ldr.w	r8, [pc, #96]	; 80a6fb4 <_ZL22Refresh_UnixTime_Cachex+0x68>
    unix_time += time_zone_cache;
 80a6f56:	e9d2 3200 	ldrd	r3, r2, [r2]
 80a6f5a:	18c0      	adds	r0, r0, r3
 80a6f5c:	eb42 0101 	adc.w	r1, r2, r1
    unix_time += dst_current_cache;
 80a6f60:	4a12      	ldr	r2, [pc, #72]	; (80a6fac <_ZL22Refresh_UnixTime_Cachex+0x60>)
{
 80a6f62:	b08c      	sub	sp, #48	; 0x30
    unix_time += dst_current_cache;
 80a6f64:	e9d2 3200 	ldrd	r3, r2, [r2]
 80a6f68:	18c6      	adds	r6, r0, r3
 80a6f6a:	eb41 0702 	adc.w	r7, r1, r2
    if(unix_time != unix_time_cache)
 80a6f6e:	e9d8 2300 	ldrd	r2, r3, [r8]
 80a6f72:	42bb      	cmp	r3, r7
 80a6f74:	bf08      	it	eq
 80a6f76:	42b2      	cmpeq	r2, r6
 80a6f78:	d013      	beq.n	80a6fa2 <_ZL22Refresh_UnixTime_Cachex+0x56>
	localtime_r(&unix_time, &calendar_time);
 80a6f7a:	a903      	add	r1, sp, #12
 80a6f7c:	4668      	mov	r0, sp
 80a6f7e:	e9cd 6700 	strd	r6, r7, [sp]
 80a6f82:	f001 fbad 	bl	80a86e0 <localtime_r>
	calendar_time.tm_year += 1900;
 80a6f86:	9b08      	ldr	r3, [sp, #32]
    {
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
 80a6f88:	4d09      	ldr	r5, [pc, #36]	; (80a6fb0 <_ZL22Refresh_UnixTime_Cachex+0x64>)
	calendar_time.tm_year += 1900;
 80a6f8a:	f203 736c 	addw	r3, r3, #1900	; 0x76c
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
 80a6f8e:	ac03      	add	r4, sp, #12
	calendar_time.tm_year += 1900;
 80a6f90:	9308      	str	r3, [sp, #32]
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
 80a6f92:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80a6f94:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80a6f96:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80a6f98:	c50f      	stmia	r5!, {r0, r1, r2, r3}
            unix_time_cache = unix_time;
 80a6f9a:	e9c8 6700 	strd	r6, r7, [r8]
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
 80a6f9e:	6823      	ldr	r3, [r4, #0]
 80a6fa0:	602b      	str	r3, [r5, #0]
    }
}
 80a6fa2:	b00c      	add	sp, #48	; 0x30
 80a6fa4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a6fa8:	20000e48 	.word	0x20000e48
 80a6fac:	20000e40 	.word	0x20000e40
 80a6fb0:	20000e18 	.word	0x20000e18
 80a6fb4:	20000e50 	.word	0x20000e50

080a6fb8 <_ZN10CloudClass12syncTimeDoneEv.isra.0>:
    bool syncTimeDone(void)
 80a6fb8:	b508      	push	{r3, lr}
        return !spark_sync_time_pending(nullptr) || disconnected();
 80a6fba:	2000      	movs	r0, #0
 80a6fbc:	f7fe fcb0 	bl	80a5920 <spark_sync_time_pending>
 80a6fc0:	b128      	cbz	r0, 80a6fce <_ZN10CloudClass12syncTimeDoneEv.isra.0+0x16>
    static bool connected(void) { return spark_cloud_flag_connected(); }
 80a6fc2:	f7fe fc95 	bl	80a58f0 <spark_cloud_flag_connected>
        return !spark_sync_time_pending(nullptr) || disconnected();
 80a6fc6:	f080 0001 	eor.w	r0, r0, #1
 80a6fca:	b2c0      	uxtb	r0, r0
    }
 80a6fcc:	bd08      	pop	{r3, pc}
        return !spark_sync_time_pending(nullptr) || disconnected();
 80a6fce:	2001      	movs	r0, #1
 80a6fd0:	e7fc      	b.n	80a6fcc <_ZN10CloudClass12syncTimeDoneEv.isra.0+0x14>
	...

080a6fd4 <_ZN9TimeClass5monthEx>:
	return month(now());
}

/* the month for the given time */
int TimeClass::month(time_t t)
{
 80a6fd4:	b508      	push	{r3, lr}
	Refresh_UnixTime_Cache(t);
 80a6fd6:	f7ff ffb9 	bl	80a6f4c <_ZL22Refresh_UnixTime_Cachex>
	return (calendar_time_cache.tm_mon + 1);//Arduino's month representation
 80a6fda:	4b02      	ldr	r3, [pc, #8]	; (80a6fe4 <_ZN9TimeClass5monthEx+0x10>)
 80a6fdc:	6918      	ldr	r0, [r3, #16]
}
 80a6fde:	3001      	adds	r0, #1
 80a6fe0:	bd08      	pop	{r3, pc}
 80a6fe2:	bf00      	nop
 80a6fe4:	20000e18 	.word	0x20000e18

080a6fe8 <_ZN9TimeClass4zoneEf>:
	return now() + time_zone_cache + dst_current_cache;
}

/* set the time zone (+/-) offset from GMT */
void TimeClass::zone(float GMT_Offset)
{
 80a6fe8:	b510      	push	{r4, lr}
	if(GMT_Offset < -12 || GMT_Offset > 14)
 80a6fea:	490a      	ldr	r1, [pc, #40]	; (80a7014 <_ZN9TimeClass4zoneEf+0x2c>)
{
 80a6fec:	4604      	mov	r4, r0
	if(GMT_Offset < -12 || GMT_Offset > 14)
 80a6fee:	f001 f9b1 	bl	80a8354 <__aeabi_fcmplt>
 80a6ff2:	b968      	cbnz	r0, 80a7010 <_ZN9TimeClass4zoneEf+0x28>
 80a6ff4:	4620      	mov	r0, r4
 80a6ff6:	4908      	ldr	r1, [pc, #32]	; (80a7018 <_ZN9TimeClass4zoneEf+0x30>)
 80a6ff8:	f001 f9ca 	bl	80a8390 <__aeabi_fcmpgt>
 80a6ffc:	b940      	cbnz	r0, 80a7010 <_ZN9TimeClass4zoneEf+0x28>
	{
		return;
	}
	time_zone_cache = GMT_Offset * 3600;
 80a6ffe:	4907      	ldr	r1, [pc, #28]	; (80a701c <_ZN9TimeClass4zoneEf+0x34>)
 80a7000:	4620      	mov	r0, r4
 80a7002:	f001 f809 	bl	80a8018 <__aeabi_fmul>
 80a7006:	f001 f9cd 	bl	80a83a4 <__aeabi_f2lz>
 80a700a:	4b05      	ldr	r3, [pc, #20]	; (80a7020 <_ZN9TimeClass4zoneEf+0x38>)
 80a700c:	e9c3 0100 	strd	r0, r1, [r3]
}
 80a7010:	bd10      	pop	{r4, pc}
 80a7012:	bf00      	nop
 80a7014:	c1400000 	.word	0xc1400000
 80a7018:	41600000 	.word	0x41600000
 80a701c:	45610000 	.word	0x45610000
 80a7020:	20000e48 	.word	0x20000e48

080a7024 <_ZN9TimeClass7isValidEv>:
    strftime(buf, sizeof(buf), format_str, calendar_time);
    return String(buf);
}

bool TimeClass::isValid()
{
 80a7024:	b510      	push	{r4, lr}
    bool rtcstate = hal_rtc_time_is_valid(nullptr);
 80a7026:	2000      	movs	r0, #0
 80a7028:	f7fe fbe2 	bl	80a57f0 <hal_rtc_time_is_valid>
    if (rtcstate)
 80a702c:	4604      	mov	r4, r0
 80a702e:	b9a0      	cbnz	r0, 80a705a <_ZN9TimeClass7isValidEv+0x36>
    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
    }

    static System_Mode_TypeDef mode(void) {
        return system_mode();
 80a7030:	f7fe fce6 	bl	80a5a00 <system_mode>
        return rtcstate;
    if (System.mode() == AUTOMATIC && system_thread_get_state(nullptr) == spark::feature::DISABLED)
 80a7034:	2801      	cmp	r0, #1
 80a7036:	d110      	bne.n	80a705a <_ZN9TimeClass7isValidEv+0x36>
 80a7038:	4620      	mov	r0, r4
 80a703a:	f7fe fd09 	bl	80a5a50 <system_thread_get_state>
 80a703e:	b960      	cbnz	r0, 80a705a <_ZN9TimeClass7isValidEv+0x36>
    {
        waitUntil(Particle.syncTimeDone);
 80a7040:	f7ff ffba 	bl	80a6fb8 <_ZN10CloudClass12syncTimeDoneEv.isra.0>


    static uint32_t freeMemory();

    template<typename Condition, typename While> static bool waitConditionWhile(Condition _condition, While _while) {
        while (_while() && !_condition()) {
 80a7044:	b910      	cbnz	r0, 80a704c <_ZN9TimeClass7isValidEv+0x28>
            spark_process();
 80a7046:	f7fe fc43 	bl	80a58d0 <spark_process>
        while (_while() && !_condition()) {
 80a704a:	e7f9      	b.n	80a7040 <_ZN9TimeClass7isValidEv+0x1c>
 80a704c:	f7ff ffb4 	bl	80a6fb8 <_ZN10CloudClass12syncTimeDoneEv.isra.0>
        return hal_rtc_time_is_valid(nullptr);
    }
    return rtcstate;
}
 80a7050:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
        return hal_rtc_time_is_valid(nullptr);
 80a7054:	2000      	movs	r0, #0
 80a7056:	f7fe bbcb 	b.w	80a57f0 <hal_rtc_time_is_valid>
}
 80a705a:	4620      	mov	r0, r4
 80a705c:	bd10      	pop	{r4, pc}

080a705e <_ZN9TimeClass3nowEv>:
{
 80a705e:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    (void)isValid();
 80a7060:	f7ff ffe0 	bl	80a7024 <_ZN9TimeClass7isValidEv>
    struct timeval tv = {};
 80a7064:	2210      	movs	r2, #16
 80a7066:	2100      	movs	r1, #0
 80a7068:	4668      	mov	r0, sp
 80a706a:	f001 fc3d 	bl	80a88e8 <memset>
    hal_rtc_get_time(&tv, nullptr);
 80a706e:	2100      	movs	r1, #0
 80a7070:	4668      	mov	r0, sp
 80a7072:	f7fe fbc5 	bl	80a5800 <hal_rtc_get_time>
}
 80a7076:	9800      	ldr	r0, [sp, #0]
 80a7078:	b005      	add	sp, #20
 80a707a:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080a7080 <_ZN9TimeClass4hourEv>:
{
 80a7080:	b508      	push	{r3, lr}
	return hour(now());
 80a7082:	f7ff ffec 	bl	80a705e <_ZN9TimeClass3nowEv>
	Refresh_UnixTime_Cache(t);
 80a7086:	17c1      	asrs	r1, r0, #31
 80a7088:	f7ff ff60 	bl	80a6f4c <_ZL22Refresh_UnixTime_Cachex>
}
 80a708c:	4b01      	ldr	r3, [pc, #4]	; (80a7094 <_ZN9TimeClass4hourEv+0x14>)
 80a708e:	6898      	ldr	r0, [r3, #8]
 80a7090:	bd08      	pop	{r3, pc}
 80a7092:	bf00      	nop
 80a7094:	20000e18 	.word	0x20000e18

080a7098 <_ZN9TimeClass6minuteEv>:
{
 80a7098:	b508      	push	{r3, lr}
	return minute(now());
 80a709a:	f7ff ffe0 	bl	80a705e <_ZN9TimeClass3nowEv>
	Refresh_UnixTime_Cache(t);
 80a709e:	17c1      	asrs	r1, r0, #31
 80a70a0:	f7ff ff54 	bl	80a6f4c <_ZL22Refresh_UnixTime_Cachex>
}
 80a70a4:	4b01      	ldr	r3, [pc, #4]	; (80a70ac <_ZN9TimeClass6minuteEv+0x14>)
 80a70a6:	6858      	ldr	r0, [r3, #4]
 80a70a8:	bd08      	pop	{r3, pc}
 80a70aa:	bf00      	nop
 80a70ac:	20000e18 	.word	0x20000e18

080a70b0 <_ZN9TimeClass3dayEv>:
{
 80a70b0:	b508      	push	{r3, lr}
	return day(now());
 80a70b2:	f7ff ffd4 	bl	80a705e <_ZN9TimeClass3nowEv>
	Refresh_UnixTime_Cache(t);
 80a70b6:	17c1      	asrs	r1, r0, #31
 80a70b8:	f7ff ff48 	bl	80a6f4c <_ZL22Refresh_UnixTime_Cachex>
}
 80a70bc:	4b01      	ldr	r3, [pc, #4]	; (80a70c4 <_ZN9TimeClass3dayEv+0x14>)
 80a70be:	68d8      	ldr	r0, [r3, #12]
 80a70c0:	bd08      	pop	{r3, pc}
 80a70c2:	bf00      	nop
 80a70c4:	20000e18 	.word	0x20000e18

080a70c8 <_ZN9TimeClass5monthEv>:
{
 80a70c8:	b508      	push	{r3, lr}
	return month(now());
 80a70ca:	f7ff ffc8 	bl	80a705e <_ZN9TimeClass3nowEv>
}
 80a70ce:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	return month(now());
 80a70d2:	17c1      	asrs	r1, r0, #31
 80a70d4:	f7ff bf7e 	b.w	80a6fd4 <_ZN9TimeClass5monthEx>

080a70d8 <_ZN9TimeClass4yearEv>:
{
 80a70d8:	b508      	push	{r3, lr}
	return year(now());
 80a70da:	f7ff ffc0 	bl	80a705e <_ZN9TimeClass3nowEv>
	Refresh_UnixTime_Cache(t);
 80a70de:	17c1      	asrs	r1, r0, #31
 80a70e0:	f7ff ff34 	bl	80a6f4c <_ZL22Refresh_UnixTime_Cachex>
}
 80a70e4:	4b01      	ldr	r3, [pc, #4]	; (80a70ec <_ZN9TimeClass4yearEv+0x14>)
 80a70e6:	6958      	ldr	r0, [r3, #20]
 80a70e8:	bd08      	pop	{r3, pc}
 80a70ea:	bf00      	nop
 80a70ec:	20000e18 	.word	0x20000e18

080a70f0 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT>:
const char* TimeClass::format_spec = TIME_FORMAT_DEFAULT;
 80a70f0:	4b02      	ldr	r3, [pc, #8]	; (80a70fc <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0xc>)
 80a70f2:	681a      	ldr	r2, [r3, #0]
 80a70f4:	4b02      	ldr	r3, [pc, #8]	; (80a7100 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0x10>)
 80a70f6:	601a      	str	r2, [r3, #0]
{
  return isValid();
}


TimeClass Time;
 80a70f8:	4770      	bx	lr
 80a70fa:	bf00      	nop
 80a70fc:	20000004 	.word	0x20000004
 80a7100:	20000e14 	.word	0x20000e14

080a7104 <_GLOBAL__sub_I__ZN5spark3LogE>:
    // This handler doesn't support direct logging
}

// spark::Logger
inline spark::Logger::Logger(const char *name) :
        name_(name) {
 80a7104:	4b01      	ldr	r3, [pc, #4]	; (80a710c <_GLOBAL__sub_I__ZN5spark3LogE+0x8>)
 80a7106:	4a02      	ldr	r2, [pc, #8]	; (80a7110 <_GLOBAL__sub_I__ZN5spark3LogE+0xc>)
 80a7108:	601a      	str	r2, [r3, #0]
#if Wiring_LogConfig

// spark::
void spark::logProcessControlRequest(ctrl_request* req) {
    JSONRequestHandler::process(req);
}
 80a710a:	4770      	bx	lr
 80a710c:	20000e58 	.word	0x20000e58
 80a7110:	080aa670 	.word	0x080aa670

080a7114 <_ZN6Stream9timedReadEv>:
#define PARSE_TIMEOUT 1000  // default number of milli-seconds to wait
#define NO_SKIP_CHAR  1  // a magic char not found in a valid ASCII numeric field

// private method to read stream with timeout
int Stream::timedRead()
{
 80a7114:	b510      	push	{r4, lr}
 80a7116:	4604      	mov	r4, r0

#ifdef __cplusplus
extern "C" {
#endif

inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
 80a7118:	f7fe fb62 	bl	80a57e0 <HAL_Timer_Get_Milli_Seconds>
  int c;
  _startMillis = millis();
 80a711c:	60e0      	str	r0, [r4, #12]
  do {
    c = read();
 80a711e:	6823      	ldr	r3, [r4, #0]
 80a7120:	4620      	mov	r0, r4
 80a7122:	695b      	ldr	r3, [r3, #20]
 80a7124:	4798      	blx	r3
    if (c >= 0) return c;
 80a7126:	2800      	cmp	r0, #0
 80a7128:	da08      	bge.n	80a713c <_ZN6Stream9timedReadEv+0x28>
 80a712a:	f7fe fb59 	bl	80a57e0 <HAL_Timer_Get_Milli_Seconds>
  } while(millis() - _startMillis < _timeout);
 80a712e:	68e3      	ldr	r3, [r4, #12]
 80a7130:	1ac0      	subs	r0, r0, r3
 80a7132:	68a3      	ldr	r3, [r4, #8]
 80a7134:	4298      	cmp	r0, r3
 80a7136:	d3f2      	bcc.n	80a711e <_ZN6Stream9timedReadEv+0xa>
  return -1;     // -1 indicates timeout
 80a7138:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 80a713c:	bd10      	pop	{r4, pc}

080a713e <_ZN6Stream10setTimeoutEm>:
// Public Methods
//////////////////////////////////////////////////////////////

void Stream::setTimeout(system_tick_t timeout)  // sets the maximum number of milliseconds to wait
{
  _timeout = timeout;
 80a713e:	6081      	str	r1, [r0, #8]
}
 80a7140:	4770      	bx	lr

080a7142 <_ZN6Stream9readBytesEPcj>:
// terminates if length characters have been read, or timeout (see setTimeout)
// returns the number of characters placed in the buffer
// the buffer is NOT null terminated.
//
size_t Stream::readBytes(char *buffer, size_t length)
{
 80a7142:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a7144:	4606      	mov	r6, r0
 80a7146:	460d      	mov	r5, r1
 80a7148:	4617      	mov	r7, r2
  size_t count = 0;
 80a714a:	2400      	movs	r4, #0
  while (count < length) {
 80a714c:	42bc      	cmp	r4, r7
 80a714e:	d007      	beq.n	80a7160 <_ZN6Stream9readBytesEPcj+0x1e>
    int c = timedRead();
 80a7150:	4630      	mov	r0, r6
 80a7152:	f7ff ffdf 	bl	80a7114 <_ZN6Stream9timedReadEv>
    if (c < 0) break;
 80a7156:	1e03      	subs	r3, r0, #0
 80a7158:	db02      	blt.n	80a7160 <_ZN6Stream9readBytesEPcj+0x1e>
    *buffer++ = (char)c;
 80a715a:	552b      	strb	r3, [r5, r4]
    count++;
 80a715c:	3401      	adds	r4, #1
  while (count < length) {
 80a715e:	e7f5      	b.n	80a714c <_ZN6Stream9readBytesEPcj+0xa>
  }
  return count;
}
 80a7160:	4620      	mov	r0, r4
 80a7162:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a7164 <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 80a7164:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a7166:	4606      	mov	r6, r0
 80a7168:	460d      	mov	r5, r1
  size_t n = 0;
 80a716a:	2400      	movs	r4, #0
 80a716c:	188f      	adds	r7, r1, r2
  while (size--) {
 80a716e:	42bd      	cmp	r5, r7
 80a7170:	d00c      	beq.n	80a718c <_ZN5Print5writeEPKhj+0x28>
     int chunk = write(*buffer++);
 80a7172:	6833      	ldr	r3, [r6, #0]
 80a7174:	4630      	mov	r0, r6
 80a7176:	689b      	ldr	r3, [r3, #8]
 80a7178:	f815 1b01 	ldrb.w	r1, [r5], #1
 80a717c:	4798      	blx	r3
     if (chunk>=0)
 80a717e:	1e03      	subs	r3, r0, #0
 80a7180:	db01      	blt.n	80a7186 <_ZN5Print5writeEPKhj+0x22>
         n += chunk;
 80a7182:	441c      	add	r4, r3
  while (size--) {
 80a7184:	e7f3      	b.n	80a716e <_ZN5Print5writeEPKhj+0xa>
     int chunk = write(*buffer++);
 80a7186:	2c00      	cmp	r4, #0
 80a7188:	bf08      	it	eq
 80a718a:	461c      	moveq	r4, r3
             n = chunk;
         break;
     }
  }
  return n;
}
 80a718c:	4620      	mov	r0, r4
 80a718e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a7190 <_ZN5Print5writeEPKc>:
    size_t write(const char *str) {
 80a7190:	b570      	push	{r4, r5, r6, lr}
 80a7192:	4605      	mov	r5, r0
      if (str == NULL) return 0;
 80a7194:	460c      	mov	r4, r1
    }
 80a7196:	4608      	mov	r0, r1
      if (str == NULL) return 0;
 80a7198:	b149      	cbz	r1, 80a71ae <_ZN5Print5writeEPKc+0x1e>
      return write((const uint8_t *)str, strlen(str));
 80a719a:	f001 fc42 	bl	80a8a22 <strlen>
 80a719e:	682b      	ldr	r3, [r5, #0]
 80a71a0:	4602      	mov	r2, r0
 80a71a2:	4621      	mov	r1, r4
 80a71a4:	4628      	mov	r0, r5
    }
 80a71a6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      return write((const uint8_t *)str, strlen(str));
 80a71aa:	68db      	ldr	r3, [r3, #12]
 80a71ac:	4718      	bx	r3
    }
 80a71ae:	bd70      	pop	{r4, r5, r6, pc}

080a71b0 <_ZN5Print5printEPKc>:

size_t Print::print(const char str[])
{
 80a71b0:	b508      	push	{r3, lr}
  return write(str);
 80a71b2:	f7ff ffed 	bl	80a7190 <_ZN5Print5writeEPKc>
}
 80a71b6:	bd08      	pop	{r3, pc}

080a71b8 <_ZN5Print5printEc>:

size_t Print::print(char c)
{
  return write(c);
 80a71b8:	6803      	ldr	r3, [r0, #0]
 80a71ba:	689b      	ldr	r3, [r3, #8]
 80a71bc:	4718      	bx	r3

080a71be <_ZN5Print7printlnEv>:
{
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
 80a71be:	b538      	push	{r3, r4, r5, lr}
  size_t n = print('\r');
 80a71c0:	210d      	movs	r1, #13
{
 80a71c2:	4605      	mov	r5, r0
  size_t n = print('\r');
 80a71c4:	f7ff fff8 	bl	80a71b8 <_ZN5Print5printEc>
  n += print('\n');
 80a71c8:	210a      	movs	r1, #10
  size_t n = print('\r');
 80a71ca:	4604      	mov	r4, r0
  n += print('\n');
 80a71cc:	4628      	mov	r0, r5
 80a71ce:	f7ff fff3 	bl	80a71b8 <_ZN5Print5printEc>
  return n;
}
 80a71d2:	4420      	add	r0, r4
 80a71d4:	bd38      	pop	{r3, r4, r5, pc}

080a71d6 <_ZN5Print11printNumberEmh>:

size_t Print::printNumber(unsigned long n, uint8_t base) {
  char buf[8 * sizeof(n) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
 80a71d6:	2300      	movs	r3, #0

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
 80a71d8:	2a01      	cmp	r2, #1
 80a71da:	bf98      	it	ls
 80a71dc:	220a      	movls	r2, #10
size_t Print::printNumber(unsigned long n, uint8_t base) {
 80a71de:	b530      	push	{r4, r5, lr}
 80a71e0:	b08b      	sub	sp, #44	; 0x2c
 80a71e2:	460c      	mov	r4, r1
  *str = '\0';
 80a71e4:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
  if (base < 2) base = 10;
 80a71e8:	a909      	add	r1, sp, #36	; 0x24

  do {
   decltype(n) m = n;
   n /= base;
 80a71ea:	4625      	mov	r5, r4
 80a71ec:	fbb4 f4f2 	udiv	r4, r4, r2
   char c = m - base * n;
 80a71f0:	fb04 5312 	mls	r3, r4, r2, r5
 80a71f4:	b2db      	uxtb	r3, r3
   *--str = c < 10 ? c + '0' : c + 'A' - 10;
 80a71f6:	2b09      	cmp	r3, #9
 80a71f8:	bf94      	ite	ls
 80a71fa:	3330      	addls	r3, #48	; 0x30
 80a71fc:	3337      	addhi	r3, #55	; 0x37
 80a71fe:	b2db      	uxtb	r3, r3
  } while(n);
 80a7200:	42aa      	cmp	r2, r5
   *--str = c < 10 ? c + '0' : c + 'A' - 10;
 80a7202:	f801 3d01 	strb.w	r3, [r1, #-1]!
  } while(n);
 80a7206:	d9f0      	bls.n	80a71ea <_ZN5Print11printNumberEmh+0x14>

  return write(str);
 80a7208:	f7ff ffc2 	bl	80a7190 <_ZN5Print5writeEPKc>
}
 80a720c:	b00b      	add	sp, #44	; 0x2c
 80a720e:	bd30      	pop	{r4, r5, pc}

080a7210 <_ZN5Print7vprintfEbPKcSt9__va_list>:

  return n;
}

size_t Print::vprintf(bool newline, const char* format, va_list args)
{
 80a7210:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a7214:	b086      	sub	sp, #24
 80a7216:	af00      	add	r7, sp, #0
 80a7218:	4605      	mov	r5, r0
 80a721a:	460e      	mov	r6, r1
    const int bufsize = 20;
    char test[bufsize];
    va_list args2;
    va_copy(args2, args);
    size_t n = vsnprintf(test, bufsize, format, args);
 80a721c:	1d38      	adds	r0, r7, #4
 80a721e:	2114      	movs	r1, #20
{
 80a7220:	4614      	mov	r4, r2
    va_copy(args2, args);
 80a7222:	603b      	str	r3, [r7, #0]
    size_t n = vsnprintf(test, bufsize, format, args);
 80a7224:	f7fe fc5a 	bl	80a5adc <vsnprintf>

    if (n<bufsize)
 80a7228:	2813      	cmp	r0, #19
 80a722a:	d80e      	bhi.n	80a724a <_ZN5Print7vprintfEbPKcSt9__va_list+0x3a>
  return write(str);
 80a722c:	4628      	mov	r0, r5
 80a722e:	1d39      	adds	r1, r7, #4
 80a7230:	f7ff ffae 	bl	80a7190 <_ZN5Print5writeEPKc>
 80a7234:	4604      	mov	r4, r0
    {
        char bigger[n+1];
        n = vsnprintf(bigger, n+1, format, args2);
        n = print(bigger);
    }
    if (newline)
 80a7236:	b11e      	cbz	r6, 80a7240 <_ZN5Print7vprintfEbPKcSt9__va_list+0x30>
        n += println();
 80a7238:	4628      	mov	r0, r5
 80a723a:	f7ff ffc0 	bl	80a71be <_ZN5Print7printlnEv>
 80a723e:	4404      	add	r4, r0

    va_end(args2);
    return n;
}
 80a7240:	4620      	mov	r0, r4
 80a7242:	3718      	adds	r7, #24
 80a7244:	46bd      	mov	sp, r7
 80a7246:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        char bigger[n+1];
 80a724a:	f100 0308 	add.w	r3, r0, #8
 80a724e:	f023 0307 	bic.w	r3, r3, #7
        n = print(bigger);
 80a7252:	46e8      	mov	r8, sp
        char bigger[n+1];
 80a7254:	ebad 0d03 	sub.w	sp, sp, r3
        n = vsnprintf(bigger, n+1, format, args2);
 80a7258:	4622      	mov	r2, r4
 80a725a:	1c41      	adds	r1, r0, #1
 80a725c:	683b      	ldr	r3, [r7, #0]
 80a725e:	4668      	mov	r0, sp
 80a7260:	f7fe fc3c 	bl	80a5adc <vsnprintf>
  return write(str);
 80a7264:	4669      	mov	r1, sp
 80a7266:	4628      	mov	r0, r5
 80a7268:	f7ff ff92 	bl	80a7190 <_ZN5Print5writeEPKc>
 80a726c:	4604      	mov	r4, r0
 80a726e:	46c5      	mov	sp, r8
 80a7270:	e7e1      	b.n	80a7236 <_ZN5Print7vprintfEbPKcSt9__va_list+0x26>

080a7272 <_ZN6StringD1Ev>:
	init();
	char buf[33];
	dtoa(value, decimalPlaces, buf);
        *this = buf;
}
String::~String()
 80a7272:	b510      	push	{r4, lr}
 80a7274:	4604      	mov	r4, r0
{
	free(buffer);
 80a7276:	6800      	ldr	r0, [r0, #0]
 80a7278:	f7fe fc18 	bl	80a5aac <free>
}
 80a727c:	4620      	mov	r0, r4
 80a727e:	bd10      	pop	{r4, pc}

080a7280 <_ZN6String10invalidateEv>:
	len = 0;
	flags = 0;
}

void String::invalidate(void)
{
 80a7280:	b510      	push	{r4, lr}
 80a7282:	4604      	mov	r4, r0
	if (buffer) free(buffer);
 80a7284:	6800      	ldr	r0, [r0, #0]
 80a7286:	b108      	cbz	r0, 80a728c <_ZN6String10invalidateEv+0xc>
 80a7288:	f7fe fc10 	bl	80a5aac <free>
	buffer = NULL;
 80a728c:	2300      	movs	r3, #0
	capacity = len = 0;
 80a728e:	e9c4 3301 	strd	r3, r3, [r4, #4]
	buffer = NULL;
 80a7292:	6023      	str	r3, [r4, #0]
}
 80a7294:	bd10      	pop	{r4, pc}

080a7296 <_ZN6String12changeBufferEj>:
	}
	return 0;
}

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
 80a7296:	b538      	push	{r3, r4, r5, lr}
 80a7298:	4604      	mov	r4, r0
 80a729a:	460d      	mov	r5, r1
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
 80a729c:	6800      	ldr	r0, [r0, #0]
 80a729e:	3101      	adds	r1, #1
 80a72a0:	f7fe fc0c 	bl	80a5abc <realloc>
	if (newbuffer) {
 80a72a4:	b110      	cbz	r0, 80a72ac <_ZN6String12changeBufferEj+0x16>
		buffer = newbuffer;
		capacity = maxStrLen;
 80a72a6:	e9c4 0500 	strd	r0, r5, [r4]
		return 1;
 80a72aa:	2001      	movs	r0, #1
	}
	return 0;
}
 80a72ac:	bd38      	pop	{r3, r4, r5, pc}

080a72ae <_ZN6String7reserveEj>:
{
 80a72ae:	b510      	push	{r4, lr}
	if (buffer && capacity >= size) return 1;
 80a72b0:	6803      	ldr	r3, [r0, #0]
{
 80a72b2:	4604      	mov	r4, r0
	if (buffer && capacity >= size) return 1;
 80a72b4:	b123      	cbz	r3, 80a72c0 <_ZN6String7reserveEj+0x12>
 80a72b6:	6843      	ldr	r3, [r0, #4]
 80a72b8:	428b      	cmp	r3, r1
 80a72ba:	d301      	bcc.n	80a72c0 <_ZN6String7reserveEj+0x12>
 80a72bc:	2001      	movs	r0, #1
}
 80a72be:	bd10      	pop	{r4, pc}
	if (changeBuffer(size)) {
 80a72c0:	4620      	mov	r0, r4
 80a72c2:	f7ff ffe8 	bl	80a7296 <_ZN6String12changeBufferEj>
 80a72c6:	2800      	cmp	r0, #0
 80a72c8:	d0f9      	beq.n	80a72be <_ZN6String7reserveEj+0x10>
		if (len == 0) buffer[0] = 0;
 80a72ca:	68a3      	ldr	r3, [r4, #8]
 80a72cc:	2b00      	cmp	r3, #0
 80a72ce:	d1f5      	bne.n	80a72bc <_ZN6String7reserveEj+0xe>
 80a72d0:	6822      	ldr	r2, [r4, #0]
 80a72d2:	7013      	strb	r3, [r2, #0]
 80a72d4:	e7f2      	b.n	80a72bc <_ZN6String7reserveEj+0xe>

080a72d6 <_ZN6String4copyEPKcj>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
 80a72d6:	b570      	push	{r4, r5, r6, lr}
 80a72d8:	460e      	mov	r6, r1
	if (!reserve(length)) {
 80a72da:	4611      	mov	r1, r2
{
 80a72dc:	4604      	mov	r4, r0
 80a72de:	4615      	mov	r5, r2
	if (!reserve(length)) {
 80a72e0:	f7ff ffe5 	bl	80a72ae <_ZN6String7reserveEj>
 80a72e4:	b920      	cbnz	r0, 80a72f0 <_ZN6String4copyEPKcj+0x1a>
		invalidate();
 80a72e6:	4620      	mov	r0, r4
 80a72e8:	f7ff ffca 	bl	80a7280 <_ZN6String10invalidateEv>
	}
	len = length;
	memcpy(buffer, cstr, length);
	buffer[len] = 0;
	return *this;
}
 80a72ec:	4620      	mov	r0, r4
 80a72ee:	bd70      	pop	{r4, r5, r6, pc}
	memcpy(buffer, cstr, length);
 80a72f0:	462a      	mov	r2, r5
 80a72f2:	4631      	mov	r1, r6
 80a72f4:	6820      	ldr	r0, [r4, #0]
	len = length;
 80a72f6:	60a5      	str	r5, [r4, #8]
	memcpy(buffer, cstr, length);
 80a72f8:	f001 fae8 	bl	80a88cc <memcpy>
	buffer[len] = 0;
 80a72fc:	2100      	movs	r1, #0
 80a72fe:	6822      	ldr	r2, [r4, #0]
 80a7300:	68a3      	ldr	r3, [r4, #8]
 80a7302:	54d1      	strb	r1, [r2, r3]
	return *this;
 80a7304:	e7f2      	b.n	80a72ec <_ZN6String4copyEPKcj+0x16>

080a7306 <_ZN6StringC1EPKc>:
String::String(const char *cstr)
 80a7306:	b538      	push	{r3, r4, r5, lr}
	buffer = NULL;
 80a7308:	2300      	movs	r3, #0
String::String(const char *cstr)
 80a730a:	4604      	mov	r4, r0
	if (cstr) copy(cstr, strlen(cstr));
 80a730c:	460d      	mov	r5, r1
	capacity = 0;
 80a730e:	e9c0 3300 	strd	r3, r3, [r0]
	len = 0;
 80a7312:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a7314:	7303      	strb	r3, [r0, #12]
	if (cstr) copy(cstr, strlen(cstr));
 80a7316:	b139      	cbz	r1, 80a7328 <_ZN6StringC1EPKc+0x22>
 80a7318:	4608      	mov	r0, r1
 80a731a:	f001 fb82 	bl	80a8a22 <strlen>
 80a731e:	4629      	mov	r1, r5
 80a7320:	4602      	mov	r2, r0
 80a7322:	4620      	mov	r0, r4
 80a7324:	f7ff ffd7 	bl	80a72d6 <_ZN6String4copyEPKcj>
}
 80a7328:	4620      	mov	r0, r4
 80a732a:	bd38      	pop	{r3, r4, r5, pc}

080a732c <_ZN6StringaSERKS_>:
}
#endif

String & String::operator = (const String &rhs)
{
	if (this == &rhs) return *this;
 80a732c:	4288      	cmp	r0, r1
{
 80a732e:	b510      	push	{r4, lr}
 80a7330:	460b      	mov	r3, r1
 80a7332:	4604      	mov	r4, r0
	if (this == &rhs) return *this;
 80a7334:	d004      	beq.n	80a7340 <_ZN6StringaSERKS_+0x14>

	if (rhs.buffer) copy(rhs.buffer, rhs.len);
 80a7336:	6809      	ldr	r1, [r1, #0]
 80a7338:	b121      	cbz	r1, 80a7344 <_ZN6StringaSERKS_+0x18>
 80a733a:	689a      	ldr	r2, [r3, #8]
 80a733c:	f7ff ffcb 	bl	80a72d6 <_ZN6String4copyEPKcj>
	else invalidate();

	return *this;
}
 80a7340:	4620      	mov	r0, r4
 80a7342:	bd10      	pop	{r4, pc}
	else invalidate();
 80a7344:	f7ff ff9c 	bl	80a7280 <_ZN6String10invalidateEv>
 80a7348:	e7fa      	b.n	80a7340 <_ZN6StringaSERKS_+0x14>

080a734a <_ZN6StringC1ERKS_>:
	buffer = NULL;
 80a734a:	2300      	movs	r3, #0
String::String(const String &value)
 80a734c:	b510      	push	{r4, lr}
 80a734e:	4604      	mov	r4, r0
	capacity = 0;
 80a7350:	e9c0 3300 	strd	r3, r3, [r0]
	len = 0;
 80a7354:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a7356:	7303      	strb	r3, [r0, #12]
	*this = value;
 80a7358:	f7ff ffe8 	bl	80a732c <_ZN6StringaSERKS_>
}
 80a735c:	4620      	mov	r0, r4
 80a735e:	bd10      	pop	{r4, pc}

080a7360 <_ZNK6String6equalsEPKc>:
{
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
 80a7360:	b508      	push	{r3, lr}
	if (len == 0) return (cstr == NULL || *cstr == 0);
 80a7362:	6882      	ldr	r2, [r0, #8]
 80a7364:	b93a      	cbnz	r2, 80a7376 <_ZNK6String6equalsEPKc+0x16>
 80a7366:	b121      	cbz	r1, 80a7372 <_ZNK6String6equalsEPKc+0x12>
 80a7368:	7808      	ldrb	r0, [r1, #0]
	if (cstr == NULL) return buffer[0] == 0;
	return strcmp(buffer, cstr) == 0;
 80a736a:	fab0 f080 	clz	r0, r0
 80a736e:	0940      	lsrs	r0, r0, #5
 80a7370:	e000      	b.n	80a7374 <_ZNK6String6equalsEPKc+0x14>
	if (len == 0) return (cstr == NULL || *cstr == 0);
 80a7372:	2001      	movs	r0, #1
}
 80a7374:	bd08      	pop	{r3, pc}
	if (cstr == NULL) return buffer[0] == 0;
 80a7376:	6800      	ldr	r0, [r0, #0]
 80a7378:	b909      	cbnz	r1, 80a737e <_ZNK6String6equalsEPKc+0x1e>
 80a737a:	7800      	ldrb	r0, [r0, #0]
 80a737c:	e7f5      	b.n	80a736a <_ZNK6String6equalsEPKc+0xa>
	return strcmp(buffer, cstr) == 0;
 80a737e:	f001 fb22 	bl	80a89c6 <strcmp>
 80a7382:	e7f2      	b.n	80a736a <_ZNK6String6equalsEPKc+0xa>

080a7384 <_ZN6StringixEj>:
}

char & String::operator[](unsigned int index)
{
	static char dummy_writable_char;
	if (index >= len || !buffer) {
 80a7384:	6883      	ldr	r3, [r0, #8]
 80a7386:	428b      	cmp	r3, r1
 80a7388:	d901      	bls.n	80a738e <_ZN6StringixEj+0xa>
 80a738a:	6800      	ldr	r0, [r0, #0]
 80a738c:	b918      	cbnz	r0, 80a7396 <_ZN6StringixEj+0x12>
		dummy_writable_char = 0;
 80a738e:	2300      	movs	r3, #0
 80a7390:	4802      	ldr	r0, [pc, #8]	; (80a739c <_ZN6StringixEj+0x18>)
 80a7392:	7003      	strb	r3, [r0, #0]
		return dummy_writable_char;
 80a7394:	4770      	bx	lr
	}
	return buffer[index];
 80a7396:	4408      	add	r0, r1
}
 80a7398:	4770      	bx	lr
 80a739a:	bf00      	nop
 80a739c:	20000e5c 	.word	0x20000e5c

080a73a0 <_Z11str_reversePc>:

//------------------------------------------------------------------------------------------
#define BUFSIZE (sizeof(long) * 8 + 1)

//utility function used by ultoa()
__attribute__((weak)) void str_reverse(char* buffer){
 80a73a0:	b510      	push	{r4, lr}
 80a73a2:	4604      	mov	r4, r0
	char *i, *j;
	char c;
	i=buffer;
	j=buffer + strlen(buffer)-1;
 80a73a4:	f001 fb3d 	bl	80a8a22 <strlen>
 80a73a8:	1e43      	subs	r3, r0, #1
 80a73aa:	4620      	mov	r0, r4
 80a73ac:	4423      	add	r3, r4
	while(i<j){
 80a73ae:	4283      	cmp	r3, r0
 80a73b0:	d906      	bls.n	80a73c0 <_Z11str_reversePc+0x20>
		c = *i;
 80a73b2:	7802      	ldrb	r2, [r0, #0]
		*i = *j;
 80a73b4:	7819      	ldrb	r1, [r3, #0]
 80a73b6:	f800 1b01 	strb.w	r1, [r0], #1
		*j = c;
 80a73ba:	f803 2901 	strb.w	r2, [r3], #-1
	while(i<j){
 80a73be:	e7f6      	b.n	80a73ae <_Z11str_reversePc+0xe>
		++i;
		--j;
	}
}
 80a73c0:	bd10      	pop	{r4, pc}

080a73c2 <ultoa>:
      memcpy(head, ++tail, i);
      return str;
}

//convert unsigned long to string
__attribute__((weak)) char* ultoa(unsigned long a, char* buffer, int radix, char pad){
 80a73c2:	b570      	push	{r4, r5, r6, lr}
 80a73c4:	460c      	mov	r4, r1
	if(radix<2 || radix>36){
 80a73c6:	1e91      	subs	r1, r2, #2
 80a73c8:	2922      	cmp	r1, #34	; 0x22
 80a73ca:	d822      	bhi.n	80a7412 <ultoa+0x50>
		return NULL;
	}
	char* ptr=buffer;
 80a73cc:	4625      	mov	r5, r4

	div_t result;
	while(a){
 80a73ce:	b168      	cbz	r0, 80a73ec <ultoa+0x2a>
            /* toolchain bug??
            result = div(a, radix);
            */
            result.quot = a/radix;
 80a73d0:	fbb0 f6f2 	udiv	r6, r0, r2
            result.rem = a%radix;
 80a73d4:	fb02 0016 	mls	r0, r2, r6, r0
            *ptr = result.rem;
 80a73d8:	b2c1      	uxtb	r1, r0
            if(result.rem<10){
 80a73da:	2809      	cmp	r0, #9
                *ptr += '0';
 80a73dc:	bf94      	ite	ls
 80a73de:	3130      	addls	r1, #48	; 0x30
            }else{
                *ptr += 'a'-10;
 80a73e0:	3157      	addhi	r1, #87	; 0x57
 80a73e2:	b2c9      	uxtb	r1, r1
            }
            ++ptr;
            a = result.quot;
 80a73e4:	4630      	mov	r0, r6
 80a73e6:	f805 1b01 	strb.w	r1, [r5], #1
	while(a){
 80a73ea:	e7f0      	b.n	80a73ce <ultoa+0xc>
 80a73ec:	462a      	mov	r2, r5
	}
        while (ptr < buffer+pad)
            *ptr++ = '0';
 80a73ee:	2130      	movs	r1, #48	; 0x30
        while (ptr < buffer+pad)
 80a73f0:	4423      	add	r3, r4
 80a73f2:	4293      	cmp	r3, r2
 80a73f4:	d902      	bls.n	80a73fc <ultoa+0x3a>
            *ptr++ = '0';
 80a73f6:	f802 1b01 	strb.w	r1, [r2], #1
        while (ptr < buffer+pad)
 80a73fa:	e7fa      	b.n	80a73f2 <ultoa+0x30>
 80a73fc:	1b5a      	subs	r2, r3, r5
 80a73fe:	42ab      	cmp	r3, r5
 80a7400:	bf38      	it	cc
 80a7402:	2200      	movcc	r2, #0

	*ptr = '\0';
 80a7404:	2300      	movs	r3, #0
	str_reverse(buffer);
 80a7406:	4620      	mov	r0, r4
	*ptr = '\0';
 80a7408:	54ab      	strb	r3, [r5, r2]
	str_reverse(buffer);
 80a740a:	f7ff ffc9 	bl	80a73a0 <_Z11str_reversePc>
	return buffer;
 80a740e:	4620      	mov	r0, r4
}
 80a7410:	bd70      	pop	{r4, r5, r6, pc}
		return NULL;
 80a7412:	2000      	movs	r0, #0
 80a7414:	e7fc      	b.n	80a7410 <ultoa+0x4e>

080a7416 <utoa>:
		ultoa(a, buffer, radix);
	}
	return buffer;
}

__attribute__((weak)) char* utoa(unsigned a, char* buffer, int radix) {
 80a7416:	b508      	push	{r3, lr}
    return ultoa(a, buffer, radix);
 80a7418:	2301      	movs	r3, #1
 80a741a:	f7ff ffd2 	bl	80a73c2 <ultoa>
}
 80a741e:	bd08      	pop	{r3, pc}

080a7420 <_ZN11SystemClass5resetEmN8particle5FlagsI19SystemResetFlagTypemEE>:
{
    reset(0, flags);
}

void SystemClass::reset(uint32_t data, SystemResetFlags flags)
{
 80a7420:	b507      	push	{r0, r1, r2, lr}
 80a7422:	460b      	mov	r3, r1
    system_reset(SYSTEM_RESET_MODE_NORMAL, RESET_REASON_USER, data, flags.value(), nullptr);
 80a7424:	2100      	movs	r1, #0
{
 80a7426:	4602      	mov	r2, r0
    system_reset(SYSTEM_RESET_MODE_NORMAL, RESET_REASON_USER, data, flags.value(), nullptr);
 80a7428:	9100      	str	r1, [sp, #0]
 80a742a:	2001      	movs	r0, #1
 80a742c:	218c      	movs	r1, #140	; 0x8c
 80a742e:	f7fe fb2b 	bl	80a5a88 <system_reset>
}
 80a7432:	b003      	add	sp, #12
 80a7434:	f85d fb04 	ldr.w	pc, [sp], #4

080a7438 <_ZN11SystemClass5resetEN8particle5FlagsI19SystemResetFlagTypemEE>:
{
 80a7438:	4601      	mov	r1, r0
    reset(0, flags);
 80a743a:	2000      	movs	r0, #0
 80a743c:	f7ff bff0 	b.w	80a7420 <_ZN11SystemClass5resetEmN8particle5FlagsI19SystemResetFlagTypemEE>

080a7440 <_ZN11SystemClass5resetEv>:
    reset(SystemResetFlags());
 80a7440:	2000      	movs	r0, #0
 80a7442:	f7ff bff9 	b.w	80a7438 <_ZN11SystemClass5resetEN8particle5FlagsI19SystemResetFlagTypemEE>
	...

080a7448 <_GLOBAL__sub_I_System>:
} // namespace particle

// particle::Flag<TagT, ValueT>
template<typename TagT, typename ValueT>
inline particle::Flag<TagT, ValueT>::Flag(ValueT val) :
        val_(val) {
 80a7448:	2202      	movs	r2, #2
              error_(SYSTEM_ERROR_NONE) {
 80a744a:	2000      	movs	r0, #0
 80a744c:	4b04      	ldr	r3, [pc, #16]	; (80a7460 <_GLOBAL__sub_I_System+0x18>)
 80a744e:	601a      	str	r2, [r3, #0]
 80a7450:	4b04      	ldr	r3, [pc, #16]	; (80a7464 <_GLOBAL__sub_I_System+0x1c>)
    SleepResult() {}
 80a7452:	4a05      	ldr	r2, [pc, #20]	; (80a7468 <_GLOBAL__sub_I_System+0x20>)
              error_(SYSTEM_ERROR_NONE) {
 80a7454:	6018      	str	r0, [r3, #0]
 80a7456:	8098      	strh	r0, [r3, #4]
    SleepResult() {}
 80a7458:	7198      	strb	r0, [r3, #6]
 80a745a:	609a      	str	r2, [r3, #8]
        set_system_mode(mode);
 80a745c:	f7fe bad8 	b.w	80a5a10 <set_system_mode>
 80a7460:	20000e6c 	.word	0x20000e6c
 80a7464:	20000e60 	.word	0x20000e60
 80a7468:	ffff0000 	.word	0xffff0000

080a746c <__tcf_0>:
}
#endif

TwoWire& __fetch_global_Wire()
{
	static TwoWire wire(HAL_I2C_INTERFACE1, acquireWireBuffer());
 80a746c:	4770      	bx	lr
	...

080a7470 <_Z17acquireWireBufferv>:
	hal_i2c_config_t config = {
 80a7470:	2300      	movs	r3, #0
{
 80a7472:	b570      	push	{r4, r5, r6, lr}
	hal_i2c_config_t config = {
 80a7474:	2520      	movs	r5, #32
 80a7476:	8043      	strh	r3, [r0, #2]
 80a7478:	2314      	movs	r3, #20
		.rx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
 80a747a:	4e08      	ldr	r6, [pc, #32]	; (80a749c <_Z17acquireWireBufferv+0x2c>)
{
 80a747c:	4604      	mov	r4, r0
	hal_i2c_config_t config = {
 80a747e:	8003      	strh	r3, [r0, #0]
		.rx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
 80a7480:	4631      	mov	r1, r6
	hal_i2c_config_t config = {
 80a7482:	6085      	str	r5, [r0, #8]
 80a7484:	6105      	str	r5, [r0, #16]
		.rx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
 80a7486:	4628      	mov	r0, r5
 80a7488:	f000 f8c5 	bl	80a7616 <_ZnajRKSt9nothrow_t>
		.tx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
 80a748c:	4631      	mov	r1, r6
	};
 80a748e:	6060      	str	r0, [r4, #4]
		.tx_buffer = new (std::nothrow) uint8_t[I2C_BUFFER_LENGTH],
 80a7490:	4628      	mov	r0, r5
 80a7492:	f000 f8c0 	bl	80a7616 <_ZnajRKSt9nothrow_t>
	};
 80a7496:	60e0      	str	r0, [r4, #12]
}
 80a7498:	4620      	mov	r0, r4
 80a749a:	bd70      	pop	{r4, r5, r6, pc}
 80a749c:	080aa674 	.word	0x080aa674

080a74a0 <_Z19__fetch_global_Wirev>:
{
 80a74a0:	b530      	push	{r4, r5, lr}
	static TwoWire wire(HAL_I2C_INTERFACE1, acquireWireBuffer());
 80a74a2:	4d0e      	ldr	r5, [pc, #56]	; (80a74dc <_Z19__fetch_global_Wirev+0x3c>)
{
 80a74a4:	b087      	sub	sp, #28
	static TwoWire wire(HAL_I2C_INTERFACE1, acquireWireBuffer());
 80a74a6:	7829      	ldrb	r1, [r5, #0]
 80a74a8:	f3bf 8f5b 	dmb	ish
 80a74ac:	f011 0401 	ands.w	r4, r1, #1
 80a74b0:	d111      	bne.n	80a74d6 <_Z19__fetch_global_Wirev+0x36>
 80a74b2:	4628      	mov	r0, r5
 80a74b4:	f7f8 fe00 	bl	80a00b8 <__cxa_guard_acquire>
 80a74b8:	b168      	cbz	r0, 80a74d6 <_Z19__fetch_global_Wirev+0x36>
 80a74ba:	a801      	add	r0, sp, #4
 80a74bc:	f7ff ffd8 	bl	80a7470 <_Z17acquireWireBufferv>
 80a74c0:	4621      	mov	r1, r4
 80a74c2:	aa01      	add	r2, sp, #4
 80a74c4:	4806      	ldr	r0, [pc, #24]	; (80a74e0 <_Z19__fetch_global_Wirev+0x40>)
 80a74c6:	f7fe fe03 	bl	80a60d0 <_ZN7TwoWireC1E19hal_i2c_interface_tRK16hal_i2c_config_t>
 80a74ca:	4628      	mov	r0, r5
 80a74cc:	f7f8 fdf9 	bl	80a00c2 <__cxa_guard_release>
 80a74d0:	4804      	ldr	r0, [pc, #16]	; (80a74e4 <_Z19__fetch_global_Wirev+0x44>)
 80a74d2:	f001 f8ff 	bl	80a86d4 <atexit>
	return wire;
}
 80a74d6:	4802      	ldr	r0, [pc, #8]	; (80a74e0 <_Z19__fetch_global_Wirev+0x40>)
 80a74d8:	b007      	add	sp, #28
 80a74da:	bd30      	pop	{r4, r5, pc}
 80a74dc:	20000e70 	.word	0x20000e70
 80a74e0:	20000e74 	.word	0x20000e74
 80a74e4:	080a746d 	.word	0x080a746d

080a74e8 <_GLOBAL__sub_I_INADDR_NONE>:
#include "spark_wiring_ipaddress.h"

#if !HAL_USE_SOCKET_HAL_POSIX
const IPAddress INADDR_NONE(0, 0, 0, 0);
 80a74e8:	2300      	movs	r3, #0
 80a74ea:	b507      	push	{r0, r1, r2, lr}
 80a74ec:	461a      	mov	r2, r3
 80a74ee:	4619      	mov	r1, r3
 80a74f0:	9300      	str	r3, [sp, #0]
 80a74f2:	4803      	ldr	r0, [pc, #12]	; (80a7500 <_GLOBAL__sub_I_INADDR_NONE+0x18>)
 80a74f4:	f7fe ff40 	bl	80a6378 <_ZN9IPAddressC1Ehhhh>
 80a74f8:	b003      	add	sp, #12
 80a74fa:	f85d fb04 	ldr.w	pc, [sp], #4
 80a74fe:	bf00      	nop
 80a7500:	20000e88 	.word	0x20000e88

080a7504 <__tcf_0>:
        dispose();
    }

    void dispose()
    {
        if (handle_) {
 80a7504:	4b02      	ldr	r3, [pc, #8]	; (80a7510 <__tcf_0+0xc>)
 80a7506:	6898      	ldr	r0, [r3, #8]
 80a7508:	b108      	cbz	r0, 80a750e <__tcf_0+0xa>
            os_mutex_recursive_destroy(handle_);
 80a750a:	f7fe b931 	b.w	80a5770 <os_mutex_recursive_destroy>

template <hal_spi_interface_t Interface>
class SpiProxy {
public:
    static SPIClass& instance() {
        static SPIClass instance(Interface);
 80a750e:	4770      	bx	lr
 80a7510:	20000d84 	.word	0x20000d84

080a7514 <pinAvailable>:
/*
 * @brief Perform safety check on desired pin to see if it's already
 * being used.  Return 0 if used, otherwise return 1 if available.
 */
bool pinAvailable(uint16_t pin) {
  if (pin >= TOTAL_PINS) {
 80a7514:	2817      	cmp	r0, #23
bool pinAvailable(uint16_t pin) {
 80a7516:	b570      	push	{r4, r5, r6, lr}
 80a7518:	4604      	mov	r4, r0
  if (pin >= TOTAL_PINS) {
 80a751a:	d901      	bls.n	80a7520 <pinAvailable+0xc>
    return false;
 80a751c:	2000      	movs	r0, #0
    return false; // 'pin' is used
  }
#endif

  return true; // 'pin' is available
}
 80a751e:	bd70      	pop	{r4, r5, r6, pc}
  if((pin == SCK || pin == MOSI || pin == MISO) && hal_spi_is_enabled(SPI.interface()) == true)
 80a7520:	f1a0 030d 	sub.w	r3, r0, #13
 80a7524:	2b02      	cmp	r3, #2
 80a7526:	d90b      	bls.n	80a7540 <pinAvailable+0x2c>
  if((pin == SCL || pin == SDA) && hal_i2c_is_enabled(Wire.interface(), nullptr) == true)
 80a7528:	2801      	cmp	r0, #1
 80a752a:	d824      	bhi.n	80a7576 <pinAvailable+0x62>
 80a752c:	f7ff ffb8 	bl	80a74a0 <_Z19__fetch_global_Wirev>
 80a7530:	2100      	movs	r1, #0
 80a7532:	7c00      	ldrb	r0, [r0, #16]
 80a7534:	f7fe f878 	bl	80a5628 <hal_i2c_is_enabled>
  if((pin == RX || pin == TX) && hal_usart_is_enabled(Serial1.interface()) == true)
 80a7538:	f080 0001 	eor.w	r0, r0, #1
 80a753c:	b2c0      	uxtb	r0, r0
 80a753e:	e7ee      	b.n	80a751e <pinAvailable+0xa>
 80a7540:	4e12      	ldr	r6, [pc, #72]	; (80a758c <pinAvailable+0x78>)
 80a7542:	7831      	ldrb	r1, [r6, #0]
 80a7544:	f3bf 8f5b 	dmb	ish
 80a7548:	f011 0501 	ands.w	r5, r1, #1
 80a754c:	d10d      	bne.n	80a756a <pinAvailable+0x56>
 80a754e:	4630      	mov	r0, r6
 80a7550:	f7f8 fdb2 	bl	80a00b8 <__cxa_guard_acquire>
 80a7554:	b148      	cbz	r0, 80a756a <pinAvailable+0x56>
 80a7556:	4629      	mov	r1, r5
 80a7558:	480d      	ldr	r0, [pc, #52]	; (80a7590 <pinAvailable+0x7c>)
 80a755a:	f7fe fb5c 	bl	80a5c16 <_ZN8SPIClassC1E19hal_spi_interface_t>
 80a755e:	4630      	mov	r0, r6
 80a7560:	f7f8 fdaf 	bl	80a00c2 <__cxa_guard_release>
 80a7564:	480b      	ldr	r0, [pc, #44]	; (80a7594 <pinAvailable+0x80>)
 80a7566:	f001 f8b5 	bl	80a86d4 <atexit>
  if((pin == SCK || pin == MOSI || pin == MISO) && hal_spi_is_enabled(SPI.interface()) == true)
 80a756a:	4b09      	ldr	r3, [pc, #36]	; (80a7590 <pinAvailable+0x7c>)
 80a756c:	7818      	ldrb	r0, [r3, #0]
 80a756e:	f7fd ffd3 	bl	80a5518 <hal_spi_is_enabled>
 80a7572:	2800      	cmp	r0, #0
 80a7574:	d1d2      	bne.n	80a751c <pinAvailable+0x8>
  if((pin == RX || pin == TX) && hal_usart_is_enabled(Serial1.interface()) == true)
 80a7576:	3c12      	subs	r4, #18
 80a7578:	2c01      	cmp	r4, #1
 80a757a:	d805      	bhi.n	80a7588 <pinAvailable+0x74>
 80a757c:	f7fe fd3e 	bl	80a5ffc <_Z22__fetch_global_Serial1v>
 80a7580:	7c00      	ldrb	r0, [r0, #16]
 80a7582:	f7fe f8a5 	bl	80a56d0 <hal_usart_is_enabled>
 80a7586:	e7d7      	b.n	80a7538 <pinAvailable+0x24>
  return true; // 'pin' is available
 80a7588:	2001      	movs	r0, #1
 80a758a:	e7c8      	b.n	80a751e <pinAvailable+0xa>
 80a758c:	20000d80 	.word	0x20000d80
 80a7590:	20000d84 	.word	0x20000d84
 80a7594:	080a7505 	.word	0x080a7505

080a7598 <pinMode>:
  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a7598:	2817      	cmp	r0, #23
{
 80a759a:	b538      	push	{r3, r4, r5, lr}
 80a759c:	4604      	mov	r4, r0
 80a759e:	460d      	mov	r5, r1
  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a75a0:	d80a      	bhi.n	80a75b8 <pinMode+0x20>
 80a75a2:	29ff      	cmp	r1, #255	; 0xff
 80a75a4:	d008      	beq.n	80a75b8 <pinMode+0x20>
  if( !pinAvailable(pin) ) {
 80a75a6:	f7ff ffb5 	bl	80a7514 <pinAvailable>
 80a75aa:	b128      	cbz	r0, 80a75b8 <pinMode+0x20>
  HAL_Pin_Mode(pin, setMode);
 80a75ac:	4629      	mov	r1, r5
 80a75ae:	4620      	mov	r0, r4
}
 80a75b0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  HAL_Pin_Mode(pin, setMode);
 80a75b4:	f7fe b934 	b.w	80a5820 <HAL_Pin_Mode>
}
 80a75b8:	bd38      	pop	{r3, r4, r5, pc}

080a75ba <digitalWrite>:

/*
 * @brief Sets a GPIO pin to HIGH or LOW.
 */
void digitalWrite(pin_t pin, uint8_t value)
{
 80a75ba:	b538      	push	{r3, r4, r5, lr}
 80a75bc:	4604      	mov	r4, r0
 80a75be:	460d      	mov	r5, r1
    PinMode mode = HAL_Get_Pin_Mode(pin);
 80a75c0:	f7fe f936 	bl	80a5830 <HAL_Get_Pin_Mode>
    if (mode==PIN_MODE_NONE || is_input_mode(mode))
 80a75c4:	28ff      	cmp	r0, #255	; 0xff
 80a75c6:	d010      	beq.n	80a75ea <digitalWrite+0x30>
            mode == INPUT_PULLDOWN ||
 80a75c8:	2806      	cmp	r0, #6
 80a75ca:	d804      	bhi.n	80a75d6 <digitalWrite+0x1c>
 80a75cc:	234d      	movs	r3, #77	; 0x4d
 80a75ce:	fa23 f000 	lsr.w	r0, r3, r0
 80a75d2:	07c3      	lsls	r3, r0, #31
 80a75d4:	d409      	bmi.n	80a75ea <digitalWrite+0x30>
        return;
  // Safety check
  if( !pinAvailable(pin) ) {
 80a75d6:	4620      	mov	r0, r4
 80a75d8:	f7ff ff9c 	bl	80a7514 <pinAvailable>
 80a75dc:	b128      	cbz	r0, 80a75ea <digitalWrite+0x30>
    return;
  }

  HAL_GPIO_Write(pin, value);
 80a75de:	4629      	mov	r1, r5
 80a75e0:	4620      	mov	r0, r4
}
 80a75e2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  HAL_GPIO_Write(pin, value);
 80a75e6:	f7fe b92b 	b.w	80a5840 <HAL_GPIO_Write>
}
 80a75ea:	bd38      	pop	{r3, r4, r5, pc}

080a75ec <digitalRead>:

/*
 * @brief Reads the value of a GPIO pin. Should return either 1 (HIGH) or 0 (LOW).
 */
int32_t digitalRead(pin_t pin)
{
 80a75ec:	b510      	push	{r4, lr}
 80a75ee:	4604      	mov	r4, r0
    PinMode mode = HAL_Get_Pin_Mode(pin);
 80a75f0:	f7fe f91e 	bl	80a5830 <HAL_Get_Pin_Mode>
    return mode == AF_OUTPUT_PUSHPULL ||
 80a75f4:	1f03      	subs	r3, r0, #4
    if (is_af_output_mode(mode))
 80a75f6:	b2db      	uxtb	r3, r3
 80a75f8:	2b01      	cmp	r3, #1
 80a75fa:	d908      	bls.n	80a760e <digitalRead+0x22>
        return LOW;

    // Safety check
    if( !pinAvailable(pin) ) {
 80a75fc:	4620      	mov	r0, r4
 80a75fe:	f7ff ff89 	bl	80a7514 <pinAvailable>
 80a7602:	b120      	cbz	r0, 80a760e <digitalRead+0x22>
      return LOW;
    }

    return HAL_GPIO_Read(pin);
 80a7604:	4620      	mov	r0, r4
}
 80a7606:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    return HAL_GPIO_Read(pin);
 80a760a:	f7fe b921 	b.w	80a5850 <HAL_GPIO_Read>
}
 80a760e:	2000      	movs	r0, #0
 80a7610:	bd10      	pop	{r4, pc}

080a7612 <_ZdlPvj>:
 80a7612:	f7f8 bd44 	b.w	80a009e <_ZdlPv>

080a7616 <_ZnajRKSt9nothrow_t>:
 80a7616:	f7f8 bd40 	b.w	80a009a <_Znaj>

080a761a <_ZSt25__throw_bad_function_callv>:
 80a761a:	b508      	push	{r3, lr}
 80a761c:	f7fe fa66 	bl	80a5aec <abort>

080a7620 <__aeabi_drsub>:
 80a7620:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80a7624:	e002      	b.n	80a762c <__adddf3>
 80a7626:	bf00      	nop

080a7628 <__aeabi_dsub>:
 80a7628:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

080a762c <__adddf3>:
 80a762c:	b530      	push	{r4, r5, lr}
 80a762e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80a7632:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80a7636:	ea94 0f05 	teq	r4, r5
 80a763a:	bf08      	it	eq
 80a763c:	ea90 0f02 	teqeq	r0, r2
 80a7640:	bf1f      	itttt	ne
 80a7642:	ea54 0c00 	orrsne.w	ip, r4, r0
 80a7646:	ea55 0c02 	orrsne.w	ip, r5, r2
 80a764a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 80a764e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80a7652:	f000 80e2 	beq.w	80a781a <__adddf3+0x1ee>
 80a7656:	ea4f 5454 	mov.w	r4, r4, lsr #21
 80a765a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 80a765e:	bfb8      	it	lt
 80a7660:	426d      	neglt	r5, r5
 80a7662:	dd0c      	ble.n	80a767e <__adddf3+0x52>
 80a7664:	442c      	add	r4, r5
 80a7666:	ea80 0202 	eor.w	r2, r0, r2
 80a766a:	ea81 0303 	eor.w	r3, r1, r3
 80a766e:	ea82 0000 	eor.w	r0, r2, r0
 80a7672:	ea83 0101 	eor.w	r1, r3, r1
 80a7676:	ea80 0202 	eor.w	r2, r0, r2
 80a767a:	ea81 0303 	eor.w	r3, r1, r3
 80a767e:	2d36      	cmp	r5, #54	; 0x36
 80a7680:	bf88      	it	hi
 80a7682:	bd30      	pophi	{r4, r5, pc}
 80a7684:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80a7688:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80a768c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 80a7690:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 80a7694:	d002      	beq.n	80a769c <__adddf3+0x70>
 80a7696:	4240      	negs	r0, r0
 80a7698:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80a769c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 80a76a0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80a76a4:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 80a76a8:	d002      	beq.n	80a76b0 <__adddf3+0x84>
 80a76aa:	4252      	negs	r2, r2
 80a76ac:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80a76b0:	ea94 0f05 	teq	r4, r5
 80a76b4:	f000 80a7 	beq.w	80a7806 <__adddf3+0x1da>
 80a76b8:	f1a4 0401 	sub.w	r4, r4, #1
 80a76bc:	f1d5 0e20 	rsbs	lr, r5, #32
 80a76c0:	db0d      	blt.n	80a76de <__adddf3+0xb2>
 80a76c2:	fa02 fc0e 	lsl.w	ip, r2, lr
 80a76c6:	fa22 f205 	lsr.w	r2, r2, r5
 80a76ca:	1880      	adds	r0, r0, r2
 80a76cc:	f141 0100 	adc.w	r1, r1, #0
 80a76d0:	fa03 f20e 	lsl.w	r2, r3, lr
 80a76d4:	1880      	adds	r0, r0, r2
 80a76d6:	fa43 f305 	asr.w	r3, r3, r5
 80a76da:	4159      	adcs	r1, r3
 80a76dc:	e00e      	b.n	80a76fc <__adddf3+0xd0>
 80a76de:	f1a5 0520 	sub.w	r5, r5, #32
 80a76e2:	f10e 0e20 	add.w	lr, lr, #32
 80a76e6:	2a01      	cmp	r2, #1
 80a76e8:	fa03 fc0e 	lsl.w	ip, r3, lr
 80a76ec:	bf28      	it	cs
 80a76ee:	f04c 0c02 	orrcs.w	ip, ip, #2
 80a76f2:	fa43 f305 	asr.w	r3, r3, r5
 80a76f6:	18c0      	adds	r0, r0, r3
 80a76f8:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80a76fc:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80a7700:	d507      	bpl.n	80a7712 <__adddf3+0xe6>
 80a7702:	f04f 0e00 	mov.w	lr, #0
 80a7706:	f1dc 0c00 	rsbs	ip, ip, #0
 80a770a:	eb7e 0000 	sbcs.w	r0, lr, r0
 80a770e:	eb6e 0101 	sbc.w	r1, lr, r1
 80a7712:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80a7716:	d31b      	bcc.n	80a7750 <__adddf3+0x124>
 80a7718:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80a771c:	d30c      	bcc.n	80a7738 <__adddf3+0x10c>
 80a771e:	0849      	lsrs	r1, r1, #1
 80a7720:	ea5f 0030 	movs.w	r0, r0, rrx
 80a7724:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80a7728:	f104 0401 	add.w	r4, r4, #1
 80a772c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80a7730:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 80a7734:	f080 809a 	bcs.w	80a786c <__adddf3+0x240>
 80a7738:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80a773c:	bf08      	it	eq
 80a773e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80a7742:	f150 0000 	adcs.w	r0, r0, #0
 80a7746:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80a774a:	ea41 0105 	orr.w	r1, r1, r5
 80a774e:	bd30      	pop	{r4, r5, pc}
 80a7750:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 80a7754:	4140      	adcs	r0, r0
 80a7756:	eb41 0101 	adc.w	r1, r1, r1
 80a775a:	3c01      	subs	r4, #1
 80a775c:	bf28      	it	cs
 80a775e:	f5b1 1f80 	cmpcs.w	r1, #1048576	; 0x100000
 80a7762:	d2e9      	bcs.n	80a7738 <__adddf3+0x10c>
 80a7764:	f091 0f00 	teq	r1, #0
 80a7768:	bf04      	itt	eq
 80a776a:	4601      	moveq	r1, r0
 80a776c:	2000      	moveq	r0, #0
 80a776e:	fab1 f381 	clz	r3, r1
 80a7772:	bf08      	it	eq
 80a7774:	3320      	addeq	r3, #32
 80a7776:	f1a3 030b 	sub.w	r3, r3, #11
 80a777a:	f1b3 0220 	subs.w	r2, r3, #32
 80a777e:	da0c      	bge.n	80a779a <__adddf3+0x16e>
 80a7780:	320c      	adds	r2, #12
 80a7782:	dd08      	ble.n	80a7796 <__adddf3+0x16a>
 80a7784:	f102 0c14 	add.w	ip, r2, #20
 80a7788:	f1c2 020c 	rsb	r2, r2, #12
 80a778c:	fa01 f00c 	lsl.w	r0, r1, ip
 80a7790:	fa21 f102 	lsr.w	r1, r1, r2
 80a7794:	e00c      	b.n	80a77b0 <__adddf3+0x184>
 80a7796:	f102 0214 	add.w	r2, r2, #20
 80a779a:	bfd8      	it	le
 80a779c:	f1c2 0c20 	rsble	ip, r2, #32
 80a77a0:	fa01 f102 	lsl.w	r1, r1, r2
 80a77a4:	fa20 fc0c 	lsr.w	ip, r0, ip
 80a77a8:	bfdc      	itt	le
 80a77aa:	ea41 010c 	orrle.w	r1, r1, ip
 80a77ae:	4090      	lslle	r0, r2
 80a77b0:	1ae4      	subs	r4, r4, r3
 80a77b2:	bfa2      	ittt	ge
 80a77b4:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 80a77b8:	4329      	orrge	r1, r5
 80a77ba:	bd30      	popge	{r4, r5, pc}
 80a77bc:	ea6f 0404 	mvn.w	r4, r4
 80a77c0:	3c1f      	subs	r4, #31
 80a77c2:	da1c      	bge.n	80a77fe <__adddf3+0x1d2>
 80a77c4:	340c      	adds	r4, #12
 80a77c6:	dc0e      	bgt.n	80a77e6 <__adddf3+0x1ba>
 80a77c8:	f104 0414 	add.w	r4, r4, #20
 80a77cc:	f1c4 0220 	rsb	r2, r4, #32
 80a77d0:	fa20 f004 	lsr.w	r0, r0, r4
 80a77d4:	fa01 f302 	lsl.w	r3, r1, r2
 80a77d8:	ea40 0003 	orr.w	r0, r0, r3
 80a77dc:	fa21 f304 	lsr.w	r3, r1, r4
 80a77e0:	ea45 0103 	orr.w	r1, r5, r3
 80a77e4:	bd30      	pop	{r4, r5, pc}
 80a77e6:	f1c4 040c 	rsb	r4, r4, #12
 80a77ea:	f1c4 0220 	rsb	r2, r4, #32
 80a77ee:	fa20 f002 	lsr.w	r0, r0, r2
 80a77f2:	fa01 f304 	lsl.w	r3, r1, r4
 80a77f6:	ea40 0003 	orr.w	r0, r0, r3
 80a77fa:	4629      	mov	r1, r5
 80a77fc:	bd30      	pop	{r4, r5, pc}
 80a77fe:	fa21 f004 	lsr.w	r0, r1, r4
 80a7802:	4629      	mov	r1, r5
 80a7804:	bd30      	pop	{r4, r5, pc}
 80a7806:	f094 0f00 	teq	r4, #0
 80a780a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 80a780e:	bf06      	itte	eq
 80a7810:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80a7814:	3401      	addeq	r4, #1
 80a7816:	3d01      	subne	r5, #1
 80a7818:	e74e      	b.n	80a76b8 <__adddf3+0x8c>
 80a781a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80a781e:	bf18      	it	ne
 80a7820:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80a7824:	d029      	beq.n	80a787a <__adddf3+0x24e>
 80a7826:	ea94 0f05 	teq	r4, r5
 80a782a:	bf08      	it	eq
 80a782c:	ea90 0f02 	teqeq	r0, r2
 80a7830:	d005      	beq.n	80a783e <__adddf3+0x212>
 80a7832:	ea54 0c00 	orrs.w	ip, r4, r0
 80a7836:	bf04      	itt	eq
 80a7838:	4619      	moveq	r1, r3
 80a783a:	4610      	moveq	r0, r2
 80a783c:	bd30      	pop	{r4, r5, pc}
 80a783e:	ea91 0f03 	teq	r1, r3
 80a7842:	bf1e      	ittt	ne
 80a7844:	2100      	movne	r1, #0
 80a7846:	2000      	movne	r0, #0
 80a7848:	bd30      	popne	{r4, r5, pc}
 80a784a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 80a784e:	d105      	bne.n	80a785c <__adddf3+0x230>
 80a7850:	0040      	lsls	r0, r0, #1
 80a7852:	4149      	adcs	r1, r1
 80a7854:	bf28      	it	cs
 80a7856:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 80a785a:	bd30      	pop	{r4, r5, pc}
 80a785c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 80a7860:	bf3c      	itt	cc
 80a7862:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 80a7866:	bd30      	popcc	{r4, r5, pc}
 80a7868:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80a786c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 80a7870:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80a7874:	f04f 0000 	mov.w	r0, #0
 80a7878:	bd30      	pop	{r4, r5, pc}
 80a787a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80a787e:	bf1a      	itte	ne
 80a7880:	4619      	movne	r1, r3
 80a7882:	4610      	movne	r0, r2
 80a7884:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 80a7888:	bf1c      	itt	ne
 80a788a:	460b      	movne	r3, r1
 80a788c:	4602      	movne	r2, r0
 80a788e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80a7892:	bf06      	itte	eq
 80a7894:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 80a7898:	ea91 0f03 	teqeq	r1, r3
 80a789c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 80a78a0:	bd30      	pop	{r4, r5, pc}
 80a78a2:	bf00      	nop

080a78a4 <__aeabi_ui2d>:
 80a78a4:	f090 0f00 	teq	r0, #0
 80a78a8:	bf04      	itt	eq
 80a78aa:	2100      	moveq	r1, #0
 80a78ac:	4770      	bxeq	lr
 80a78ae:	b530      	push	{r4, r5, lr}
 80a78b0:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80a78b4:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80a78b8:	f04f 0500 	mov.w	r5, #0
 80a78bc:	f04f 0100 	mov.w	r1, #0
 80a78c0:	e750      	b.n	80a7764 <__adddf3+0x138>
 80a78c2:	bf00      	nop

080a78c4 <__aeabi_i2d>:
 80a78c4:	f090 0f00 	teq	r0, #0
 80a78c8:	bf04      	itt	eq
 80a78ca:	2100      	moveq	r1, #0
 80a78cc:	4770      	bxeq	lr
 80a78ce:	b530      	push	{r4, r5, lr}
 80a78d0:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80a78d4:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80a78d8:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 80a78dc:	bf48      	it	mi
 80a78de:	4240      	negmi	r0, r0
 80a78e0:	f04f 0100 	mov.w	r1, #0
 80a78e4:	e73e      	b.n	80a7764 <__adddf3+0x138>
 80a78e6:	bf00      	nop

080a78e8 <__aeabi_f2d>:
 80a78e8:	0042      	lsls	r2, r0, #1
 80a78ea:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80a78ee:	ea4f 0131 	mov.w	r1, r1, rrx
 80a78f2:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80a78f6:	bf1f      	itttt	ne
 80a78f8:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 80a78fc:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80a7900:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 80a7904:	4770      	bxne	lr
 80a7906:	f032 427f 	bics.w	r2, r2, #4278190080	; 0xff000000
 80a790a:	bf08      	it	eq
 80a790c:	4770      	bxeq	lr
 80a790e:	f093 4f7f 	teq	r3, #4278190080	; 0xff000000
 80a7912:	bf04      	itt	eq
 80a7914:	f441 2100 	orreq.w	r1, r1, #524288	; 0x80000
 80a7918:	4770      	bxeq	lr
 80a791a:	b530      	push	{r4, r5, lr}
 80a791c:	f44f 7460 	mov.w	r4, #896	; 0x380
 80a7920:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80a7924:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80a7928:	e71c      	b.n	80a7764 <__adddf3+0x138>
 80a792a:	bf00      	nop

080a792c <__aeabi_ul2d>:
 80a792c:	ea50 0201 	orrs.w	r2, r0, r1
 80a7930:	bf08      	it	eq
 80a7932:	4770      	bxeq	lr
 80a7934:	b530      	push	{r4, r5, lr}
 80a7936:	f04f 0500 	mov.w	r5, #0
 80a793a:	e00a      	b.n	80a7952 <__aeabi_l2d+0x16>

080a793c <__aeabi_l2d>:
 80a793c:	ea50 0201 	orrs.w	r2, r0, r1
 80a7940:	bf08      	it	eq
 80a7942:	4770      	bxeq	lr
 80a7944:	b530      	push	{r4, r5, lr}
 80a7946:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 80a794a:	d502      	bpl.n	80a7952 <__aeabi_l2d+0x16>
 80a794c:	4240      	negs	r0, r0
 80a794e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80a7952:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80a7956:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80a795a:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 80a795e:	f43f aed8 	beq.w	80a7712 <__adddf3+0xe6>
 80a7962:	f04f 0203 	mov.w	r2, #3
 80a7966:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80a796a:	bf18      	it	ne
 80a796c:	3203      	addne	r2, #3
 80a796e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80a7972:	bf18      	it	ne
 80a7974:	3203      	addne	r2, #3
 80a7976:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 80a797a:	f1c2 0320 	rsb	r3, r2, #32
 80a797e:	fa00 fc03 	lsl.w	ip, r0, r3
 80a7982:	fa20 f002 	lsr.w	r0, r0, r2
 80a7986:	fa01 fe03 	lsl.w	lr, r1, r3
 80a798a:	ea40 000e 	orr.w	r0, r0, lr
 80a798e:	fa21 f102 	lsr.w	r1, r1, r2
 80a7992:	4414      	add	r4, r2
 80a7994:	e6bd      	b.n	80a7712 <__adddf3+0xe6>
 80a7996:	bf00      	nop

080a7998 <__aeabi_dmul>:
 80a7998:	b570      	push	{r4, r5, r6, lr}
 80a799a:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80a799e:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80a79a2:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80a79a6:	bf1d      	ittte	ne
 80a79a8:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80a79ac:	ea94 0f0c 	teqne	r4, ip
 80a79b0:	ea95 0f0c 	teqne	r5, ip
 80a79b4:	f000 f8de 	bleq	80a7b74 <__aeabi_dmul+0x1dc>
 80a79b8:	442c      	add	r4, r5
 80a79ba:	ea81 0603 	eor.w	r6, r1, r3
 80a79be:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 80a79c2:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 80a79c6:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 80a79ca:	bf18      	it	ne
 80a79cc:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 80a79d0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80a79d4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80a79d8:	d038      	beq.n	80a7a4c <__aeabi_dmul+0xb4>
 80a79da:	fba0 ce02 	umull	ip, lr, r0, r2
 80a79de:	f04f 0500 	mov.w	r5, #0
 80a79e2:	fbe1 e502 	umlal	lr, r5, r1, r2
 80a79e6:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 80a79ea:	fbe0 e503 	umlal	lr, r5, r0, r3
 80a79ee:	f04f 0600 	mov.w	r6, #0
 80a79f2:	fbe1 5603 	umlal	r5, r6, r1, r3
 80a79f6:	f09c 0f00 	teq	ip, #0
 80a79fa:	bf18      	it	ne
 80a79fc:	f04e 0e01 	orrne.w	lr, lr, #1
 80a7a00:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 80a7a04:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 80a7a08:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 80a7a0c:	d204      	bcs.n	80a7a18 <__aeabi_dmul+0x80>
 80a7a0e:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 80a7a12:	416d      	adcs	r5, r5
 80a7a14:	eb46 0606 	adc.w	r6, r6, r6
 80a7a18:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 80a7a1c:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 80a7a20:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 80a7a24:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 80a7a28:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 80a7a2c:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80a7a30:	bf88      	it	hi
 80a7a32:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80a7a36:	d81e      	bhi.n	80a7a76 <__aeabi_dmul+0xde>
 80a7a38:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 80a7a3c:	bf08      	it	eq
 80a7a3e:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 80a7a42:	f150 0000 	adcs.w	r0, r0, #0
 80a7a46:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80a7a4a:	bd70      	pop	{r4, r5, r6, pc}
 80a7a4c:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 80a7a50:	ea46 0101 	orr.w	r1, r6, r1
 80a7a54:	ea40 0002 	orr.w	r0, r0, r2
 80a7a58:	ea81 0103 	eor.w	r1, r1, r3
 80a7a5c:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 80a7a60:	bfc2      	ittt	gt
 80a7a62:	ebd4 050c 	rsbsgt	r5, r4, ip
 80a7a66:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80a7a6a:	bd70      	popgt	{r4, r5, r6, pc}
 80a7a6c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80a7a70:	f04f 0e00 	mov.w	lr, #0
 80a7a74:	3c01      	subs	r4, #1
 80a7a76:	f300 80ab 	bgt.w	80a7bd0 <__aeabi_dmul+0x238>
 80a7a7a:	f114 0f36 	cmn.w	r4, #54	; 0x36
 80a7a7e:	bfde      	ittt	le
 80a7a80:	2000      	movle	r0, #0
 80a7a82:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 80a7a86:	bd70      	pople	{r4, r5, r6, pc}
 80a7a88:	f1c4 0400 	rsb	r4, r4, #0
 80a7a8c:	3c20      	subs	r4, #32
 80a7a8e:	da35      	bge.n	80a7afc <__aeabi_dmul+0x164>
 80a7a90:	340c      	adds	r4, #12
 80a7a92:	dc1b      	bgt.n	80a7acc <__aeabi_dmul+0x134>
 80a7a94:	f104 0414 	add.w	r4, r4, #20
 80a7a98:	f1c4 0520 	rsb	r5, r4, #32
 80a7a9c:	fa00 f305 	lsl.w	r3, r0, r5
 80a7aa0:	fa20 f004 	lsr.w	r0, r0, r4
 80a7aa4:	fa01 f205 	lsl.w	r2, r1, r5
 80a7aa8:	ea40 0002 	orr.w	r0, r0, r2
 80a7aac:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 80a7ab0:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80a7ab4:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80a7ab8:	fa21 f604 	lsr.w	r6, r1, r4
 80a7abc:	eb42 0106 	adc.w	r1, r2, r6
 80a7ac0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80a7ac4:	bf08      	it	eq
 80a7ac6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80a7aca:	bd70      	pop	{r4, r5, r6, pc}
 80a7acc:	f1c4 040c 	rsb	r4, r4, #12
 80a7ad0:	f1c4 0520 	rsb	r5, r4, #32
 80a7ad4:	fa00 f304 	lsl.w	r3, r0, r4
 80a7ad8:	fa20 f005 	lsr.w	r0, r0, r5
 80a7adc:	fa01 f204 	lsl.w	r2, r1, r4
 80a7ae0:	ea40 0002 	orr.w	r0, r0, r2
 80a7ae4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80a7ae8:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80a7aec:	f141 0100 	adc.w	r1, r1, #0
 80a7af0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80a7af4:	bf08      	it	eq
 80a7af6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80a7afa:	bd70      	pop	{r4, r5, r6, pc}
 80a7afc:	f1c4 0520 	rsb	r5, r4, #32
 80a7b00:	fa00 f205 	lsl.w	r2, r0, r5
 80a7b04:	ea4e 0e02 	orr.w	lr, lr, r2
 80a7b08:	fa20 f304 	lsr.w	r3, r0, r4
 80a7b0c:	fa01 f205 	lsl.w	r2, r1, r5
 80a7b10:	ea43 0302 	orr.w	r3, r3, r2
 80a7b14:	fa21 f004 	lsr.w	r0, r1, r4
 80a7b18:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80a7b1c:	fa21 f204 	lsr.w	r2, r1, r4
 80a7b20:	ea20 0002 	bic.w	r0, r0, r2
 80a7b24:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 80a7b28:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80a7b2c:	bf08      	it	eq
 80a7b2e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80a7b32:	bd70      	pop	{r4, r5, r6, pc}
 80a7b34:	f094 0f00 	teq	r4, #0
 80a7b38:	d10f      	bne.n	80a7b5a <__aeabi_dmul+0x1c2>
 80a7b3a:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 80a7b3e:	0040      	lsls	r0, r0, #1
 80a7b40:	eb41 0101 	adc.w	r1, r1, r1
 80a7b44:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80a7b48:	bf08      	it	eq
 80a7b4a:	3c01      	subeq	r4, #1
 80a7b4c:	d0f7      	beq.n	80a7b3e <__aeabi_dmul+0x1a6>
 80a7b4e:	ea41 0106 	orr.w	r1, r1, r6
 80a7b52:	f095 0f00 	teq	r5, #0
 80a7b56:	bf18      	it	ne
 80a7b58:	4770      	bxne	lr
 80a7b5a:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 80a7b5e:	0052      	lsls	r2, r2, #1
 80a7b60:	eb43 0303 	adc.w	r3, r3, r3
 80a7b64:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 80a7b68:	bf08      	it	eq
 80a7b6a:	3d01      	subeq	r5, #1
 80a7b6c:	d0f7      	beq.n	80a7b5e <__aeabi_dmul+0x1c6>
 80a7b6e:	ea43 0306 	orr.w	r3, r3, r6
 80a7b72:	4770      	bx	lr
 80a7b74:	ea94 0f0c 	teq	r4, ip
 80a7b78:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80a7b7c:	bf18      	it	ne
 80a7b7e:	ea95 0f0c 	teqne	r5, ip
 80a7b82:	d00c      	beq.n	80a7b9e <__aeabi_dmul+0x206>
 80a7b84:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80a7b88:	bf18      	it	ne
 80a7b8a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80a7b8e:	d1d1      	bne.n	80a7b34 <__aeabi_dmul+0x19c>
 80a7b90:	ea81 0103 	eor.w	r1, r1, r3
 80a7b94:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80a7b98:	f04f 0000 	mov.w	r0, #0
 80a7b9c:	bd70      	pop	{r4, r5, r6, pc}
 80a7b9e:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80a7ba2:	bf06      	itte	eq
 80a7ba4:	4610      	moveq	r0, r2
 80a7ba6:	4619      	moveq	r1, r3
 80a7ba8:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80a7bac:	d019      	beq.n	80a7be2 <__aeabi_dmul+0x24a>
 80a7bae:	ea94 0f0c 	teq	r4, ip
 80a7bb2:	d102      	bne.n	80a7bba <__aeabi_dmul+0x222>
 80a7bb4:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 80a7bb8:	d113      	bne.n	80a7be2 <__aeabi_dmul+0x24a>
 80a7bba:	ea95 0f0c 	teq	r5, ip
 80a7bbe:	d105      	bne.n	80a7bcc <__aeabi_dmul+0x234>
 80a7bc0:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 80a7bc4:	bf1c      	itt	ne
 80a7bc6:	4610      	movne	r0, r2
 80a7bc8:	4619      	movne	r1, r3
 80a7bca:	d10a      	bne.n	80a7be2 <__aeabi_dmul+0x24a>
 80a7bcc:	ea81 0103 	eor.w	r1, r1, r3
 80a7bd0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80a7bd4:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80a7bd8:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80a7bdc:	f04f 0000 	mov.w	r0, #0
 80a7be0:	bd70      	pop	{r4, r5, r6, pc}
 80a7be2:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80a7be6:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 80a7bea:	bd70      	pop	{r4, r5, r6, pc}

080a7bec <__aeabi_ddiv>:
 80a7bec:	b570      	push	{r4, r5, r6, lr}
 80a7bee:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80a7bf2:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80a7bf6:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80a7bfa:	bf1d      	ittte	ne
 80a7bfc:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80a7c00:	ea94 0f0c 	teqne	r4, ip
 80a7c04:	ea95 0f0c 	teqne	r5, ip
 80a7c08:	f000 f8a7 	bleq	80a7d5a <__aeabi_ddiv+0x16e>
 80a7c0c:	eba4 0405 	sub.w	r4, r4, r5
 80a7c10:	ea81 0e03 	eor.w	lr, r1, r3
 80a7c14:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80a7c18:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80a7c1c:	f000 8088 	beq.w	80a7d30 <__aeabi_ddiv+0x144>
 80a7c20:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80a7c24:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 80a7c28:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 80a7c2c:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80a7c30:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80a7c34:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 80a7c38:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 80a7c3c:	ea4f 2600 	mov.w	r6, r0, lsl #8
 80a7c40:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 80a7c44:	429d      	cmp	r5, r3
 80a7c46:	bf08      	it	eq
 80a7c48:	4296      	cmpeq	r6, r2
 80a7c4a:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 80a7c4e:	f504 7440 	add.w	r4, r4, #768	; 0x300
 80a7c52:	d202      	bcs.n	80a7c5a <__aeabi_ddiv+0x6e>
 80a7c54:	085b      	lsrs	r3, r3, #1
 80a7c56:	ea4f 0232 	mov.w	r2, r2, rrx
 80a7c5a:	1ab6      	subs	r6, r6, r2
 80a7c5c:	eb65 0503 	sbc.w	r5, r5, r3
 80a7c60:	085b      	lsrs	r3, r3, #1
 80a7c62:	ea4f 0232 	mov.w	r2, r2, rrx
 80a7c66:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80a7c6a:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 80a7c6e:	ebb6 0e02 	subs.w	lr, r6, r2
 80a7c72:	eb75 0e03 	sbcs.w	lr, r5, r3
 80a7c76:	bf22      	ittt	cs
 80a7c78:	1ab6      	subcs	r6, r6, r2
 80a7c7a:	4675      	movcs	r5, lr
 80a7c7c:	ea40 000c 	orrcs.w	r0, r0, ip
 80a7c80:	085b      	lsrs	r3, r3, #1
 80a7c82:	ea4f 0232 	mov.w	r2, r2, rrx
 80a7c86:	ebb6 0e02 	subs.w	lr, r6, r2
 80a7c8a:	eb75 0e03 	sbcs.w	lr, r5, r3
 80a7c8e:	bf22      	ittt	cs
 80a7c90:	1ab6      	subcs	r6, r6, r2
 80a7c92:	4675      	movcs	r5, lr
 80a7c94:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 80a7c98:	085b      	lsrs	r3, r3, #1
 80a7c9a:	ea4f 0232 	mov.w	r2, r2, rrx
 80a7c9e:	ebb6 0e02 	subs.w	lr, r6, r2
 80a7ca2:	eb75 0e03 	sbcs.w	lr, r5, r3
 80a7ca6:	bf22      	ittt	cs
 80a7ca8:	1ab6      	subcs	r6, r6, r2
 80a7caa:	4675      	movcs	r5, lr
 80a7cac:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 80a7cb0:	085b      	lsrs	r3, r3, #1
 80a7cb2:	ea4f 0232 	mov.w	r2, r2, rrx
 80a7cb6:	ebb6 0e02 	subs.w	lr, r6, r2
 80a7cba:	eb75 0e03 	sbcs.w	lr, r5, r3
 80a7cbe:	bf22      	ittt	cs
 80a7cc0:	1ab6      	subcs	r6, r6, r2
 80a7cc2:	4675      	movcs	r5, lr
 80a7cc4:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 80a7cc8:	ea55 0e06 	orrs.w	lr, r5, r6
 80a7ccc:	d018      	beq.n	80a7d00 <__aeabi_ddiv+0x114>
 80a7cce:	ea4f 1505 	mov.w	r5, r5, lsl #4
 80a7cd2:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 80a7cd6:	ea4f 1606 	mov.w	r6, r6, lsl #4
 80a7cda:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80a7cde:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 80a7ce2:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 80a7ce6:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 80a7cea:	d1c0      	bne.n	80a7c6e <__aeabi_ddiv+0x82>
 80a7cec:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80a7cf0:	d10b      	bne.n	80a7d0a <__aeabi_ddiv+0x11e>
 80a7cf2:	ea41 0100 	orr.w	r1, r1, r0
 80a7cf6:	f04f 0000 	mov.w	r0, #0
 80a7cfa:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 80a7cfe:	e7b6      	b.n	80a7c6e <__aeabi_ddiv+0x82>
 80a7d00:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80a7d04:	bf04      	itt	eq
 80a7d06:	4301      	orreq	r1, r0
 80a7d08:	2000      	moveq	r0, #0
 80a7d0a:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80a7d0e:	bf88      	it	hi
 80a7d10:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80a7d14:	f63f aeaf 	bhi.w	80a7a76 <__aeabi_dmul+0xde>
 80a7d18:	ebb5 0c03 	subs.w	ip, r5, r3
 80a7d1c:	bf04      	itt	eq
 80a7d1e:	ebb6 0c02 	subseq.w	ip, r6, r2
 80a7d22:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80a7d26:	f150 0000 	adcs.w	r0, r0, #0
 80a7d2a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80a7d2e:	bd70      	pop	{r4, r5, r6, pc}
 80a7d30:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 80a7d34:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 80a7d38:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 80a7d3c:	bfc2      	ittt	gt
 80a7d3e:	ebd4 050c 	rsbsgt	r5, r4, ip
 80a7d42:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80a7d46:	bd70      	popgt	{r4, r5, r6, pc}
 80a7d48:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80a7d4c:	f04f 0e00 	mov.w	lr, #0
 80a7d50:	3c01      	subs	r4, #1
 80a7d52:	e690      	b.n	80a7a76 <__aeabi_dmul+0xde>
 80a7d54:	ea45 0e06 	orr.w	lr, r5, r6
 80a7d58:	e68d      	b.n	80a7a76 <__aeabi_dmul+0xde>
 80a7d5a:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80a7d5e:	ea94 0f0c 	teq	r4, ip
 80a7d62:	bf08      	it	eq
 80a7d64:	ea95 0f0c 	teqeq	r5, ip
 80a7d68:	f43f af3b 	beq.w	80a7be2 <__aeabi_dmul+0x24a>
 80a7d6c:	ea94 0f0c 	teq	r4, ip
 80a7d70:	d10a      	bne.n	80a7d88 <__aeabi_ddiv+0x19c>
 80a7d72:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80a7d76:	f47f af34 	bne.w	80a7be2 <__aeabi_dmul+0x24a>
 80a7d7a:	ea95 0f0c 	teq	r5, ip
 80a7d7e:	f47f af25 	bne.w	80a7bcc <__aeabi_dmul+0x234>
 80a7d82:	4610      	mov	r0, r2
 80a7d84:	4619      	mov	r1, r3
 80a7d86:	e72c      	b.n	80a7be2 <__aeabi_dmul+0x24a>
 80a7d88:	ea95 0f0c 	teq	r5, ip
 80a7d8c:	d106      	bne.n	80a7d9c <__aeabi_ddiv+0x1b0>
 80a7d8e:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80a7d92:	f43f aefd 	beq.w	80a7b90 <__aeabi_dmul+0x1f8>
 80a7d96:	4610      	mov	r0, r2
 80a7d98:	4619      	mov	r1, r3
 80a7d9a:	e722      	b.n	80a7be2 <__aeabi_dmul+0x24a>
 80a7d9c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80a7da0:	bf18      	it	ne
 80a7da2:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80a7da6:	f47f aec5 	bne.w	80a7b34 <__aeabi_dmul+0x19c>
 80a7daa:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 80a7dae:	f47f af0d 	bne.w	80a7bcc <__aeabi_dmul+0x234>
 80a7db2:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 80a7db6:	f47f aeeb 	bne.w	80a7b90 <__aeabi_dmul+0x1f8>
 80a7dba:	e712      	b.n	80a7be2 <__aeabi_dmul+0x24a>

080a7dbc <__aeabi_d2uiz>:
 80a7dbc:	004a      	lsls	r2, r1, #1
 80a7dbe:	d211      	bcs.n	80a7de4 <__aeabi_d2uiz+0x28>
 80a7dc0:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 80a7dc4:	d211      	bcs.n	80a7dea <__aeabi_d2uiz+0x2e>
 80a7dc6:	d50d      	bpl.n	80a7de4 <__aeabi_d2uiz+0x28>
 80a7dc8:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 80a7dcc:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 80a7dd0:	d40e      	bmi.n	80a7df0 <__aeabi_d2uiz+0x34>
 80a7dd2:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 80a7dd6:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80a7dda:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 80a7dde:	fa23 f002 	lsr.w	r0, r3, r2
 80a7de2:	4770      	bx	lr
 80a7de4:	f04f 0000 	mov.w	r0, #0
 80a7de8:	4770      	bx	lr
 80a7dea:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 80a7dee:	d102      	bne.n	80a7df6 <__aeabi_d2uiz+0x3a>
 80a7df0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80a7df4:	4770      	bx	lr
 80a7df6:	f04f 0000 	mov.w	r0, #0
 80a7dfa:	4770      	bx	lr

080a7dfc <__aeabi_frsub>:
 80a7dfc:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
 80a7e00:	e002      	b.n	80a7e08 <__addsf3>
 80a7e02:	bf00      	nop

080a7e04 <__aeabi_fsub>:
 80a7e04:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

080a7e08 <__addsf3>:
 80a7e08:	0042      	lsls	r2, r0, #1
 80a7e0a:	bf1f      	itttt	ne
 80a7e0c:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 80a7e10:	ea92 0f03 	teqne	r2, r3
 80a7e14:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 80a7e18:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80a7e1c:	d06a      	beq.n	80a7ef4 <__addsf3+0xec>
 80a7e1e:	ea4f 6212 	mov.w	r2, r2, lsr #24
 80a7e22:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 80a7e26:	bfc1      	itttt	gt
 80a7e28:	18d2      	addgt	r2, r2, r3
 80a7e2a:	4041      	eorgt	r1, r0
 80a7e2c:	4048      	eorgt	r0, r1
 80a7e2e:	4041      	eorgt	r1, r0
 80a7e30:	bfb8      	it	lt
 80a7e32:	425b      	neglt	r3, r3
 80a7e34:	2b19      	cmp	r3, #25
 80a7e36:	bf88      	it	hi
 80a7e38:	4770      	bxhi	lr
 80a7e3a:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 80a7e3e:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a7e42:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 80a7e46:	bf18      	it	ne
 80a7e48:	4240      	negne	r0, r0
 80a7e4a:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80a7e4e:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 80a7e52:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 80a7e56:	bf18      	it	ne
 80a7e58:	4249      	negne	r1, r1
 80a7e5a:	ea92 0f03 	teq	r2, r3
 80a7e5e:	d03f      	beq.n	80a7ee0 <__addsf3+0xd8>
 80a7e60:	f1a2 0201 	sub.w	r2, r2, #1
 80a7e64:	fa41 fc03 	asr.w	ip, r1, r3
 80a7e68:	eb10 000c 	adds.w	r0, r0, ip
 80a7e6c:	f1c3 0320 	rsb	r3, r3, #32
 80a7e70:	fa01 f103 	lsl.w	r1, r1, r3
 80a7e74:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 80a7e78:	d502      	bpl.n	80a7e80 <__addsf3+0x78>
 80a7e7a:	4249      	negs	r1, r1
 80a7e7c:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 80a7e80:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 80a7e84:	d313      	bcc.n	80a7eae <__addsf3+0xa6>
 80a7e86:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 80a7e8a:	d306      	bcc.n	80a7e9a <__addsf3+0x92>
 80a7e8c:	0840      	lsrs	r0, r0, #1
 80a7e8e:	ea4f 0131 	mov.w	r1, r1, rrx
 80a7e92:	f102 0201 	add.w	r2, r2, #1
 80a7e96:	2afe      	cmp	r2, #254	; 0xfe
 80a7e98:	d251      	bcs.n	80a7f3e <__addsf3+0x136>
 80a7e9a:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 80a7e9e:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80a7ea2:	bf08      	it	eq
 80a7ea4:	f020 0001 	biceq.w	r0, r0, #1
 80a7ea8:	ea40 0003 	orr.w	r0, r0, r3
 80a7eac:	4770      	bx	lr
 80a7eae:	0049      	lsls	r1, r1, #1
 80a7eb0:	eb40 0000 	adc.w	r0, r0, r0
 80a7eb4:	3a01      	subs	r2, #1
 80a7eb6:	bf28      	it	cs
 80a7eb8:	f5b0 0f00 	cmpcs.w	r0, #8388608	; 0x800000
 80a7ebc:	d2ed      	bcs.n	80a7e9a <__addsf3+0x92>
 80a7ebe:	fab0 fc80 	clz	ip, r0
 80a7ec2:	f1ac 0c08 	sub.w	ip, ip, #8
 80a7ec6:	ebb2 020c 	subs.w	r2, r2, ip
 80a7eca:	fa00 f00c 	lsl.w	r0, r0, ip
 80a7ece:	bfaa      	itet	ge
 80a7ed0:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 80a7ed4:	4252      	neglt	r2, r2
 80a7ed6:	4318      	orrge	r0, r3
 80a7ed8:	bfbc      	itt	lt
 80a7eda:	40d0      	lsrlt	r0, r2
 80a7edc:	4318      	orrlt	r0, r3
 80a7ede:	4770      	bx	lr
 80a7ee0:	f092 0f00 	teq	r2, #0
 80a7ee4:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
 80a7ee8:	bf06      	itte	eq
 80a7eea:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
 80a7eee:	3201      	addeq	r2, #1
 80a7ef0:	3b01      	subne	r3, #1
 80a7ef2:	e7b5      	b.n	80a7e60 <__addsf3+0x58>
 80a7ef4:	ea4f 0341 	mov.w	r3, r1, lsl #1
 80a7ef8:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 80a7efc:	bf18      	it	ne
 80a7efe:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80a7f02:	d021      	beq.n	80a7f48 <__addsf3+0x140>
 80a7f04:	ea92 0f03 	teq	r2, r3
 80a7f08:	d004      	beq.n	80a7f14 <__addsf3+0x10c>
 80a7f0a:	f092 0f00 	teq	r2, #0
 80a7f0e:	bf08      	it	eq
 80a7f10:	4608      	moveq	r0, r1
 80a7f12:	4770      	bx	lr
 80a7f14:	ea90 0f01 	teq	r0, r1
 80a7f18:	bf1c      	itt	ne
 80a7f1a:	2000      	movne	r0, #0
 80a7f1c:	4770      	bxne	lr
 80a7f1e:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
 80a7f22:	d104      	bne.n	80a7f2e <__addsf3+0x126>
 80a7f24:	0040      	lsls	r0, r0, #1
 80a7f26:	bf28      	it	cs
 80a7f28:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
 80a7f2c:	4770      	bx	lr
 80a7f2e:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 80a7f32:	bf3c      	itt	cc
 80a7f34:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
 80a7f38:	4770      	bxcc	lr
 80a7f3a:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 80a7f3e:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
 80a7f42:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a7f46:	4770      	bx	lr
 80a7f48:	ea7f 6222 	mvns.w	r2, r2, asr #24
 80a7f4c:	bf16      	itet	ne
 80a7f4e:	4608      	movne	r0, r1
 80a7f50:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 80a7f54:	4601      	movne	r1, r0
 80a7f56:	0242      	lsls	r2, r0, #9
 80a7f58:	bf06      	itte	eq
 80a7f5a:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 80a7f5e:	ea90 0f01 	teqeq	r0, r1
 80a7f62:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
 80a7f66:	4770      	bx	lr

080a7f68 <__aeabi_ui2f>:
 80a7f68:	f04f 0300 	mov.w	r3, #0
 80a7f6c:	e004      	b.n	80a7f78 <__aeabi_i2f+0x8>
 80a7f6e:	bf00      	nop

080a7f70 <__aeabi_i2f>:
 80a7f70:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
 80a7f74:	bf48      	it	mi
 80a7f76:	4240      	negmi	r0, r0
 80a7f78:	ea5f 0c00 	movs.w	ip, r0
 80a7f7c:	bf08      	it	eq
 80a7f7e:	4770      	bxeq	lr
 80a7f80:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
 80a7f84:	4601      	mov	r1, r0
 80a7f86:	f04f 0000 	mov.w	r0, #0
 80a7f8a:	e01c      	b.n	80a7fc6 <__aeabi_l2f+0x2a>

080a7f8c <__aeabi_ul2f>:
 80a7f8c:	ea50 0201 	orrs.w	r2, r0, r1
 80a7f90:	bf08      	it	eq
 80a7f92:	4770      	bxeq	lr
 80a7f94:	f04f 0300 	mov.w	r3, #0
 80a7f98:	e00a      	b.n	80a7fb0 <__aeabi_l2f+0x14>
 80a7f9a:	bf00      	nop

080a7f9c <__aeabi_l2f>:
 80a7f9c:	ea50 0201 	orrs.w	r2, r0, r1
 80a7fa0:	bf08      	it	eq
 80a7fa2:	4770      	bxeq	lr
 80a7fa4:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
 80a7fa8:	d502      	bpl.n	80a7fb0 <__aeabi_l2f+0x14>
 80a7faa:	4240      	negs	r0, r0
 80a7fac:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80a7fb0:	ea5f 0c01 	movs.w	ip, r1
 80a7fb4:	bf02      	ittt	eq
 80a7fb6:	4684      	moveq	ip, r0
 80a7fb8:	4601      	moveq	r1, r0
 80a7fba:	2000      	moveq	r0, #0
 80a7fbc:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
 80a7fc0:	bf08      	it	eq
 80a7fc2:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
 80a7fc6:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 80a7fca:	fabc f28c 	clz	r2, ip
 80a7fce:	3a08      	subs	r2, #8
 80a7fd0:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 80a7fd4:	db10      	blt.n	80a7ff8 <__aeabi_l2f+0x5c>
 80a7fd6:	fa01 fc02 	lsl.w	ip, r1, r2
 80a7fda:	4463      	add	r3, ip
 80a7fdc:	fa00 fc02 	lsl.w	ip, r0, r2
 80a7fe0:	f1c2 0220 	rsb	r2, r2, #32
 80a7fe4:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80a7fe8:	fa20 f202 	lsr.w	r2, r0, r2
 80a7fec:	eb43 0002 	adc.w	r0, r3, r2
 80a7ff0:	bf08      	it	eq
 80a7ff2:	f020 0001 	biceq.w	r0, r0, #1
 80a7ff6:	4770      	bx	lr
 80a7ff8:	f102 0220 	add.w	r2, r2, #32
 80a7ffc:	fa01 fc02 	lsl.w	ip, r1, r2
 80a8000:	f1c2 0220 	rsb	r2, r2, #32
 80a8004:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 80a8008:	fa21 f202 	lsr.w	r2, r1, r2
 80a800c:	eb43 0002 	adc.w	r0, r3, r2
 80a8010:	bf08      	it	eq
 80a8012:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 80a8016:	4770      	bx	lr

080a8018 <__aeabi_fmul>:
 80a8018:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80a801c:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 80a8020:	bf1e      	ittt	ne
 80a8022:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 80a8026:	ea92 0f0c 	teqne	r2, ip
 80a802a:	ea93 0f0c 	teqne	r3, ip
 80a802e:	d06f      	beq.n	80a8110 <__aeabi_fmul+0xf8>
 80a8030:	441a      	add	r2, r3
 80a8032:	ea80 0c01 	eor.w	ip, r0, r1
 80a8036:	0240      	lsls	r0, r0, #9
 80a8038:	bf18      	it	ne
 80a803a:	ea5f 2141 	movsne.w	r1, r1, lsl #9
 80a803e:	d01e      	beq.n	80a807e <__aeabi_fmul+0x66>
 80a8040:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 80a8044:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
 80a8048:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
 80a804c:	fba0 3101 	umull	r3, r1, r0, r1
 80a8050:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 80a8054:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 80a8058:	bf3e      	ittt	cc
 80a805a:	0049      	lslcc	r1, r1, #1
 80a805c:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
 80a8060:	005b      	lslcc	r3, r3, #1
 80a8062:	ea40 0001 	orr.w	r0, r0, r1
 80a8066:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
 80a806a:	2afd      	cmp	r2, #253	; 0xfd
 80a806c:	d81d      	bhi.n	80a80aa <__aeabi_fmul+0x92>
 80a806e:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 80a8072:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80a8076:	bf08      	it	eq
 80a8078:	f020 0001 	biceq.w	r0, r0, #1
 80a807c:	4770      	bx	lr
 80a807e:	f090 0f00 	teq	r0, #0
 80a8082:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 80a8086:	bf08      	it	eq
 80a8088:	0249      	lsleq	r1, r1, #9
 80a808a:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 80a808e:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
 80a8092:	3a7f      	subs	r2, #127	; 0x7f
 80a8094:	bfc2      	ittt	gt
 80a8096:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 80a809a:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 80a809e:	4770      	bxgt	lr
 80a80a0:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a80a4:	f04f 0300 	mov.w	r3, #0
 80a80a8:	3a01      	subs	r2, #1
 80a80aa:	dc5d      	bgt.n	80a8168 <__aeabi_fmul+0x150>
 80a80ac:	f112 0f19 	cmn.w	r2, #25
 80a80b0:	bfdc      	itt	le
 80a80b2:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
 80a80b6:	4770      	bxle	lr
 80a80b8:	f1c2 0200 	rsb	r2, r2, #0
 80a80bc:	0041      	lsls	r1, r0, #1
 80a80be:	fa21 f102 	lsr.w	r1, r1, r2
 80a80c2:	f1c2 0220 	rsb	r2, r2, #32
 80a80c6:	fa00 fc02 	lsl.w	ip, r0, r2
 80a80ca:	ea5f 0031 	movs.w	r0, r1, rrx
 80a80ce:	f140 0000 	adc.w	r0, r0, #0
 80a80d2:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
 80a80d6:	bf08      	it	eq
 80a80d8:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 80a80dc:	4770      	bx	lr
 80a80de:	f092 0f00 	teq	r2, #0
 80a80e2:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 80a80e6:	bf02      	ittt	eq
 80a80e8:	0040      	lsleq	r0, r0, #1
 80a80ea:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 80a80ee:	3a01      	subeq	r2, #1
 80a80f0:	d0f9      	beq.n	80a80e6 <__aeabi_fmul+0xce>
 80a80f2:	ea40 000c 	orr.w	r0, r0, ip
 80a80f6:	f093 0f00 	teq	r3, #0
 80a80fa:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 80a80fe:	bf02      	ittt	eq
 80a8100:	0049      	lsleq	r1, r1, #1
 80a8102:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 80a8106:	3b01      	subeq	r3, #1
 80a8108:	d0f9      	beq.n	80a80fe <__aeabi_fmul+0xe6>
 80a810a:	ea41 010c 	orr.w	r1, r1, ip
 80a810e:	e78f      	b.n	80a8030 <__aeabi_fmul+0x18>
 80a8110:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 80a8114:	ea92 0f0c 	teq	r2, ip
 80a8118:	bf18      	it	ne
 80a811a:	ea93 0f0c 	teqne	r3, ip
 80a811e:	d00a      	beq.n	80a8136 <__aeabi_fmul+0x11e>
 80a8120:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 80a8124:	bf18      	it	ne
 80a8126:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 80a812a:	d1d8      	bne.n	80a80de <__aeabi_fmul+0xc6>
 80a812c:	ea80 0001 	eor.w	r0, r0, r1
 80a8130:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 80a8134:	4770      	bx	lr
 80a8136:	f090 0f00 	teq	r0, #0
 80a813a:	bf17      	itett	ne
 80a813c:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
 80a8140:	4608      	moveq	r0, r1
 80a8142:	f091 0f00 	teqne	r1, #0
 80a8146:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
 80a814a:	d014      	beq.n	80a8176 <__aeabi_fmul+0x15e>
 80a814c:	ea92 0f0c 	teq	r2, ip
 80a8150:	d101      	bne.n	80a8156 <__aeabi_fmul+0x13e>
 80a8152:	0242      	lsls	r2, r0, #9
 80a8154:	d10f      	bne.n	80a8176 <__aeabi_fmul+0x15e>
 80a8156:	ea93 0f0c 	teq	r3, ip
 80a815a:	d103      	bne.n	80a8164 <__aeabi_fmul+0x14c>
 80a815c:	024b      	lsls	r3, r1, #9
 80a815e:	bf18      	it	ne
 80a8160:	4608      	movne	r0, r1
 80a8162:	d108      	bne.n	80a8176 <__aeabi_fmul+0x15e>
 80a8164:	ea80 0001 	eor.w	r0, r0, r1
 80a8168:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 80a816c:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 80a8170:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a8174:	4770      	bx	lr
 80a8176:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 80a817a:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
 80a817e:	4770      	bx	lr

080a8180 <__aeabi_fdiv>:
 80a8180:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80a8184:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 80a8188:	bf1e      	ittt	ne
 80a818a:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 80a818e:	ea92 0f0c 	teqne	r2, ip
 80a8192:	ea93 0f0c 	teqne	r3, ip
 80a8196:	d069      	beq.n	80a826c <__aeabi_fdiv+0xec>
 80a8198:	eba2 0203 	sub.w	r2, r2, r3
 80a819c:	ea80 0c01 	eor.w	ip, r0, r1
 80a81a0:	0249      	lsls	r1, r1, #9
 80a81a2:	ea4f 2040 	mov.w	r0, r0, lsl #9
 80a81a6:	d037      	beq.n	80a8218 <__aeabi_fdiv+0x98>
 80a81a8:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 80a81ac:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
 80a81b0:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
 80a81b4:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 80a81b8:	428b      	cmp	r3, r1
 80a81ba:	bf38      	it	cc
 80a81bc:	005b      	lslcc	r3, r3, #1
 80a81be:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
 80a81c2:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
 80a81c6:	428b      	cmp	r3, r1
 80a81c8:	bf24      	itt	cs
 80a81ca:	1a5b      	subcs	r3, r3, r1
 80a81cc:	ea40 000c 	orrcs.w	r0, r0, ip
 80a81d0:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
 80a81d4:	bf24      	itt	cs
 80a81d6:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
 80a81da:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 80a81de:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
 80a81e2:	bf24      	itt	cs
 80a81e4:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
 80a81e8:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 80a81ec:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
 80a81f0:	bf24      	itt	cs
 80a81f2:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
 80a81f6:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 80a81fa:	011b      	lsls	r3, r3, #4
 80a81fc:	bf18      	it	ne
 80a81fe:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
 80a8202:	d1e0      	bne.n	80a81c6 <__aeabi_fdiv+0x46>
 80a8204:	2afd      	cmp	r2, #253	; 0xfd
 80a8206:	f63f af50 	bhi.w	80a80aa <__aeabi_fmul+0x92>
 80a820a:	428b      	cmp	r3, r1
 80a820c:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80a8210:	bf08      	it	eq
 80a8212:	f020 0001 	biceq.w	r0, r0, #1
 80a8216:	4770      	bx	lr
 80a8218:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 80a821c:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 80a8220:	327f      	adds	r2, #127	; 0x7f
 80a8222:	bfc2      	ittt	gt
 80a8224:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 80a8228:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 80a822c:	4770      	bxgt	lr
 80a822e:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a8232:	f04f 0300 	mov.w	r3, #0
 80a8236:	3a01      	subs	r2, #1
 80a8238:	e737      	b.n	80a80aa <__aeabi_fmul+0x92>
 80a823a:	f092 0f00 	teq	r2, #0
 80a823e:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 80a8242:	bf02      	ittt	eq
 80a8244:	0040      	lsleq	r0, r0, #1
 80a8246:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 80a824a:	3a01      	subeq	r2, #1
 80a824c:	d0f9      	beq.n	80a8242 <__aeabi_fdiv+0xc2>
 80a824e:	ea40 000c 	orr.w	r0, r0, ip
 80a8252:	f093 0f00 	teq	r3, #0
 80a8256:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 80a825a:	bf02      	ittt	eq
 80a825c:	0049      	lsleq	r1, r1, #1
 80a825e:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 80a8262:	3b01      	subeq	r3, #1
 80a8264:	d0f9      	beq.n	80a825a <__aeabi_fdiv+0xda>
 80a8266:	ea41 010c 	orr.w	r1, r1, ip
 80a826a:	e795      	b.n	80a8198 <__aeabi_fdiv+0x18>
 80a826c:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 80a8270:	ea92 0f0c 	teq	r2, ip
 80a8274:	d108      	bne.n	80a8288 <__aeabi_fdiv+0x108>
 80a8276:	0242      	lsls	r2, r0, #9
 80a8278:	f47f af7d 	bne.w	80a8176 <__aeabi_fmul+0x15e>
 80a827c:	ea93 0f0c 	teq	r3, ip
 80a8280:	f47f af70 	bne.w	80a8164 <__aeabi_fmul+0x14c>
 80a8284:	4608      	mov	r0, r1
 80a8286:	e776      	b.n	80a8176 <__aeabi_fmul+0x15e>
 80a8288:	ea93 0f0c 	teq	r3, ip
 80a828c:	d104      	bne.n	80a8298 <__aeabi_fdiv+0x118>
 80a828e:	024b      	lsls	r3, r1, #9
 80a8290:	f43f af4c 	beq.w	80a812c <__aeabi_fmul+0x114>
 80a8294:	4608      	mov	r0, r1
 80a8296:	e76e      	b.n	80a8176 <__aeabi_fmul+0x15e>
 80a8298:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 80a829c:	bf18      	it	ne
 80a829e:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 80a82a2:	d1ca      	bne.n	80a823a <__aeabi_fdiv+0xba>
 80a82a4:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
 80a82a8:	f47f af5c 	bne.w	80a8164 <__aeabi_fmul+0x14c>
 80a82ac:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
 80a82b0:	f47f af3c 	bne.w	80a812c <__aeabi_fmul+0x114>
 80a82b4:	e75f      	b.n	80a8176 <__aeabi_fmul+0x15e>
 80a82b6:	bf00      	nop

080a82b8 <__gesf2>:
 80a82b8:	f04f 3cff 	mov.w	ip, #4294967295	; 0xffffffff
 80a82bc:	e006      	b.n	80a82cc <__cmpsf2+0x4>
 80a82be:	bf00      	nop

080a82c0 <__lesf2>:
 80a82c0:	f04f 0c01 	mov.w	ip, #1
 80a82c4:	e002      	b.n	80a82cc <__cmpsf2+0x4>
 80a82c6:	bf00      	nop

080a82c8 <__cmpsf2>:
 80a82c8:	f04f 0c01 	mov.w	ip, #1
 80a82cc:	f84d cd04 	str.w	ip, [sp, #-4]!
 80a82d0:	ea4f 0240 	mov.w	r2, r0, lsl #1
 80a82d4:	ea4f 0341 	mov.w	r3, r1, lsl #1
 80a82d8:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 80a82dc:	bf18      	it	ne
 80a82de:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80a82e2:	d011      	beq.n	80a8308 <__cmpsf2+0x40>
 80a82e4:	b001      	add	sp, #4
 80a82e6:	ea52 0c53 	orrs.w	ip, r2, r3, lsr #1
 80a82ea:	bf18      	it	ne
 80a82ec:	ea90 0f01 	teqne	r0, r1
 80a82f0:	bf58      	it	pl
 80a82f2:	ebb2 0003 	subspl.w	r0, r2, r3
 80a82f6:	bf88      	it	hi
 80a82f8:	17c8      	asrhi	r0, r1, #31
 80a82fa:	bf38      	it	cc
 80a82fc:	ea6f 70e1 	mvncc.w	r0, r1, asr #31
 80a8300:	bf18      	it	ne
 80a8302:	f040 0001 	orrne.w	r0, r0, #1
 80a8306:	4770      	bx	lr
 80a8308:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 80a830c:	d102      	bne.n	80a8314 <__cmpsf2+0x4c>
 80a830e:	ea5f 2c40 	movs.w	ip, r0, lsl #9
 80a8312:	d105      	bne.n	80a8320 <__cmpsf2+0x58>
 80a8314:	ea7f 6c23 	mvns.w	ip, r3, asr #24
 80a8318:	d1e4      	bne.n	80a82e4 <__cmpsf2+0x1c>
 80a831a:	ea5f 2c41 	movs.w	ip, r1, lsl #9
 80a831e:	d0e1      	beq.n	80a82e4 <__cmpsf2+0x1c>
 80a8320:	f85d 0b04 	ldr.w	r0, [sp], #4
 80a8324:	4770      	bx	lr
 80a8326:	bf00      	nop

080a8328 <__aeabi_cfrcmple>:
 80a8328:	4684      	mov	ip, r0
 80a832a:	4608      	mov	r0, r1
 80a832c:	4661      	mov	r1, ip
 80a832e:	e7ff      	b.n	80a8330 <__aeabi_cfcmpeq>

080a8330 <__aeabi_cfcmpeq>:
 80a8330:	b50f      	push	{r0, r1, r2, r3, lr}
 80a8332:	f7ff ffc9 	bl	80a82c8 <__cmpsf2>
 80a8336:	2800      	cmp	r0, #0
 80a8338:	bf48      	it	mi
 80a833a:	f110 0f00 	cmnmi.w	r0, #0
 80a833e:	bd0f      	pop	{r0, r1, r2, r3, pc}

080a8340 <__aeabi_fcmpeq>:
 80a8340:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a8344:	f7ff fff4 	bl	80a8330 <__aeabi_cfcmpeq>
 80a8348:	bf0c      	ite	eq
 80a834a:	2001      	moveq	r0, #1
 80a834c:	2000      	movne	r0, #0
 80a834e:	f85d fb08 	ldr.w	pc, [sp], #8
 80a8352:	bf00      	nop

080a8354 <__aeabi_fcmplt>:
 80a8354:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a8358:	f7ff ffea 	bl	80a8330 <__aeabi_cfcmpeq>
 80a835c:	bf34      	ite	cc
 80a835e:	2001      	movcc	r0, #1
 80a8360:	2000      	movcs	r0, #0
 80a8362:	f85d fb08 	ldr.w	pc, [sp], #8
 80a8366:	bf00      	nop

080a8368 <__aeabi_fcmple>:
 80a8368:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a836c:	f7ff ffe0 	bl	80a8330 <__aeabi_cfcmpeq>
 80a8370:	bf94      	ite	ls
 80a8372:	2001      	movls	r0, #1
 80a8374:	2000      	movhi	r0, #0
 80a8376:	f85d fb08 	ldr.w	pc, [sp], #8
 80a837a:	bf00      	nop

080a837c <__aeabi_fcmpge>:
 80a837c:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a8380:	f7ff ffd2 	bl	80a8328 <__aeabi_cfrcmple>
 80a8384:	bf94      	ite	ls
 80a8386:	2001      	movls	r0, #1
 80a8388:	2000      	movhi	r0, #0
 80a838a:	f85d fb08 	ldr.w	pc, [sp], #8
 80a838e:	bf00      	nop

080a8390 <__aeabi_fcmpgt>:
 80a8390:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a8394:	f7ff ffc8 	bl	80a8328 <__aeabi_cfrcmple>
 80a8398:	bf34      	ite	cc
 80a839a:	2001      	movcc	r0, #1
 80a839c:	2000      	movcs	r0, #0
 80a839e:	f85d fb08 	ldr.w	pc, [sp], #8
 80a83a2:	bf00      	nop

080a83a4 <__aeabi_f2lz>:
 80a83a4:	b510      	push	{r4, lr}
 80a83a6:	2100      	movs	r1, #0
 80a83a8:	4604      	mov	r4, r0
 80a83aa:	f7ff ffd3 	bl	80a8354 <__aeabi_fcmplt>
 80a83ae:	b920      	cbnz	r0, 80a83ba <__aeabi_f2lz+0x16>
 80a83b0:	4620      	mov	r0, r4
 80a83b2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a83b6:	f000 b809 	b.w	80a83cc <__aeabi_f2ulz>
 80a83ba:	f104 4000 	add.w	r0, r4, #2147483648	; 0x80000000
 80a83be:	f000 f805 	bl	80a83cc <__aeabi_f2ulz>
 80a83c2:	4240      	negs	r0, r0
 80a83c4:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80a83c8:	bd10      	pop	{r4, pc}
 80a83ca:	bf00      	nop

080a83cc <__aeabi_f2ulz>:
 80a83cc:	b5d0      	push	{r4, r6, r7, lr}
 80a83ce:	f7ff fa8b 	bl	80a78e8 <__aeabi_f2d>
 80a83d2:	2200      	movs	r2, #0
 80a83d4:	4b0b      	ldr	r3, [pc, #44]	; (80a8404 <__aeabi_f2ulz+0x38>)
 80a83d6:	4606      	mov	r6, r0
 80a83d8:	460f      	mov	r7, r1
 80a83da:	f7ff fadd 	bl	80a7998 <__aeabi_dmul>
 80a83de:	f7ff fced 	bl	80a7dbc <__aeabi_d2uiz>
 80a83e2:	4604      	mov	r4, r0
 80a83e4:	f7ff fa5e 	bl	80a78a4 <__aeabi_ui2d>
 80a83e8:	2200      	movs	r2, #0
 80a83ea:	4b07      	ldr	r3, [pc, #28]	; (80a8408 <__aeabi_f2ulz+0x3c>)
 80a83ec:	f7ff fad4 	bl	80a7998 <__aeabi_dmul>
 80a83f0:	4602      	mov	r2, r0
 80a83f2:	460b      	mov	r3, r1
 80a83f4:	4630      	mov	r0, r6
 80a83f6:	4639      	mov	r1, r7
 80a83f8:	f7ff f916 	bl	80a7628 <__aeabi_dsub>
 80a83fc:	f7ff fcde 	bl	80a7dbc <__aeabi_d2uiz>
 80a8400:	4621      	mov	r1, r4
 80a8402:	bdd0      	pop	{r4, r6, r7, pc}
 80a8404:	3df00000 	.word	0x3df00000
 80a8408:	41f00000 	.word	0x41f00000

080a840c <__udivmoddi4>:
 80a840c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80a8410:	9e08      	ldr	r6, [sp, #32]
 80a8412:	460d      	mov	r5, r1
 80a8414:	4604      	mov	r4, r0
 80a8416:	468e      	mov	lr, r1
 80a8418:	2b00      	cmp	r3, #0
 80a841a:	f040 8083 	bne.w	80a8524 <__udivmoddi4+0x118>
 80a841e:	428a      	cmp	r2, r1
 80a8420:	4617      	mov	r7, r2
 80a8422:	d947      	bls.n	80a84b4 <__udivmoddi4+0xa8>
 80a8424:	fab2 f382 	clz	r3, r2
 80a8428:	b14b      	cbz	r3, 80a843e <__udivmoddi4+0x32>
 80a842a:	f1c3 0120 	rsb	r1, r3, #32
 80a842e:	fa05 fe03 	lsl.w	lr, r5, r3
 80a8432:	fa20 f101 	lsr.w	r1, r0, r1
 80a8436:	409f      	lsls	r7, r3
 80a8438:	ea41 0e0e 	orr.w	lr, r1, lr
 80a843c:	409c      	lsls	r4, r3
 80a843e:	ea4f 4817 	mov.w	r8, r7, lsr #16
 80a8442:	fbbe fcf8 	udiv	ip, lr, r8
 80a8446:	fa1f f987 	uxth.w	r9, r7
 80a844a:	fb08 e21c 	mls	r2, r8, ip, lr
 80a844e:	fb0c f009 	mul.w	r0, ip, r9
 80a8452:	0c21      	lsrs	r1, r4, #16
 80a8454:	ea41 4202 	orr.w	r2, r1, r2, lsl #16
 80a8458:	4290      	cmp	r0, r2
 80a845a:	d90a      	bls.n	80a8472 <__udivmoddi4+0x66>
 80a845c:	18ba      	adds	r2, r7, r2
 80a845e:	f10c 31ff 	add.w	r1, ip, #4294967295	; 0xffffffff
 80a8462:	f080 8118 	bcs.w	80a8696 <__udivmoddi4+0x28a>
 80a8466:	4290      	cmp	r0, r2
 80a8468:	f240 8115 	bls.w	80a8696 <__udivmoddi4+0x28a>
 80a846c:	f1ac 0c02 	sub.w	ip, ip, #2
 80a8470:	443a      	add	r2, r7
 80a8472:	1a12      	subs	r2, r2, r0
 80a8474:	fbb2 f0f8 	udiv	r0, r2, r8
 80a8478:	fb08 2210 	mls	r2, r8, r0, r2
 80a847c:	fb00 f109 	mul.w	r1, r0, r9
 80a8480:	b2a4      	uxth	r4, r4
 80a8482:	ea44 4402 	orr.w	r4, r4, r2, lsl #16
 80a8486:	42a1      	cmp	r1, r4
 80a8488:	d909      	bls.n	80a849e <__udivmoddi4+0x92>
 80a848a:	193c      	adds	r4, r7, r4
 80a848c:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
 80a8490:	f080 8103 	bcs.w	80a869a <__udivmoddi4+0x28e>
 80a8494:	42a1      	cmp	r1, r4
 80a8496:	f240 8100 	bls.w	80a869a <__udivmoddi4+0x28e>
 80a849a:	3802      	subs	r0, #2
 80a849c:	443c      	add	r4, r7
 80a849e:	1a64      	subs	r4, r4, r1
 80a84a0:	2100      	movs	r1, #0
 80a84a2:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 80a84a6:	b11e      	cbz	r6, 80a84b0 <__udivmoddi4+0xa4>
 80a84a8:	2200      	movs	r2, #0
 80a84aa:	40dc      	lsrs	r4, r3
 80a84ac:	e9c6 4200 	strd	r4, r2, [r6]
 80a84b0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a84b4:	b902      	cbnz	r2, 80a84b8 <__udivmoddi4+0xac>
 80a84b6:	deff      	udf	#255	; 0xff
 80a84b8:	fab2 f382 	clz	r3, r2
 80a84bc:	2b00      	cmp	r3, #0
 80a84be:	d14f      	bne.n	80a8560 <__udivmoddi4+0x154>
 80a84c0:	1a8d      	subs	r5, r1, r2
 80a84c2:	2101      	movs	r1, #1
 80a84c4:	ea4f 4e12 	mov.w	lr, r2, lsr #16
 80a84c8:	fa1f f882 	uxth.w	r8, r2
 80a84cc:	fbb5 fcfe 	udiv	ip, r5, lr
 80a84d0:	fb0e 551c 	mls	r5, lr, ip, r5
 80a84d4:	fb08 f00c 	mul.w	r0, r8, ip
 80a84d8:	0c22      	lsrs	r2, r4, #16
 80a84da:	ea42 4505 	orr.w	r5, r2, r5, lsl #16
 80a84de:	42a8      	cmp	r0, r5
 80a84e0:	d907      	bls.n	80a84f2 <__udivmoddi4+0xe6>
 80a84e2:	197d      	adds	r5, r7, r5
 80a84e4:	f10c 32ff 	add.w	r2, ip, #4294967295	; 0xffffffff
 80a84e8:	d202      	bcs.n	80a84f0 <__udivmoddi4+0xe4>
 80a84ea:	42a8      	cmp	r0, r5
 80a84ec:	f200 80e9 	bhi.w	80a86c2 <__udivmoddi4+0x2b6>
 80a84f0:	4694      	mov	ip, r2
 80a84f2:	1a2d      	subs	r5, r5, r0
 80a84f4:	fbb5 f0fe 	udiv	r0, r5, lr
 80a84f8:	fb0e 5510 	mls	r5, lr, r0, r5
 80a84fc:	fb08 f800 	mul.w	r8, r8, r0
 80a8500:	b2a4      	uxth	r4, r4
 80a8502:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 80a8506:	45a0      	cmp	r8, r4
 80a8508:	d907      	bls.n	80a851a <__udivmoddi4+0x10e>
 80a850a:	193c      	adds	r4, r7, r4
 80a850c:	f100 32ff 	add.w	r2, r0, #4294967295	; 0xffffffff
 80a8510:	d202      	bcs.n	80a8518 <__udivmoddi4+0x10c>
 80a8512:	45a0      	cmp	r8, r4
 80a8514:	f200 80d9 	bhi.w	80a86ca <__udivmoddi4+0x2be>
 80a8518:	4610      	mov	r0, r2
 80a851a:	eba4 0408 	sub.w	r4, r4, r8
 80a851e:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 80a8522:	e7c0      	b.n	80a84a6 <__udivmoddi4+0x9a>
 80a8524:	428b      	cmp	r3, r1
 80a8526:	d908      	bls.n	80a853a <__udivmoddi4+0x12e>
 80a8528:	2e00      	cmp	r6, #0
 80a852a:	f000 80b1 	beq.w	80a8690 <__udivmoddi4+0x284>
 80a852e:	2100      	movs	r1, #0
 80a8530:	e9c6 0500 	strd	r0, r5, [r6]
 80a8534:	4608      	mov	r0, r1
 80a8536:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a853a:	fab3 f183 	clz	r1, r3
 80a853e:	2900      	cmp	r1, #0
 80a8540:	d14b      	bne.n	80a85da <__udivmoddi4+0x1ce>
 80a8542:	42ab      	cmp	r3, r5
 80a8544:	d302      	bcc.n	80a854c <__udivmoddi4+0x140>
 80a8546:	4282      	cmp	r2, r0
 80a8548:	f200 80b9 	bhi.w	80a86be <__udivmoddi4+0x2b2>
 80a854c:	1a84      	subs	r4, r0, r2
 80a854e:	eb65 0303 	sbc.w	r3, r5, r3
 80a8552:	2001      	movs	r0, #1
 80a8554:	469e      	mov	lr, r3
 80a8556:	2e00      	cmp	r6, #0
 80a8558:	d0aa      	beq.n	80a84b0 <__udivmoddi4+0xa4>
 80a855a:	e9c6 4e00 	strd	r4, lr, [r6]
 80a855e:	e7a7      	b.n	80a84b0 <__udivmoddi4+0xa4>
 80a8560:	409f      	lsls	r7, r3
 80a8562:	f1c3 0220 	rsb	r2, r3, #32
 80a8566:	40d1      	lsrs	r1, r2
 80a8568:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 80a856c:	fbb1 f0fe 	udiv	r0, r1, lr
 80a8570:	fa1f f887 	uxth.w	r8, r7
 80a8574:	fb0e 1110 	mls	r1, lr, r0, r1
 80a8578:	fa24 f202 	lsr.w	r2, r4, r2
 80a857c:	409d      	lsls	r5, r3
 80a857e:	fb00 fc08 	mul.w	ip, r0, r8
 80a8582:	432a      	orrs	r2, r5
 80a8584:	0c15      	lsrs	r5, r2, #16
 80a8586:	ea45 4501 	orr.w	r5, r5, r1, lsl #16
 80a858a:	45ac      	cmp	ip, r5
 80a858c:	fa04 f403 	lsl.w	r4, r4, r3
 80a8590:	d909      	bls.n	80a85a6 <__udivmoddi4+0x19a>
 80a8592:	197d      	adds	r5, r7, r5
 80a8594:	f100 31ff 	add.w	r1, r0, #4294967295	; 0xffffffff
 80a8598:	f080 808f 	bcs.w	80a86ba <__udivmoddi4+0x2ae>
 80a859c:	45ac      	cmp	ip, r5
 80a859e:	f240 808c 	bls.w	80a86ba <__udivmoddi4+0x2ae>
 80a85a2:	3802      	subs	r0, #2
 80a85a4:	443d      	add	r5, r7
 80a85a6:	eba5 050c 	sub.w	r5, r5, ip
 80a85aa:	fbb5 f1fe 	udiv	r1, r5, lr
 80a85ae:	fb0e 5c11 	mls	ip, lr, r1, r5
 80a85b2:	fb01 f908 	mul.w	r9, r1, r8
 80a85b6:	b295      	uxth	r5, r2
 80a85b8:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
 80a85bc:	45a9      	cmp	r9, r5
 80a85be:	d907      	bls.n	80a85d0 <__udivmoddi4+0x1c4>
 80a85c0:	197d      	adds	r5, r7, r5
 80a85c2:	f101 32ff 	add.w	r2, r1, #4294967295	; 0xffffffff
 80a85c6:	d274      	bcs.n	80a86b2 <__udivmoddi4+0x2a6>
 80a85c8:	45a9      	cmp	r9, r5
 80a85ca:	d972      	bls.n	80a86b2 <__udivmoddi4+0x2a6>
 80a85cc:	3902      	subs	r1, #2
 80a85ce:	443d      	add	r5, r7
 80a85d0:	eba5 0509 	sub.w	r5, r5, r9
 80a85d4:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 80a85d8:	e778      	b.n	80a84cc <__udivmoddi4+0xc0>
 80a85da:	f1c1 0720 	rsb	r7, r1, #32
 80a85de:	408b      	lsls	r3, r1
 80a85e0:	fa22 fc07 	lsr.w	ip, r2, r7
 80a85e4:	ea4c 0c03 	orr.w	ip, ip, r3
 80a85e8:	fa25 f407 	lsr.w	r4, r5, r7
 80a85ec:	ea4f 4e1c 	mov.w	lr, ip, lsr #16
 80a85f0:	fbb4 f9fe 	udiv	r9, r4, lr
 80a85f4:	fa1f f88c 	uxth.w	r8, ip
 80a85f8:	fb0e 4419 	mls	r4, lr, r9, r4
 80a85fc:	fa20 f307 	lsr.w	r3, r0, r7
 80a8600:	fb09 fa08 	mul.w	sl, r9, r8
 80a8604:	408d      	lsls	r5, r1
 80a8606:	431d      	orrs	r5, r3
 80a8608:	0c2b      	lsrs	r3, r5, #16
 80a860a:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
 80a860e:	45a2      	cmp	sl, r4
 80a8610:	fa02 f201 	lsl.w	r2, r2, r1
 80a8614:	fa00 f301 	lsl.w	r3, r0, r1
 80a8618:	d909      	bls.n	80a862e <__udivmoddi4+0x222>
 80a861a:	eb1c 0404 	adds.w	r4, ip, r4
 80a861e:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
 80a8622:	d248      	bcs.n	80a86b6 <__udivmoddi4+0x2aa>
 80a8624:	45a2      	cmp	sl, r4
 80a8626:	d946      	bls.n	80a86b6 <__udivmoddi4+0x2aa>
 80a8628:	f1a9 0902 	sub.w	r9, r9, #2
 80a862c:	4464      	add	r4, ip
 80a862e:	eba4 040a 	sub.w	r4, r4, sl
 80a8632:	fbb4 f0fe 	udiv	r0, r4, lr
 80a8636:	fb0e 4410 	mls	r4, lr, r0, r4
 80a863a:	fb00 fa08 	mul.w	sl, r0, r8
 80a863e:	b2ad      	uxth	r5, r5
 80a8640:	ea45 4404 	orr.w	r4, r5, r4, lsl #16
 80a8644:	45a2      	cmp	sl, r4
 80a8646:	d908      	bls.n	80a865a <__udivmoddi4+0x24e>
 80a8648:	eb1c 0404 	adds.w	r4, ip, r4
 80a864c:	f100 35ff 	add.w	r5, r0, #4294967295	; 0xffffffff
 80a8650:	d22d      	bcs.n	80a86ae <__udivmoddi4+0x2a2>
 80a8652:	45a2      	cmp	sl, r4
 80a8654:	d92b      	bls.n	80a86ae <__udivmoddi4+0x2a2>
 80a8656:	3802      	subs	r0, #2
 80a8658:	4464      	add	r4, ip
 80a865a:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 80a865e:	fba0 8902 	umull	r8, r9, r0, r2
 80a8662:	eba4 040a 	sub.w	r4, r4, sl
 80a8666:	454c      	cmp	r4, r9
 80a8668:	46c6      	mov	lr, r8
 80a866a:	464d      	mov	r5, r9
 80a866c:	d319      	bcc.n	80a86a2 <__udivmoddi4+0x296>
 80a866e:	d016      	beq.n	80a869e <__udivmoddi4+0x292>
 80a8670:	b15e      	cbz	r6, 80a868a <__udivmoddi4+0x27e>
 80a8672:	ebb3 020e 	subs.w	r2, r3, lr
 80a8676:	eb64 0405 	sbc.w	r4, r4, r5
 80a867a:	fa04 f707 	lsl.w	r7, r4, r7
 80a867e:	fa22 f301 	lsr.w	r3, r2, r1
 80a8682:	431f      	orrs	r7, r3
 80a8684:	40cc      	lsrs	r4, r1
 80a8686:	e9c6 7400 	strd	r7, r4, [r6]
 80a868a:	2100      	movs	r1, #0
 80a868c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a8690:	4631      	mov	r1, r6
 80a8692:	4630      	mov	r0, r6
 80a8694:	e70c      	b.n	80a84b0 <__udivmoddi4+0xa4>
 80a8696:	468c      	mov	ip, r1
 80a8698:	e6eb      	b.n	80a8472 <__udivmoddi4+0x66>
 80a869a:	4610      	mov	r0, r2
 80a869c:	e6ff      	b.n	80a849e <__udivmoddi4+0x92>
 80a869e:	4543      	cmp	r3, r8
 80a86a0:	d2e6      	bcs.n	80a8670 <__udivmoddi4+0x264>
 80a86a2:	ebb8 0e02 	subs.w	lr, r8, r2
 80a86a6:	eb69 050c 	sbc.w	r5, r9, ip
 80a86aa:	3801      	subs	r0, #1
 80a86ac:	e7e0      	b.n	80a8670 <__udivmoddi4+0x264>
 80a86ae:	4628      	mov	r0, r5
 80a86b0:	e7d3      	b.n	80a865a <__udivmoddi4+0x24e>
 80a86b2:	4611      	mov	r1, r2
 80a86b4:	e78c      	b.n	80a85d0 <__udivmoddi4+0x1c4>
 80a86b6:	4681      	mov	r9, r0
 80a86b8:	e7b9      	b.n	80a862e <__udivmoddi4+0x222>
 80a86ba:	4608      	mov	r0, r1
 80a86bc:	e773      	b.n	80a85a6 <__udivmoddi4+0x19a>
 80a86be:	4608      	mov	r0, r1
 80a86c0:	e749      	b.n	80a8556 <__udivmoddi4+0x14a>
 80a86c2:	f1ac 0c02 	sub.w	ip, ip, #2
 80a86c6:	443d      	add	r5, r7
 80a86c8:	e713      	b.n	80a84f2 <__udivmoddi4+0xe6>
 80a86ca:	3802      	subs	r0, #2
 80a86cc:	443c      	add	r4, r7
 80a86ce:	e724      	b.n	80a851a <__udivmoddi4+0x10e>

080a86d0 <__aeabi_idiv0>:
 80a86d0:	4770      	bx	lr
 80a86d2:	bf00      	nop

080a86d4 <atexit>:
 80a86d4:	2300      	movs	r3, #0
 80a86d6:	4601      	mov	r1, r0
 80a86d8:	461a      	mov	r2, r3
 80a86da:	4618      	mov	r0, r3
 80a86dc:	f000 bc8e 	b.w	80a8ffc <__register_exitproc>

080a86e0 <localtime_r>:
 80a86e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a86e4:	460c      	mov	r4, r1
 80a86e6:	4607      	mov	r7, r0
 80a86e8:	f000 fd2e 	bl	80a9148 <__gettzinfo>
 80a86ec:	4621      	mov	r1, r4
 80a86ee:	4680      	mov	r8, r0
 80a86f0:	4638      	mov	r0, r7
 80a86f2:	f000 fd2d 	bl	80a9150 <gmtime_r>
 80a86f6:	6943      	ldr	r3, [r0, #20]
 80a86f8:	4604      	mov	r4, r0
 80a86fa:	079a      	lsls	r2, r3, #30
 80a86fc:	f203 766c 	addw	r6, r3, #1900	; 0x76c
 80a8700:	d105      	bne.n	80a870e <localtime_r+0x2e>
 80a8702:	2264      	movs	r2, #100	; 0x64
 80a8704:	fb96 f3f2 	sdiv	r3, r6, r2
 80a8708:	fb02 6313 	mls	r3, r2, r3, r6
 80a870c:	bb7b      	cbnz	r3, 80a876e <localtime_r+0x8e>
 80a870e:	f44f 73c8 	mov.w	r3, #400	; 0x190
 80a8712:	fb96 f5f3 	sdiv	r5, r6, r3
 80a8716:	fb03 6515 	mls	r5, r3, r5, r6
 80a871a:	fab5 f585 	clz	r5, r5
 80a871e:	096d      	lsrs	r5, r5, #5
 80a8720:	2230      	movs	r2, #48	; 0x30
 80a8722:	4b68      	ldr	r3, [pc, #416]	; (80a88c4 <localtime_r+0x1e4>)
 80a8724:	fb02 3505 	mla	r5, r2, r5, r3
 80a8728:	f000 fad6 	bl	80a8cd8 <__tz_lock>
 80a872c:	f000 fae0 	bl	80a8cf0 <_tzset_unlocked>
 80a8730:	4b65      	ldr	r3, [pc, #404]	; (80a88c8 <localtime_r+0x1e8>)
 80a8732:	681b      	ldr	r3, [r3, #0]
 80a8734:	b353      	cbz	r3, 80a878c <localtime_r+0xac>
 80a8736:	f8d8 3004 	ldr.w	r3, [r8, #4]
 80a873a:	42b3      	cmp	r3, r6
 80a873c:	d119      	bne.n	80a8772 <localtime_r+0x92>
 80a873e:	e9d7 6700 	ldrd	r6, r7, [r7]
 80a8742:	e9d8 2308 	ldrd	r2, r3, [r8, #32]
 80a8746:	f8d8 1000 	ldr.w	r1, [r8]
 80a874a:	b9d1      	cbnz	r1, 80a8782 <localtime_r+0xa2>
 80a874c:	4296      	cmp	r6, r2
 80a874e:	eb77 0303 	sbcs.w	r3, r7, r3
 80a8752:	da23      	bge.n	80a879c <localtime_r+0xbc>
 80a8754:	e9d8 2312 	ldrd	r2, r3, [r8, #72]	; 0x48
 80a8758:	4296      	cmp	r6, r2
 80a875a:	eb77 0303 	sbcs.w	r3, r7, r3
 80a875e:	bfb4      	ite	lt
 80a8760:	2301      	movlt	r3, #1
 80a8762:	2300      	movge	r3, #0
 80a8764:	6223      	str	r3, [r4, #32]
 80a8766:	db1b      	blt.n	80a87a0 <localtime_r+0xc0>
 80a8768:	f8d8 1028 	ldr.w	r1, [r8, #40]	; 0x28
 80a876c:	e01a      	b.n	80a87a4 <localtime_r+0xc4>
 80a876e:	2501      	movs	r5, #1
 80a8770:	e7d6      	b.n	80a8720 <localtime_r+0x40>
 80a8772:	4630      	mov	r0, r6
 80a8774:	f000 fa08 	bl	80a8b88 <__tzcalc_limits>
 80a8778:	2800      	cmp	r0, #0
 80a877a:	d1e0      	bne.n	80a873e <localtime_r+0x5e>
 80a877c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80a8780:	e004      	b.n	80a878c <localtime_r+0xac>
 80a8782:	4296      	cmp	r6, r2
 80a8784:	eb77 0303 	sbcs.w	r3, r7, r3
 80a8788:	da02      	bge.n	80a8790 <localtime_r+0xb0>
 80a878a:	2300      	movs	r3, #0
 80a878c:	6223      	str	r3, [r4, #32]
 80a878e:	e7eb      	b.n	80a8768 <localtime_r+0x88>
 80a8790:	e9d8 2312 	ldrd	r2, r3, [r8, #72]	; 0x48
 80a8794:	4296      	cmp	r6, r2
 80a8796:	eb77 0303 	sbcs.w	r3, r7, r3
 80a879a:	daf6      	bge.n	80a878a <localtime_r+0xaa>
 80a879c:	2301      	movs	r3, #1
 80a879e:	6223      	str	r3, [r4, #32]
 80a87a0:	f8d8 1050 	ldr.w	r1, [r8, #80]	; 0x50
 80a87a4:	f44f 6361 	mov.w	r3, #3600	; 0xe10
 80a87a8:	fb91 f6f3 	sdiv	r6, r1, r3
 80a87ac:	203c      	movs	r0, #60	; 0x3c
 80a87ae:	fb03 1316 	mls	r3, r3, r6, r1
 80a87b2:	fb93 f2f0 	sdiv	r2, r3, r0
 80a87b6:	fb00 3012 	mls	r0, r0, r2, r3
 80a87ba:	6861      	ldr	r1, [r4, #4]
 80a87bc:	6823      	ldr	r3, [r4, #0]
 80a87be:	1a89      	subs	r1, r1, r2
 80a87c0:	68a2      	ldr	r2, [r4, #8]
 80a87c2:	1a1b      	subs	r3, r3, r0
 80a87c4:	1b92      	subs	r2, r2, r6
 80a87c6:	2b3b      	cmp	r3, #59	; 0x3b
 80a87c8:	6023      	str	r3, [r4, #0]
 80a87ca:	6061      	str	r1, [r4, #4]
 80a87cc:	60a2      	str	r2, [r4, #8]
 80a87ce:	dd34      	ble.n	80a883a <localtime_r+0x15a>
 80a87d0:	3101      	adds	r1, #1
 80a87d2:	6061      	str	r1, [r4, #4]
 80a87d4:	3b3c      	subs	r3, #60	; 0x3c
 80a87d6:	6023      	str	r3, [r4, #0]
 80a87d8:	6863      	ldr	r3, [r4, #4]
 80a87da:	2b3b      	cmp	r3, #59	; 0x3b
 80a87dc:	dd33      	ble.n	80a8846 <localtime_r+0x166>
 80a87de:	3201      	adds	r2, #1
 80a87e0:	60a2      	str	r2, [r4, #8]
 80a87e2:	3b3c      	subs	r3, #60	; 0x3c
 80a87e4:	6063      	str	r3, [r4, #4]
 80a87e6:	68a3      	ldr	r3, [r4, #8]
 80a87e8:	2b17      	cmp	r3, #23
 80a87ea:	dd32      	ble.n	80a8852 <localtime_r+0x172>
 80a87ec:	69e2      	ldr	r2, [r4, #28]
 80a87ee:	3b18      	subs	r3, #24
 80a87f0:	3201      	adds	r2, #1
 80a87f2:	61e2      	str	r2, [r4, #28]
 80a87f4:	69a2      	ldr	r2, [r4, #24]
 80a87f6:	60a3      	str	r3, [r4, #8]
 80a87f8:	3201      	adds	r2, #1
 80a87fa:	2a06      	cmp	r2, #6
 80a87fc:	bfc8      	it	gt
 80a87fe:	2200      	movgt	r2, #0
 80a8800:	61a2      	str	r2, [r4, #24]
 80a8802:	68e2      	ldr	r2, [r4, #12]
 80a8804:	6923      	ldr	r3, [r4, #16]
 80a8806:	3201      	adds	r2, #1
 80a8808:	60e2      	str	r2, [r4, #12]
 80a880a:	f855 1023 	ldr.w	r1, [r5, r3, lsl #2]
 80a880e:	428a      	cmp	r2, r1
 80a8810:	dd0e      	ble.n	80a8830 <localtime_r+0x150>
 80a8812:	2b0b      	cmp	r3, #11
 80a8814:	eba2 0201 	sub.w	r2, r2, r1
 80a8818:	60e2      	str	r2, [r4, #12]
 80a881a:	f103 0201 	add.w	r2, r3, #1
 80a881e:	bf05      	ittet	eq
 80a8820:	2200      	moveq	r2, #0
 80a8822:	6963      	ldreq	r3, [r4, #20]
 80a8824:	6122      	strne	r2, [r4, #16]
 80a8826:	3301      	addeq	r3, #1
 80a8828:	bf02      	ittt	eq
 80a882a:	6122      	streq	r2, [r4, #16]
 80a882c:	6163      	streq	r3, [r4, #20]
 80a882e:	61e2      	streq	r2, [r4, #28]
 80a8830:	f000 fa58 	bl	80a8ce4 <__tz_unlock>
 80a8834:	4620      	mov	r0, r4
 80a8836:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a883a:	2b00      	cmp	r3, #0
 80a883c:	dacc      	bge.n	80a87d8 <localtime_r+0xf8>
 80a883e:	3901      	subs	r1, #1
 80a8840:	6061      	str	r1, [r4, #4]
 80a8842:	333c      	adds	r3, #60	; 0x3c
 80a8844:	e7c7      	b.n	80a87d6 <localtime_r+0xf6>
 80a8846:	2b00      	cmp	r3, #0
 80a8848:	dacd      	bge.n	80a87e6 <localtime_r+0x106>
 80a884a:	3a01      	subs	r2, #1
 80a884c:	60a2      	str	r2, [r4, #8]
 80a884e:	333c      	adds	r3, #60	; 0x3c
 80a8850:	e7c8      	b.n	80a87e4 <localtime_r+0x104>
 80a8852:	2b00      	cmp	r3, #0
 80a8854:	daec      	bge.n	80a8830 <localtime_r+0x150>
 80a8856:	69e2      	ldr	r2, [r4, #28]
 80a8858:	3318      	adds	r3, #24
 80a885a:	3a01      	subs	r2, #1
 80a885c:	61e2      	str	r2, [r4, #28]
 80a885e:	69a2      	ldr	r2, [r4, #24]
 80a8860:	60a3      	str	r3, [r4, #8]
 80a8862:	3a01      	subs	r2, #1
 80a8864:	bf48      	it	mi
 80a8866:	2206      	movmi	r2, #6
 80a8868:	61a2      	str	r2, [r4, #24]
 80a886a:	68e2      	ldr	r2, [r4, #12]
 80a886c:	3a01      	subs	r2, #1
 80a886e:	60e2      	str	r2, [r4, #12]
 80a8870:	2a00      	cmp	r2, #0
 80a8872:	d1dd      	bne.n	80a8830 <localtime_r+0x150>
 80a8874:	6923      	ldr	r3, [r4, #16]
 80a8876:	3b01      	subs	r3, #1
 80a8878:	d405      	bmi.n	80a8886 <localtime_r+0x1a6>
 80a887a:	6123      	str	r3, [r4, #16]
 80a887c:	6923      	ldr	r3, [r4, #16]
 80a887e:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
 80a8882:	60e3      	str	r3, [r4, #12]
 80a8884:	e7d4      	b.n	80a8830 <localtime_r+0x150>
 80a8886:	230b      	movs	r3, #11
 80a8888:	6123      	str	r3, [r4, #16]
 80a888a:	6963      	ldr	r3, [r4, #20]
 80a888c:	1e5a      	subs	r2, r3, #1
 80a888e:	6162      	str	r2, [r4, #20]
 80a8890:	f203 726b 	addw	r2, r3, #1899	; 0x76b
 80a8894:	0793      	lsls	r3, r2, #30
 80a8896:	d105      	bne.n	80a88a4 <localtime_r+0x1c4>
 80a8898:	2164      	movs	r1, #100	; 0x64
 80a889a:	fb92 f3f1 	sdiv	r3, r2, r1
 80a889e:	fb01 2313 	mls	r3, r1, r3, r2
 80a88a2:	b963      	cbnz	r3, 80a88be <localtime_r+0x1de>
 80a88a4:	f44f 71c8 	mov.w	r1, #400	; 0x190
 80a88a8:	fb92 f3f1 	sdiv	r3, r2, r1
 80a88ac:	fb01 2313 	mls	r3, r1, r3, r2
 80a88b0:	fab3 f383 	clz	r3, r3
 80a88b4:	095b      	lsrs	r3, r3, #5
 80a88b6:	f503 73b6 	add.w	r3, r3, #364	; 0x16c
 80a88ba:	61e3      	str	r3, [r4, #28]
 80a88bc:	e7de      	b.n	80a887c <localtime_r+0x19c>
 80a88be:	2301      	movs	r3, #1
 80a88c0:	e7f9      	b.n	80a88b6 <localtime_r+0x1d6>
 80a88c2:	bf00      	nop
 80a88c4:	080aa678 	.word	0x080aa678
 80a88c8:	20000ec0 	.word	0x20000ec0

080a88cc <memcpy>:
 80a88cc:	440a      	add	r2, r1
 80a88ce:	4291      	cmp	r1, r2
 80a88d0:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 80a88d4:	d100      	bne.n	80a88d8 <memcpy+0xc>
 80a88d6:	4770      	bx	lr
 80a88d8:	b510      	push	{r4, lr}
 80a88da:	f811 4b01 	ldrb.w	r4, [r1], #1
 80a88de:	4291      	cmp	r1, r2
 80a88e0:	f803 4f01 	strb.w	r4, [r3, #1]!
 80a88e4:	d1f9      	bne.n	80a88da <memcpy+0xe>
 80a88e6:	bd10      	pop	{r4, pc}

080a88e8 <memset>:
 80a88e8:	4603      	mov	r3, r0
 80a88ea:	4402      	add	r2, r0
 80a88ec:	4293      	cmp	r3, r2
 80a88ee:	d100      	bne.n	80a88f2 <memset+0xa>
 80a88f0:	4770      	bx	lr
 80a88f2:	f803 1b01 	strb.w	r1, [r3], #1
 80a88f6:	e7f9      	b.n	80a88ec <memset+0x4>

080a88f8 <srand>:
 80a88f8:	b538      	push	{r3, r4, r5, lr}
 80a88fa:	4b0d      	ldr	r3, [pc, #52]	; (80a8930 <srand+0x38>)
 80a88fc:	4604      	mov	r4, r0
 80a88fe:	681d      	ldr	r5, [r3, #0]
 80a8900:	6bab      	ldr	r3, [r5, #56]	; 0x38
 80a8902:	b97b      	cbnz	r3, 80a8924 <srand+0x2c>
 80a8904:	2018      	movs	r0, #24
 80a8906:	f7fd f8c9 	bl	80a5a9c <malloc>
 80a890a:	4a0a      	ldr	r2, [pc, #40]	; (80a8934 <srand+0x3c>)
 80a890c:	4b0a      	ldr	r3, [pc, #40]	; (80a8938 <srand+0x40>)
 80a890e:	63a8      	str	r0, [r5, #56]	; 0x38
 80a8910:	e9c0 2300 	strd	r2, r3, [r0]
 80a8914:	4b09      	ldr	r3, [pc, #36]	; (80a893c <srand+0x44>)
 80a8916:	2201      	movs	r2, #1
 80a8918:	6083      	str	r3, [r0, #8]
 80a891a:	230b      	movs	r3, #11
 80a891c:	8183      	strh	r3, [r0, #12]
 80a891e:	2300      	movs	r3, #0
 80a8920:	e9c0 2304 	strd	r2, r3, [r0, #16]
 80a8924:	2200      	movs	r2, #0
 80a8926:	6bab      	ldr	r3, [r5, #56]	; 0x38
 80a8928:	611c      	str	r4, [r3, #16]
 80a892a:	615a      	str	r2, [r3, #20]
 80a892c:	bd38      	pop	{r3, r4, r5, pc}
 80a892e:	bf00      	nop
 80a8930:	20000008 	.word	0x20000008
 80a8934:	abcd330e 	.word	0xabcd330e
 80a8938:	e66d1234 	.word	0xe66d1234
 80a893c:	0005deec 	.word	0x0005deec

080a8940 <rand>:
 80a8940:	4b13      	ldr	r3, [pc, #76]	; (80a8990 <rand+0x50>)
 80a8942:	b510      	push	{r4, lr}
 80a8944:	681c      	ldr	r4, [r3, #0]
 80a8946:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80a8948:	b97b      	cbnz	r3, 80a896a <rand+0x2a>
 80a894a:	2018      	movs	r0, #24
 80a894c:	f7fd f8a6 	bl	80a5a9c <malloc>
 80a8950:	4a10      	ldr	r2, [pc, #64]	; (80a8994 <rand+0x54>)
 80a8952:	4b11      	ldr	r3, [pc, #68]	; (80a8998 <rand+0x58>)
 80a8954:	63a0      	str	r0, [r4, #56]	; 0x38
 80a8956:	e9c0 2300 	strd	r2, r3, [r0]
 80a895a:	4b10      	ldr	r3, [pc, #64]	; (80a899c <rand+0x5c>)
 80a895c:	2201      	movs	r2, #1
 80a895e:	6083      	str	r3, [r0, #8]
 80a8960:	230b      	movs	r3, #11
 80a8962:	8183      	strh	r3, [r0, #12]
 80a8964:	2300      	movs	r3, #0
 80a8966:	e9c0 2304 	strd	r2, r3, [r0, #16]
 80a896a:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 80a896c:	480c      	ldr	r0, [pc, #48]	; (80a89a0 <rand+0x60>)
 80a896e:	690a      	ldr	r2, [r1, #16]
 80a8970:	694b      	ldr	r3, [r1, #20]
 80a8972:	4350      	muls	r0, r2
 80a8974:	4c0b      	ldr	r4, [pc, #44]	; (80a89a4 <rand+0x64>)
 80a8976:	fb04 0003 	mla	r0, r4, r3, r0
 80a897a:	fba2 3404 	umull	r3, r4, r2, r4
 80a897e:	1c5a      	adds	r2, r3, #1
 80a8980:	4404      	add	r4, r0
 80a8982:	f144 0000 	adc.w	r0, r4, #0
 80a8986:	e9c1 2004 	strd	r2, r0, [r1, #16]
 80a898a:	f020 4000 	bic.w	r0, r0, #2147483648	; 0x80000000
 80a898e:	bd10      	pop	{r4, pc}
 80a8990:	20000008 	.word	0x20000008
 80a8994:	abcd330e 	.word	0xabcd330e
 80a8998:	e66d1234 	.word	0xe66d1234
 80a899c:	0005deec 	.word	0x0005deec
 80a89a0:	5851f42d 	.word	0x5851f42d
 80a89a4:	4c957f2d 	.word	0x4c957f2d

080a89a8 <strcat>:
 80a89a8:	4602      	mov	r2, r0
 80a89aa:	b510      	push	{r4, lr}
 80a89ac:	7814      	ldrb	r4, [r2, #0]
 80a89ae:	4613      	mov	r3, r2
 80a89b0:	3201      	adds	r2, #1
 80a89b2:	2c00      	cmp	r4, #0
 80a89b4:	d1fa      	bne.n	80a89ac <strcat+0x4>
 80a89b6:	3b01      	subs	r3, #1
 80a89b8:	f811 2b01 	ldrb.w	r2, [r1], #1
 80a89bc:	f803 2f01 	strb.w	r2, [r3, #1]!
 80a89c0:	2a00      	cmp	r2, #0
 80a89c2:	d1f9      	bne.n	80a89b8 <strcat+0x10>
 80a89c4:	bd10      	pop	{r4, pc}

080a89c6 <strcmp>:
 80a89c6:	f810 2b01 	ldrb.w	r2, [r0], #1
 80a89ca:	f811 3b01 	ldrb.w	r3, [r1], #1
 80a89ce:	2a01      	cmp	r2, #1
 80a89d0:	bf28      	it	cs
 80a89d2:	429a      	cmpcs	r2, r3
 80a89d4:	d0f7      	beq.n	80a89c6 <strcmp>
 80a89d6:	1ad0      	subs	r0, r2, r3
 80a89d8:	4770      	bx	lr

080a89da <strcpy>:
 80a89da:	4603      	mov	r3, r0
 80a89dc:	f811 2b01 	ldrb.w	r2, [r1], #1
 80a89e0:	f803 2b01 	strb.w	r2, [r3], #1
 80a89e4:	2a00      	cmp	r2, #0
 80a89e6:	d1f9      	bne.n	80a89dc <strcpy+0x2>
 80a89e8:	4770      	bx	lr
	...

080a89ec <strdup>:
 80a89ec:	4b02      	ldr	r3, [pc, #8]	; (80a89f8 <strdup+0xc>)
 80a89ee:	4601      	mov	r1, r0
 80a89f0:	6818      	ldr	r0, [r3, #0]
 80a89f2:	f000 b803 	b.w	80a89fc <_strdup_r>
 80a89f6:	bf00      	nop
 80a89f8:	20000008 	.word	0x20000008

080a89fc <_strdup_r>:
 80a89fc:	b570      	push	{r4, r5, r6, lr}
 80a89fe:	4604      	mov	r4, r0
 80a8a00:	4608      	mov	r0, r1
 80a8a02:	460d      	mov	r5, r1
 80a8a04:	f000 f80d 	bl	80a8a22 <strlen>
 80a8a08:	1c46      	adds	r6, r0, #1
 80a8a0a:	4631      	mov	r1, r6
 80a8a0c:	4620      	mov	r0, r4
 80a8a0e:	f7fd f875 	bl	80a5afc <_malloc_r>
 80a8a12:	4604      	mov	r4, r0
 80a8a14:	b118      	cbz	r0, 80a8a1e <_strdup_r+0x22>
 80a8a16:	4632      	mov	r2, r6
 80a8a18:	4629      	mov	r1, r5
 80a8a1a:	f7ff ff57 	bl	80a88cc <memcpy>
 80a8a1e:	4620      	mov	r0, r4
 80a8a20:	bd70      	pop	{r4, r5, r6, pc}

080a8a22 <strlen>:
 80a8a22:	4603      	mov	r3, r0
 80a8a24:	f813 2b01 	ldrb.w	r2, [r3], #1
 80a8a28:	2a00      	cmp	r2, #0
 80a8a2a:	d1fb      	bne.n	80a8a24 <strlen+0x2>
 80a8a2c:	1a18      	subs	r0, r3, r0
 80a8a2e:	3801      	subs	r0, #1
 80a8a30:	4770      	bx	lr

080a8a32 <strncmp>:
 80a8a32:	b510      	push	{r4, lr}
 80a8a34:	b16a      	cbz	r2, 80a8a52 <strncmp+0x20>
 80a8a36:	3901      	subs	r1, #1
 80a8a38:	1884      	adds	r4, r0, r2
 80a8a3a:	f810 3b01 	ldrb.w	r3, [r0], #1
 80a8a3e:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 80a8a42:	4293      	cmp	r3, r2
 80a8a44:	d103      	bne.n	80a8a4e <strncmp+0x1c>
 80a8a46:	42a0      	cmp	r0, r4
 80a8a48:	d001      	beq.n	80a8a4e <strncmp+0x1c>
 80a8a4a:	2b00      	cmp	r3, #0
 80a8a4c:	d1f5      	bne.n	80a8a3a <strncmp+0x8>
 80a8a4e:	1a98      	subs	r0, r3, r2
 80a8a50:	bd10      	pop	{r4, pc}
 80a8a52:	4610      	mov	r0, r2
 80a8a54:	e7fc      	b.n	80a8a50 <strncmp+0x1e>

080a8a56 <strncpy>:
 80a8a56:	4603      	mov	r3, r0
 80a8a58:	b510      	push	{r4, lr}
 80a8a5a:	3901      	subs	r1, #1
 80a8a5c:	b132      	cbz	r2, 80a8a6c <strncpy+0x16>
 80a8a5e:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 80a8a62:	3a01      	subs	r2, #1
 80a8a64:	f803 4b01 	strb.w	r4, [r3], #1
 80a8a68:	2c00      	cmp	r4, #0
 80a8a6a:	d1f7      	bne.n	80a8a5c <strncpy+0x6>
 80a8a6c:	2100      	movs	r1, #0
 80a8a6e:	441a      	add	r2, r3
 80a8a70:	4293      	cmp	r3, r2
 80a8a72:	d100      	bne.n	80a8a76 <strncpy+0x20>
 80a8a74:	bd10      	pop	{r4, pc}
 80a8a76:	f803 1b01 	strb.w	r1, [r3], #1
 80a8a7a:	e7f9      	b.n	80a8a70 <strncpy+0x1a>

080a8a7c <_strtoul_l.isra.0>:
 80a8a7c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a8a80:	468c      	mov	ip, r1
 80a8a82:	4686      	mov	lr, r0
 80a8a84:	4e3a      	ldr	r6, [pc, #232]	; (80a8b70 <_strtoul_l.isra.0+0xf4>)
 80a8a86:	4660      	mov	r0, ip
 80a8a88:	f81c 4b01 	ldrb.w	r4, [ip], #1
 80a8a8c:	5da5      	ldrb	r5, [r4, r6]
 80a8a8e:	f015 0508 	ands.w	r5, r5, #8
 80a8a92:	d1f8      	bne.n	80a8a86 <_strtoul_l.isra.0+0xa>
 80a8a94:	2c2d      	cmp	r4, #45	; 0x2d
 80a8a96:	d134      	bne.n	80a8b02 <_strtoul_l.isra.0+0x86>
 80a8a98:	f04f 0801 	mov.w	r8, #1
 80a8a9c:	f89c 4000 	ldrb.w	r4, [ip]
 80a8aa0:	f100 0c02 	add.w	ip, r0, #2
 80a8aa4:	2b00      	cmp	r3, #0
 80a8aa6:	d05e      	beq.n	80a8b66 <_strtoul_l.isra.0+0xea>
 80a8aa8:	2b10      	cmp	r3, #16
 80a8aaa:	d10c      	bne.n	80a8ac6 <_strtoul_l.isra.0+0x4a>
 80a8aac:	2c30      	cmp	r4, #48	; 0x30
 80a8aae:	d10a      	bne.n	80a8ac6 <_strtoul_l.isra.0+0x4a>
 80a8ab0:	f89c 0000 	ldrb.w	r0, [ip]
 80a8ab4:	f000 00df 	and.w	r0, r0, #223	; 0xdf
 80a8ab8:	2858      	cmp	r0, #88	; 0x58
 80a8aba:	d14f      	bne.n	80a8b5c <_strtoul_l.isra.0+0xe0>
 80a8abc:	2310      	movs	r3, #16
 80a8abe:	f89c 4001 	ldrb.w	r4, [ip, #1]
 80a8ac2:	f10c 0c02 	add.w	ip, ip, #2
 80a8ac6:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
 80a8aca:	fbb7 f7f3 	udiv	r7, r7, r3
 80a8ace:	2500      	movs	r5, #0
 80a8ad0:	fb03 f907 	mul.w	r9, r3, r7
 80a8ad4:	4628      	mov	r0, r5
 80a8ad6:	ea6f 0909 	mvn.w	r9, r9
 80a8ada:	f1a4 0630 	sub.w	r6, r4, #48	; 0x30
 80a8ade:	2e09      	cmp	r6, #9
 80a8ae0:	d818      	bhi.n	80a8b14 <_strtoul_l.isra.0+0x98>
 80a8ae2:	4634      	mov	r4, r6
 80a8ae4:	42a3      	cmp	r3, r4
 80a8ae6:	dd24      	ble.n	80a8b32 <_strtoul_l.isra.0+0xb6>
 80a8ae8:	2d00      	cmp	r5, #0
 80a8aea:	db1f      	blt.n	80a8b2c <_strtoul_l.isra.0+0xb0>
 80a8aec:	4287      	cmp	r7, r0
 80a8aee:	d31d      	bcc.n	80a8b2c <_strtoul_l.isra.0+0xb0>
 80a8af0:	d101      	bne.n	80a8af6 <_strtoul_l.isra.0+0x7a>
 80a8af2:	45a1      	cmp	r9, r4
 80a8af4:	db1a      	blt.n	80a8b2c <_strtoul_l.isra.0+0xb0>
 80a8af6:	2501      	movs	r5, #1
 80a8af8:	fb00 4003 	mla	r0, r0, r3, r4
 80a8afc:	f81c 4b01 	ldrb.w	r4, [ip], #1
 80a8b00:	e7eb      	b.n	80a8ada <_strtoul_l.isra.0+0x5e>
 80a8b02:	2c2b      	cmp	r4, #43	; 0x2b
 80a8b04:	bf08      	it	eq
 80a8b06:	f89c 4000 	ldrbeq.w	r4, [ip]
 80a8b0a:	46a8      	mov	r8, r5
 80a8b0c:	bf08      	it	eq
 80a8b0e:	f100 0c02 	addeq.w	ip, r0, #2
 80a8b12:	e7c7      	b.n	80a8aa4 <_strtoul_l.isra.0+0x28>
 80a8b14:	f1a4 0641 	sub.w	r6, r4, #65	; 0x41
 80a8b18:	2e19      	cmp	r6, #25
 80a8b1a:	d801      	bhi.n	80a8b20 <_strtoul_l.isra.0+0xa4>
 80a8b1c:	3c37      	subs	r4, #55	; 0x37
 80a8b1e:	e7e1      	b.n	80a8ae4 <_strtoul_l.isra.0+0x68>
 80a8b20:	f1a4 0661 	sub.w	r6, r4, #97	; 0x61
 80a8b24:	2e19      	cmp	r6, #25
 80a8b26:	d804      	bhi.n	80a8b32 <_strtoul_l.isra.0+0xb6>
 80a8b28:	3c57      	subs	r4, #87	; 0x57
 80a8b2a:	e7db      	b.n	80a8ae4 <_strtoul_l.isra.0+0x68>
 80a8b2c:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
 80a8b30:	e7e4      	b.n	80a8afc <_strtoul_l.isra.0+0x80>
 80a8b32:	2d00      	cmp	r5, #0
 80a8b34:	da07      	bge.n	80a8b46 <_strtoul_l.isra.0+0xca>
 80a8b36:	2322      	movs	r3, #34	; 0x22
 80a8b38:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80a8b3c:	f8ce 3000 	str.w	r3, [lr]
 80a8b40:	b942      	cbnz	r2, 80a8b54 <_strtoul_l.isra.0+0xd8>
 80a8b42:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80a8b46:	f1b8 0f00 	cmp.w	r8, #0
 80a8b4a:	d000      	beq.n	80a8b4e <_strtoul_l.isra.0+0xd2>
 80a8b4c:	4240      	negs	r0, r0
 80a8b4e:	2a00      	cmp	r2, #0
 80a8b50:	d0f7      	beq.n	80a8b42 <_strtoul_l.isra.0+0xc6>
 80a8b52:	b10d      	cbz	r5, 80a8b58 <_strtoul_l.isra.0+0xdc>
 80a8b54:	f10c 31ff 	add.w	r1, ip, #4294967295	; 0xffffffff
 80a8b58:	6011      	str	r1, [r2, #0]
 80a8b5a:	e7f2      	b.n	80a8b42 <_strtoul_l.isra.0+0xc6>
 80a8b5c:	2430      	movs	r4, #48	; 0x30
 80a8b5e:	2b00      	cmp	r3, #0
 80a8b60:	d1b1      	bne.n	80a8ac6 <_strtoul_l.isra.0+0x4a>
 80a8b62:	2308      	movs	r3, #8
 80a8b64:	e7af      	b.n	80a8ac6 <_strtoul_l.isra.0+0x4a>
 80a8b66:	2c30      	cmp	r4, #48	; 0x30
 80a8b68:	d0a2      	beq.n	80a8ab0 <_strtoul_l.isra.0+0x34>
 80a8b6a:	230a      	movs	r3, #10
 80a8b6c:	e7ab      	b.n	80a8ac6 <_strtoul_l.isra.0+0x4a>
 80a8b6e:	bf00      	nop
 80a8b70:	080aa715 	.word	0x080aa715

080a8b74 <strtoul>:
 80a8b74:	4613      	mov	r3, r2
 80a8b76:	460a      	mov	r2, r1
 80a8b78:	4601      	mov	r1, r0
 80a8b7a:	4802      	ldr	r0, [pc, #8]	; (80a8b84 <strtoul+0x10>)
 80a8b7c:	6800      	ldr	r0, [r0, #0]
 80a8b7e:	f7ff bf7d 	b.w	80a8a7c <_strtoul_l.isra.0>
 80a8b82:	bf00      	nop
 80a8b84:	20000008 	.word	0x20000008

080a8b88 <__tzcalc_limits>:
 80a8b88:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a8b8c:	4680      	mov	r8, r0
 80a8b8e:	f000 fadb 	bl	80a9148 <__gettzinfo>
 80a8b92:	f240 73b1 	movw	r3, #1969	; 0x7b1
 80a8b96:	4598      	cmp	r8, r3
 80a8b98:	f340 8097 	ble.w	80a8cca <__tzcalc_limits+0x142>
 80a8b9c:	f46f 63f6 	mvn.w	r3, #1968	; 0x7b0
 80a8ba0:	f240 126d 	movw	r2, #365	; 0x16d
 80a8ba4:	4443      	add	r3, r8
 80a8ba6:	109b      	asrs	r3, r3, #2
 80a8ba8:	f2a8 75b2 	subw	r5, r8, #1970	; 0x7b2
 80a8bac:	fb02 3505 	mla	r5, r2, r5, r3
 80a8bb0:	f06f 0263 	mvn.w	r2, #99	; 0x63
 80a8bb4:	f2a8 736d 	subw	r3, r8, #1901	; 0x76d
 80a8bb8:	fb93 f3f2 	sdiv	r3, r3, r2
 80a8bbc:	f46f 62c8 	mvn.w	r2, #1600	; 0x640
 80a8bc0:	441d      	add	r5, r3
 80a8bc2:	f44f 73c8 	mov.w	r3, #400	; 0x190
 80a8bc6:	4442      	add	r2, r8
 80a8bc8:	fbb2 f2f3 	udiv	r2, r2, r3
 80a8bcc:	fb98 f7f3 	sdiv	r7, r8, r3
 80a8bd0:	4415      	add	r5, r2
 80a8bd2:	2264      	movs	r2, #100	; 0x64
 80a8bd4:	fb03 8717 	mls	r7, r3, r7, r8
 80a8bd8:	fb98 f6f2 	sdiv	r6, r8, r2
 80a8bdc:	fab7 fc87 	clz	ip, r7
 80a8be0:	4604      	mov	r4, r0
 80a8be2:	f04f 0e07 	mov.w	lr, #7
 80a8be6:	fb02 8616 	mls	r6, r2, r6, r8
 80a8bea:	f008 0303 	and.w	r3, r8, #3
 80a8bee:	f8c0 8004 	str.w	r8, [r0, #4]
 80a8bf2:	ea4f 1c5c 	mov.w	ip, ip, lsr #5
 80a8bf6:	f100 0b50 	add.w	fp, r0, #80	; 0x50
 80a8bfa:	9300      	str	r3, [sp, #0]
 80a8bfc:	7a22      	ldrb	r2, [r4, #8]
 80a8bfe:	6963      	ldr	r3, [r4, #20]
 80a8c00:	2a4a      	cmp	r2, #74	; 0x4a
 80a8c02:	d128      	bne.n	80a8c56 <__tzcalc_limits+0xce>
 80a8c04:	9900      	ldr	r1, [sp, #0]
 80a8c06:	18ea      	adds	r2, r5, r3
 80a8c08:	b901      	cbnz	r1, 80a8c0c <__tzcalc_limits+0x84>
 80a8c0a:	b906      	cbnz	r6, 80a8c0e <__tzcalc_limits+0x86>
 80a8c0c:	bb0f      	cbnz	r7, 80a8c52 <__tzcalc_limits+0xca>
 80a8c0e:	2b3b      	cmp	r3, #59	; 0x3b
 80a8c10:	bfd4      	ite	le
 80a8c12:	2300      	movle	r3, #0
 80a8c14:	2301      	movgt	r3, #1
 80a8c16:	4413      	add	r3, r2
 80a8c18:	1e5a      	subs	r2, r3, #1
 80a8c1a:	69a3      	ldr	r3, [r4, #24]
 80a8c1c:	492c      	ldr	r1, [pc, #176]	; (80a8cd0 <__tzcalc_limits+0x148>)
 80a8c1e:	3428      	adds	r4, #40	; 0x28
 80a8c20:	fb01 3202 	mla	r2, r1, r2, r3
 80a8c24:	6823      	ldr	r3, [r4, #0]
 80a8c26:	4413      	add	r3, r2
 80a8c28:	461a      	mov	r2, r3
 80a8c2a:	17db      	asrs	r3, r3, #31
 80a8c2c:	e944 2302 	strd	r2, r3, [r4, #-8]
 80a8c30:	45a3      	cmp	fp, r4
 80a8c32:	d1e3      	bne.n	80a8bfc <__tzcalc_limits+0x74>
 80a8c34:	e9d0 4508 	ldrd	r4, r5, [r0, #32]
 80a8c38:	e9d0 2312 	ldrd	r2, r3, [r0, #72]	; 0x48
 80a8c3c:	4294      	cmp	r4, r2
 80a8c3e:	eb75 0303 	sbcs.w	r3, r5, r3
 80a8c42:	bfb4      	ite	lt
 80a8c44:	2301      	movlt	r3, #1
 80a8c46:	2300      	movge	r3, #0
 80a8c48:	6003      	str	r3, [r0, #0]
 80a8c4a:	2001      	movs	r0, #1
 80a8c4c:	b003      	add	sp, #12
 80a8c4e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a8c52:	2300      	movs	r3, #0
 80a8c54:	e7df      	b.n	80a8c16 <__tzcalc_limits+0x8e>
 80a8c56:	2a44      	cmp	r2, #68	; 0x44
 80a8c58:	d101      	bne.n	80a8c5e <__tzcalc_limits+0xd6>
 80a8c5a:	18ea      	adds	r2, r5, r3
 80a8c5c:	e7dd      	b.n	80a8c1a <__tzcalc_limits+0x92>
 80a8c5e:	9a00      	ldr	r2, [sp, #0]
 80a8c60:	bb6a      	cbnz	r2, 80a8cbe <__tzcalc_limits+0x136>
 80a8c62:	2e00      	cmp	r6, #0
 80a8c64:	bf0c      	ite	eq
 80a8c66:	46e0      	moveq	r8, ip
 80a8c68:	f04f 0801 	movne.w	r8, #1
 80a8c6c:	f04f 0a30 	mov.w	sl, #48	; 0x30
 80a8c70:	68e2      	ldr	r2, [r4, #12]
 80a8c72:	f04f 0900 	mov.w	r9, #0
 80a8c76:	9201      	str	r2, [sp, #4]
 80a8c78:	462a      	mov	r2, r5
 80a8c7a:	4916      	ldr	r1, [pc, #88]	; (80a8cd4 <__tzcalc_limits+0x14c>)
 80a8c7c:	fb0a 1808 	mla	r8, sl, r8, r1
 80a8c80:	f1a8 0804 	sub.w	r8, r8, #4
 80a8c84:	9901      	ldr	r1, [sp, #4]
 80a8c86:	f109 0901 	add.w	r9, r9, #1
 80a8c8a:	4549      	cmp	r1, r9
 80a8c8c:	f858 a029 	ldr.w	sl, [r8, r9, lsl #2]
 80a8c90:	dc17      	bgt.n	80a8cc2 <__tzcalc_limits+0x13a>
 80a8c92:	f102 0804 	add.w	r8, r2, #4
 80a8c96:	fb98 f9fe 	sdiv	r9, r8, lr
 80a8c9a:	ebc9 09c9 	rsb	r9, r9, r9, lsl #3
 80a8c9e:	eba8 0909 	sub.w	r9, r8, r9
 80a8ca2:	ebb3 0909 	subs.w	r9, r3, r9
 80a8ca6:	6923      	ldr	r3, [r4, #16]
 80a8ca8:	bf48      	it	mi
 80a8caa:	f109 0907 	addmi.w	r9, r9, #7
 80a8cae:	3b01      	subs	r3, #1
 80a8cb0:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80a8cb4:	444b      	add	r3, r9
 80a8cb6:	4553      	cmp	r3, sl
 80a8cb8:	da05      	bge.n	80a8cc6 <__tzcalc_limits+0x13e>
 80a8cba:	441a      	add	r2, r3
 80a8cbc:	e7ad      	b.n	80a8c1a <__tzcalc_limits+0x92>
 80a8cbe:	46e0      	mov	r8, ip
 80a8cc0:	e7d4      	b.n	80a8c6c <__tzcalc_limits+0xe4>
 80a8cc2:	4452      	add	r2, sl
 80a8cc4:	e7de      	b.n	80a8c84 <__tzcalc_limits+0xfc>
 80a8cc6:	3b07      	subs	r3, #7
 80a8cc8:	e7f5      	b.n	80a8cb6 <__tzcalc_limits+0x12e>
 80a8cca:	2000      	movs	r0, #0
 80a8ccc:	e7be      	b.n	80a8c4c <__tzcalc_limits+0xc4>
 80a8cce:	bf00      	nop
 80a8cd0:	00015180 	.word	0x00015180
 80a8cd4:	080aa678 	.word	0x080aa678

080a8cd8 <__tz_lock>:
 80a8cd8:	4801      	ldr	r0, [pc, #4]	; (80a8ce0 <__tz_lock+0x8>)
 80a8cda:	f000 bae9 	b.w	80a92b0 <__retarget_lock_acquire>
 80a8cde:	bf00      	nop
 80a8ce0:	20000f63 	.word	0x20000f63

080a8ce4 <__tz_unlock>:
 80a8ce4:	4801      	ldr	r0, [pc, #4]	; (80a8cec <__tz_unlock+0x8>)
 80a8ce6:	f000 bae5 	b.w	80a92b4 <__retarget_lock_release>
 80a8cea:	bf00      	nop
 80a8cec:	20000f63 	.word	0x20000f63

080a8cf0 <_tzset_unlocked>:
 80a8cf0:	4b01      	ldr	r3, [pc, #4]	; (80a8cf8 <_tzset_unlocked+0x8>)
 80a8cf2:	6818      	ldr	r0, [r3, #0]
 80a8cf4:	f000 b802 	b.w	80a8cfc <_tzset_unlocked_r>
 80a8cf8:	20000008 	.word	0x20000008

080a8cfc <_tzset_unlocked_r>:
 80a8cfc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a8d00:	b08d      	sub	sp, #52	; 0x34
 80a8d02:	4607      	mov	r7, r0
 80a8d04:	f000 fa20 	bl	80a9148 <__gettzinfo>
 80a8d08:	49b0      	ldr	r1, [pc, #704]	; (80a8fcc <_tzset_unlocked_r+0x2d0>)
 80a8d0a:	4605      	mov	r5, r0
 80a8d0c:	4638      	mov	r0, r7
 80a8d0e:	f000 fa13 	bl	80a9138 <_getenv_r>
 80a8d12:	4eaf      	ldr	r6, [pc, #700]	; (80a8fd0 <_tzset_unlocked_r+0x2d4>)
 80a8d14:	4604      	mov	r4, r0
 80a8d16:	b970      	cbnz	r0, 80a8d36 <_tzset_unlocked_r+0x3a>
 80a8d18:	4bae      	ldr	r3, [pc, #696]	; (80a8fd4 <_tzset_unlocked_r+0x2d8>)
 80a8d1a:	4aaf      	ldr	r2, [pc, #700]	; (80a8fd8 <_tzset_unlocked_r+0x2dc>)
 80a8d1c:	6018      	str	r0, [r3, #0]
 80a8d1e:	4baf      	ldr	r3, [pc, #700]	; (80a8fdc <_tzset_unlocked_r+0x2e0>)
 80a8d20:	6018      	str	r0, [r3, #0]
 80a8d22:	4baf      	ldr	r3, [pc, #700]	; (80a8fe0 <_tzset_unlocked_r+0x2e4>)
 80a8d24:	6830      	ldr	r0, [r6, #0]
 80a8d26:	e9c3 2200 	strd	r2, r2, [r3]
 80a8d2a:	f7fc febf 	bl	80a5aac <free>
 80a8d2e:	6034      	str	r4, [r6, #0]
 80a8d30:	b00d      	add	sp, #52	; 0x34
 80a8d32:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a8d36:	6831      	ldr	r1, [r6, #0]
 80a8d38:	2900      	cmp	r1, #0
 80a8d3a:	d15f      	bne.n	80a8dfc <_tzset_unlocked_r+0x100>
 80a8d3c:	6830      	ldr	r0, [r6, #0]
 80a8d3e:	f7fc feb5 	bl	80a5aac <free>
 80a8d42:	4620      	mov	r0, r4
 80a8d44:	f7ff fe6d 	bl	80a8a22 <strlen>
 80a8d48:	1c41      	adds	r1, r0, #1
 80a8d4a:	4638      	mov	r0, r7
 80a8d4c:	f7fc fed6 	bl	80a5afc <_malloc_r>
 80a8d50:	6030      	str	r0, [r6, #0]
 80a8d52:	2800      	cmp	r0, #0
 80a8d54:	d157      	bne.n	80a8e06 <_tzset_unlocked_r+0x10a>
 80a8d56:	7823      	ldrb	r3, [r4, #0]
 80a8d58:	ae0a      	add	r6, sp, #40	; 0x28
 80a8d5a:	2b3a      	cmp	r3, #58	; 0x3a
 80a8d5c:	bf08      	it	eq
 80a8d5e:	3401      	addeq	r4, #1
 80a8d60:	4633      	mov	r3, r6
 80a8d62:	4620      	mov	r0, r4
 80a8d64:	4a9f      	ldr	r2, [pc, #636]	; (80a8fe4 <_tzset_unlocked_r+0x2e8>)
 80a8d66:	49a0      	ldr	r1, [pc, #640]	; (80a8fe8 <_tzset_unlocked_r+0x2ec>)
 80a8d68:	f7fc feb0 	bl	80a5acc <siscanf>
 80a8d6c:	2800      	cmp	r0, #0
 80a8d6e:	dddf      	ble.n	80a8d30 <_tzset_unlocked_r+0x34>
 80a8d70:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80a8d72:	18e7      	adds	r7, r4, r3
 80a8d74:	5ce3      	ldrb	r3, [r4, r3]
 80a8d76:	2b2d      	cmp	r3, #45	; 0x2d
 80a8d78:	d149      	bne.n	80a8e0e <_tzset_unlocked_r+0x112>
 80a8d7a:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 80a8d7e:	3701      	adds	r7, #1
 80a8d80:	f04f 0800 	mov.w	r8, #0
 80a8d84:	f10d 0a20 	add.w	sl, sp, #32
 80a8d88:	f10d 0b1e 	add.w	fp, sp, #30
 80a8d8c:	4633      	mov	r3, r6
 80a8d8e:	4638      	mov	r0, r7
 80a8d90:	e9cd 6a01 	strd	r6, sl, [sp, #4]
 80a8d94:	4995      	ldr	r1, [pc, #596]	; (80a8fec <_tzset_unlocked_r+0x2f0>)
 80a8d96:	9603      	str	r6, [sp, #12]
 80a8d98:	f8cd b000 	str.w	fp, [sp]
 80a8d9c:	aa07      	add	r2, sp, #28
 80a8d9e:	f8ad 801e 	strh.w	r8, [sp, #30]
 80a8da2:	f8ad 8020 	strh.w	r8, [sp, #32]
 80a8da6:	f7fc fe91 	bl	80a5acc <siscanf>
 80a8daa:	4540      	cmp	r0, r8
 80a8dac:	ddc0      	ble.n	80a8d30 <_tzset_unlocked_r+0x34>
 80a8dae:	213c      	movs	r1, #60	; 0x3c
 80a8db0:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 80a8db4:	f8bd 2020 	ldrh.w	r2, [sp, #32]
 80a8db8:	f8df 923c 	ldr.w	r9, [pc, #572]	; 80a8ff8 <_tzset_unlocked_r+0x2fc>
 80a8dbc:	fb01 2203 	mla	r2, r1, r3, r2
 80a8dc0:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 80a8dc4:	f8bd 301c 	ldrh.w	r3, [sp, #28]
 80a8dc8:	fb01 2303 	mla	r3, r1, r3, r2
 80a8dcc:	435c      	muls	r4, r3
 80a8dce:	4b85      	ldr	r3, [pc, #532]	; (80a8fe4 <_tzset_unlocked_r+0x2e8>)
 80a8dd0:	62ac      	str	r4, [r5, #40]	; 0x28
 80a8dd2:	4c83      	ldr	r4, [pc, #524]	; (80a8fe0 <_tzset_unlocked_r+0x2e4>)
 80a8dd4:	464a      	mov	r2, r9
 80a8dd6:	6023      	str	r3, [r4, #0]
 80a8dd8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80a8dda:	4983      	ldr	r1, [pc, #524]	; (80a8fe8 <_tzset_unlocked_r+0x2ec>)
 80a8ddc:	441f      	add	r7, r3
 80a8dde:	4638      	mov	r0, r7
 80a8de0:	4633      	mov	r3, r6
 80a8de2:	f7fc fe73 	bl	80a5acc <siscanf>
 80a8de6:	4540      	cmp	r0, r8
 80a8de8:	dc17      	bgt.n	80a8e1a <_tzset_unlocked_r+0x11e>
 80a8dea:	6823      	ldr	r3, [r4, #0]
 80a8dec:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 80a8dee:	6063      	str	r3, [r4, #4]
 80a8df0:	4b78      	ldr	r3, [pc, #480]	; (80a8fd4 <_tzset_unlocked_r+0x2d8>)
 80a8df2:	601a      	str	r2, [r3, #0]
 80a8df4:	4b79      	ldr	r3, [pc, #484]	; (80a8fdc <_tzset_unlocked_r+0x2e0>)
 80a8df6:	f8c3 8000 	str.w	r8, [r3]
 80a8dfa:	e799      	b.n	80a8d30 <_tzset_unlocked_r+0x34>
 80a8dfc:	f7ff fde3 	bl	80a89c6 <strcmp>
 80a8e00:	2800      	cmp	r0, #0
 80a8e02:	d19b      	bne.n	80a8d3c <_tzset_unlocked_r+0x40>
 80a8e04:	e794      	b.n	80a8d30 <_tzset_unlocked_r+0x34>
 80a8e06:	4621      	mov	r1, r4
 80a8e08:	f7ff fde7 	bl	80a89da <strcpy>
 80a8e0c:	e7a3      	b.n	80a8d56 <_tzset_unlocked_r+0x5a>
 80a8e0e:	2b2b      	cmp	r3, #43	; 0x2b
 80a8e10:	f04f 0401 	mov.w	r4, #1
 80a8e14:	bf08      	it	eq
 80a8e16:	3701      	addeq	r7, #1
 80a8e18:	e7b2      	b.n	80a8d80 <_tzset_unlocked_r+0x84>
 80a8e1a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80a8e1c:	f8c4 9004 	str.w	r9, [r4, #4]
 80a8e20:	18fc      	adds	r4, r7, r3
 80a8e22:	5cfb      	ldrb	r3, [r7, r3]
 80a8e24:	2b2d      	cmp	r3, #45	; 0x2d
 80a8e26:	f040 808c 	bne.w	80a8f42 <_tzset_unlocked_r+0x246>
 80a8e2a:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
 80a8e2e:	3401      	adds	r4, #1
 80a8e30:	2300      	movs	r3, #0
 80a8e32:	4620      	mov	r0, r4
 80a8e34:	f8ad 301c 	strh.w	r3, [sp, #28]
 80a8e38:	f8ad 301e 	strh.w	r3, [sp, #30]
 80a8e3c:	f8ad 3020 	strh.w	r3, [sp, #32]
 80a8e40:	930a      	str	r3, [sp, #40]	; 0x28
 80a8e42:	e9cd a602 	strd	sl, r6, [sp, #8]
 80a8e46:	4633      	mov	r3, r6
 80a8e48:	e9cd b600 	strd	fp, r6, [sp]
 80a8e4c:	4967      	ldr	r1, [pc, #412]	; (80a8fec <_tzset_unlocked_r+0x2f0>)
 80a8e4e:	aa07      	add	r2, sp, #28
 80a8e50:	f7fc fe3c 	bl	80a5acc <siscanf>
 80a8e54:	2800      	cmp	r0, #0
 80a8e56:	dc7a      	bgt.n	80a8f4e <_tzset_unlocked_r+0x252>
 80a8e58:	6aaf      	ldr	r7, [r5, #40]	; 0x28
 80a8e5a:	f5a7 6761 	sub.w	r7, r7, #3600	; 0xe10
 80a8e5e:	652f      	str	r7, [r5, #80]	; 0x50
 80a8e60:	f04f 0900 	mov.w	r9, #0
 80a8e64:	462f      	mov	r7, r5
 80a8e66:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80a8e68:	441c      	add	r4, r3
 80a8e6a:	7823      	ldrb	r3, [r4, #0]
 80a8e6c:	2b2c      	cmp	r3, #44	; 0x2c
 80a8e6e:	bf08      	it	eq
 80a8e70:	3401      	addeq	r4, #1
 80a8e72:	f894 8000 	ldrb.w	r8, [r4]
 80a8e76:	f1b8 0f4d 	cmp.w	r8, #77	; 0x4d
 80a8e7a:	d17a      	bne.n	80a8f72 <_tzset_unlocked_r+0x276>
 80a8e7c:	f10d 0326 	add.w	r3, sp, #38	; 0x26
 80a8e80:	e9cd 6301 	strd	r6, r3, [sp, #4]
 80a8e84:	ab09      	add	r3, sp, #36	; 0x24
 80a8e86:	9300      	str	r3, [sp, #0]
 80a8e88:	4620      	mov	r0, r4
 80a8e8a:	4633      	mov	r3, r6
 80a8e8c:	4958      	ldr	r1, [pc, #352]	; (80a8ff0 <_tzset_unlocked_r+0x2f4>)
 80a8e8e:	9603      	str	r6, [sp, #12]
 80a8e90:	f10d 0222 	add.w	r2, sp, #34	; 0x22
 80a8e94:	f7fc fe1a 	bl	80a5acc <siscanf>
 80a8e98:	2803      	cmp	r0, #3
 80a8e9a:	f47f af49 	bne.w	80a8d30 <_tzset_unlocked_r+0x34>
 80a8e9e:	f8bd 1022 	ldrh.w	r1, [sp, #34]	; 0x22
 80a8ea2:	1e4b      	subs	r3, r1, #1
 80a8ea4:	2b0b      	cmp	r3, #11
 80a8ea6:	f63f af43 	bhi.w	80a8d30 <_tzset_unlocked_r+0x34>
 80a8eaa:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
 80a8eae:	1e53      	subs	r3, r2, #1
 80a8eb0:	2b04      	cmp	r3, #4
 80a8eb2:	f63f af3d 	bhi.w	80a8d30 <_tzset_unlocked_r+0x34>
 80a8eb6:	f8bd 3026 	ldrh.w	r3, [sp, #38]	; 0x26
 80a8eba:	2b06      	cmp	r3, #6
 80a8ebc:	f63f af38 	bhi.w	80a8d30 <_tzset_unlocked_r+0x34>
 80a8ec0:	e9c7 1203 	strd	r1, r2, [r7, #12]
 80a8ec4:	f887 8008 	strb.w	r8, [r7, #8]
 80a8ec8:	617b      	str	r3, [r7, #20]
 80a8eca:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80a8ecc:	eb04 0803 	add.w	r8, r4, r3
 80a8ed0:	2302      	movs	r3, #2
 80a8ed2:	f8ad 301c 	strh.w	r3, [sp, #28]
 80a8ed6:	2300      	movs	r3, #0
 80a8ed8:	f8ad 301e 	strh.w	r3, [sp, #30]
 80a8edc:	f8ad 3020 	strh.w	r3, [sp, #32]
 80a8ee0:	930a      	str	r3, [sp, #40]	; 0x28
 80a8ee2:	f898 3000 	ldrb.w	r3, [r8]
 80a8ee6:	2b2f      	cmp	r3, #47	; 0x2f
 80a8ee8:	d109      	bne.n	80a8efe <_tzset_unlocked_r+0x202>
 80a8eea:	4633      	mov	r3, r6
 80a8eec:	4640      	mov	r0, r8
 80a8eee:	e9cd a602 	strd	sl, r6, [sp, #8]
 80a8ef2:	e9cd b600 	strd	fp, r6, [sp]
 80a8ef6:	493f      	ldr	r1, [pc, #252]	; (80a8ff4 <_tzset_unlocked_r+0x2f8>)
 80a8ef8:	aa07      	add	r2, sp, #28
 80a8efa:	f7fc fde7 	bl	80a5acc <siscanf>
 80a8efe:	213c      	movs	r1, #60	; 0x3c
 80a8f00:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 80a8f04:	f8bd 2020 	ldrh.w	r2, [sp, #32]
 80a8f08:	3728      	adds	r7, #40	; 0x28
 80a8f0a:	fb01 2203 	mla	r2, r1, r3, r2
 80a8f0e:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 80a8f12:	f8bd 301c 	ldrh.w	r3, [sp, #28]
 80a8f16:	fb01 2303 	mla	r3, r1, r3, r2
 80a8f1a:	f847 3c10 	str.w	r3, [r7, #-16]
 80a8f1e:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 80a8f20:	4444      	add	r4, r8
 80a8f22:	f1b9 0f00 	cmp.w	r9, #0
 80a8f26:	d021      	beq.n	80a8f6c <_tzset_unlocked_r+0x270>
 80a8f28:	6868      	ldr	r0, [r5, #4]
 80a8f2a:	f7ff fe2d 	bl	80a8b88 <__tzcalc_limits>
 80a8f2e:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 80a8f30:	4b28      	ldr	r3, [pc, #160]	; (80a8fd4 <_tzset_unlocked_r+0x2d8>)
 80a8f32:	601a      	str	r2, [r3, #0]
 80a8f34:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 80a8f36:	1a9b      	subs	r3, r3, r2
 80a8f38:	bf18      	it	ne
 80a8f3a:	2301      	movne	r3, #1
 80a8f3c:	4a27      	ldr	r2, [pc, #156]	; (80a8fdc <_tzset_unlocked_r+0x2e0>)
 80a8f3e:	6013      	str	r3, [r2, #0]
 80a8f40:	e6f6      	b.n	80a8d30 <_tzset_unlocked_r+0x34>
 80a8f42:	2b2b      	cmp	r3, #43	; 0x2b
 80a8f44:	f04f 0701 	mov.w	r7, #1
 80a8f48:	bf08      	it	eq
 80a8f4a:	3401      	addeq	r4, #1
 80a8f4c:	e770      	b.n	80a8e30 <_tzset_unlocked_r+0x134>
 80a8f4e:	213c      	movs	r1, #60	; 0x3c
 80a8f50:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 80a8f54:	f8bd 2020 	ldrh.w	r2, [sp, #32]
 80a8f58:	fb01 2203 	mla	r2, r1, r3, r2
 80a8f5c:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 80a8f60:	f8bd 301c 	ldrh.w	r3, [sp, #28]
 80a8f64:	fb01 2303 	mla	r3, r1, r3, r2
 80a8f68:	435f      	muls	r7, r3
 80a8f6a:	e778      	b.n	80a8e5e <_tzset_unlocked_r+0x162>
 80a8f6c:	f04f 0901 	mov.w	r9, #1
 80a8f70:	e77b      	b.n	80a8e6a <_tzset_unlocked_r+0x16e>
 80a8f72:	f1b8 0f4a 	cmp.w	r8, #74	; 0x4a
 80a8f76:	bf0a      	itet	eq
 80a8f78:	4643      	moveq	r3, r8
 80a8f7a:	2344      	movne	r3, #68	; 0x44
 80a8f7c:	3401      	addeq	r4, #1
 80a8f7e:	220a      	movs	r2, #10
 80a8f80:	4620      	mov	r0, r4
 80a8f82:	a90b      	add	r1, sp, #44	; 0x2c
 80a8f84:	9305      	str	r3, [sp, #20]
 80a8f86:	f7ff fdf5 	bl	80a8b74 <strtoul>
 80a8f8a:	f8dd 802c 	ldr.w	r8, [sp, #44]	; 0x2c
 80a8f8e:	9b05      	ldr	r3, [sp, #20]
 80a8f90:	45a0      	cmp	r8, r4
 80a8f92:	f8ad 0026 	strh.w	r0, [sp, #38]	; 0x26
 80a8f96:	d114      	bne.n	80a8fc2 <_tzset_unlocked_r+0x2c6>
 80a8f98:	234d      	movs	r3, #77	; 0x4d
 80a8f9a:	f1b9 0f00 	cmp.w	r9, #0
 80a8f9e:	d107      	bne.n	80a8fb0 <_tzset_unlocked_r+0x2b4>
 80a8fa0:	2103      	movs	r1, #3
 80a8fa2:	722b      	strb	r3, [r5, #8]
 80a8fa4:	2302      	movs	r3, #2
 80a8fa6:	f8c5 9014 	str.w	r9, [r5, #20]
 80a8faa:	e9c5 1303 	strd	r1, r3, [r5, #12]
 80a8fae:	e78f      	b.n	80a8ed0 <_tzset_unlocked_r+0x1d4>
 80a8fb0:	220b      	movs	r2, #11
 80a8fb2:	f885 3030 	strb.w	r3, [r5, #48]	; 0x30
 80a8fb6:	2301      	movs	r3, #1
 80a8fb8:	e9c5 230d 	strd	r2, r3, [r5, #52]	; 0x34
 80a8fbc:	2300      	movs	r3, #0
 80a8fbe:	63eb      	str	r3, [r5, #60]	; 0x3c
 80a8fc0:	e786      	b.n	80a8ed0 <_tzset_unlocked_r+0x1d4>
 80a8fc2:	b280      	uxth	r0, r0
 80a8fc4:	723b      	strb	r3, [r7, #8]
 80a8fc6:	6178      	str	r0, [r7, #20]
 80a8fc8:	e782      	b.n	80a8ed0 <_tzset_unlocked_r+0x1d4>
 80a8fca:	bf00      	nop
 80a8fcc:	080aa6d8 	.word	0x080aa6d8
 80a8fd0:	20000ebc 	.word	0x20000ebc
 80a8fd4:	20000ec4 	.word	0x20000ec4
 80a8fd8:	080aa6db 	.word	0x080aa6db
 80a8fdc:	20000ec0 	.word	0x20000ec0
 80a8fe0:	2000006c 	.word	0x2000006c
 80a8fe4:	20000eaf 	.word	0x20000eaf
 80a8fe8:	080aa6df 	.word	0x080aa6df
 80a8fec:	080aa702 	.word	0x080aa702
 80a8ff0:	080aa6ee 	.word	0x080aa6ee
 80a8ff4:	080aa701 	.word	0x080aa701
 80a8ff8:	20000ea4 	.word	0x20000ea4

080a8ffc <__register_exitproc>:
 80a8ffc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80a9000:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 80a90c0 <__register_exitproc+0xc4>
 80a9004:	4606      	mov	r6, r0
 80a9006:	f8d8 0000 	ldr.w	r0, [r8]
 80a900a:	461f      	mov	r7, r3
 80a900c:	460d      	mov	r5, r1
 80a900e:	4691      	mov	r9, r2
 80a9010:	f000 f94f 	bl	80a92b2 <__retarget_lock_acquire_recursive>
 80a9014:	4b26      	ldr	r3, [pc, #152]	; (80a90b0 <__register_exitproc+0xb4>)
 80a9016:	681c      	ldr	r4, [r3, #0]
 80a9018:	b934      	cbnz	r4, 80a9028 <__register_exitproc+0x2c>
 80a901a:	4c26      	ldr	r4, [pc, #152]	; (80a90b4 <__register_exitproc+0xb8>)
 80a901c:	601c      	str	r4, [r3, #0]
 80a901e:	4b26      	ldr	r3, [pc, #152]	; (80a90b8 <__register_exitproc+0xbc>)
 80a9020:	b113      	cbz	r3, 80a9028 <__register_exitproc+0x2c>
 80a9022:	681b      	ldr	r3, [r3, #0]
 80a9024:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
 80a9028:	6863      	ldr	r3, [r4, #4]
 80a902a:	2b1f      	cmp	r3, #31
 80a902c:	dd07      	ble.n	80a903e <__register_exitproc+0x42>
 80a902e:	f8d8 0000 	ldr.w	r0, [r8]
 80a9032:	f000 f940 	bl	80a92b6 <__retarget_lock_release_recursive>
 80a9036:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80a903a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80a903e:	b35e      	cbz	r6, 80a9098 <__register_exitproc+0x9c>
 80a9040:	f8d4 0088 	ldr.w	r0, [r4, #136]	; 0x88
 80a9044:	b988      	cbnz	r0, 80a906a <__register_exitproc+0x6e>
 80a9046:	4b1d      	ldr	r3, [pc, #116]	; (80a90bc <__register_exitproc+0xc0>)
 80a9048:	b923      	cbnz	r3, 80a9054 <__register_exitproc+0x58>
 80a904a:	f8d8 0000 	ldr.w	r0, [r8]
 80a904e:	f000 f931 	bl	80a92b4 <__retarget_lock_release>
 80a9052:	e7f0      	b.n	80a9036 <__register_exitproc+0x3a>
 80a9054:	f44f 7084 	mov.w	r0, #264	; 0x108
 80a9058:	f7fc fd20 	bl	80a5a9c <malloc>
 80a905c:	2800      	cmp	r0, #0
 80a905e:	d0f4      	beq.n	80a904a <__register_exitproc+0x4e>
 80a9060:	2300      	movs	r3, #0
 80a9062:	e9c0 3340 	strd	r3, r3, [r0, #256]	; 0x100
 80a9066:	f8c4 0088 	str.w	r0, [r4, #136]	; 0x88
 80a906a:	2201      	movs	r2, #1
 80a906c:	6863      	ldr	r3, [r4, #4]
 80a906e:	2e02      	cmp	r6, #2
 80a9070:	f840 9023 	str.w	r9, [r0, r3, lsl #2]
 80a9074:	fa02 f203 	lsl.w	r2, r2, r3
 80a9078:	eb00 0183 	add.w	r1, r0, r3, lsl #2
 80a907c:	f8d0 3100 	ldr.w	r3, [r0, #256]	; 0x100
 80a9080:	ea43 0302 	orr.w	r3, r3, r2
 80a9084:	f8c0 3100 	str.w	r3, [r0, #256]	; 0x100
 80a9088:	f8c1 7080 	str.w	r7, [r1, #128]	; 0x80
 80a908c:	bf02      	ittt	eq
 80a908e:	f8d0 3104 	ldreq.w	r3, [r0, #260]	; 0x104
 80a9092:	431a      	orreq	r2, r3
 80a9094:	f8c0 2104 	streq.w	r2, [r0, #260]	; 0x104
 80a9098:	6863      	ldr	r3, [r4, #4]
 80a909a:	f8d8 0000 	ldr.w	r0, [r8]
 80a909e:	1c5a      	adds	r2, r3, #1
 80a90a0:	3302      	adds	r3, #2
 80a90a2:	6062      	str	r2, [r4, #4]
 80a90a4:	f844 5023 	str.w	r5, [r4, r3, lsl #2]
 80a90a8:	f000 f905 	bl	80a92b6 <__retarget_lock_release_recursive>
 80a90ac:	2000      	movs	r0, #0
 80a90ae:	e7c4      	b.n	80a903a <__register_exitproc+0x3e>
 80a90b0:	20000f54 	.word	0x20000f54
 80a90b4:	20000ec8 	.word	0x20000ec8
 80a90b8:	00000000 	.word	0x00000000
 80a90bc:	080a5a9d 	.word	0x080a5a9d
 80a90c0:	20000074 	.word	0x20000074

080a90c4 <_findenv_r>:
 80a90c4:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a90c8:	4607      	mov	r7, r0
 80a90ca:	4689      	mov	r9, r1
 80a90cc:	4616      	mov	r6, r2
 80a90ce:	f000 f8f3 	bl	80a92b8 <__env_lock>
 80a90d2:	4b18      	ldr	r3, [pc, #96]	; (80a9134 <_findenv_r+0x70>)
 80a90d4:	681c      	ldr	r4, [r3, #0]
 80a90d6:	469a      	mov	sl, r3
 80a90d8:	b134      	cbz	r4, 80a90e8 <_findenv_r+0x24>
 80a90da:	464b      	mov	r3, r9
 80a90dc:	4698      	mov	r8, r3
 80a90de:	f813 1b01 	ldrb.w	r1, [r3], #1
 80a90e2:	b139      	cbz	r1, 80a90f4 <_findenv_r+0x30>
 80a90e4:	293d      	cmp	r1, #61	; 0x3d
 80a90e6:	d1f9      	bne.n	80a90dc <_findenv_r+0x18>
 80a90e8:	4638      	mov	r0, r7
 80a90ea:	f000 f8eb 	bl	80a92c4 <__env_unlock>
 80a90ee:	2000      	movs	r0, #0
 80a90f0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a90f4:	eba8 0809 	sub.w	r8, r8, r9
 80a90f8:	46a3      	mov	fp, r4
 80a90fa:	f854 0b04 	ldr.w	r0, [r4], #4
 80a90fe:	2800      	cmp	r0, #0
 80a9100:	d0f2      	beq.n	80a90e8 <_findenv_r+0x24>
 80a9102:	4642      	mov	r2, r8
 80a9104:	4649      	mov	r1, r9
 80a9106:	f7ff fc94 	bl	80a8a32 <strncmp>
 80a910a:	2800      	cmp	r0, #0
 80a910c:	d1f4      	bne.n	80a90f8 <_findenv_r+0x34>
 80a910e:	f854 3c04 	ldr.w	r3, [r4, #-4]
 80a9112:	eb03 0508 	add.w	r5, r3, r8
 80a9116:	f813 3008 	ldrb.w	r3, [r3, r8]
 80a911a:	2b3d      	cmp	r3, #61	; 0x3d
 80a911c:	d1ec      	bne.n	80a90f8 <_findenv_r+0x34>
 80a911e:	f8da 3000 	ldr.w	r3, [sl]
 80a9122:	4638      	mov	r0, r7
 80a9124:	ebab 0303 	sub.w	r3, fp, r3
 80a9128:	109b      	asrs	r3, r3, #2
 80a912a:	6033      	str	r3, [r6, #0]
 80a912c:	f000 f8ca 	bl	80a92c4 <__env_unlock>
 80a9130:	1c68      	adds	r0, r5, #1
 80a9132:	e7dd      	b.n	80a90f0 <_findenv_r+0x2c>
 80a9134:	200000d0 	.word	0x200000d0

080a9138 <_getenv_r>:
 80a9138:	b507      	push	{r0, r1, r2, lr}
 80a913a:	aa01      	add	r2, sp, #4
 80a913c:	f7ff ffc2 	bl	80a90c4 <_findenv_r>
 80a9140:	b003      	add	sp, #12
 80a9142:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080a9148 <__gettzinfo>:
 80a9148:	4800      	ldr	r0, [pc, #0]	; (80a914c <__gettzinfo+0x4>)
 80a914a:	4770      	bx	lr
 80a914c:	20000078 	.word	0x20000078

080a9150 <gmtime_r>:
 80a9150:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a9154:	e9d0 6700 	ldrd	r6, r7, [r0]
 80a9158:	460c      	mov	r4, r1
 80a915a:	2300      	movs	r3, #0
 80a915c:	4630      	mov	r0, r6
 80a915e:	4639      	mov	r1, r7
 80a9160:	4a4f      	ldr	r2, [pc, #316]	; (80a92a0 <gmtime_r+0x150>)
 80a9162:	f000 f8b5 	bl	80a92d0 <__aeabi_ldivmod>
 80a9166:	4639      	mov	r1, r7
 80a9168:	4605      	mov	r5, r0
 80a916a:	2300      	movs	r3, #0
 80a916c:	4630      	mov	r0, r6
 80a916e:	4a4c      	ldr	r2, [pc, #304]	; (80a92a0 <gmtime_r+0x150>)
 80a9170:	f000 f8ae 	bl	80a92d0 <__aeabi_ldivmod>
 80a9174:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 80a9178:	2a00      	cmp	r2, #0
 80a917a:	bfbc      	itt	lt
 80a917c:	f502 32a8 	addlt.w	r2, r2, #86016	; 0x15000
 80a9180:	f502 72c0 	addlt.w	r2, r2, #384	; 0x180
 80a9184:	fbb2 f3f1 	udiv	r3, r2, r1
 80a9188:	fb01 2213 	mls	r2, r1, r3, r2
 80a918c:	f04f 013c 	mov.w	r1, #60	; 0x3c
 80a9190:	60a3      	str	r3, [r4, #8]
 80a9192:	fbb2 f3f1 	udiv	r3, r2, r1
 80a9196:	fb01 2213 	mls	r2, r1, r3, r2
 80a919a:	6022      	str	r2, [r4, #0]
 80a919c:	f04f 0207 	mov.w	r2, #7
 80a91a0:	f505 202f 	add.w	r0, r5, #716800	; 0xaf000
 80a91a4:	bfac      	ite	ge
 80a91a6:	f600 206c 	addwge	r0, r0, #2668	; 0xa6c
 80a91aa:	f600 206b 	addwlt	r0, r0, #2667	; 0xa6b
 80a91ae:	6063      	str	r3, [r4, #4]
 80a91b0:	1cc3      	adds	r3, r0, #3
 80a91b2:	fb93 f2f2 	sdiv	r2, r3, r2
 80a91b6:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 80a91ba:	1a9b      	subs	r3, r3, r2
 80a91bc:	bf48      	it	mi
 80a91be:	3307      	addmi	r3, #7
 80a91c0:	2800      	cmp	r0, #0
 80a91c2:	4938      	ldr	r1, [pc, #224]	; (80a92a4 <gmtime_r+0x154>)
 80a91c4:	61a3      	str	r3, [r4, #24]
 80a91c6:	bfbd      	ittte	lt
 80a91c8:	f5a0 330e 	sublt.w	r3, r0, #145408	; 0x23800
 80a91cc:	f5a3 732c 	sublt.w	r3, r3, #688	; 0x2b0
 80a91d0:	fb93 f1f1 	sdivlt	r1, r3, r1
 80a91d4:	fb90 f1f1 	sdivge	r1, r0, r1
 80a91d8:	f648 62ac 	movw	r2, #36524	; 0x8eac
 80a91dc:	f240 5cb4 	movw	ip, #1460	; 0x5b4
 80a91e0:	4b31      	ldr	r3, [pc, #196]	; (80a92a8 <gmtime_r+0x158>)
 80a91e2:	f240 176d 	movw	r7, #365	; 0x16d
 80a91e6:	fb03 0001 	mla	r0, r3, r1, r0
 80a91ea:	fbb0 f2f2 	udiv	r2, r0, r2
 80a91ee:	fbb0 f3fc 	udiv	r3, r0, ip
 80a91f2:	4402      	add	r2, r0
 80a91f4:	1ad2      	subs	r2, r2, r3
 80a91f6:	4b2d      	ldr	r3, [pc, #180]	; (80a92ac <gmtime_r+0x15c>)
 80a91f8:	2664      	movs	r6, #100	; 0x64
 80a91fa:	fbb0 f3f3 	udiv	r3, r0, r3
 80a91fe:	1ad3      	subs	r3, r2, r3
 80a9200:	fbb3 f5f7 	udiv	r5, r3, r7
 80a9204:	fbb3 f3fc 	udiv	r3, r3, ip
 80a9208:	fbb5 f2f6 	udiv	r2, r5, r6
 80a920c:	1ad3      	subs	r3, r2, r3
 80a920e:	4403      	add	r3, r0
 80a9210:	2099      	movs	r0, #153	; 0x99
 80a9212:	fb07 3315 	mls	r3, r7, r5, r3
 80a9216:	eb03 0c83 	add.w	ip, r3, r3, lsl #2
 80a921a:	f10c 0c02 	add.w	ip, ip, #2
 80a921e:	fbbc f7f0 	udiv	r7, ip, r0
 80a9222:	f04f 0805 	mov.w	r8, #5
 80a9226:	4378      	muls	r0, r7
 80a9228:	3002      	adds	r0, #2
 80a922a:	fbb0 f0f8 	udiv	r0, r0, r8
 80a922e:	f103 0e01 	add.w	lr, r3, #1
 80a9232:	ebae 0000 	sub.w	r0, lr, r0
 80a9236:	f240 5ef9 	movw	lr, #1529	; 0x5f9
 80a923a:	45f4      	cmp	ip, lr
 80a923c:	bf94      	ite	ls
 80a923e:	f04f 0c02 	movls.w	ip, #2
 80a9242:	f06f 0c09 	mvnhi.w	ip, #9
 80a9246:	4467      	add	r7, ip
 80a9248:	f44f 7cc8 	mov.w	ip, #400	; 0x190
 80a924c:	fb0c 5101 	mla	r1, ip, r1, r5
 80a9250:	2f01      	cmp	r7, #1
 80a9252:	bf98      	it	ls
 80a9254:	3101      	addls	r1, #1
 80a9256:	f5b3 7f99 	cmp.w	r3, #306	; 0x132
 80a925a:	d30c      	bcc.n	80a9276 <gmtime_r+0x126>
 80a925c:	f5a3 7399 	sub.w	r3, r3, #306	; 0x132
 80a9260:	61e3      	str	r3, [r4, #28]
 80a9262:	2300      	movs	r3, #0
 80a9264:	f2a1 716c 	subw	r1, r1, #1900	; 0x76c
 80a9268:	60e0      	str	r0, [r4, #12]
 80a926a:	e9c4 7104 	strd	r7, r1, [r4, #16]
 80a926e:	4620      	mov	r0, r4
 80a9270:	6223      	str	r3, [r4, #32]
 80a9272:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a9276:	f015 0f03 	tst.w	r5, #3
 80a927a:	d102      	bne.n	80a9282 <gmtime_r+0x132>
 80a927c:	fb06 5212 	mls	r2, r6, r2, r5
 80a9280:	b95a      	cbnz	r2, 80a929a <gmtime_r+0x14a>
 80a9282:	f44f 76c8 	mov.w	r6, #400	; 0x190
 80a9286:	fbb5 f2f6 	udiv	r2, r5, r6
 80a928a:	fb06 5212 	mls	r2, r6, r2, r5
 80a928e:	fab2 f282 	clz	r2, r2
 80a9292:	0952      	lsrs	r2, r2, #5
 80a9294:	333b      	adds	r3, #59	; 0x3b
 80a9296:	4413      	add	r3, r2
 80a9298:	e7e2      	b.n	80a9260 <gmtime_r+0x110>
 80a929a:	2201      	movs	r2, #1
 80a929c:	e7fa      	b.n	80a9294 <gmtime_r+0x144>
 80a929e:	bf00      	nop
 80a92a0:	00015180 	.word	0x00015180
 80a92a4:	00023ab1 	.word	0x00023ab1
 80a92a8:	fffdc54f 	.word	0xfffdc54f
 80a92ac:	00023ab0 	.word	0x00023ab0

080a92b0 <__retarget_lock_acquire>:
 80a92b0:	4770      	bx	lr

080a92b2 <__retarget_lock_acquire_recursive>:
 80a92b2:	4770      	bx	lr

080a92b4 <__retarget_lock_release>:
 80a92b4:	4770      	bx	lr

080a92b6 <__retarget_lock_release_recursive>:
 80a92b6:	4770      	bx	lr

080a92b8 <__env_lock>:
 80a92b8:	4801      	ldr	r0, [pc, #4]	; (80a92c0 <__env_lock+0x8>)
 80a92ba:	f7ff bffa 	b.w	80a92b2 <__retarget_lock_acquire_recursive>
 80a92be:	bf00      	nop
 80a92c0:	20000f62 	.word	0x20000f62

080a92c4 <__env_unlock>:
 80a92c4:	4801      	ldr	r0, [pc, #4]	; (80a92cc <__env_unlock+0x8>)
 80a92c6:	f7ff bff6 	b.w	80a92b6 <__retarget_lock_release_recursive>
 80a92ca:	bf00      	nop
 80a92cc:	20000f62 	.word	0x20000f62

080a92d0 <__aeabi_ldivmod>:
 80a92d0:	b97b      	cbnz	r3, 80a92f2 <__aeabi_ldivmod+0x22>
 80a92d2:	b972      	cbnz	r2, 80a92f2 <__aeabi_ldivmod+0x22>
 80a92d4:	2900      	cmp	r1, #0
 80a92d6:	bfbe      	ittt	lt
 80a92d8:	2000      	movlt	r0, #0
 80a92da:	f04f 4100 	movlt.w	r1, #2147483648	; 0x80000000
 80a92de:	e006      	blt.n	80a92ee <__aeabi_ldivmod+0x1e>
 80a92e0:	bf08      	it	eq
 80a92e2:	2800      	cmpeq	r0, #0
 80a92e4:	bf1c      	itt	ne
 80a92e6:	f06f 4100 	mvnne.w	r1, #2147483648	; 0x80000000
 80a92ea:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
 80a92ee:	f7ff b9ef 	b.w	80a86d0 <__aeabi_idiv0>
 80a92f2:	f1ad 0c08 	sub.w	ip, sp, #8
 80a92f6:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80a92fa:	2900      	cmp	r1, #0
 80a92fc:	db09      	blt.n	80a9312 <__aeabi_ldivmod+0x42>
 80a92fe:	2b00      	cmp	r3, #0
 80a9300:	db1a      	blt.n	80a9338 <__aeabi_ldivmod+0x68>
 80a9302:	f7ff f883 	bl	80a840c <__udivmoddi4>
 80a9306:	f8dd e004 	ldr.w	lr, [sp, #4]
 80a930a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80a930e:	b004      	add	sp, #16
 80a9310:	4770      	bx	lr
 80a9312:	4240      	negs	r0, r0
 80a9314:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80a9318:	2b00      	cmp	r3, #0
 80a931a:	db1b      	blt.n	80a9354 <__aeabi_ldivmod+0x84>
 80a931c:	f7ff f876 	bl	80a840c <__udivmoddi4>
 80a9320:	f8dd e004 	ldr.w	lr, [sp, #4]
 80a9324:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80a9328:	b004      	add	sp, #16
 80a932a:	4240      	negs	r0, r0
 80a932c:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80a9330:	4252      	negs	r2, r2
 80a9332:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80a9336:	4770      	bx	lr
 80a9338:	4252      	negs	r2, r2
 80a933a:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80a933e:	f7ff f865 	bl	80a840c <__udivmoddi4>
 80a9342:	f8dd e004 	ldr.w	lr, [sp, #4]
 80a9346:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80a934a:	b004      	add	sp, #16
 80a934c:	4240      	negs	r0, r0
 80a934e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80a9352:	4770      	bx	lr
 80a9354:	4252      	negs	r2, r2
 80a9356:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80a935a:	f7ff f857 	bl	80a840c <__udivmoddi4>
 80a935e:	f8dd e004 	ldr.w	lr, [sp, #4]
 80a9362:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80a9366:	b004      	add	sp, #16
 80a9368:	4252      	negs	r2, r2
 80a936a:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80a936e:	4770      	bx	lr

080a9370 <dynalib_user>:
 80a9370:	001d 080a 005d 080a 0085 080a 0089 080a     ....]...........
 80a9380:	0000 0000 003a 002f 654d 7272 2079 6843     ....:./.Merry Ch
 80a9390:	6972 7473 616d 0073 6854 6e61 736b 6967     ristmas.Thanksgi
 80a93a0:	6976 676e 0073 6148 7070 2079 6156 656c     vings.Happy Vale
 80a93b0:	746e 6e69 7365 4900 6c20 766f 2065 6f79     ntines.I love yo
 80a93c0:	2075 293a 6500 6978 0074 7845 7469 6e69     u :).exit.Exitin
 80a93d0:	0067 7845 7469 6e69 2e67 4500 6978 6974     g.Exiting..Exiti
 80a93e0:	676e 2e2e 4500 6978 6974 676e 2e2e 002e     ng...Exiting....
 80a93f0:	7845 7469 6e69 2e67 2e2e 002e 6572 6573     Exiting.....rese
 80a9400:	0074 6552 6573 7474 6e69 2067 6544 6976     t.Resetting Devi
 80a9410:	6563 5200 7365 7465 6974 676e 4420 7665     ce.Resetting Dev
 80a9420:	6369 2e65 5200 7365 7465 6974 676e 4420     ice..Resetting D
 80a9430:	7665 6369 2e65 002e 6552 6573 7474 6e69     evice...Resettin
 80a9440:	2067 6544 6976 6563 2e2e 002e 6552 6573     g Device....Rese
 80a9450:	7474 6e69 2067 6544 6976 6563 2e2e 2e2e     tting Device....
 80a9460:	5200 7365 7465 6974 676e 4420 7665 6369     .Resetting Devic
 80a9470:	2e65 2e2e 2e2e 7700 6669 6c69 7369 6574     e......wifiliste
 80a9480:	006e 6553 7474 6e69 2067 6957 6966 7420     n.Setting Wifi t
 80a9490:	206f 696c 7473 6e65 6e69 2067 6f6d 6564     o listening mode
 80a94a0:	2e2e 002e 6957 6946 6820 7361 6220 6565     ....WiFi has bee
 80a94b0:	206e 6573 2074 6f74 6c20 7369 6574 696e     n set to listeni
 80a94c0:	676e 6d20 646f 2165 0021 6562 7065 6200     ng mode!!.beep.b
 80a94d0:	6565 6970 676e 2e2e 002e 6f43 706d 656c     eeping....Comple
 80a94e0:	6574 2064 6542 7065 6e69 0067 654d 7373     ted Beeping.Mess
 80a94f0:	6761 2065 6552 6563 6569 6576 0064 7551     age Receieved.Qu
 80a9500:	6369 4d6b 7365 6173 6567 7300 004c 4c74     ickMessage.sL.tL
 80a9510:	7400 676f 6c67 5765 6669 0069 6177 656b     .toggleWifi.wake
 80a9520:	7055 7542 7474 6e6f 6a00 0030 6574 7478     UpButton.j0.text
 80a9530:	6f42 0078 3067 6e00 0050 3074 7100 5472     Box.g0.nP.t0.qrT
 80a9540:	6761 6200 0031 3262 6200 0033 3462 6200     ag.b1.b2.b3.b4.b
 80a9550:	0035 3362 0037 6274 0030 3962 6200 3031     5.b37.tb0.b9.b10
 80a9560:	6200 0038 7566 636e 6974 6e6f 3131 6600     .b8.function11.f
 80a9570:	6e75 7463 6f69 316e 0032 7566 636e 6974     unction12.functi
 80a9580:	6e6f 3331 6600 6e75 7463 6f69 316e 0034     on13.function14.
 80a9590:	7566 636e 6974 6e6f 3531 6600 6e75 7463     function15.funct
 80a95a0:	6f69 316e 0036 7566 636e 6974 6e6f 3731     ion16.function17
 80a95b0:	6600 6e75 7463 6f69 316e 0038 7566 636e     .function18.func
 80a95c0:	6974 6e6f 3132 6600 6e75 7463 6f69 326e     tion21.function2
 80a95d0:	0032 7566 636e 6974 6e6f 3332 6600 6e75     2.function23.fun
 80a95e0:	7463 6f69 326e 0034 7566 636e 6974 6e6f     ction24.function
 80a95f0:	3532 6600 6e75 7463 6f69 326e 0036 7566     25.function26.fu
 80a9600:	636e 6974 6e6f 3220 0037 307a 6800 0065     nction 27.z0.he.
 80a9610:	317a 7a00 0032 306e 6e00 0031 326e 6e00     z1.z2.n0.n1.n2.n
 80a9620:	746f 6669 666f 0066 6f6e 6974 6f66 006e     otifoff.notifon.
 80a9630:	6970 6f63 6666 7000 6369 6e6f 7400 676f     picoff.picon.tog
 80a9640:	6c67 4c65 4445 7200 6265 6f6f 0074 6c73     gleLED.reboot.sl
 80a9650:	6565 0070 6177 656b 7500 6c6e 636f 006b     eep.wake.unlock.
 80a9660:	6553 7474 6e69 2067 7075 2e2e 002e 7570     Setting up....pu
 80a9670:	6873 6c00 756f 0064 6f63 6d6d 6e61 0064     sh.loud.command.
 80a9680:	6857 7461 6120 6572 7920 756f 6420 696f     What are you doi
 80a9690:	676e 003f 2049 696d 7373 7920 756f 3a20     ng?.I miss you :
 80a96a0:	0028 7241 2065 6f79 2075 6e69 7920 756f     (.Are you in you
 80a96b0:	2072 6f64 6d72 003f 6f48 2077 7261 2065     r dorm?.How are 
 80a96c0:	6f79 2075 6f64 6e69 3f67 4800 7965 4220     you doing?.Hey B
 80a96d0:	6261 0065                                   abe.

080a96d4 <_ZTV5Timer>:
	...
 80a96dc:	0895 080a 08dd 080a 069d 080a 2828 4132     ............((2A
 80a96ec:	7301 656c 7065 303d 6400 6d69 363d 0030     .sleep=0.dim=60.
 80a96fc:	6170 6567 3420 7000 6761 2065 0030 6c73     page 4.page 0.sl
 80a970c:	6565 2070 203d 0030 6964 206d 203d 3035     eep = 0.dim = 50
 80a971c:	7300 656c 7065 3d20 3120 6400 6d69 3d20     .sleep = 1.dim =
 80a972c:	3020 7000 6761 2065 3331 6400 6d69 323d      0.page 13.dim=2
 80a973c:	0030 7874 0074 ffff 00ff 6b62 6d63 3d64     0.txt.....bkcmd=
 80a974c:	0031 003d 223d 6400 6d69 003d 0000 0000     1.=.=".dim=.....
 80a975c:	0000 0000 0000 6200 7561 7364 003d 0000     .......bauds=...
 80a976c:	0000 0000 0000 6200 7561 3d64 0000 0000     .......baud=....
 80a977c:	0000 0000 0000 6700 7465 0020 0000 0000     .......get .....
	...
 80a97a0:	0000 7600 6c61 4c00 5349 4433 0048 0000     ...val.LIS3DH...

080a97b0 <_ZTV15Adafruit_LIS3DH>:
	...
 80a97b8:	1ef9 080a 1f35 080a 1ef7 080a 23c1 080a     ....5........#..
 80a97c8:	1efd 080a                                   ....

080a97cc <_ZTV12Adafruit_GFX>:
	...
 80a97dc:	25a7 080a 7165 080a 00a5 080a 23f7 080a     .%..eq.......#..
 80a97ec:	251b 080a 2537 080a 24b3 080a 2551 080a     .%..7%...$..Q%..
 80a97fc:	2589 080a 25a5 080a 27fb 080a               .%...%...'..

080a9808 <glcdfontBitmaps>:
 80a9808:	ff00 0000 0000 0000 0000 f870 f8a8 88d8     ..........p.....
 80a9818:	0070 f870 f8a8 d888 0070 5000 f8f8 70f8     p.p.....p..P...p
 80a9828:	0020 2000 f870 70f8 0020 5070 a8f8 20f8      .. p..p .pP... 
 80a9838:	0070 7020 f8f8 20f8 0070 0000 7020 2070     p. p... p... pp 
 80a9848:	0000 f8f8 88d8 d888 f8f8 0000 5020 2050     ............ PP 
 80a9858:	0000 f8f8 a8d8 d8a8 f8f8 3800 6818 a0a0     ...........8.h..
 80a9868:	0040 8870 7088 f820 0020 4878 4078 4040     @.p..p . .xHx@@@
 80a9878:	00c0 4878 4878 5848 00c0 a820 d870 70d8     ..xHxHHX.. .p..p
 80a9888:	20a8 c080 f8f0 c0f0 0080 1808 f878 1878     . ..........x.x.
 80a9898:	0008 7020 20a8 70a8 0020 d8d8 d8d8 00d8     .. p. .p .......
 80a98a8:	00d8 a878 68a8 2828 0028 4830 2850 4810     ..x..h(((.0HP(.H
 80a98b8:	3048 0000 0000 f800 00f8 7020 20a8 70a8     H0........ p. .p
 80a98c8:	f820 2000 a870 2020 0020 2000 2020 70a8      .. p.   ..   .p
 80a98d8:	0020 2000 f810 2010 0000 2000 f840 2040      .. ... ... @.@ 
 80a98e8:	0000 8000 8080 00f8 0000 5000 f8f8 0050     ...........P..P.
 80a98f8:	0000 2000 7020 f8f8 0000 f800 70f8 2020     ...  p.......p  
	...
 80a9910:	0000 2020 2020 0020 0020 5050 0050 0000     ..     . .PPP...
 80a9920:	0000 5050 50f8 50f8 0050 7820 70a0 f028     ..PP.P.PP. x.p(.
 80a9930:	0020 c8c0 2010 9840 0018 a040 40a0 90a8      .... @...@..@..
 80a9940:	0068 3030 4020 0000 0000 2010 4040 2040     h.00 @..... @@@ 
 80a9950:	0010 2040 1010 2010 0040 a820 f870 a870     ..@ ... @. .p.p.
 80a9960:	0020 2000 f820 2020 0000 0000 0000 3030      ..  .  ......00
 80a9970:	4020 0000 f800 0000 0000 0000 0000 3000      @.............0
 80a9980:	0030 0800 2010 8040 0000 8870 a898 88c8     0.... @...p.....
 80a9990:	0070 6020 2020 2020 0070 8870 7008 8080     p. `    p.p..p..
 80a99a0:	00f8 08f8 3010 8808 0070 3010 9050 10f8     .....0..p..0P...
 80a99b0:	0010 80f8 08f0 8808 0070 4038 f080 8888     ........p.8@....
 80a99c0:	0070 08f8 1008 4020 0080 8870 7088 8888     p..... @..p..p..
 80a99d0:	0070 8870 7888 1008 00e0 0000 0020 0020     p.p..x...... . .
 80a99e0:	0000 0000 0020 2020 0040 1008 4020 1020     .... .  @... @ .
 80a99f0:	0008 0000 00f8 00f8 0000 2040 0810 2010     ..........@ ... 
 80a9a00:	0040 8870 3008 0020 0020 8870 b8a8 80b0     @.p..0 . .p.....
 80a9a10:	0078 5020 8888 88f8 0088 88f0 f088 8888     x. P............
 80a9a20:	00f0 8870 8080 8880 0070 88f0 8888 8888     ..p.....p.......
 80a9a30:	00f0 80f8 f080 8080 00f8 80f8 f080 8080     ................
 80a9a40:	0080 8878 8080 8898 0078 8888 f888 8888     ..x.....x.......
 80a9a50:	0088 2070 2020 2020 0070 1038 1010 9010     ..p     p.8.....
 80a9a60:	0060 9088 c0a0 90a0 0088 8080 8080 8080     `...............
 80a9a70:	00f8 d888 a8a8 88a8 0088 8888 a8c8 8898     ................
 80a9a80:	0088 8870 8888 8888 0070 88f0 f088 8080     ..p.....p.......
 80a9a90:	0080 8870 8888 90a8 0068 88f0 f088 90a0     ..p.....h.......
 80a9aa0:	0088 8870 7080 8808 0070 a8f8 2020 2020     ..p..p..p...    
 80a9ab0:	0020 8888 8888 8888 0070 8888 8888 5088      .......p......P
 80a9ac0:	0020 8888 a888 a8a8 0050 8888 2050 8850      .......P...P P.
 80a9ad0:	0088 8888 2050 2020 0020 08f8 7010 8040     ....P    ....p@.
 80a9ae0:	00f8 4078 4040 4040 0078 8000 2040 0810     ..x@@@@@x...@ ..
 80a9af0:	0000 0878 0808 0808 0078 5020 0088 0000     ..x.....x. P....
	...
 80a9b08:	00f8 6060 1020 0000 0000 0000 1060 9070     ..`` .......`.p.
 80a9b18:	0078 8080 c8b0 c888 00b0 0000 8870 8880     x...........p...
 80a9b28:	0070 0808 9868 9888 0068 0000 8870 80f8     p...h...h...p...
 80a9b38:	0070 2810 7020 2020 0020 0000 9870 6898     p..( p   ...p..h
 80a9b48:	7008 8080 c8b0 8888 0088 0020 2060 2020     .p........ .`   
 80a9b58:	0070 0010 1010 9010 0060 8080 a090 a0c0     p.......`.......
 80a9b68:	0090 2060 2020 2020 0070 0000 a8d0 a8a8     ..`     p.......
 80a9b78:	00a8 0000 c8b0 8888 0088 0000 8870 8888     ............p...
 80a9b88:	0070 0000 c8b0 b0c8 8080 0000 9868 6898     p...........h..h
 80a9b98:	0808 0000 c8b0 8080 0080 0000 8078 0870     ............x.p.
 80a9ba8:	00f0 2020 20f8 2820 0010 0000 8888 9888     ..  .  (........
 80a9bb8:	0068 0000 8888 5088 0020 0000 8888 a8a8     h......P .......
 80a9bc8:	0050 0000 5088 5020 0088 0000 8888 0878     P....P P......x.
 80a9bd8:	7088 0000 10f8 4020 00f8 2010 4020 2020     .p.... @...  @  
 80a9be8:	0010 2020 0020 2020 0020 2040 1020 2020     ..   .   .@  .  
 80a9bf8:	0040 a840 0010 0000 0000 7020 88d8 f888     @.@....... p....
 80a9c08:	0000 8870 8080 7088 6010 8800 8800 9888     ..p....p.`......
 80a9c18:	0068 0018 8870 80f8 0078 00f8 1060 9070     h...p...x...`.p.
 80a9c28:	0078 0088 1060 9070 0078 00c0 1060 9070     x...`.p.x...`.p.
 80a9c38:	0078 0030 1060 9070 0078 7800 c0c0 1078     x.0.`.p.x..x..x.
 80a9c48:	0030 00f8 8870 80f8 0078 0088 8870 80f8     0...p...x...p...
 80a9c58:	0078 00c0 8870 80f8 0078 0028 1030 1010     x...p...x.(.0...
 80a9c68:	0038 4830 1030 1010 0038 0060 1030 1010     8.0H0...8.`.0...
 80a9c78:	0038 0050 5020 f888 8888 0020 5020 f888     8.P. P.... . P..
 80a9c88:	8888 0030 80f0 80e0 00f0 0000 1078 9078     ..0.........x.x.
 80a9c98:	0078 5038 f890 9090 0098 8870 7000 8888     x.8P......p..p..
 80a9ca8:	0070 8800 7000 8888 0070 c000 7000 8888     p....p..p....p..
 80a9cb8:	0070 8870 8800 9888 0068 c000 8800 9888     p.p.....h.......
 80a9cc8:	0068 0048 4848 3848 7008 0088 8870 8888     h.H.HHH8.p..p...
 80a9cd8:	0070 0088 8888 8888 0070 2020 a0f8 f8a0     p.......p.  ....
 80a9ce8:	2020 5830 e048 4840 00f8 d8d8 f870 f820       0XH.@H....p. .
 80a9cf8:	2020 90e0 e090 b890 9090 2818 7020 2020       .........( p  
 80a9d08:	c0a0 0018 1060 9070 0078 0018 1030 1010     ....`.p.x...0...
 80a9d18:	0038 1800 7000 8888 0070 1800 8800 9888     8....p..p.......
 80a9d28:	0068 7800 7000 4848 0048 00f8 e8c8 98b8     h..x.pHHH.......
 80a9d38:	0088 9070 7890 f800 0000 8870 7088 f800     ..p..x....p..p..
 80a9d48:	0000 0020 6020 8880 0070 0000 f800 8080     .. . `..p.......
 80a9d58:	0000 0000 f800 0808 0000 8880 b890 9848     ..............H.
 80a9d68:	3820 8880 a890 b858 0808 2020 2000 2020      8....X...  .   
 80a9d78:	0020 2800 a050 2850 0000 a000 2850 a050      ..(P.P(....P(P.
 80a9d88:	0000 8820 8820 8820 8820 a850 a850 a850     .. . . . .P.P.P.
 80a9d98:	a850 1010 1010 1010 1010 1010 1010 10f0     P...............
 80a9da8:	1010 1010 10f0 10f0 1010 2828 2828 28e8     ..........((((.(
 80a9db8:	2828 0000 0000 28f8 2828 0000 10f0 10f0     ((.....(((......
 80a9dc8:	1010 2828 08e8 28e8 2828 2828 2828 2828     ..((...(((((((((
 80a9dd8:	2828 0000 08f8 28e8 2828 2828 08e8 00f8     ((.....(((((....
 80a9de8:	0000 2828 2828 00f8 0000 1010 10f0 00f0     ..((((..........
 80a9df8:	0000 0000 0000 10f0 1010 1010 1010 0018     ................
 80a9e08:	0000 1010 1010 00f8 0000 0000 0000 10f8     ................
 80a9e18:	1010 1010 1010 1018 1010 0000 0000 00f8     ................
 80a9e28:	0000 1010 1010 10f8 1010 1010 1018 1018     ................
 80a9e38:	1010 2828 2828 2828 2828 2828 2028 0038     ..((((((((((( 8.
 80a9e48:	0000 0000 2038 2828 2828 2828 00e8 00f8     ....8 ((((((....
 80a9e58:	0000 0000 00f8 28e8 2828 2828 2028 2828     .......(((((( ((
 80a9e68:	2828 0000 00f8 00f8 0000 2828 00e8 28e8     ((........((...(
 80a9e78:	2828 1010 00f8 00f8 0000 2828 2828 00f8     ((........((((..
 80a9e88:	0000 0000 00f8 10f8 1010 0000 0000 28f8     ...............(
 80a9e98:	2828 2828 2828 0038 0000 1010 1018 0018     ((((((8.........
 80a9ea8:	0000 0000 1018 1018 1010 0000 0000 2838     ..............8(
 80a9eb8:	2828 2828 2828 28f8 2828 1010 10f8 10f8     ((((((.(((......
 80a9ec8:	1010 1010 1010 00f0 0000 0000 0000 1018     ................
 80a9ed8:	1010 f8f8 f8f8 f8f8 f8f8 0000 0000 f8f8     ................
 80a9ee8:	f8f8 e0e0 e0e0 e0e0 e0e0 1818 1818 1818     ................
 80a9ef8:	1818 f8f8 f8f8 0000 0000 0000 9068 9090     ............h...
 80a9f08:	0068 7000 f098 f098 0080 f800 8098 8080     h..p............
 80a9f18:	0080 f800 5050 5050 0050 88f8 2040 8840     ....PPPPP...@ @.
 80a9f28:	00f8 0000 9078 9090 0060 5000 5050 6850     ....x...`..PPPPh
 80a9f38:	00c0 f800 20a0 2020 0020 20f8 8870 7088     .....    .. p..p
 80a9f48:	f820 5020 f888 5088 0020 5020 8888 5050      . P...P . P..PP
 80a9f58:	00d8 4030 7030 8888 0070 0000 7000 a8a8     ..0@0p..p....p..
 80a9f68:	0070 7008 a898 c8a8 8070 8070 f080 8080     p..p....p.p.....
 80a9f78:	0070 8870 8888 8888 0088 f800 f800 f800     p.p.............
 80a9f88:	0000 2020 20f8 0020 00f8 2040 2010 0040     ..  .  ...@ . @.
 80a9f98:	00f8 2010 2040 0010 00f8 2838 2020 2020     ... @ ....8(    
 80a9fa8:	2020 2020 2020 a020 e0a0 3030 f800 3000            ...00...0
 80a9fb8:	0030 e800 00b8 b8e8 0000 d870 70d8 0000     0.........p..p..
 80a9fc8:	0000 0000 3000 0030 0000 0000 0000 0030     .....00.......0.
 80a9fd8:	0000 2038 2020 a0a0 2060 4870 4848 0048     ..8   ..` pHHHH.
 80a9fe8:	0000 1870 6030 0078 0000 0000 7878 7878     ..p.0`x.....xxxx
	...

080aa002 <glcdfontDescriptors>:
 80aa002:	0805 0000 0805 0008 0805 0010 0805 0018     ................
 80aa012:	0805 0020 0805 0028 0805 0030 0805 0038     .. ...(...0...8.
 80aa022:	0805 0040 0805 0048 0805 0050 0805 0058     ..@...H...P...X.
 80aa032:	0805 0060 0805 0068 0805 0070 0805 0078     ..`...h...p...x.
 80aa042:	0805 0080 0805 0088 0805 0090 0805 0098     ................
 80aa052:	0805 00a0 0805 00a8 0805 00b0 0805 00b8     ................
 80aa062:	0805 00c0 0805 00c8 0805 00d0 0805 00d8     ................
 80aa072:	0805 00e0 0805 00e8 0805 00f0 0805 00f8     ................
 80aa082:	0805 0100 0805 0108 0805 0110 0805 0118     ................
 80aa092:	0805 0120 0805 0128 0805 0130 0805 0138     .. ...(...0...8.
 80aa0a2:	0805 0140 0805 0148 0805 0150 0805 0158     ..@...H...P...X.
 80aa0b2:	0805 0160 0805 0168 0805 0170 0805 0178     ..`...h...p...x.
 80aa0c2:	0805 0180 0805 0188 0805 0190 0805 0198     ................
 80aa0d2:	0805 01a0 0805 01a8 0805 01b0 0805 01b8     ................
 80aa0e2:	0805 01c0 0805 01c8 0805 01d0 0805 01d8     ................
 80aa0f2:	0805 01e0 0805 01e8 0805 01f0 0805 01f8     ................
 80aa102:	0805 0200 0805 0208 0805 0210 0805 0218     ................
 80aa112:	0805 0220 0805 0228 0805 0230 0805 0238     .. ...(...0...8.
 80aa122:	0805 0240 0805 0248 0805 0250 0805 0258     ..@...H...P...X.
 80aa132:	0805 0260 0805 0268 0805 0270 0805 0278     ..`...h...p...x.
 80aa142:	0805 0280 0805 0288 0805 0290 0805 0298     ................
 80aa152:	0805 02a0 0805 02a8 0805 02b0 0805 02b8     ................
 80aa162:	0805 02c0 0805 02c8 0805 02d0 0805 02d8     ................
 80aa172:	0805 02e0 0805 02e8 0805 02f0 0805 02f8     ................
 80aa182:	0805 0300 0805 0308 0805 0310 0805 0318     ................
 80aa192:	0805 0320 0805 0328 0805 0330 0805 0338     .. ...(...0...8.
 80aa1a2:	0805 0340 0805 0348 0805 0350 0805 0358     ..@...H...P...X.
 80aa1b2:	0805 0360 0805 0368 0805 0370 0805 0378     ..`...h...p...x.
 80aa1c2:	0805 0380 0805 0388 0805 0390 0805 0398     ................
 80aa1d2:	0805 03a0 0805 03a8 0805 03b0 0805 03b8     ................
 80aa1e2:	0805 03c0 0805 03c8 0805 03d0 0805 03d8     ................
 80aa1f2:	0805 03e0 0805 03e8 0805 03f0 0805 03f8     ................
 80aa202:	0805 0400 0805 0408 0805 0410 0805 0418     ................
 80aa212:	0805 0420 0805 0428 0805 0430 0805 0438     .. ...(...0...8.
 80aa222:	0805 0440 0805 0448 0805 0450 0805 0458     ..@...H...P...X.
 80aa232:	0805 0460 0805 0468 0805 0470 0805 0478     ..`...h...p...x.
 80aa242:	0805 0480 0805 0488 0805 0490 0805 0498     ................
 80aa252:	0805 04a0 0805 04a8 0805 04b0 0805 04b8     ................
 80aa262:	0805 04c0 0805 04c8 0805 04d0 0805 04d8     ................
 80aa272:	0805 04e0 0805 04e8 0805 04f0 0805 04f8     ................
 80aa282:	0805 0500 0805 0508 0805 0510 0805 0518     ................
 80aa292:	0805 0520 0805 0528 0805 0530 0805 0538     .. ...(...0...8.
 80aa2a2:	0805 0540 0805 0548 0805 0550 0805 0558     ..@...H...P...X.
 80aa2b2:	0805 0560 0805 0568 0805 0570 0805 0578     ..`...h...p...x.
 80aa2c2:	0805 0580 0805 0588 0805 0590 0805 0598     ................
 80aa2d2:	0805 05a0 0805 05a8 0805 05b0 0805 05b8     ................
 80aa2e2:	0805 05c0 0805 05c8 0805 05d0 0805 05d8     ................
 80aa2f2:	0805 05e0 0805 05e8 0805 05f0 0805 05f8     ................
 80aa302:	0805 0600 0805 0608 0805 0610 0805 0618     ................
 80aa312:	0805 0620 0805 0628 0805 0630 0805 0638     .. ...(...0...8.
 80aa322:	0805 0640 0805 0648 0805 0650 0805 0658     ..@...H...P...X.
 80aa332:	0805 0660 0805 0668 0805 0670 0805 0678     ..`...h...p...x.
 80aa342:	0805 0680 0805 0688 0805 0690 0805 0698     ................
 80aa352:	0805 06a0 0805 06a8 0805 06b0 0805 06b8     ................
 80aa362:	0805 06c0 0805 06c8 0805 06d0 0805 06d8     ................
 80aa372:	0805 06e0 0805 06e8 0805 06f0 0805 06f8     ................
 80aa382:	0805 0700 0805 0708 0805 0710 0805 0718     ................
 80aa392:	0805 0720 0805 0728 0805 0730 0805 0738     .. ...(...0...8.
 80aa3a2:	0805 0740 0805 0748 0805 0750 0805 0758     ..@...H...P...X.
 80aa3b2:	0805 0760 0805 0768 0805 0770 0805 0778     ..`...h...p...x.
 80aa3c2:	0805 0780 0805 0788 0805 0790 0805 0798     ................
 80aa3d2:	0805 07a0 0805 07a8 0805 07b0 0805 07b8     ................
 80aa3e2:	0805 07c0 0805 07c8 0805 07d0 0805 07d8     ................
 80aa3f2:	0805 07e0 0805 07e8 0805 07f0 0805 07f8     ................
	...

080aa404 <CSWTCH.189>:
 80aa404:	012c 0000 0018 0000 01f4 0000 012c 0000     ,...........,...
 80aa414:	0050 0000 6564 6166 6c75 2074 4d00 4253     P...default .MSB
 80aa424:	4c00 4253 3c00 5053 5349 7465 6974 676e     .LSB.<SPISetting
 80aa434:	2073 6564 6166 6c75 3e74 3c00 5053 5349     s default>.<SPIS
 80aa444:	7465 6974 676e 2073 7325 7525 2520 2073     ettings %s%u %s 
 80aa454:	4f4d 4544 7525 003e                         MODE%u>.

080aa45c <_ZTVN8particle11SPISettingsE>:
	...
 80aa464:	4339 080a 42e1 080a 4301 080a               9C...B...C..

080aa470 <_ZTV16Adafruit_ILI9341>:
	...
 80aa478:	42ff 080a 430f 080a 25a7 080a 7165 080a     .B...C...%..eq..
 80aa488:	496d 080a 23f7 080a 4b11 080a 4cd5 080a     mI...#...K...L..
 80aa498:	24b3 080a 4e95 080a 42e3 080a 48a1 080a     .$...N...B...H..
 80aa4a8:	27fb 080a                                   .'..

080aa4ac <_ZTVN5spark12NetworkClassE>:
	...
 80aa4b4:	5b1d 080a 5b27 080a 5b31 080a 5b3b 080a     .[..'[..1[..;[..
 80aa4c4:	5b45 080a 5b51 080a 5b5d 080a 5b65 080a     E[..Q[..][..e[..
 80aa4d4:	5b6d 080a 5b79 080a 5b81 080a 5b8b 080a     m[..y[...[...[..
 80aa4e4:	5b95 080a                                   .[..

080aa4e8 <_ZN12_GLOBAL__N_1L14clock_divisorsE>:
 80aa4e8:	0800 1810 2820 3830                         .... (08

080aa4f0 <_ZTVN5spark9WiFiClassE>:
	...
 80aa4f8:	5eff 080a 5ef5 080a 5eeb 080a 5e5d 080a     .^...^...^..]^..
 80aa508:	5edf 080a 5ed3 080a 5b5d 080a 5b65 080a     .^...^..][..e[..
 80aa518:	5ec7 080a 5ebf 080a 5eb5 080a 5eab 080a     .^...^...^...^..
 80aa528:	5e67 080a                                   g^..

080aa52c <_ZTV11USARTSerial>:
	...
 80aa534:	5f45 080a 5faf 080a 5f8b 080a 7165 080a     E_..._..._..eq..
 80aa544:	5f5b 080a 5f77 080a 5f69 080a 5f85 080a     [_..w_..i_..._..
 80aa554:	5f47 080a 5f4d 080a                         G_..M_..

080aa55c <_ZTV7TwoWire>:
	...
 80aa564:	6079 080a 60c3 080a 609b 080a 607b 080a     y`...`...`..{`..
 80aa574:	60a3 080a 60ab 080a 60b3 080a 60bb 080a     .`...`...`...`..

080aa584 <_ZTV9USBSerial>:
	...
 80aa58c:	617b 080a 61e1 080a 61b9 080a 7165 080a     {a...a...a..eq..
 80aa59c:	61ab 080a 617d 080a 618d 080a 61db 080a     .a..}a...a...a..
 80aa5ac:	619d 080a 6175 080a                         .a..ua..

080aa5b4 <_ZTV9IPAddress>:
	...
 80aa5bc:	62d9 080a 62c9 080a 62cb 080a               .b...b...b..

080aa5c8 <_ZTVSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE>:
	...
 80aa5d0:	63a5 080a 63ab 080a 63e9 080a 63b9 080a     .c...c...c...c..
 80aa5e0:	63a7 080a                                   .c..

080aa5e4 <_ZTV3UDP>:
	...
 80aa5ec:	6f15 080a 6f39 080a 6b03 080a 6c2f 080a     .o..9o...k../l..
 80aa5fc:	6afb 080a 6b1b 080a 6b39 080a 6b53 080a     .j...k..9k..Sk..
 80aa60c:	6b75 080a 6bcd 080a 6bef 080a 6d91 080a     uk...k...k...m..
 80aa61c:	6c95 080a 6ae5 080a 6ea9 080a 6d09 080a     .l...j...n...m..
 80aa62c:	6dc9 080a 6ed7 080a 6c59 080a 6af1 080a     .m...n..Yl...j..
 80aa63c:	6d71 080a 6af7 080a 6b55 080a fff0 ffff     qm...j..Uk......
 80aa64c:	0000 0000 6b6d 080a 5925 252d 2d6d 6425     ....mk..%Y-%m-%d
 80aa65c:	2554 3a48 4d25 253a 2553 007a 7361 7463     T%H:%M:%S%z.asct
 80aa66c:	6d69 0065 7061 0070                         ime.app.

080aa674 <_ZSt7nothrow>:
 80aa674:	0000 0000                                   ....

080aa678 <__month_lengths>:
 80aa678:	001f 0000 001c 0000 001f 0000 001e 0000     ................
 80aa688:	001f 0000 001e 0000 001f 0000 001f 0000     ................
 80aa698:	001e 0000 001f 0000 001e 0000 001f 0000     ................
 80aa6a8:	001f 0000 001d 0000 001f 0000 001e 0000     ................
 80aa6b8:	001f 0000 001e 0000 001f 0000 001f 0000     ................
 80aa6c8:	001e 0000 001f 0000 001e 0000 001f 0000     ................
 80aa6d8:	5a54 4700 544d 2500 3031 5e5b 2d30 2c39     TZ.GMT.%10[^0-9,
 80aa6e8:	2d2b 255d 006e 254d 7568 6e25 252e 7568     +-]%n.M%hu%n.%hu
 80aa6f8:	6e25 252e 7568 6e25 2f00 6825 2575 3a6e     %n.%hu%n./%hu%n:
 80aa708:	6825 2575 3a6e 6825 2575 006e               %hu%n:%hu%n.

080aa714 <_ctype_>:
 80aa714:	2000 2020 2020 2020 2020 2828 2828 2028     .         ((((( 
 80aa724:	2020 2020 2020 2020 2020 2020 2020 2020                     
 80aa734:	8820 1010 1010 1010 1010 1010 1010 1010      ...............
 80aa744:	0410 0404 0404 0404 0404 1004 1010 1010     ................
 80aa754:	1010 4141 4141 4141 0101 0101 0101 0101     ..AAAAAA........
 80aa764:	0101 0101 0101 0101 0101 0101 1010 1010     ................
 80aa774:	1010 4242 4242 4242 0202 0202 0202 0202     ..BBBBBB........
 80aa784:	0202 0202 0202 0202 0202 0202 1010 1010     ................
 80aa794:	0020 0000 0000 0000 0000 0000 0000 0000      ...............
	...

080aa815 <link_const_variable_data_end>:
 80aa815:	00          	.byte	0x00
	...

080aa818 <link_constructors_location>:
 80aa818:	080a1531 	.word	0x080a1531
 80aa81c:	080a193d 	.word	0x080a193d
 80aa820:	080a3acd 	.word	0x080a3acd
 80aa824:	080a5bfd 	.word	0x080a5bfd
 80aa828:	080a5f09 	.word	0x080a5f09
 80aa82c:	080a6ad9 	.word	0x080a6ad9
 80aa830:	080a70f1 	.word	0x080a70f1
 80aa834:	080a7105 	.word	0x080a7105
 80aa838:	080a7449 	.word	0x080a7449
 80aa83c:	080a74e9 	.word	0x080a74e9
